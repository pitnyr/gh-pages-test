(function(scope){
'use strict';

function F(arity, fun, wrapper) {
  wrapper.a = arity;
  wrapper.f = fun;
  return wrapper;
}

function F2(fun) {
  return F(2, fun, function(a) { return function(b) { return fun(a,b); }; })
}
function F3(fun) {
  return F(3, fun, function(a) {
    return function(b) { return function(c) { return fun(a, b, c); }; };
  });
}
function F4(fun) {
  return F(4, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return fun(a, b, c, d); }; }; };
  });
}
function F5(fun) {
  return F(5, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };
  });
}
function F6(fun) {
  return F(6, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return fun(a, b, c, d, e, f); }; }; }; }; };
  });
}
function F7(fun) {
  return F(7, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };
  });
}
function F8(fun) {
  return F(8, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) {
    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };
  });
}
function F9(fun) {
  return F(9, fun, function(a) { return function(b) { return function(c) {
    return function(d) { return function(e) { return function(f) {
    return function(g) { return function(h) { return function(i) {
    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };
  });
}

function A2(fun, a, b) {
  return fun.a === 2 ? fun.f(a, b) : fun(a)(b);
}
function A3(fun, a, b, c) {
  return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);
}
function A4(fun, a, b, c, d) {
  return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);
}
function A5(fun, a, b, c, d, e) {
  return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);
}
function A6(fun, a, b, c, d, e, f) {
  return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);
}
function A7(fun, a, b, c, d, e, f, g) {
  return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);
}
function A8(fun, a, b, c, d, e, f, g, h) {
  return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);
}
function A9(fun, a, b, c, d, e, f, g, h, i) {
  return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);
}

console.warn('Compiled in DEV mode. Follow the advice at https://elm-lang.org/0.19.1/optimize for better performance and smaller assets.');


var _JsArray_empty = [];

function _JsArray_singleton(value)
{
    return [value];
}

function _JsArray_length(array)
{
    return array.length;
}

var _JsArray_initialize = F3(function(size, offset, func)
{
    var result = new Array(size);

    for (var i = 0; i < size; i++)
    {
        result[i] = func(offset + i);
    }

    return result;
});

var _JsArray_initializeFromList = F2(function (max, ls)
{
    var result = new Array(max);

    for (var i = 0; i < max && ls.b; i++)
    {
        result[i] = ls.a;
        ls = ls.b;
    }

    result.length = i;
    return _Utils_Tuple2(result, ls);
});

var _JsArray_unsafeGet = F2(function(index, array)
{
    return array[index];
});

var _JsArray_unsafeSet = F3(function(index, value, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = array[i];
    }

    result[index] = value;
    return result;
});

var _JsArray_push = F2(function(value, array)
{
    var length = array.length;
    var result = new Array(length + 1);

    for (var i = 0; i < length; i++)
    {
        result[i] = array[i];
    }

    result[length] = value;
    return result;
});

var _JsArray_foldl = F3(function(func, acc, array)
{
    var length = array.length;

    for (var i = 0; i < length; i++)
    {
        acc = A2(func, array[i], acc);
    }

    return acc;
});

var _JsArray_foldr = F3(function(func, acc, array)
{
    for (var i = array.length - 1; i >= 0; i--)
    {
        acc = A2(func, array[i], acc);
    }

    return acc;
});

var _JsArray_map = F2(function(func, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = func(array[i]);
    }

    return result;
});

var _JsArray_indexedMap = F3(function(func, offset, array)
{
    var length = array.length;
    var result = new Array(length);

    for (var i = 0; i < length; i++)
    {
        result[i] = A2(func, offset + i, array[i]);
    }

    return result;
});

var _JsArray_slice = F3(function(from, to, array)
{
    return array.slice(from, to);
});

var _JsArray_appendN = F3(function(n, dest, source)
{
    var destLen = dest.length;
    var itemsToCopy = n - destLen;

    if (itemsToCopy > source.length)
    {
        itemsToCopy = source.length;
    }

    var size = destLen + itemsToCopy;
    var result = new Array(size);

    for (var i = 0; i < destLen; i++)
    {
        result[i] = dest[i];
    }

    for (var i = 0; i < itemsToCopy; i++)
    {
        result[i + destLen] = source[i];
    }

    return result;
});



// LOG

var _Debug_log_UNUSED = F2(function(tag, value)
{
	return value;
});

var _Debug_log = F2(function(tag, value)
{
	console.log(tag + ': ' + _Debug_toString(value));
	return value;
});


// TODOS

function _Debug_todo(moduleName, region)
{
	return function(message) {
		_Debug_crash(8, moduleName, region, message);
	};
}

function _Debug_todoCase(moduleName, region, value)
{
	return function(message) {
		_Debug_crash(9, moduleName, region, value, message);
	};
}


// TO STRING

function _Debug_toString_UNUSED(value)
{
	return '<internals>';
}

function _Debug_toString(value)
{
	return _Debug_toAnsiString(false, value);
}

function _Debug_toAnsiString(ansi, value)
{
	if (typeof value === 'function')
	{
		return _Debug_internalColor(ansi, '<function>');
	}

	if (typeof value === 'boolean')
	{
		return _Debug_ctorColor(ansi, value ? 'True' : 'False');
	}

	if (typeof value === 'number')
	{
		return _Debug_numberColor(ansi, value + '');
	}

	if (value instanceof String)
	{
		return _Debug_charColor(ansi, "'" + _Debug_addSlashes(value, true) + "'");
	}

	if (typeof value === 'string')
	{
		return _Debug_stringColor(ansi, '"' + _Debug_addSlashes(value, false) + '"');
	}

	if (typeof value === 'object' && '$' in value)
	{
		var tag = value.$;

		if (typeof tag === 'number')
		{
			return _Debug_internalColor(ansi, '<internals>');
		}

		if (tag[0] === '#')
		{
			var output = [];
			for (var k in value)
			{
				if (k === '$') continue;
				output.push(_Debug_toAnsiString(ansi, value[k]));
			}
			return '(' + output.join(',') + ')';
		}

		if (tag === 'Set_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Set')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Set$toList(value));
		}

		if (tag === 'RBNode_elm_builtin' || tag === 'RBEmpty_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Dict')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Dict$toList(value));
		}

		if (tag === 'Array_elm_builtin')
		{
			return _Debug_ctorColor(ansi, 'Array')
				+ _Debug_fadeColor(ansi, '.fromList') + ' '
				+ _Debug_toAnsiString(ansi, $elm$core$Array$toList(value));
		}

		if (tag === '::' || tag === '[]')
		{
			var output = '[';

			value.b && (output += _Debug_toAnsiString(ansi, value.a), value = value.b)

			for (; value.b; value = value.b) // WHILE_CONS
			{
				output += ',' + _Debug_toAnsiString(ansi, value.a);
			}
			return output + ']';
		}

		var output = '';
		for (var i in value)
		{
			if (i === '$') continue;
			var str = _Debug_toAnsiString(ansi, value[i]);
			var c0 = str[0];
			var parenless = c0 === '{' || c0 === '(' || c0 === '[' || c0 === '<' || c0 === '"' || str.indexOf(' ') < 0;
			output += ' ' + (parenless ? str : '(' + str + ')');
		}
		return _Debug_ctorColor(ansi, tag) + output;
	}

	if (typeof DataView === 'function' && value instanceof DataView)
	{
		return _Debug_stringColor(ansi, '<' + value.byteLength + ' bytes>');
	}

	if (typeof File !== 'undefined' && value instanceof File)
	{
		return _Debug_internalColor(ansi, '<' + value.name + '>');
	}

	if (typeof value === 'object')
	{
		var output = [];
		for (var key in value)
		{
			var field = key[0] === '_' ? key.slice(1) : key;
			output.push(_Debug_fadeColor(ansi, field) + ' = ' + _Debug_toAnsiString(ansi, value[key]));
		}
		if (output.length === 0)
		{
			return '{}';
		}
		return '{ ' + output.join(', ') + ' }';
	}

	return _Debug_internalColor(ansi, '<internals>');
}

function _Debug_addSlashes(str, isChar)
{
	var s = str
		.replace(/\\/g, '\\\\')
		.replace(/\n/g, '\\n')
		.replace(/\t/g, '\\t')
		.replace(/\r/g, '\\r')
		.replace(/\v/g, '\\v')
		.replace(/\0/g, '\\0');

	if (isChar)
	{
		return s.replace(/\'/g, '\\\'');
	}
	else
	{
		return s.replace(/\"/g, '\\"');
	}
}

function _Debug_ctorColor(ansi, string)
{
	return ansi ? '\x1b[96m' + string + '\x1b[0m' : string;
}

function _Debug_numberColor(ansi, string)
{
	return ansi ? '\x1b[95m' + string + '\x1b[0m' : string;
}

function _Debug_stringColor(ansi, string)
{
	return ansi ? '\x1b[93m' + string + '\x1b[0m' : string;
}

function _Debug_charColor(ansi, string)
{
	return ansi ? '\x1b[92m' + string + '\x1b[0m' : string;
}

function _Debug_fadeColor(ansi, string)
{
	return ansi ? '\x1b[37m' + string + '\x1b[0m' : string;
}

function _Debug_internalColor(ansi, string)
{
	return ansi ? '\x1b[36m' + string + '\x1b[0m' : string;
}

function _Debug_toHexDigit(n)
{
	return String.fromCharCode(n < 10 ? 48 + n : 55 + n);
}


// CRASH


function _Debug_crash_UNUSED(identifier)
{
	throw new Error('https://github.com/elm/core/blob/1.0.0/hints/' + identifier + '.md');
}


function _Debug_crash(identifier, fact1, fact2, fact3, fact4)
{
	switch(identifier)
	{
		case 0:
			throw new Error('What node should I take over? In JavaScript I need something like:\n\n    Elm.Main.init({\n        node: document.getElementById("elm-node")\n    })\n\nYou need to do this with any Browser.sandbox or Browser.element program.');

		case 1:
			throw new Error('Browser.application programs cannot handle URLs like this:\n\n    ' + document.location.href + '\n\nWhat is the root? The root of your file system? Try looking at this program with `elm reactor` or some other server.');

		case 2:
			var jsonErrorString = fact1;
			throw new Error('Problem with the flags given to your Elm program on initialization.\n\n' + jsonErrorString);

		case 3:
			var portName = fact1;
			throw new Error('There can only be one port named `' + portName + '`, but your program has multiple.');

		case 4:
			var portName = fact1;
			var problem = fact2;
			throw new Error('Trying to send an unexpected type of value through port `' + portName + '`:\n' + problem);

		case 5:
			throw new Error('Trying to use `(==)` on functions.\nThere is no way to know if functions are "the same" in the Elm sense.\nRead more about this at https://package.elm-lang.org/packages/elm/core/latest/Basics#== which describes why it is this way and what the better version will look like.');

		case 6:
			var moduleName = fact1;
			throw new Error('Your page is loading multiple Elm scripts with a module named ' + moduleName + '. Maybe a duplicate script is getting loaded accidentally? If not, rename one of them so I know which is which!');

		case 8:
			var moduleName = fact1;
			var region = fact2;
			var message = fact3;
			throw new Error('TODO in module `' + moduleName + '` ' + _Debug_regionToString(region) + '\n\n' + message);

		case 9:
			var moduleName = fact1;
			var region = fact2;
			var value = fact3;
			var message = fact4;
			throw new Error(
				'TODO in module `' + moduleName + '` from the `case` expression '
				+ _Debug_regionToString(region) + '\n\nIt received the following value:\n\n    '
				+ _Debug_toString(value).replace('\n', '\n    ')
				+ '\n\nBut the branch that handles it says:\n\n    ' + message.replace('\n', '\n    ')
			);

		case 10:
			throw new Error('Bug in https://github.com/elm/virtual-dom/issues');

		case 11:
			throw new Error('Cannot perform mod 0. Division by zero error.');
	}
}

function _Debug_regionToString(region)
{
	if (region.start.line === region.end.line)
	{
		return 'on line ' + region.start.line;
	}
	return 'on lines ' + region.start.line + ' through ' + region.end.line;
}



// EQUALITY

function _Utils_eq(x, y)
{
	for (
		var pair, stack = [], isEqual = _Utils_eqHelp(x, y, 0, stack);
		isEqual && (pair = stack.pop());
		isEqual = _Utils_eqHelp(pair.a, pair.b, 0, stack)
		)
	{}

	return isEqual;
}

function _Utils_eqHelp(x, y, depth, stack)
{
	if (x === y)
	{
		return true;
	}

	if (typeof x !== 'object' || x === null || y === null)
	{
		typeof x === 'function' && _Debug_crash(5);
		return false;
	}

	if (depth > 100)
	{
		stack.push(_Utils_Tuple2(x,y));
		return true;
	}

	/**/
	if (x.$ === 'Set_elm_builtin')
	{
		x = $elm$core$Set$toList(x);
		y = $elm$core$Set$toList(y);
	}
	if (x.$ === 'RBNode_elm_builtin' || x.$ === 'RBEmpty_elm_builtin')
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/

	/**_UNUSED/
	if (x.$ < 0)
	{
		x = $elm$core$Dict$toList(x);
		y = $elm$core$Dict$toList(y);
	}
	//*/

	for (var key in x)
	{
		if (!_Utils_eqHelp(x[key], y[key], depth + 1, stack))
		{
			return false;
		}
	}
	return true;
}

var _Utils_equal = F2(_Utils_eq);
var _Utils_notEqual = F2(function(a, b) { return !_Utils_eq(a,b); });



// COMPARISONS

// Code in Generate/JavaScript.hs, Basics.js, and List.js depends on
// the particular integer values assigned to LT, EQ, and GT.

function _Utils_cmp(x, y, ord)
{
	if (typeof x !== 'object')
	{
		return x === y ? /*EQ*/ 0 : x < y ? /*LT*/ -1 : /*GT*/ 1;
	}

	/**/
	if (x instanceof String)
	{
		var a = x.valueOf();
		var b = y.valueOf();
		return a === b ? 0 : a < b ? -1 : 1;
	}
	//*/

	/**_UNUSED/
	if (typeof x.$ === 'undefined')
	//*/
	/**/
	if (x.$[0] === '#')
	//*/
	{
		return (ord = _Utils_cmp(x.a, y.a))
			? ord
			: (ord = _Utils_cmp(x.b, y.b))
				? ord
				: _Utils_cmp(x.c, y.c);
	}

	// traverse conses until end of a list or a mismatch
	for (; x.b && y.b && !(ord = _Utils_cmp(x.a, y.a)); x = x.b, y = y.b) {} // WHILE_CONSES
	return ord || (x.b ? /*GT*/ 1 : y.b ? /*LT*/ -1 : /*EQ*/ 0);
}

var _Utils_lt = F2(function(a, b) { return _Utils_cmp(a, b) < 0; });
var _Utils_le = F2(function(a, b) { return _Utils_cmp(a, b) < 1; });
var _Utils_gt = F2(function(a, b) { return _Utils_cmp(a, b) > 0; });
var _Utils_ge = F2(function(a, b) { return _Utils_cmp(a, b) >= 0; });

var _Utils_compare = F2(function(x, y)
{
	var n = _Utils_cmp(x, y);
	return n < 0 ? $elm$core$Basics$LT : n ? $elm$core$Basics$GT : $elm$core$Basics$EQ;
});


// COMMON VALUES

var _Utils_Tuple0_UNUSED = 0;
var _Utils_Tuple0 = { $: '#0' };

function _Utils_Tuple2_UNUSED(a, b) { return { a: a, b: b }; }
function _Utils_Tuple2(a, b) { return { $: '#2', a: a, b: b }; }

function _Utils_Tuple3_UNUSED(a, b, c) { return { a: a, b: b, c: c }; }
function _Utils_Tuple3(a, b, c) { return { $: '#3', a: a, b: b, c: c }; }

function _Utils_chr_UNUSED(c) { return c; }
function _Utils_chr(c) { return new String(c); }


// RECORDS

function _Utils_update(oldRecord, updatedFields)
{
	var newRecord = {};

	for (var key in oldRecord)
	{
		newRecord[key] = oldRecord[key];
	}

	for (var key in updatedFields)
	{
		newRecord[key] = updatedFields[key];
	}

	return newRecord;
}


// APPEND

var _Utils_append = F2(_Utils_ap);

function _Utils_ap(xs, ys)
{
	// append Strings
	if (typeof xs === 'string')
	{
		return xs + ys;
	}

	// append Lists
	if (!xs.b)
	{
		return ys;
	}
	var root = _List_Cons(xs.a, ys);
	xs = xs.b
	for (var curr = root; xs.b; xs = xs.b) // WHILE_CONS
	{
		curr = curr.b = _List_Cons(xs.a, ys);
	}
	return root;
}



var _List_Nil_UNUSED = { $: 0 };
var _List_Nil = { $: '[]' };

function _List_Cons_UNUSED(hd, tl) { return { $: 1, a: hd, b: tl }; }
function _List_Cons(hd, tl) { return { $: '::', a: hd, b: tl }; }


var _List_cons = F2(_List_Cons);

function _List_fromArray(arr)
{
	var out = _List_Nil;
	for (var i = arr.length; i--; )
	{
		out = _List_Cons(arr[i], out);
	}
	return out;
}

function _List_toArray(xs)
{
	for (var out = []; xs.b; xs = xs.b) // WHILE_CONS
	{
		out.push(xs.a);
	}
	return out;
}

var _List_map2 = F3(function(f, xs, ys)
{
	for (var arr = []; xs.b && ys.b; xs = xs.b, ys = ys.b) // WHILE_CONSES
	{
		arr.push(A2(f, xs.a, ys.a));
	}
	return _List_fromArray(arr);
});

var _List_map3 = F4(function(f, xs, ys, zs)
{
	for (var arr = []; xs.b && ys.b && zs.b; xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A3(f, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_map4 = F5(function(f, ws, xs, ys, zs)
{
	for (var arr = []; ws.b && xs.b && ys.b && zs.b; ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A4(f, ws.a, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_map5 = F6(function(f, vs, ws, xs, ys, zs)
{
	for (var arr = []; vs.b && ws.b && xs.b && ys.b && zs.b; vs = vs.b, ws = ws.b, xs = xs.b, ys = ys.b, zs = zs.b) // WHILE_CONSES
	{
		arr.push(A5(f, vs.a, ws.a, xs.a, ys.a, zs.a));
	}
	return _List_fromArray(arr);
});

var _List_sortBy = F2(function(f, xs)
{
	return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
		return _Utils_cmp(f(a), f(b));
	}));
});

var _List_sortWith = F2(function(f, xs)
{
	return _List_fromArray(_List_toArray(xs).sort(function(a, b) {
		var ord = A2(f, a, b);
		return ord === $elm$core$Basics$EQ ? 0 : ord === $elm$core$Basics$LT ? -1 : 1;
	}));
});



// MATH

var _Basics_add = F2(function(a, b) { return a + b; });
var _Basics_sub = F2(function(a, b) { return a - b; });
var _Basics_mul = F2(function(a, b) { return a * b; });
var _Basics_fdiv = F2(function(a, b) { return a / b; });
var _Basics_idiv = F2(function(a, b) { return (a / b) | 0; });
var _Basics_pow = F2(Math.pow);

var _Basics_remainderBy = F2(function(b, a) { return a % b; });

// https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/divmodnote-letter.pdf
var _Basics_modBy = F2(function(modulus, x)
{
	var answer = x % modulus;
	return modulus === 0
		? _Debug_crash(11)
		:
	((answer > 0 && modulus < 0) || (answer < 0 && modulus > 0))
		? answer + modulus
		: answer;
});


// TRIGONOMETRY

var _Basics_pi = Math.PI;
var _Basics_e = Math.E;
var _Basics_cos = Math.cos;
var _Basics_sin = Math.sin;
var _Basics_tan = Math.tan;
var _Basics_acos = Math.acos;
var _Basics_asin = Math.asin;
var _Basics_atan = Math.atan;
var _Basics_atan2 = F2(Math.atan2);


// MORE MATH

function _Basics_toFloat(x) { return x; }
function _Basics_truncate(n) { return n | 0; }
function _Basics_isInfinite(n) { return n === Infinity || n === -Infinity; }

var _Basics_ceiling = Math.ceil;
var _Basics_floor = Math.floor;
var _Basics_round = Math.round;
var _Basics_sqrt = Math.sqrt;
var _Basics_log = Math.log;
var _Basics_isNaN = isNaN;


// BOOLEANS

function _Basics_not(bool) { return !bool; }
var _Basics_and = F2(function(a, b) { return a && b; });
var _Basics_or  = F2(function(a, b) { return a || b; });
var _Basics_xor = F2(function(a, b) { return a !== b; });



var _String_cons = F2(function(chr, str)
{
	return chr + str;
});

function _String_uncons(string)
{
	var word = string.charCodeAt(0);
	return !isNaN(word)
		? $elm$core$Maybe$Just(
			0xD800 <= word && word <= 0xDBFF
				? _Utils_Tuple2(_Utils_chr(string[0] + string[1]), string.slice(2))
				: _Utils_Tuple2(_Utils_chr(string[0]), string.slice(1))
		)
		: $elm$core$Maybe$Nothing;
}

var _String_append = F2(function(a, b)
{
	return a + b;
});

function _String_length(str)
{
	return str.length;
}

var _String_map = F2(function(func, string)
{
	var len = string.length;
	var array = new Array(len);
	var i = 0;
	while (i < len)
	{
		var word = string.charCodeAt(i);
		if (0xD800 <= word && word <= 0xDBFF)
		{
			array[i] = func(_Utils_chr(string[i] + string[i+1]));
			i += 2;
			continue;
		}
		array[i] = func(_Utils_chr(string[i]));
		i++;
	}
	return array.join('');
});

var _String_filter = F2(function(isGood, str)
{
	var arr = [];
	var len = str.length;
	var i = 0;
	while (i < len)
	{
		var char = str[i];
		var word = str.charCodeAt(i);
		i++;
		if (0xD800 <= word && word <= 0xDBFF)
		{
			char += str[i];
			i++;
		}

		if (isGood(_Utils_chr(char)))
		{
			arr.push(char);
		}
	}
	return arr.join('');
});

function _String_reverse(str)
{
	var len = str.length;
	var arr = new Array(len);
	var i = 0;
	while (i < len)
	{
		var word = str.charCodeAt(i);
		if (0xD800 <= word && word <= 0xDBFF)
		{
			arr[len - i] = str[i + 1];
			i++;
			arr[len - i] = str[i - 1];
			i++;
		}
		else
		{
			arr[len - i] = str[i];
			i++;
		}
	}
	return arr.join('');
}

var _String_foldl = F3(function(func, state, string)
{
	var len = string.length;
	var i = 0;
	while (i < len)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		i++;
		if (0xD800 <= word && word <= 0xDBFF)
		{
			char += string[i];
			i++;
		}
		state = A2(func, _Utils_chr(char), state);
	}
	return state;
});

var _String_foldr = F3(function(func, state, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		state = A2(func, _Utils_chr(char), state);
	}
	return state;
});

var _String_split = F2(function(sep, str)
{
	return str.split(sep);
});

var _String_join = F2(function(sep, strs)
{
	return strs.join(sep);
});

var _String_slice = F3(function(start, end, str) {
	return str.slice(start, end);
});

function _String_trim(str)
{
	return str.trim();
}

function _String_trimLeft(str)
{
	return str.replace(/^\s+/, '');
}

function _String_trimRight(str)
{
	return str.replace(/\s+$/, '');
}

function _String_words(str)
{
	return _List_fromArray(str.trim().split(/\s+/g));
}

function _String_lines(str)
{
	return _List_fromArray(str.split(/\r\n|\r|\n/g));
}

function _String_toUpper(str)
{
	return str.toUpperCase();
}

function _String_toLower(str)
{
	return str.toLowerCase();
}

var _String_any = F2(function(isGood, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		if (isGood(_Utils_chr(char)))
		{
			return true;
		}
	}
	return false;
});

var _String_all = F2(function(isGood, string)
{
	var i = string.length;
	while (i--)
	{
		var char = string[i];
		var word = string.charCodeAt(i);
		if (0xDC00 <= word && word <= 0xDFFF)
		{
			i--;
			char = string[i] + char;
		}
		if (!isGood(_Utils_chr(char)))
		{
			return false;
		}
	}
	return true;
});

var _String_contains = F2(function(sub, str)
{
	return str.indexOf(sub) > -1;
});

var _String_startsWith = F2(function(sub, str)
{
	return str.indexOf(sub) === 0;
});

var _String_endsWith = F2(function(sub, str)
{
	return str.length >= sub.length &&
		str.lastIndexOf(sub) === str.length - sub.length;
});

var _String_indexes = F2(function(sub, str)
{
	var subLen = sub.length;

	if (subLen < 1)
	{
		return _List_Nil;
	}

	var i = 0;
	var is = [];

	while ((i = str.indexOf(sub, i)) > -1)
	{
		is.push(i);
		i = i + subLen;
	}

	return _List_fromArray(is);
});


// TO STRING

function _String_fromNumber(number)
{
	return number + '';
}


// INT CONVERSIONS

function _String_toInt(str)
{
	var total = 0;
	var code0 = str.charCodeAt(0);
	var start = code0 == 0x2B /* + */ || code0 == 0x2D /* - */ ? 1 : 0;

	for (var i = start; i < str.length; ++i)
	{
		var code = str.charCodeAt(i);
		if (code < 0x30 || 0x39 < code)
		{
			return $elm$core$Maybe$Nothing;
		}
		total = 10 * total + code - 0x30;
	}

	return i == start
		? $elm$core$Maybe$Nothing
		: $elm$core$Maybe$Just(code0 == 0x2D ? -total : total);
}


// FLOAT CONVERSIONS

function _String_toFloat(s)
{
	// check if it is a hex, octal, or binary number
	if (s.length === 0 || /[\sxbo]/.test(s))
	{
		return $elm$core$Maybe$Nothing;
	}
	var n = +s;
	// faster isNaN check
	return n === n ? $elm$core$Maybe$Just(n) : $elm$core$Maybe$Nothing;
}

function _String_fromList(chars)
{
	return _List_toArray(chars).join('');
}




function _Char_toCode(char)
{
	var code = char.charCodeAt(0);
	if (0xD800 <= code && code <= 0xDBFF)
	{
		return (code - 0xD800) * 0x400 + char.charCodeAt(1) - 0xDC00 + 0x10000
	}
	return code;
}

function _Char_fromCode(code)
{
	return _Utils_chr(
		(code < 0 || 0x10FFFF < code)
			? '\uFFFD'
			:
		(code <= 0xFFFF)
			? String.fromCharCode(code)
			:
		(code -= 0x10000,
			String.fromCharCode(Math.floor(code / 0x400) + 0xD800, code % 0x400 + 0xDC00)
		)
	);
}

function _Char_toUpper(char)
{
	return _Utils_chr(char.toUpperCase());
}

function _Char_toLower(char)
{
	return _Utils_chr(char.toLowerCase());
}

function _Char_toLocaleUpper(char)
{
	return _Utils_chr(char.toLocaleUpperCase());
}

function _Char_toLocaleLower(char)
{
	return _Utils_chr(char.toLocaleLowerCase());
}



/**/
function _Json_errorToString(error)
{
	return $elm$json$Json$Decode$errorToString(error);
}
//*/


// CORE DECODERS

function _Json_succeed(msg)
{
	return {
		$: 0,
		a: msg
	};
}

function _Json_fail(msg)
{
	return {
		$: 1,
		a: msg
	};
}

function _Json_decodePrim(decoder)
{
	return { $: 2, b: decoder };
}

var _Json_decodeInt = _Json_decodePrim(function(value) {
	return (typeof value !== 'number')
		? _Json_expecting('an INT', value)
		:
	(-2147483647 < value && value < 2147483647 && (value | 0) === value)
		? $elm$core$Result$Ok(value)
		:
	(isFinite(value) && !(value % 1))
		? $elm$core$Result$Ok(value)
		: _Json_expecting('an INT', value);
});

var _Json_decodeBool = _Json_decodePrim(function(value) {
	return (typeof value === 'boolean')
		? $elm$core$Result$Ok(value)
		: _Json_expecting('a BOOL', value);
});

var _Json_decodeFloat = _Json_decodePrim(function(value) {
	return (typeof value === 'number')
		? $elm$core$Result$Ok(value)
		: _Json_expecting('a FLOAT', value);
});

var _Json_decodeValue = _Json_decodePrim(function(value) {
	return $elm$core$Result$Ok(_Json_wrap(value));
});

var _Json_decodeString = _Json_decodePrim(function(value) {
	return (typeof value === 'string')
		? $elm$core$Result$Ok(value)
		: (value instanceof String)
			? $elm$core$Result$Ok(value + '')
			: _Json_expecting('a STRING', value);
});

function _Json_decodeList(decoder) { return { $: 3, b: decoder }; }
function _Json_decodeArray(decoder) { return { $: 4, b: decoder }; }

function _Json_decodeNull(value) { return { $: 5, c: value }; }

var _Json_decodeField = F2(function(field, decoder)
{
	return {
		$: 6,
		d: field,
		b: decoder
	};
});

var _Json_decodeIndex = F2(function(index, decoder)
{
	return {
		$: 7,
		e: index,
		b: decoder
	};
});

function _Json_decodeKeyValuePairs(decoder)
{
	return {
		$: 8,
		b: decoder
	};
}

function _Json_mapMany(f, decoders)
{
	return {
		$: 9,
		f: f,
		g: decoders
	};
}

var _Json_andThen = F2(function(callback, decoder)
{
	return {
		$: 10,
		b: decoder,
		h: callback
	};
});

function _Json_oneOf(decoders)
{
	return {
		$: 11,
		g: decoders
	};
}


// DECODING OBJECTS

var _Json_map1 = F2(function(f, d1)
{
	return _Json_mapMany(f, [d1]);
});

var _Json_map2 = F3(function(f, d1, d2)
{
	return _Json_mapMany(f, [d1, d2]);
});

var _Json_map3 = F4(function(f, d1, d2, d3)
{
	return _Json_mapMany(f, [d1, d2, d3]);
});

var _Json_map4 = F5(function(f, d1, d2, d3, d4)
{
	return _Json_mapMany(f, [d1, d2, d3, d4]);
});

var _Json_map5 = F6(function(f, d1, d2, d3, d4, d5)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5]);
});

var _Json_map6 = F7(function(f, d1, d2, d3, d4, d5, d6)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6]);
});

var _Json_map7 = F8(function(f, d1, d2, d3, d4, d5, d6, d7)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7]);
});

var _Json_map8 = F9(function(f, d1, d2, d3, d4, d5, d6, d7, d8)
{
	return _Json_mapMany(f, [d1, d2, d3, d4, d5, d6, d7, d8]);
});


// DECODE

var _Json_runOnString = F2(function(decoder, string)
{
	try
	{
		var value = JSON.parse(string);
		return _Json_runHelp(decoder, value);
	}
	catch (e)
	{
		return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, 'This is not valid JSON! ' + e.message, _Json_wrap(string)));
	}
});

var _Json_run = F2(function(decoder, value)
{
	return _Json_runHelp(decoder, _Json_unwrap(value));
});

function _Json_runHelp(decoder, value)
{
	switch (decoder.$)
	{
		case 2:
			return decoder.b(value);

		case 5:
			return (value === null)
				? $elm$core$Result$Ok(decoder.c)
				: _Json_expecting('null', value);

		case 3:
			if (!_Json_isArray(value))
			{
				return _Json_expecting('a LIST', value);
			}
			return _Json_runArrayDecoder(decoder.b, value, _List_fromArray);

		case 4:
			if (!_Json_isArray(value))
			{
				return _Json_expecting('an ARRAY', value);
			}
			return _Json_runArrayDecoder(decoder.b, value, _Json_toElmArray);

		case 6:
			var field = decoder.d;
			if (typeof value !== 'object' || value === null || !(field in value))
			{
				return _Json_expecting('an OBJECT with a field named `' + field + '`', value);
			}
			var result = _Json_runHelp(decoder.b, value[field]);
			return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, field, result.a));

		case 7:
			var index = decoder.e;
			if (!_Json_isArray(value))
			{
				return _Json_expecting('an ARRAY', value);
			}
			if (index >= value.length)
			{
				return _Json_expecting('a LONGER array. Need index ' + index + ' but only see ' + value.length + ' entries', value);
			}
			var result = _Json_runHelp(decoder.b, value[index]);
			return ($elm$core$Result$isOk(result)) ? result : $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, index, result.a));

		case 8:
			if (typeof value !== 'object' || value === null || _Json_isArray(value))
			{
				return _Json_expecting('an OBJECT', value);
			}

			var keyValuePairs = _List_Nil;
			// TODO test perf of Object.keys and switch when support is good enough
			for (var key in value)
			{
				if (value.hasOwnProperty(key))
				{
					var result = _Json_runHelp(decoder.b, value[key]);
					if (!$elm$core$Result$isOk(result))
					{
						return $elm$core$Result$Err(A2($elm$json$Json$Decode$Field, key, result.a));
					}
					keyValuePairs = _List_Cons(_Utils_Tuple2(key, result.a), keyValuePairs);
				}
			}
			return $elm$core$Result$Ok($elm$core$List$reverse(keyValuePairs));

		case 9:
			var answer = decoder.f;
			var decoders = decoder.g;
			for (var i = 0; i < decoders.length; i++)
			{
				var result = _Json_runHelp(decoders[i], value);
				if (!$elm$core$Result$isOk(result))
				{
					return result;
				}
				answer = answer(result.a);
			}
			return $elm$core$Result$Ok(answer);

		case 10:
			var result = _Json_runHelp(decoder.b, value);
			return (!$elm$core$Result$isOk(result))
				? result
				: _Json_runHelp(decoder.h(result.a), value);

		case 11:
			var errors = _List_Nil;
			for (var temp = decoder.g; temp.b; temp = temp.b) // WHILE_CONS
			{
				var result = _Json_runHelp(temp.a, value);
				if ($elm$core$Result$isOk(result))
				{
					return result;
				}
				errors = _List_Cons(result.a, errors);
			}
			return $elm$core$Result$Err($elm$json$Json$Decode$OneOf($elm$core$List$reverse(errors)));

		case 1:
			return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, decoder.a, _Json_wrap(value)));

		case 0:
			return $elm$core$Result$Ok(decoder.a);
	}
}

function _Json_runArrayDecoder(decoder, value, toElmValue)
{
	var len = value.length;
	var array = new Array(len);
	for (var i = 0; i < len; i++)
	{
		var result = _Json_runHelp(decoder, value[i]);
		if (!$elm$core$Result$isOk(result))
		{
			return $elm$core$Result$Err(A2($elm$json$Json$Decode$Index, i, result.a));
		}
		array[i] = result.a;
	}
	return $elm$core$Result$Ok(toElmValue(array));
}

function _Json_isArray(value)
{
	return Array.isArray(value) || (typeof FileList !== 'undefined' && value instanceof FileList);
}

function _Json_toElmArray(array)
{
	return A2($elm$core$Array$initialize, array.length, function(i) { return array[i]; });
}

function _Json_expecting(type, value)
{
	return $elm$core$Result$Err(A2($elm$json$Json$Decode$Failure, 'Expecting ' + type, _Json_wrap(value)));
}


// EQUALITY

function _Json_equality(x, y)
{
	if (x === y)
	{
		return true;
	}

	if (x.$ !== y.$)
	{
		return false;
	}

	switch (x.$)
	{
		case 0:
		case 1:
			return x.a === y.a;

		case 2:
			return x.b === y.b;

		case 5:
			return x.c === y.c;

		case 3:
		case 4:
		case 8:
			return _Json_equality(x.b, y.b);

		case 6:
			return x.d === y.d && _Json_equality(x.b, y.b);

		case 7:
			return x.e === y.e && _Json_equality(x.b, y.b);

		case 9:
			return x.f === y.f && _Json_listEquality(x.g, y.g);

		case 10:
			return x.h === y.h && _Json_equality(x.b, y.b);

		case 11:
			return _Json_listEquality(x.g, y.g);
	}
}

function _Json_listEquality(aDecoders, bDecoders)
{
	var len = aDecoders.length;
	if (len !== bDecoders.length)
	{
		return false;
	}
	for (var i = 0; i < len; i++)
	{
		if (!_Json_equality(aDecoders[i], bDecoders[i]))
		{
			return false;
		}
	}
	return true;
}


// ENCODE

var _Json_encode = F2(function(indentLevel, value)
{
	return JSON.stringify(_Json_unwrap(value), null, indentLevel) + '';
});

function _Json_wrap(value) { return { $: 0, a: value }; }
function _Json_unwrap(value) { return value.a; }

function _Json_wrap_UNUSED(value) { return value; }
function _Json_unwrap_UNUSED(value) { return value; }

function _Json_emptyArray() { return []; }
function _Json_emptyObject() { return {}; }

var _Json_addField = F3(function(key, value, object)
{
	object[key] = _Json_unwrap(value);
	return object;
});

function _Json_addEntry(func)
{
	return F2(function(entry, array)
	{
		array.push(_Json_unwrap(func(entry)));
		return array;
	});
}

var _Json_encodeNull = _Json_wrap(null);



// TASKS

function _Scheduler_succeed(value)
{
	return {
		$: 0,
		a: value
	};
}

function _Scheduler_fail(error)
{
	return {
		$: 1,
		a: error
	};
}

function _Scheduler_binding(callback)
{
	return {
		$: 2,
		b: callback,
		c: null
	};
}

var _Scheduler_andThen = F2(function(callback, task)
{
	return {
		$: 3,
		b: callback,
		d: task
	};
});

var _Scheduler_onError = F2(function(callback, task)
{
	return {
		$: 4,
		b: callback,
		d: task
	};
});

function _Scheduler_receive(callback)
{
	return {
		$: 5,
		b: callback
	};
}


// PROCESSES

var _Scheduler_guid = 0;

function _Scheduler_rawSpawn(task)
{
	var proc = {
		$: 0,
		e: _Scheduler_guid++,
		f: task,
		g: null,
		h: []
	};

	_Scheduler_enqueue(proc);

	return proc;
}

function _Scheduler_spawn(task)
{
	return _Scheduler_binding(function(callback) {
		callback(_Scheduler_succeed(_Scheduler_rawSpawn(task)));
	});
}

function _Scheduler_rawSend(proc, msg)
{
	proc.h.push(msg);
	_Scheduler_enqueue(proc);
}

var _Scheduler_send = F2(function(proc, msg)
{
	return _Scheduler_binding(function(callback) {
		_Scheduler_rawSend(proc, msg);
		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
});

function _Scheduler_kill(proc)
{
	return _Scheduler_binding(function(callback) {
		var task = proc.f;
		if (task.$ === 2 && task.c)
		{
			task.c();
		}

		proc.f = null;

		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
}


/* STEP PROCESSES

type alias Process =
  { $ : tag
  , id : unique_id
  , root : Task
  , stack : null | { $: SUCCEED | FAIL, a: callback, b: stack }
  , mailbox : [msg]
  }

*/


var _Scheduler_working = false;
var _Scheduler_queue = [];


function _Scheduler_enqueue(proc)
{
	_Scheduler_queue.push(proc);
	if (_Scheduler_working)
	{
		return;
	}
	_Scheduler_working = true;
	while (proc = _Scheduler_queue.shift())
	{
		_Scheduler_step(proc);
	}
	_Scheduler_working = false;
}


function _Scheduler_step(proc)
{
	while (proc.f)
	{
		var rootTag = proc.f.$;
		if (rootTag === 0 || rootTag === 1)
		{
			while (proc.g && proc.g.$ !== rootTag)
			{
				proc.g = proc.g.i;
			}
			if (!proc.g)
			{
				return;
			}
			proc.f = proc.g.b(proc.f.a);
			proc.g = proc.g.i;
		}
		else if (rootTag === 2)
		{
			proc.f.c = proc.f.b(function(newRoot) {
				proc.f = newRoot;
				_Scheduler_enqueue(proc);
			});
			return;
		}
		else if (rootTag === 5)
		{
			if (proc.h.length === 0)
			{
				return;
			}
			proc.f = proc.f.b(proc.h.shift());
		}
		else // if (rootTag === 3 || rootTag === 4)
		{
			proc.g = {
				$: rootTag === 3 ? 0 : 1,
				b: proc.f.b,
				i: proc.g
			};
			proc.f = proc.f.d;
		}
	}
}



function _Process_sleep(time)
{
	return _Scheduler_binding(function(callback) {
		var id = setTimeout(function() {
			callback(_Scheduler_succeed(_Utils_Tuple0));
		}, time);

		return function() { clearTimeout(id); };
	});
}




// PROGRAMS


var _Platform_worker = F4(function(impl, flagDecoder, debugMetadata, args)
{
	return _Platform_initialize(
		flagDecoder,
		args,
		impl.init,
		impl.update,
		impl.subscriptions,
		function() { return function() {} }
	);
});



// INITIALIZE A PROGRAM


function _Platform_initialize(flagDecoder, args, init, update, subscriptions, stepperBuilder)
{
	var result = A2(_Json_run, flagDecoder, _Json_wrap(args ? args['flags'] : undefined));
	$elm$core$Result$isOk(result) || _Debug_crash(2 /**/, _Json_errorToString(result.a) /**/);
	var managers = {};
	var initPair = init(result.a);
	var model = initPair.a;
	var stepper = stepperBuilder(sendToApp, model);
	var ports = _Platform_setupEffects(managers, sendToApp);

	function sendToApp(msg, viewMetadata)
	{
		var pair = A2(update, msg, model);
		stepper(model = pair.a, viewMetadata);
		_Platform_enqueueEffects(managers, pair.b, subscriptions(model));
	}

	_Platform_enqueueEffects(managers, initPair.b, subscriptions(model));

	return ports ? { ports: ports } : {};
}



// TRACK PRELOADS
//
// This is used by code in elm/browser and elm/http
// to register any HTTP requests that are triggered by init.
//


var _Platform_preload;


function _Platform_registerPreload(url)
{
	_Platform_preload.add(url);
}



// EFFECT MANAGERS


var _Platform_effectManagers = {};


function _Platform_setupEffects(managers, sendToApp)
{
	var ports;

	// setup all necessary effect managers
	for (var key in _Platform_effectManagers)
	{
		var manager = _Platform_effectManagers[key];

		if (manager.a)
		{
			ports = ports || {};
			ports[key] = manager.a(key, sendToApp);
		}

		managers[key] = _Platform_instantiateManager(manager, sendToApp);
	}

	return ports;
}


function _Platform_createManager(init, onEffects, onSelfMsg, cmdMap, subMap)
{
	return {
		b: init,
		c: onEffects,
		d: onSelfMsg,
		e: cmdMap,
		f: subMap
	};
}


function _Platform_instantiateManager(info, sendToApp)
{
	var router = {
		g: sendToApp,
		h: undefined
	};

	var onEffects = info.c;
	var onSelfMsg = info.d;
	var cmdMap = info.e;
	var subMap = info.f;

	function loop(state)
	{
		return A2(_Scheduler_andThen, loop, _Scheduler_receive(function(msg)
		{
			var value = msg.a;

			if (msg.$ === 0)
			{
				return A3(onSelfMsg, router, value, state);
			}

			return cmdMap && subMap
				? A4(onEffects, router, value.i, value.j, state)
				: A3(onEffects, router, cmdMap ? value.i : value.j, state);
		}));
	}

	return router.h = _Scheduler_rawSpawn(A2(_Scheduler_andThen, loop, info.b));
}



// ROUTING


var _Platform_sendToApp = F2(function(router, msg)
{
	return _Scheduler_binding(function(callback)
	{
		router.g(msg);
		callback(_Scheduler_succeed(_Utils_Tuple0));
	});
});


var _Platform_sendToSelf = F2(function(router, msg)
{
	return A2(_Scheduler_send, router.h, {
		$: 0,
		a: msg
	});
});



// BAGS


function _Platform_leaf(home)
{
	return function(value)
	{
		return {
			$: 1,
			k: home,
			l: value
		};
	};
}


function _Platform_batch(list)
{
	return {
		$: 2,
		m: list
	};
}


var _Platform_map = F2(function(tagger, bag)
{
	return {
		$: 3,
		n: tagger,
		o: bag
	}
});



// PIPE BAGS INTO EFFECT MANAGERS
//
// Effects must be queued!
//
// Say your init contains a synchronous command, like Time.now or Time.here
//
//   - This will produce a batch of effects (FX_1)
//   - The synchronous task triggers the subsequent `update` call
//   - This will produce a batch of effects (FX_2)
//
// If we just start dispatching FX_2, subscriptions from FX_2 can be processed
// before subscriptions from FX_1. No good! Earlier versions of this code had
// this problem, leading to these reports:
//
//   https://github.com/elm/core/issues/980
//   https://github.com/elm/core/pull/981
//   https://github.com/elm/compiler/issues/1776
//
// The queue is necessary to avoid ordering issues for synchronous commands.


// Why use true/false here? Why not just check the length of the queue?
// The goal is to detect "are we currently dispatching effects?" If we
// are, we need to bail and let the ongoing while loop handle things.
//
// Now say the queue has 1 element. When we dequeue the final element,
// the queue will be empty, but we are still actively dispatching effects.
// So you could get queue jumping in a really tricky category of cases.
//
var _Platform_effectsQueue = [];
var _Platform_effectsActive = false;


function _Platform_enqueueEffects(managers, cmdBag, subBag)
{
	_Platform_effectsQueue.push({ p: managers, q: cmdBag, r: subBag });

	if (_Platform_effectsActive) return;

	_Platform_effectsActive = true;
	for (var fx; fx = _Platform_effectsQueue.shift(); )
	{
		_Platform_dispatchEffects(fx.p, fx.q, fx.r);
	}
	_Platform_effectsActive = false;
}


function _Platform_dispatchEffects(managers, cmdBag, subBag)
{
	var effectsDict = {};
	_Platform_gatherEffects(true, cmdBag, effectsDict, null);
	_Platform_gatherEffects(false, subBag, effectsDict, null);

	for (var home in managers)
	{
		_Scheduler_rawSend(managers[home], {
			$: 'fx',
			a: effectsDict[home] || { i: _List_Nil, j: _List_Nil }
		});
	}
}


function _Platform_gatherEffects(isCmd, bag, effectsDict, taggers)
{
	switch (bag.$)
	{
		case 1:
			var home = bag.k;
			var effect = _Platform_toEffect(isCmd, home, taggers, bag.l);
			effectsDict[home] = _Platform_insert(isCmd, effect, effectsDict[home]);
			return;

		case 2:
			for (var list = bag.m; list.b; list = list.b) // WHILE_CONS
			{
				_Platform_gatherEffects(isCmd, list.a, effectsDict, taggers);
			}
			return;

		case 3:
			_Platform_gatherEffects(isCmd, bag.o, effectsDict, {
				s: bag.n,
				t: taggers
			});
			return;
	}
}


function _Platform_toEffect(isCmd, home, taggers, value)
{
	function applyTaggers(x)
	{
		for (var temp = taggers; temp; temp = temp.t)
		{
			x = temp.s(x);
		}
		return x;
	}

	var map = isCmd
		? _Platform_effectManagers[home].e
		: _Platform_effectManagers[home].f;

	return A2(map, applyTaggers, value)
}


function _Platform_insert(isCmd, newEffect, effects)
{
	effects = effects || { i: _List_Nil, j: _List_Nil };

	isCmd
		? (effects.i = _List_Cons(newEffect, effects.i))
		: (effects.j = _List_Cons(newEffect, effects.j));

	return effects;
}



// PORTS


function _Platform_checkPortName(name)
{
	if (_Platform_effectManagers[name])
	{
		_Debug_crash(3, name)
	}
}



// OUTGOING PORTS


function _Platform_outgoingPort(name, converter)
{
	_Platform_checkPortName(name);
	_Platform_effectManagers[name] = {
		e: _Platform_outgoingPortMap,
		u: converter,
		a: _Platform_setupOutgoingPort
	};
	return _Platform_leaf(name);
}


var _Platform_outgoingPortMap = F2(function(tagger, value) { return value; });


function _Platform_setupOutgoingPort(name)
{
	var subs = [];
	var converter = _Platform_effectManagers[name].u;

	// CREATE MANAGER

	var init = _Process_sleep(0);

	_Platform_effectManagers[name].b = init;
	_Platform_effectManagers[name].c = F3(function(router, cmdList, state)
	{
		for ( ; cmdList.b; cmdList = cmdList.b) // WHILE_CONS
		{
			// grab a separate reference to subs in case unsubscribe is called
			var currentSubs = subs;
			var value = _Json_unwrap(converter(cmdList.a));
			for (var i = 0; i < currentSubs.length; i++)
			{
				currentSubs[i](value);
			}
		}
		return init;
	});

	// PUBLIC API

	function subscribe(callback)
	{
		subs.push(callback);
	}

	function unsubscribe(callback)
	{
		// copy subs into a new array in case unsubscribe is called within a
		// subscribed callback
		subs = subs.slice();
		var index = subs.indexOf(callback);
		if (index >= 0)
		{
			subs.splice(index, 1);
		}
	}

	return {
		subscribe: subscribe,
		unsubscribe: unsubscribe
	};
}



// INCOMING PORTS


function _Platform_incomingPort(name, converter)
{
	_Platform_checkPortName(name);
	_Platform_effectManagers[name] = {
		f: _Platform_incomingPortMap,
		u: converter,
		a: _Platform_setupIncomingPort
	};
	return _Platform_leaf(name);
}


var _Platform_incomingPortMap = F2(function(tagger, finalTagger)
{
	return function(value)
	{
		return tagger(finalTagger(value));
	};
});


function _Platform_setupIncomingPort(name, sendToApp)
{
	var subs = _List_Nil;
	var converter = _Platform_effectManagers[name].u;

	// CREATE MANAGER

	var init = _Scheduler_succeed(null);

	_Platform_effectManagers[name].b = init;
	_Platform_effectManagers[name].c = F3(function(router, subList, state)
	{
		subs = subList;
		return init;
	});

	// PUBLIC API

	function send(incomingValue)
	{
		var result = A2(_Json_run, converter, _Json_wrap(incomingValue));

		$elm$core$Result$isOk(result) || _Debug_crash(4, name, result.a);

		var value = result.a;
		for (var temp = subs; temp.b; temp = temp.b) // WHILE_CONS
		{
			sendToApp(temp.a(value));
		}
	}

	return { send: send };
}



// EXPORT ELM MODULES
//
// Have DEBUG and PROD versions so that we can (1) give nicer errors in
// debug mode and (2) not pay for the bits needed for that in prod mode.
//


function _Platform_export_UNUSED(exports)
{
	scope['Elm']
		? _Platform_mergeExportsProd(scope['Elm'], exports)
		: scope['Elm'] = exports;
}


function _Platform_mergeExportsProd(obj, exports)
{
	for (var name in exports)
	{
		(name in obj)
			? (name == 'init')
				? _Debug_crash(6)
				: _Platform_mergeExportsProd(obj[name], exports[name])
			: (obj[name] = exports[name]);
	}
}


function _Platform_export(exports)
{
	scope['Elm']
		? _Platform_mergeExportsDebug('Elm', scope['Elm'], exports)
		: scope['Elm'] = exports;
}


function _Platform_mergeExportsDebug(moduleName, obj, exports)
{
	for (var name in exports)
	{
		(name in obj)
			? (name == 'init')
				? _Debug_crash(6, moduleName)
				: _Platform_mergeExportsDebug(moduleName + '.' + name, obj[name], exports[name])
			: (obj[name] = exports[name]);
	}
}



function _Time_now(millisToPosix)
{
	return _Scheduler_binding(function(callback)
	{
		callback(_Scheduler_succeed(millisToPosix(Date.now())));
	});
}

var _Time_setInterval = F2(function(interval, task)
{
	return _Scheduler_binding(function(callback)
	{
		var id = setInterval(function() { _Scheduler_rawSpawn(task); }, interval);
		return function() { clearInterval(id); };
	});
});

function _Time_here()
{
	return _Scheduler_binding(function(callback)
	{
		callback(_Scheduler_succeed(
			A2($elm$time$Time$customZone, -(new Date().getTimezoneOffset()), _List_Nil)
		));
	});
}


function _Time_getZoneName()
{
	return _Scheduler_binding(function(callback)
	{
		try
		{
			var name = $elm$time$Time$Name(Intl.DateTimeFormat().resolvedOptions().timeZone);
		}
		catch (e)
		{
			var name = $elm$time$Time$Offset(new Date().getTimezoneOffset());
		}
		callback(_Scheduler_succeed(name));
	});
}



// SEND REQUEST

var _Http_toTask = F3(function(router, toTask, request)
{
	return _Scheduler_binding(function(callback)
	{
		function done(response) {
			callback(toTask(request.expect.a(response)));
		}

		var xhr = new XMLHttpRequest();
		xhr.addEventListener('error', function() { done($elm$http$Http$NetworkError_); });
		xhr.addEventListener('timeout', function() { done($elm$http$Http$Timeout_); });
		xhr.addEventListener('load', function() { done(_Http_toResponse(request.expect.b, xhr)); });
		$elm$core$Maybe$isJust(request.tracker) && _Http_track(router, xhr, request.tracker.a);

		try {
			xhr.open(request.method, request.url, true);
		} catch (e) {
			return done($elm$http$Http$BadUrl_(request.url));
		}

		_Http_configureRequest(xhr, request);

		request.body.a && xhr.setRequestHeader('Content-Type', request.body.a);
		xhr.send(request.body.b);

		return function() { xhr.c = true; xhr.abort(); };
	});
});


// CONFIGURE

function _Http_configureRequest(xhr, request)
{
	for (var headers = request.headers; headers.b; headers = headers.b) // WHILE_CONS
	{
		xhr.setRequestHeader(headers.a.a, headers.a.b);
	}
	xhr.timeout = request.timeout.a || 0;
	xhr.responseType = request.expect.d;
	xhr.withCredentials = request.allowCookiesFromOtherDomains;
}


// RESPONSES

function _Http_toResponse(toBody, xhr)
{
	return A2(
		200 <= xhr.status && xhr.status < 300 ? $elm$http$Http$GoodStatus_ : $elm$http$Http$BadStatus_,
		_Http_toMetadata(xhr),
		toBody(xhr.response)
	);
}


// METADATA

function _Http_toMetadata(xhr)
{
	return {
		url: xhr.responseURL,
		statusCode: xhr.status,
		statusText: xhr.statusText,
		headers: _Http_parseHeaders(xhr.getAllResponseHeaders())
	};
}


// HEADERS

function _Http_parseHeaders(rawHeaders)
{
	if (!rawHeaders)
	{
		return $elm$core$Dict$empty;
	}

	var headers = $elm$core$Dict$empty;
	var headerPairs = rawHeaders.split('\r\n');
	for (var i = headerPairs.length; i--; )
	{
		var headerPair = headerPairs[i];
		var index = headerPair.indexOf(': ');
		if (index > 0)
		{
			var key = headerPair.substring(0, index);
			var value = headerPair.substring(index + 2);

			headers = A3($elm$core$Dict$update, key, function(oldValue) {
				return $elm$core$Maybe$Just($elm$core$Maybe$isJust(oldValue)
					? value + ', ' + oldValue.a
					: value
				);
			}, headers);
		}
	}
	return headers;
}


// EXPECT

var _Http_expect = F3(function(type, toBody, toValue)
{
	return {
		$: 0,
		d: type,
		b: toBody,
		a: toValue
	};
});

var _Http_mapExpect = F2(function(func, expect)
{
	return {
		$: 0,
		d: expect.d,
		b: expect.b,
		a: function(x) { return func(expect.a(x)); }
	};
});

function _Http_toDataView(arrayBuffer)
{
	return new DataView(arrayBuffer);
}


// BODY and PARTS

var _Http_emptyBody = { $: 0 };
var _Http_pair = F2(function(a, b) { return { $: 0, a: a, b: b }; });

function _Http_toFormData(parts)
{
	for (var formData = new FormData(); parts.b; parts = parts.b) // WHILE_CONS
	{
		var part = parts.a;
		formData.append(part.a, part.b);
	}
	return formData;
}

var _Http_bytesToBlob = F2(function(mime, bytes)
{
	return new Blob([bytes], { type: mime });
});


// PROGRESS

function _Http_track(router, xhr, tracker)
{
	// TODO check out lengthComputable on loadstart event

	xhr.upload.addEventListener('progress', function(event) {
		if (xhr.c) { return; }
		_Scheduler_rawSpawn(A2($elm$core$Platform$sendToSelf, router, _Utils_Tuple2(tracker, $elm$http$Http$Sending({
			sent: event.loaded,
			size: event.total
		}))));
	});
	xhr.addEventListener('progress', function(event) {
		if (xhr.c) { return; }
		_Scheduler_rawSpawn(A2($elm$core$Platform$sendToSelf, router, _Utils_Tuple2(tracker, $elm$http$Http$Receiving({
			received: event.loaded,
			size: event.lengthComputable ? $elm$core$Maybe$Just(event.total) : $elm$core$Maybe$Nothing
		}))));
	});
}

// BYTES

function _Bytes_width(bytes)
{
	return bytes.byteLength;
}

var _Bytes_getHostEndianness = F2(function(le, be)
{
	return _Scheduler_binding(function(callback)
	{
		callback(_Scheduler_succeed(new Uint8Array(new Uint32Array([1]))[0] === 1 ? le : be));
	});
});


// ENCODERS

function _Bytes_encode(encoder)
{
	var mutableBytes = new DataView(new ArrayBuffer($elm$bytes$Bytes$Encode$getWidth(encoder)));
	$elm$bytes$Bytes$Encode$write(encoder)(mutableBytes)(0);
	return mutableBytes;
}


// SIGNED INTEGERS

var _Bytes_write_i8  = F3(function(mb, i, n) { mb.setInt8(i, n); return i + 1; });
var _Bytes_write_i16 = F4(function(mb, i, n, isLE) { mb.setInt16(i, n, isLE); return i + 2; });
var _Bytes_write_i32 = F4(function(mb, i, n, isLE) { mb.setInt32(i, n, isLE); return i + 4; });


// UNSIGNED INTEGERS

var _Bytes_write_u8  = F3(function(mb, i, n) { mb.setUint8(i, n); return i + 1 ;});
var _Bytes_write_u16 = F4(function(mb, i, n, isLE) { mb.setUint16(i, n, isLE); return i + 2; });
var _Bytes_write_u32 = F4(function(mb, i, n, isLE) { mb.setUint32(i, n, isLE); return i + 4; });


// FLOATS

var _Bytes_write_f32 = F4(function(mb, i, n, isLE) { mb.setFloat32(i, n, isLE); return i + 4; });
var _Bytes_write_f64 = F4(function(mb, i, n, isLE) { mb.setFloat64(i, n, isLE); return i + 8; });


// BYTES

var _Bytes_write_bytes = F3(function(mb, offset, bytes)
{
	for (var i = 0, len = bytes.byteLength, limit = len - 4; i <= limit; i += 4)
	{
		mb.setUint32(offset + i, bytes.getUint32(i));
	}
	for (; i < len; i++)
	{
		mb.setUint8(offset + i, bytes.getUint8(i));
	}
	return offset + len;
});


// STRINGS

function _Bytes_getStringWidth(string)
{
	for (var width = 0, i = 0; i < string.length; i++)
	{
		var code = string.charCodeAt(i);
		width +=
			(code < 0x80) ? 1 :
			(code < 0x800) ? 2 :
			(code < 0xD800 || 0xDBFF < code) ? 3 : (i++, 4);
	}
	return width;
}

var _Bytes_write_string = F3(function(mb, offset, string)
{
	for (var i = 0; i < string.length; i++)
	{
		var code = string.charCodeAt(i);
		offset +=
			(code < 0x80)
				? (mb.setUint8(offset, code)
				, 1
				)
				:
			(code < 0x800)
				? (mb.setUint16(offset, 0xC080 /* 0b1100000010000000 */
					| (code >>> 6 & 0x1F /* 0b00011111 */) << 8
					| code & 0x3F /* 0b00111111 */)
				, 2
				)
				:
			(code < 0xD800 || 0xDBFF < code)
				? (mb.setUint16(offset, 0xE080 /* 0b1110000010000000 */
					| (code >>> 12 & 0xF /* 0b00001111 */) << 8
					| code >>> 6 & 0x3F /* 0b00111111 */)
				, mb.setUint8(offset + 2, 0x80 /* 0b10000000 */
					| code & 0x3F /* 0b00111111 */)
				, 3
				)
				:
			(code = (code - 0xD800) * 0x400 + string.charCodeAt(++i) - 0xDC00 + 0x10000
			, mb.setUint32(offset, 0xF0808080 /* 0b11110000100000001000000010000000 */
				| (code >>> 18 & 0x7 /* 0b00000111 */) << 24
				| (code >>> 12 & 0x3F /* 0b00111111 */) << 16
				| (code >>> 6 & 0x3F /* 0b00111111 */) << 8
				| code & 0x3F /* 0b00111111 */)
			, 4
			);
	}
	return offset;
});


// DECODER

var _Bytes_decode = F2(function(decoder, bytes)
{
	try {
		return $elm$core$Maybe$Just(A2(decoder, bytes, 0).b);
	} catch(e) {
		return $elm$core$Maybe$Nothing;
	}
});

var _Bytes_read_i8  = F2(function(      bytes, offset) { return _Utils_Tuple2(offset + 1, bytes.getInt8(offset)); });
var _Bytes_read_i16 = F3(function(isLE, bytes, offset) { return _Utils_Tuple2(offset + 2, bytes.getInt16(offset, isLE)); });
var _Bytes_read_i32 = F3(function(isLE, bytes, offset) { return _Utils_Tuple2(offset + 4, bytes.getInt32(offset, isLE)); });
var _Bytes_read_u8  = F2(function(      bytes, offset) { return _Utils_Tuple2(offset + 1, bytes.getUint8(offset)); });
var _Bytes_read_u16 = F3(function(isLE, bytes, offset) { return _Utils_Tuple2(offset + 2, bytes.getUint16(offset, isLE)); });
var _Bytes_read_u32 = F3(function(isLE, bytes, offset) { return _Utils_Tuple2(offset + 4, bytes.getUint32(offset, isLE)); });
var _Bytes_read_f32 = F3(function(isLE, bytes, offset) { return _Utils_Tuple2(offset + 4, bytes.getFloat32(offset, isLE)); });
var _Bytes_read_f64 = F3(function(isLE, bytes, offset) { return _Utils_Tuple2(offset + 8, bytes.getFloat64(offset, isLE)); });

var _Bytes_read_bytes = F3(function(len, bytes, offset)
{
	return _Utils_Tuple2(offset + len, new DataView(bytes.buffer, bytes.byteOffset + offset, len));
});

var _Bytes_read_string = F3(function(len, bytes, offset)
{
	var string = '';
	var end = offset + len;
	for (; offset < end;)
	{
		var byte = bytes.getUint8(offset++);
		string +=
			(byte < 128)
				? String.fromCharCode(byte)
				:
			((byte & 0xE0 /* 0b11100000 */) === 0xC0 /* 0b11000000 */)
				? String.fromCharCode((byte & 0x1F /* 0b00011111 */) << 6 | bytes.getUint8(offset++) & 0x3F /* 0b00111111 */)
				:
			((byte & 0xF0 /* 0b11110000 */) === 0xE0 /* 0b11100000 */)
				? String.fromCharCode(
					(byte & 0xF /* 0b00001111 */) << 12
					| (bytes.getUint8(offset++) & 0x3F /* 0b00111111 */) << 6
					| bytes.getUint8(offset++) & 0x3F /* 0b00111111 */
				)
				:
				(byte =
					((byte & 0x7 /* 0b00000111 */) << 18
						| (bytes.getUint8(offset++) & 0x3F /* 0b00111111 */) << 12
						| (bytes.getUint8(offset++) & 0x3F /* 0b00111111 */) << 6
						| bytes.getUint8(offset++) & 0x3F /* 0b00111111 */
					) - 0x10000
				, String.fromCharCode(Math.floor(byte / 0x400) + 0xD800, byte % 0x400 + 0xDC00)
				);
	}
	return _Utils_Tuple2(offset, string);
});

var _Bytes_decodeFailure = F2(function() { throw 0; });



var _Bitwise_and = F2(function(a, b)
{
	return a & b;
});

var _Bitwise_or = F2(function(a, b)
{
	return a | b;
});

var _Bitwise_xor = F2(function(a, b)
{
	return a ^ b;
});

function _Bitwise_complement(a)
{
	return ~a;
};

var _Bitwise_shiftLeftBy = F2(function(offset, a)
{
	return a << offset;
});

var _Bitwise_shiftRightBy = F2(function(offset, a)
{
	return a >> offset;
});

var _Bitwise_shiftRightZfBy = F2(function(offset, a)
{
	return a >>> offset;
});
var $elm$core$List$cons = _List_cons;
var $elm$core$Elm$JsArray$foldr = _JsArray_foldr;
var $elm$core$Array$foldr = F3(
	function (func, baseCase, _v0) {
		var tree = _v0.c;
		var tail = _v0.d;
		var helper = F2(
			function (node, acc) {
				if (node.$ === 'SubTree') {
					var subTree = node.a;
					return A3($elm$core$Elm$JsArray$foldr, helper, acc, subTree);
				} else {
					var values = node.a;
					return A3($elm$core$Elm$JsArray$foldr, func, acc, values);
				}
			});
		return A3(
			$elm$core$Elm$JsArray$foldr,
			helper,
			A3($elm$core$Elm$JsArray$foldr, func, baseCase, tail),
			tree);
	});
var $elm$core$Array$toList = function (array) {
	return A3($elm$core$Array$foldr, $elm$core$List$cons, _List_Nil, array);
};
var $elm$core$Dict$foldr = F3(
	function (func, acc, t) {
		foldr:
		while (true) {
			if (t.$ === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var key = t.b;
				var value = t.c;
				var left = t.d;
				var right = t.e;
				var $temp$func = func,
					$temp$acc = A3(
					func,
					key,
					value,
					A3($elm$core$Dict$foldr, func, acc, right)),
					$temp$t = left;
				func = $temp$func;
				acc = $temp$acc;
				t = $temp$t;
				continue foldr;
			}
		}
	});
var $elm$core$Dict$toList = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, list) {
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(key, value),
					list);
			}),
		_List_Nil,
		dict);
};
var $elm$core$Dict$keys = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, keyList) {
				return A2($elm$core$List$cons, key, keyList);
			}),
		_List_Nil,
		dict);
};
var $elm$core$Set$toList = function (_v0) {
	var dict = _v0.a;
	return $elm$core$Dict$keys(dict);
};
var $elm$core$Basics$EQ = {$: 'EQ'};
var $elm$core$Basics$GT = {$: 'GT'};
var $elm$core$Basics$LT = {$: 'LT'};
var $elm$core$Result$Err = function (a) {
	return {$: 'Err', a: a};
};
var $elm$json$Json$Decode$Failure = F2(
	function (a, b) {
		return {$: 'Failure', a: a, b: b};
	});
var $elm$json$Json$Decode$Field = F2(
	function (a, b) {
		return {$: 'Field', a: a, b: b};
	});
var $elm$json$Json$Decode$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $elm$core$Result$Ok = function (a) {
	return {$: 'Ok', a: a};
};
var $elm$json$Json$Decode$OneOf = function (a) {
	return {$: 'OneOf', a: a};
};
var $elm$core$Basics$False = {$: 'False'};
var $elm$core$Basics$add = _Basics_add;
var $elm$core$Maybe$Just = function (a) {
	return {$: 'Just', a: a};
};
var $elm$core$Maybe$Nothing = {$: 'Nothing'};
var $elm$core$String$all = _String_all;
var $elm$core$Basics$and = _Basics_and;
var $elm$core$Basics$append = _Utils_append;
var $elm$json$Json$Encode$encode = _Json_encode;
var $elm$core$String$fromInt = _String_fromNumber;
var $elm$core$String$join = F2(
	function (sep, chunks) {
		return A2(
			_String_join,
			sep,
			_List_toArray(chunks));
	});
var $elm$core$String$split = F2(
	function (sep, string) {
		return _List_fromArray(
			A2(_String_split, sep, string));
	});
var $elm$json$Json$Decode$indent = function (str) {
	return A2(
		$elm$core$String$join,
		'\n    ',
		A2($elm$core$String$split, '\n', str));
};
var $elm$core$List$foldl = F3(
	function (func, acc, list) {
		foldl:
		while (true) {
			if (!list.b) {
				return acc;
			} else {
				var x = list.a;
				var xs = list.b;
				var $temp$func = func,
					$temp$acc = A2(func, x, acc),
					$temp$list = xs;
				func = $temp$func;
				acc = $temp$acc;
				list = $temp$list;
				continue foldl;
			}
		}
	});
var $elm$core$List$length = function (xs) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (_v0, i) {
				return i + 1;
			}),
		0,
		xs);
};
var $elm$core$List$map2 = _List_map2;
var $elm$core$Basics$le = _Utils_le;
var $elm$core$Basics$sub = _Basics_sub;
var $elm$core$List$rangeHelp = F3(
	function (lo, hi, list) {
		rangeHelp:
		while (true) {
			if (_Utils_cmp(lo, hi) < 1) {
				var $temp$lo = lo,
					$temp$hi = hi - 1,
					$temp$list = A2($elm$core$List$cons, hi, list);
				lo = $temp$lo;
				hi = $temp$hi;
				list = $temp$list;
				continue rangeHelp;
			} else {
				return list;
			}
		}
	});
var $elm$core$List$range = F2(
	function (lo, hi) {
		return A3($elm$core$List$rangeHelp, lo, hi, _List_Nil);
	});
var $elm$core$List$indexedMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$map2,
			f,
			A2(
				$elm$core$List$range,
				0,
				$elm$core$List$length(xs) - 1),
			xs);
	});
var $elm$core$Char$toCode = _Char_toCode;
var $elm$core$Char$isLower = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (97 <= code) && (code <= 122);
};
var $elm$core$Char$isUpper = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (code <= 90) && (65 <= code);
};
var $elm$core$Basics$or = _Basics_or;
var $elm$core$Char$isAlpha = function (_char) {
	return $elm$core$Char$isLower(_char) || $elm$core$Char$isUpper(_char);
};
var $elm$core$Char$isDigit = function (_char) {
	var code = $elm$core$Char$toCode(_char);
	return (code <= 57) && (48 <= code);
};
var $elm$core$Char$isAlphaNum = function (_char) {
	return $elm$core$Char$isLower(_char) || ($elm$core$Char$isUpper(_char) || $elm$core$Char$isDigit(_char));
};
var $elm$core$List$reverse = function (list) {
	return A3($elm$core$List$foldl, $elm$core$List$cons, _List_Nil, list);
};
var $elm$core$String$uncons = _String_uncons;
var $elm$json$Json$Decode$errorOneOf = F2(
	function (i, error) {
		return '\n\n(' + ($elm$core$String$fromInt(i + 1) + (') ' + $elm$json$Json$Decode$indent(
			$elm$json$Json$Decode$errorToString(error))));
	});
var $elm$json$Json$Decode$errorToString = function (error) {
	return A2($elm$json$Json$Decode$errorToStringHelp, error, _List_Nil);
};
var $elm$json$Json$Decode$errorToStringHelp = F2(
	function (error, context) {
		errorToStringHelp:
		while (true) {
			switch (error.$) {
				case 'Field':
					var f = error.a;
					var err = error.b;
					var isSimple = function () {
						var _v1 = $elm$core$String$uncons(f);
						if (_v1.$ === 'Nothing') {
							return false;
						} else {
							var _v2 = _v1.a;
							var _char = _v2.a;
							var rest = _v2.b;
							return $elm$core$Char$isAlpha(_char) && A2($elm$core$String$all, $elm$core$Char$isAlphaNum, rest);
						}
					}();
					var fieldName = isSimple ? ('.' + f) : ('[\'' + (f + '\']'));
					var $temp$error = err,
						$temp$context = A2($elm$core$List$cons, fieldName, context);
					error = $temp$error;
					context = $temp$context;
					continue errorToStringHelp;
				case 'Index':
					var i = error.a;
					var err = error.b;
					var indexName = '[' + ($elm$core$String$fromInt(i) + ']');
					var $temp$error = err,
						$temp$context = A2($elm$core$List$cons, indexName, context);
					error = $temp$error;
					context = $temp$context;
					continue errorToStringHelp;
				case 'OneOf':
					var errors = error.a;
					if (!errors.b) {
						return 'Ran into a Json.Decode.oneOf with no possibilities' + function () {
							if (!context.b) {
								return '!';
							} else {
								return ' at json' + A2(
									$elm$core$String$join,
									'',
									$elm$core$List$reverse(context));
							}
						}();
					} else {
						if (!errors.b.b) {
							var err = errors.a;
							var $temp$error = err,
								$temp$context = context;
							error = $temp$error;
							context = $temp$context;
							continue errorToStringHelp;
						} else {
							var starter = function () {
								if (!context.b) {
									return 'Json.Decode.oneOf';
								} else {
									return 'The Json.Decode.oneOf at json' + A2(
										$elm$core$String$join,
										'',
										$elm$core$List$reverse(context));
								}
							}();
							var introduction = starter + (' failed in the following ' + ($elm$core$String$fromInt(
								$elm$core$List$length(errors)) + ' ways:'));
							return A2(
								$elm$core$String$join,
								'\n\n',
								A2(
									$elm$core$List$cons,
									introduction,
									A2($elm$core$List$indexedMap, $elm$json$Json$Decode$errorOneOf, errors)));
						}
					}
				default:
					var msg = error.a;
					var json = error.b;
					var introduction = function () {
						if (!context.b) {
							return 'Problem with the given value:\n\n';
						} else {
							return 'Problem with the value at json' + (A2(
								$elm$core$String$join,
								'',
								$elm$core$List$reverse(context)) + ':\n\n    ');
						}
					}();
					return introduction + ($elm$json$Json$Decode$indent(
						A2($elm$json$Json$Encode$encode, 4, json)) + ('\n\n' + msg));
			}
		}
	});
var $elm$core$Array$branchFactor = 32;
var $elm$core$Array$Array_elm_builtin = F4(
	function (a, b, c, d) {
		return {$: 'Array_elm_builtin', a: a, b: b, c: c, d: d};
	});
var $elm$core$Elm$JsArray$empty = _JsArray_empty;
var $elm$core$Basics$ceiling = _Basics_ceiling;
var $elm$core$Basics$fdiv = _Basics_fdiv;
var $elm$core$Basics$logBase = F2(
	function (base, number) {
		return _Basics_log(number) / _Basics_log(base);
	});
var $elm$core$Basics$toFloat = _Basics_toFloat;
var $elm$core$Array$shiftStep = $elm$core$Basics$ceiling(
	A2($elm$core$Basics$logBase, 2, $elm$core$Array$branchFactor));
var $elm$core$Array$empty = A4($elm$core$Array$Array_elm_builtin, 0, $elm$core$Array$shiftStep, $elm$core$Elm$JsArray$empty, $elm$core$Elm$JsArray$empty);
var $elm$core$Elm$JsArray$initialize = _JsArray_initialize;
var $elm$core$Array$Leaf = function (a) {
	return {$: 'Leaf', a: a};
};
var $elm$core$Basics$apL = F2(
	function (f, x) {
		return f(x);
	});
var $elm$core$Basics$apR = F2(
	function (x, f) {
		return f(x);
	});
var $elm$core$Basics$eq = _Utils_equal;
var $elm$core$Basics$floor = _Basics_floor;
var $elm$core$Elm$JsArray$length = _JsArray_length;
var $elm$core$Basics$gt = _Utils_gt;
var $elm$core$Basics$max = F2(
	function (x, y) {
		return (_Utils_cmp(x, y) > 0) ? x : y;
	});
var $elm$core$Basics$mul = _Basics_mul;
var $elm$core$Array$SubTree = function (a) {
	return {$: 'SubTree', a: a};
};
var $elm$core$Elm$JsArray$initializeFromList = _JsArray_initializeFromList;
var $elm$core$Array$compressNodes = F2(
	function (nodes, acc) {
		compressNodes:
		while (true) {
			var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodes);
			var node = _v0.a;
			var remainingNodes = _v0.b;
			var newAcc = A2(
				$elm$core$List$cons,
				$elm$core$Array$SubTree(node),
				acc);
			if (!remainingNodes.b) {
				return $elm$core$List$reverse(newAcc);
			} else {
				var $temp$nodes = remainingNodes,
					$temp$acc = newAcc;
				nodes = $temp$nodes;
				acc = $temp$acc;
				continue compressNodes;
			}
		}
	});
var $elm$core$Tuple$first = function (_v0) {
	var x = _v0.a;
	return x;
};
var $elm$core$Array$treeFromBuilder = F2(
	function (nodeList, nodeListSize) {
		treeFromBuilder:
		while (true) {
			var newNodeSize = $elm$core$Basics$ceiling(nodeListSize / $elm$core$Array$branchFactor);
			if (newNodeSize === 1) {
				return A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, nodeList).a;
			} else {
				var $temp$nodeList = A2($elm$core$Array$compressNodes, nodeList, _List_Nil),
					$temp$nodeListSize = newNodeSize;
				nodeList = $temp$nodeList;
				nodeListSize = $temp$nodeListSize;
				continue treeFromBuilder;
			}
		}
	});
var $elm$core$Array$builderToArray = F2(
	function (reverseNodeList, builder) {
		if (!builder.nodeListSize) {
			return A4(
				$elm$core$Array$Array_elm_builtin,
				$elm$core$Elm$JsArray$length(builder.tail),
				$elm$core$Array$shiftStep,
				$elm$core$Elm$JsArray$empty,
				builder.tail);
		} else {
			var treeLen = builder.nodeListSize * $elm$core$Array$branchFactor;
			var depth = $elm$core$Basics$floor(
				A2($elm$core$Basics$logBase, $elm$core$Array$branchFactor, treeLen - 1));
			var correctNodeList = reverseNodeList ? $elm$core$List$reverse(builder.nodeList) : builder.nodeList;
			var tree = A2($elm$core$Array$treeFromBuilder, correctNodeList, builder.nodeListSize);
			return A4(
				$elm$core$Array$Array_elm_builtin,
				$elm$core$Elm$JsArray$length(builder.tail) + treeLen,
				A2($elm$core$Basics$max, 5, depth * $elm$core$Array$shiftStep),
				tree,
				builder.tail);
		}
	});
var $elm$core$Basics$idiv = _Basics_idiv;
var $elm$core$Basics$lt = _Utils_lt;
var $elm$core$Array$initializeHelp = F5(
	function (fn, fromIndex, len, nodeList, tail) {
		initializeHelp:
		while (true) {
			if (fromIndex < 0) {
				return A2(
					$elm$core$Array$builderToArray,
					false,
					{nodeList: nodeList, nodeListSize: (len / $elm$core$Array$branchFactor) | 0, tail: tail});
			} else {
				var leaf = $elm$core$Array$Leaf(
					A3($elm$core$Elm$JsArray$initialize, $elm$core$Array$branchFactor, fromIndex, fn));
				var $temp$fn = fn,
					$temp$fromIndex = fromIndex - $elm$core$Array$branchFactor,
					$temp$len = len,
					$temp$nodeList = A2($elm$core$List$cons, leaf, nodeList),
					$temp$tail = tail;
				fn = $temp$fn;
				fromIndex = $temp$fromIndex;
				len = $temp$len;
				nodeList = $temp$nodeList;
				tail = $temp$tail;
				continue initializeHelp;
			}
		}
	});
var $elm$core$Basics$remainderBy = _Basics_remainderBy;
var $elm$core$Array$initialize = F2(
	function (len, fn) {
		if (len <= 0) {
			return $elm$core$Array$empty;
		} else {
			var tailLen = len % $elm$core$Array$branchFactor;
			var tail = A3($elm$core$Elm$JsArray$initialize, tailLen, len - tailLen, fn);
			var initialFromIndex = (len - tailLen) - $elm$core$Array$branchFactor;
			return A5($elm$core$Array$initializeHelp, fn, initialFromIndex, len, _List_Nil, tail);
		}
	});
var $elm$core$Basics$True = {$: 'True'};
var $elm$core$Result$isOk = function (result) {
	if (result.$ === 'Ok') {
		return true;
	} else {
		return false;
	}
};
var $elm$json$Json$Decode$andThen = _Json_andThen;
var $elm$json$Json$Decode$index = _Json_decodeIndex;
var $author$project$Global$State = F8(
	function (a, b, c, d, e, f, g, h) {
		return {$: 'State', a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h};
	});
var $author$project$Repl$Worker$LocalState = F3(
	function (a, b, c) {
		return {$: 'LocalState', a: a, b: b, c: c};
	});
var $author$project$Repl$Worker$ReplStopped = {$: 'ReplStopped'};
var $elm$core$Dict$RBEmpty_elm_builtin = {$: 'RBEmpty_elm_builtin'};
var $elm$core$Dict$empty = $elm$core$Dict$RBEmpty_elm_builtin;
var $author$project$Extra$Type$Map$empty = $elm$core$Dict$empty;
var $author$project$Repl$Worker$initialLocalState = A3(
	$author$project$Repl$Worker$LocalState,
	$elm$core$Maybe$Nothing,
	_Utils_Tuple3($author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty),
	$author$project$Repl$Worker$ReplStopped);
var $elm$core$Basics$identity = function (x) {
	return x;
};
var $author$project$Terminal$Repl$LocalState = function (a) {
	return {$: 'LocalState', a: a};
};
var $author$project$Terminal$Repl$initialLocalState = $author$project$Terminal$Repl$LocalState($elm$core$Maybe$Nothing);
var $author$project$Builder$Build$LocalState = F7(
	function (a, b, c, d, e, f, g) {
		return {$: 'LocalState', a: a, b: b, c: c, d: d, e: e, f: f, g: g};
	});
var $author$project$Extra$System$MVar$initialState = function (name) {
	return _Utils_Tuple3(0, $author$project$Extra$Type$Map$empty, name);
};
var $author$project$Builder$Build$initialState = A7(
	$author$project$Builder$Build$LocalState,
	$author$project$Extra$System$MVar$initialState('Status'),
	$author$project$Extra$System$MVar$initialState('StatusMap'),
	$author$project$Extra$System$MVar$initialState('RootStatus'),
	$author$project$Extra$System$MVar$initialState('RootResult'),
	$author$project$Extra$System$MVar$initialState('Result'),
	$author$project$Extra$System$MVar$initialState('ResultMap'),
	$author$project$Extra$System$MVar$initialState('CachedInterface'));
var $author$project$Builder$Elm$Details$LocalState = F8(
	function (a, b, c, d, e, f, g, h) {
		return {$: 'LocalState', a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h};
	});
var $author$project$Builder$Elm$Details$initialState = A8(
	$author$project$Builder$Elm$Details$LocalState,
	$author$project$Extra$System$MVar$initialState('Dep'),
	$author$project$Extra$System$MVar$initialState('DepDict'),
	$author$project$Extra$System$MVar$initialState('Status'),
	$author$project$Extra$System$MVar$initialState('StatusDict'),
	$author$project$Extra$System$MVar$initialState('Result'),
	$author$project$Extra$System$MVar$initialState('ResultDict'),
	$author$project$Extra$System$MVar$initialState('Interfaces'),
	$author$project$Extra$System$MVar$initialState('GlobalGraph'));
var $author$project$Builder$Generate$LocalState = F2(
	function (a, b) {
		return {$: 'LocalState', a: a, b: b};
	});
var $author$project$Builder$Generate$initialState = A2(
	$author$project$Builder$Generate$LocalState,
	$author$project$Extra$System$MVar$initialState('LocalGraph'),
	$author$project$Extra$System$MVar$initialState('Types'));
var $author$project$Builder$Http$initialState = $elm$core$Maybe$Nothing;
var $author$project$Extra$System$File$FileSystem = F3(
	function (a, b, c) {
		return {$: 'FileSystem', a: a, b: b, c: c};
	});
var $author$project$Extra$System$File$initialState = A3($author$project$Extra$System$File$FileSystem, $author$project$Extra$Type$Map$empty, _List_Nil, $elm$core$Maybe$Nothing);
var $author$project$Terminal$Command$LocalState = F6(
	function (a, b, c, d, e, f) {
		return {$: 'LocalState', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Terminal$Command$initialState = A6($author$project$Terminal$Command$LocalState, _List_Nil, _List_Nil, '', '', $elm$core$Maybe$Nothing, $elm$core$Maybe$Nothing);
var $author$project$Repl$Worker$initialModel = A8($author$project$Global$State, $author$project$Extra$System$File$initialState, $author$project$Builder$Http$initialState, $author$project$Builder$Elm$Details$initialState, $author$project$Builder$Build$initialState, $author$project$Builder$Generate$initialState, $author$project$Terminal$Command$initialState, $author$project$Terminal$Repl$initialLocalState, $author$project$Repl$Worker$initialLocalState);
var $author$project$Extra$System$File$Absolute = function (a) {
	return {$: 'Absolute', a: a};
};
var $author$project$Extra$System$File$Relative = function (a) {
	return {$: 'Relative', a: a};
};
var $elm$core$String$length = _String_length;
var $elm$core$String$slice = _String_slice;
var $elm$core$String$dropLeft = F2(
	function (n, string) {
		return (n < 1) ? string : A3(
			$elm$core$String$slice,
			n,
			$elm$core$String$length(string),
			string);
	});
var $elm$core$List$foldrHelper = F4(
	function (fn, acc, ctr, ls) {
		if (!ls.b) {
			return acc;
		} else {
			var a = ls.a;
			var r1 = ls.b;
			if (!r1.b) {
				return A2(fn, a, acc);
			} else {
				var b = r1.a;
				var r2 = r1.b;
				if (!r2.b) {
					return A2(
						fn,
						a,
						A2(fn, b, acc));
				} else {
					var c = r2.a;
					var r3 = r2.b;
					if (!r3.b) {
						return A2(
							fn,
							a,
							A2(
								fn,
								b,
								A2(fn, c, acc)));
					} else {
						var d = r3.a;
						var r4 = r3.b;
						var res = (ctr > 500) ? A3(
							$elm$core$List$foldl,
							fn,
							acc,
							$elm$core$List$reverse(r4)) : A4($elm$core$List$foldrHelper, fn, acc, ctr + 1, r4);
						return A2(
							fn,
							a,
							A2(
								fn,
								b,
								A2(
									fn,
									c,
									A2(fn, d, res))));
					}
				}
			}
		}
	});
var $elm$core$List$foldr = F3(
	function (fn, acc, ls) {
		return A4($elm$core$List$foldrHelper, fn, acc, 0, ls);
	});
var $elm$core$List$filter = F2(
	function (isGood, list) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, xs) {
					return isGood(x) ? A2($elm$core$List$cons, x, xs) : xs;
				}),
			_List_Nil,
			list);
	});
var $author$project$Extra$Type$List$filter = $elm$core$List$filter;
var $elm$core$Basics$neq = _Utils_notEqual;
var $author$project$Extra$Type$List$reverse = $elm$core$List$reverse;
var $author$project$Extra$System$File$fromStringHelper = F2(
	function (constructor, string) {
		return constructor(
			$author$project$Extra$Type$List$reverse(
				A2(
					$author$project$Extra$Type$List$filter,
					$elm$core$Basics$neq(''),
					A2($elm$core$String$split, '/', string))));
	});
var $elm$core$String$startsWith = _String_startsWith;
var $author$project$Extra$System$File$fromString = function (string) {
	return A2($elm$core$String$startsWith, '/', string) ? A2(
		$author$project$Extra$System$File$fromStringHelper,
		$author$project$Extra$System$File$Absolute,
		A2($elm$core$String$dropLeft, 1, string)) : A2($author$project$Extra$System$File$fromStringHelper, $author$project$Extra$System$File$Relative, string);
};
var $elm$core$Dict$Black = {$: 'Black'};
var $elm$core$Dict$RBNode_elm_builtin = F5(
	function (a, b, c, d, e) {
		return {$: 'RBNode_elm_builtin', a: a, b: b, c: c, d: d, e: e};
	});
var $elm$core$Dict$Red = {$: 'Red'};
var $elm$core$Dict$balance = F5(
	function (color, key, value, left, right) {
		if ((right.$ === 'RBNode_elm_builtin') && (right.a.$ === 'Red')) {
			var _v1 = right.a;
			var rK = right.b;
			var rV = right.c;
			var rLeft = right.d;
			var rRight = right.e;
			if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) {
				var _v3 = left.a;
				var lK = left.b;
				var lV = left.c;
				var lLeft = left.d;
				var lRight = left.e;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Red,
					key,
					value,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					color,
					rK,
					rV,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, left, rLeft),
					rRight);
			}
		} else {
			if ((((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) && (left.d.$ === 'RBNode_elm_builtin')) && (left.d.a.$ === 'Red')) {
				var _v5 = left.a;
				var lK = left.b;
				var lV = left.c;
				var _v6 = left.d;
				var _v7 = _v6.a;
				var llK = _v6.b;
				var llV = _v6.c;
				var llLeft = _v6.d;
				var llRight = _v6.e;
				var lRight = left.e;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Red,
					lK,
					lV,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, lRight, right));
			} else {
				return A5($elm$core$Dict$RBNode_elm_builtin, color, key, value, left, right);
			}
		}
	});
var $elm$core$Basics$compare = _Utils_compare;
var $elm$core$Dict$insertHelp = F3(
	function (key, value, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
		} else {
			var nColor = dict.a;
			var nKey = dict.b;
			var nValue = dict.c;
			var nLeft = dict.d;
			var nRight = dict.e;
			var _v1 = A2($elm$core$Basics$compare, key, nKey);
			switch (_v1.$) {
				case 'LT':
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						A3($elm$core$Dict$insertHelp, key, value, nLeft),
						nRight);
				case 'EQ':
					return A5($elm$core$Dict$RBNode_elm_builtin, nColor, nKey, value, nLeft, nRight);
				default:
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						nLeft,
						A3($elm$core$Dict$insertHelp, key, value, nRight));
			}
		}
	});
var $elm$core$Dict$insert = F3(
	function (key, value, dict) {
		var _v0 = A3($elm$core$Dict$insertHelp, key, value, dict);
		if ((_v0.$ === 'RBNode_elm_builtin') && (_v0.a.$ === 'Red')) {
			var _v1 = _v0.a;
			var k = _v0.b;
			var v = _v0.c;
			var l = _v0.d;
			var r = _v0.e;
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
		} else {
			var x = _v0;
			return x;
		}
	});
var $author$project$Extra$Type$Map$insert = $elm$core$Dict$insert;
var $author$project$Repl$Worker$lensReplMode = {
	getter: function (_v0) {
		var _v1 = _v0.h;
		var x = _v1.b;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var _v3 = _v2.h;
			var ai = _v3.a;
			var ci = _v3.c;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				d,
				e,
				f,
				g,
				A3($author$project$Repl$Worker$LocalState, ai, x, ci));
		})
};
var $author$project$Extra$System$IO$Pure = function (a) {
	return {$: 'Pure', a: a};
};
var $author$project$Extra$System$IO$modify = F2(
	function (f, s) {
		return _Utils_Tuple2(
			$author$project$Extra$System$IO$Pure(_Utils_Tuple0),
			f(s));
	});
var $author$project$Extra$Type$Lens$modify = F3(
	function (lens, f, a) {
		return A2(
			lens.setter,
			f(
				lens.getter(a)),
			a);
	});
var $author$project$Extra$System$IO$modifyLens = F2(
	function (lens, f) {
		return $author$project$Extra$System$IO$modify(
			A2($author$project$Extra$Type$Lens$modify, lens, f));
	});
var $author$project$Extra$System$IO$ImpureCmd = function (a) {
	return {$: 'ImpureCmd', a: a};
};
var $author$project$Extra$System$IO$ImpureCont = function (a) {
	return {$: 'ImpureCont', a: a};
};
var $author$project$Extra$System$IO$contFmap = F3(
	function (f, ca, ret) {
		return ca(
			function (a) {
				return ret(
					f(a));
			});
	});
var $elm$core$Platform$Cmd$map = _Platform_map;
var $author$project$Extra$System$IO$bind = F3(
	function (ma, f, s0) {
		var _v0 = ma(s0);
		switch (_v0.a.$) {
			case 'Pure':
				var a = _v0.a.a;
				var s1 = _v0.b;
				return A2(f, a, s1);
			case 'ImpureCmd':
				var cmd = _v0.a.a;
				var s1 = _v0.b;
				return _Utils_Tuple2(
					$author$project$Extra$System$IO$ImpureCmd(
						A2(
							$elm$core$Platform$Cmd$map,
							function (ima) {
								return A2($author$project$Extra$System$IO$bind, ima, f);
							},
							cmd)),
					s1);
			default:
				var cont = _v0.a.a;
				var s1 = _v0.b;
				return _Utils_Tuple2(
					$author$project$Extra$System$IO$ImpureCont(
						A2(
							$author$project$Extra$System$IO$contFmap,
							function (ima) {
								return A2($author$project$Extra$System$IO$bind, ima, f);
							},
							cont)),
					s1);
		}
	});
var $author$project$Extra$System$IO$get = function (s) {
	return _Utils_Tuple2(
		$author$project$Extra$System$IO$Pure(s),
		s);
};
var $author$project$Extra$System$IO$return = F2(
	function (a, s) {
		return _Utils_Tuple2(
			$author$project$Extra$System$IO$Pure(a),
			s);
	});
var $author$project$Extra$System$IO$fmap = F2(
	function (f, ma) {
		return A2(
			$author$project$Extra$System$IO$bind,
			ma,
			function (a) {
				return $author$project$Extra$System$IO$return(
					f(a));
			});
	});
var $author$project$Extra$System$IO$rmap = F2(
	function (ma, f) {
		return A2($author$project$Extra$System$IO$fmap, f, ma);
	});
var $author$project$Extra$System$IO$getLens = function (lens) {
	return A2($author$project$Extra$System$IO$rmap, $author$project$Extra$System$IO$get, lens.getter);
};
var $author$project$Extra$System$IO$liftCmdIO = F2(
	function (cmd, s) {
		return _Utils_Tuple2(
			$author$project$Extra$System$IO$ImpureCmd(cmd),
			s);
	});
var $elm$core$Task$Perform = function (a) {
	return {$: 'Perform', a: a};
};
var $elm$core$Task$succeed = _Scheduler_succeed;
var $elm$core$Task$init = $elm$core$Task$succeed(_Utils_Tuple0);
var $elm$core$List$map = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldr,
			F2(
				function (x, acc) {
					return A2(
						$elm$core$List$cons,
						f(x),
						acc);
				}),
			_List_Nil,
			xs);
	});
var $elm$core$Task$andThen = _Scheduler_andThen;
var $elm$core$Task$map = F2(
	function (func, taskA) {
		return A2(
			$elm$core$Task$andThen,
			function (a) {
				return $elm$core$Task$succeed(
					func(a));
			},
			taskA);
	});
var $elm$core$Task$map2 = F3(
	function (func, taskA, taskB) {
		return A2(
			$elm$core$Task$andThen,
			function (a) {
				return A2(
					$elm$core$Task$andThen,
					function (b) {
						return $elm$core$Task$succeed(
							A2(func, a, b));
					},
					taskB);
			},
			taskA);
	});
var $elm$core$Task$sequence = function (tasks) {
	return A3(
		$elm$core$List$foldr,
		$elm$core$Task$map2($elm$core$List$cons),
		$elm$core$Task$succeed(_List_Nil),
		tasks);
};
var $elm$core$Platform$sendToApp = _Platform_sendToApp;
var $elm$core$Task$spawnCmd = F2(
	function (router, _v0) {
		var task = _v0.a;
		return _Scheduler_spawn(
			A2(
				$elm$core$Task$andThen,
				$elm$core$Platform$sendToApp(router),
				task));
	});
var $elm$core$Task$onEffects = F3(
	function (router, commands, state) {
		return A2(
			$elm$core$Task$map,
			function (_v0) {
				return _Utils_Tuple0;
			},
			$elm$core$Task$sequence(
				A2(
					$elm$core$List$map,
					$elm$core$Task$spawnCmd(router),
					commands)));
	});
var $elm$core$Task$onSelfMsg = F3(
	function (_v0, _v1, _v2) {
		return $elm$core$Task$succeed(_Utils_Tuple0);
	});
var $elm$core$Task$cmdMap = F2(
	function (tagger, _v0) {
		var task = _v0.a;
		return $elm$core$Task$Perform(
			A2($elm$core$Task$map, tagger, task));
	});
_Platform_effectManagers['Task'] = _Platform_createManager($elm$core$Task$init, $elm$core$Task$onEffects, $elm$core$Task$onSelfMsg, $elm$core$Task$cmdMap);
var $elm$core$Task$command = _Platform_leaf('Task');
var $elm$core$Task$perform = F2(
	function (toMessage, task) {
		return $elm$core$Task$command(
			$elm$core$Task$Perform(
				A2($elm$core$Task$map, toMessage, task)));
	});
var $author$project$Extra$System$IO$liftTask = function (task) {
	return $author$project$Extra$System$IO$liftCmdIO(
		A2($elm$core$Task$perform, $author$project$Extra$System$IO$return, task));
};
var $elm$time$Time$Name = function (a) {
	return {$: 'Name', a: a};
};
var $elm$time$Time$Offset = function (a) {
	return {$: 'Offset', a: a};
};
var $elm$time$Time$Zone = F2(
	function (a, b) {
		return {$: 'Zone', a: a, b: b};
	});
var $elm$time$Time$customZone = $elm$time$Time$Zone;
var $elm$time$Time$Posix = function (a) {
	return {$: 'Posix', a: a};
};
var $elm$time$Time$millisToPosix = $elm$time$Time$Posix;
var $elm$time$Time$now = _Time_now($elm$time$Time$millisToPosix);
var $author$project$Extra$System$IO$now = $author$project$Extra$System$IO$liftTask($elm$time$Time$now);
var $author$project$Extra$System$File$Util$getTreeError = A2(
	$author$project$Extra$System$IO$rmap,
	$author$project$Extra$System$IO$now,
	function (time) {
		return _Utils_Tuple2(time, $author$project$Extra$Type$Map$empty);
	});
var $author$project$Extra$System$File$Remote$afterDirStep = F3(
	function (_v0, beforeFilePath, _v1) {
		return beforeFilePath;
	});
var $author$project$Extra$System$File$Remote$beforeDirStep = F2(
	function (name, dirPath) {
		return dirPath + ('/' + name);
	});
var $author$project$Extra$System$Http$Manager = function (a) {
	return {$: 'Manager', a: a};
};
var $author$project$Extra$System$Http$newManager = function (maybePrefix) {
	return $author$project$Extra$System$IO$return(
		$author$project$Extra$System$Http$Manager(maybePrefix));
};
var $elm$http$Http$BadStatus_ = F2(
	function (a, b) {
		return {$: 'BadStatus_', a: a, b: b};
	});
var $elm$http$Http$BadUrl_ = function (a) {
	return {$: 'BadUrl_', a: a};
};
var $elm$http$Http$GoodStatus_ = F2(
	function (a, b) {
		return {$: 'GoodStatus_', a: a, b: b};
	});
var $elm$http$Http$NetworkError_ = {$: 'NetworkError_'};
var $elm$http$Http$Receiving = function (a) {
	return {$: 'Receiving', a: a};
};
var $elm$http$Http$Sending = function (a) {
	return {$: 'Sending', a: a};
};
var $elm$http$Http$Timeout_ = {$: 'Timeout_'};
var $elm$core$Maybe$isJust = function (maybe) {
	if (maybe.$ === 'Just') {
		return true;
	} else {
		return false;
	}
};
var $elm$core$Platform$sendToSelf = _Platform_sendToSelf;
var $elm$core$Dict$get = F2(
	function (targetKey, dict) {
		get:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return $elm$core$Maybe$Nothing;
			} else {
				var key = dict.b;
				var value = dict.c;
				var left = dict.d;
				var right = dict.e;
				var _v1 = A2($elm$core$Basics$compare, targetKey, key);
				switch (_v1.$) {
					case 'LT':
						var $temp$targetKey = targetKey,
							$temp$dict = left;
						targetKey = $temp$targetKey;
						dict = $temp$dict;
						continue get;
					case 'EQ':
						return $elm$core$Maybe$Just(value);
					default:
						var $temp$targetKey = targetKey,
							$temp$dict = right;
						targetKey = $temp$targetKey;
						dict = $temp$dict;
						continue get;
				}
			}
		}
	});
var $elm$core$Dict$getMin = function (dict) {
	getMin:
	while (true) {
		if ((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) {
			var left = dict.d;
			var $temp$dict = left;
			dict = $temp$dict;
			continue getMin;
		} else {
			return dict;
		}
	}
};
var $elm$core$Dict$moveRedLeft = function (dict) {
	if (((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) && (dict.e.$ === 'RBNode_elm_builtin')) {
		if ((dict.e.d.$ === 'RBNode_elm_builtin') && (dict.e.d.a.$ === 'Red')) {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v1 = dict.d;
			var lClr = _v1.a;
			var lK = _v1.b;
			var lV = _v1.c;
			var lLeft = _v1.d;
			var lRight = _v1.e;
			var _v2 = dict.e;
			var rClr = _v2.a;
			var rK = _v2.b;
			var rV = _v2.c;
			var rLeft = _v2.d;
			var _v3 = rLeft.a;
			var rlK = rLeft.b;
			var rlV = rLeft.c;
			var rlL = rLeft.d;
			var rlR = rLeft.e;
			var rRight = _v2.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				$elm$core$Dict$Red,
				rlK,
				rlV,
				A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					rlL),
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, rK, rV, rlR, rRight));
		} else {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v4 = dict.d;
			var lClr = _v4.a;
			var lK = _v4.b;
			var lV = _v4.c;
			var lLeft = _v4.d;
			var lRight = _v4.e;
			var _v5 = dict.e;
			var rClr = _v5.a;
			var rK = _v5.b;
			var rV = _v5.c;
			var rLeft = _v5.d;
			var rRight = _v5.e;
			if (clr.$ === 'Black') {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			}
		}
	} else {
		return dict;
	}
};
var $elm$core$Dict$moveRedRight = function (dict) {
	if (((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) && (dict.e.$ === 'RBNode_elm_builtin')) {
		if ((dict.d.d.$ === 'RBNode_elm_builtin') && (dict.d.d.a.$ === 'Red')) {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v1 = dict.d;
			var lClr = _v1.a;
			var lK = _v1.b;
			var lV = _v1.c;
			var _v2 = _v1.d;
			var _v3 = _v2.a;
			var llK = _v2.b;
			var llV = _v2.c;
			var llLeft = _v2.d;
			var llRight = _v2.e;
			var lRight = _v1.e;
			var _v4 = dict.e;
			var rClr = _v4.a;
			var rK = _v4.b;
			var rV = _v4.c;
			var rLeft = _v4.d;
			var rRight = _v4.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				$elm$core$Dict$Red,
				lK,
				lV,
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, llK, llV, llLeft, llRight),
				A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					lRight,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight)));
		} else {
			var clr = dict.a;
			var k = dict.b;
			var v = dict.c;
			var _v5 = dict.d;
			var lClr = _v5.a;
			var lK = _v5.b;
			var lV = _v5.c;
			var lLeft = _v5.d;
			var lRight = _v5.e;
			var _v6 = dict.e;
			var rClr = _v6.a;
			var rK = _v6.b;
			var rV = _v6.c;
			var rLeft = _v6.d;
			var rRight = _v6.e;
			if (clr.$ === 'Black') {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			} else {
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					$elm$core$Dict$Black,
					k,
					v,
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, lK, lV, lLeft, lRight),
					A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, rK, rV, rLeft, rRight));
			}
		}
	} else {
		return dict;
	}
};
var $elm$core$Dict$removeHelpPrepEQGT = F7(
	function (targetKey, dict, color, key, value, left, right) {
		if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Red')) {
			var _v1 = left.a;
			var lK = left.b;
			var lV = left.c;
			var lLeft = left.d;
			var lRight = left.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				lK,
				lV,
				lLeft,
				A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Red, key, value, lRight, right));
		} else {
			_v2$2:
			while (true) {
				if ((right.$ === 'RBNode_elm_builtin') && (right.a.$ === 'Black')) {
					if (right.d.$ === 'RBNode_elm_builtin') {
						if (right.d.a.$ === 'Black') {
							var _v3 = right.a;
							var _v4 = right.d;
							var _v5 = _v4.a;
							return $elm$core$Dict$moveRedRight(dict);
						} else {
							break _v2$2;
						}
					} else {
						var _v6 = right.a;
						var _v7 = right.d;
						return $elm$core$Dict$moveRedRight(dict);
					}
				} else {
					break _v2$2;
				}
			}
			return dict;
		}
	});
var $elm$core$Dict$removeMin = function (dict) {
	if ((dict.$ === 'RBNode_elm_builtin') && (dict.d.$ === 'RBNode_elm_builtin')) {
		var color = dict.a;
		var key = dict.b;
		var value = dict.c;
		var left = dict.d;
		var lColor = left.a;
		var lLeft = left.d;
		var right = dict.e;
		if (lColor.$ === 'Black') {
			if ((lLeft.$ === 'RBNode_elm_builtin') && (lLeft.a.$ === 'Red')) {
				var _v3 = lLeft.a;
				return A5(
					$elm$core$Dict$RBNode_elm_builtin,
					color,
					key,
					value,
					$elm$core$Dict$removeMin(left),
					right);
			} else {
				var _v4 = $elm$core$Dict$moveRedLeft(dict);
				if (_v4.$ === 'RBNode_elm_builtin') {
					var nColor = _v4.a;
					var nKey = _v4.b;
					var nValue = _v4.c;
					var nLeft = _v4.d;
					var nRight = _v4.e;
					return A5(
						$elm$core$Dict$balance,
						nColor,
						nKey,
						nValue,
						$elm$core$Dict$removeMin(nLeft),
						nRight);
				} else {
					return $elm$core$Dict$RBEmpty_elm_builtin;
				}
			}
		} else {
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				key,
				value,
				$elm$core$Dict$removeMin(left),
				right);
		}
	} else {
		return $elm$core$Dict$RBEmpty_elm_builtin;
	}
};
var $elm$core$Dict$removeHelp = F2(
	function (targetKey, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		} else {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			if (_Utils_cmp(targetKey, key) < 0) {
				if ((left.$ === 'RBNode_elm_builtin') && (left.a.$ === 'Black')) {
					var _v4 = left.a;
					var lLeft = left.d;
					if ((lLeft.$ === 'RBNode_elm_builtin') && (lLeft.a.$ === 'Red')) {
						var _v6 = lLeft.a;
						return A5(
							$elm$core$Dict$RBNode_elm_builtin,
							color,
							key,
							value,
							A2($elm$core$Dict$removeHelp, targetKey, left),
							right);
					} else {
						var _v7 = $elm$core$Dict$moveRedLeft(dict);
						if (_v7.$ === 'RBNode_elm_builtin') {
							var nColor = _v7.a;
							var nKey = _v7.b;
							var nValue = _v7.c;
							var nLeft = _v7.d;
							var nRight = _v7.e;
							return A5(
								$elm$core$Dict$balance,
								nColor,
								nKey,
								nValue,
								A2($elm$core$Dict$removeHelp, targetKey, nLeft),
								nRight);
						} else {
							return $elm$core$Dict$RBEmpty_elm_builtin;
						}
					}
				} else {
					return A5(
						$elm$core$Dict$RBNode_elm_builtin,
						color,
						key,
						value,
						A2($elm$core$Dict$removeHelp, targetKey, left),
						right);
				}
			} else {
				return A2(
					$elm$core$Dict$removeHelpEQGT,
					targetKey,
					A7($elm$core$Dict$removeHelpPrepEQGT, targetKey, dict, color, key, value, left, right));
			}
		}
	});
var $elm$core$Dict$removeHelpEQGT = F2(
	function (targetKey, dict) {
		if (dict.$ === 'RBNode_elm_builtin') {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			if (_Utils_eq(targetKey, key)) {
				var _v1 = $elm$core$Dict$getMin(right);
				if (_v1.$ === 'RBNode_elm_builtin') {
					var minKey = _v1.b;
					var minValue = _v1.c;
					return A5(
						$elm$core$Dict$balance,
						color,
						minKey,
						minValue,
						left,
						$elm$core$Dict$removeMin(right));
				} else {
					return $elm$core$Dict$RBEmpty_elm_builtin;
				}
			} else {
				return A5(
					$elm$core$Dict$balance,
					color,
					key,
					value,
					left,
					A2($elm$core$Dict$removeHelp, targetKey, right));
			}
		} else {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		}
	});
var $elm$core$Dict$remove = F2(
	function (key, dict) {
		var _v0 = A2($elm$core$Dict$removeHelp, key, dict);
		if ((_v0.$ === 'RBNode_elm_builtin') && (_v0.a.$ === 'Red')) {
			var _v1 = _v0.a;
			var k = _v0.b;
			var v = _v0.c;
			var l = _v0.d;
			var r = _v0.e;
			return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, k, v, l, r);
		} else {
			var x = _v0;
			return x;
		}
	});
var $elm$core$Dict$update = F3(
	function (targetKey, alter, dictionary) {
		var _v0 = alter(
			A2($elm$core$Dict$get, targetKey, dictionary));
		if (_v0.$ === 'Just') {
			var value = _v0.a;
			return A3($elm$core$Dict$insert, targetKey, value, dictionary);
		} else {
			return A2($elm$core$Dict$remove, targetKey, dictionary);
		}
	});
var $elm$http$Http$emptyBody = _Http_emptyBody;
var $author$project$Extra$System$Http$methodGet = 'GET';
var $author$project$Extra$System$Http$parseUrlThrow = function (url) {
	return $author$project$Extra$System$IO$return(
		{body: $elm$http$Http$emptyBody, headers: _List_Nil, method: $author$project$Extra$System$Http$methodGet, url: url});
};
var $author$project$Extra$System$File$Util$performRequest = F3(
	function (prefix, remotePath, callback) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$Http$newManager(prefix),
			function (manager) {
				return A2(
					$author$project$Extra$System$IO$bind,
					$author$project$Extra$System$Http$parseUrlThrow(remotePath),
					callback(manager));
			});
	});
var $elm$core$Basics$composeR = F3(
	function (f, g, x) {
		return g(
			f(x));
	});
var $elm$http$Http$expectBytesResponse = F2(
	function (toMsg, toResult) {
		return A3(
			_Http_expect,
			'arraybuffer',
			_Http_toDataView,
			A2($elm$core$Basics$composeR, toResult, toMsg));
	});
var $author$project$Extra$Type$Either$Left = function (a) {
	return {$: 'Left', a: a};
};
var $author$project$Extra$Type$Either$Right = function (a) {
	return {$: 'Right', a: a};
};
var $author$project$Extra$System$Http$mapHandler = F2(
	function (handler, result) {
		return handler(
			function () {
				if (result.$ === 'Ok') {
					var a = result.a;
					return $author$project$Extra$Type$Either$Right(a);
				} else {
					var error = result.a;
					return $author$project$Extra$Type$Either$Left(error);
				}
			}());
	});
var $elm$http$Http$BadStatus = function (a) {
	return {$: 'BadStatus', a: a};
};
var $elm$http$Http$BadUrl = function (a) {
	return {$: 'BadUrl', a: a};
};
var $elm$http$Http$NetworkError = {$: 'NetworkError'};
var $elm$http$Http$Timeout = {$: 'Timeout'};
var $author$project$Extra$System$Http$toResult = function (response) {
	switch (response.$) {
		case 'BadUrl_':
			var url = response.a;
			return $elm$core$Result$Err(
				$elm$http$Http$BadUrl(url));
		case 'Timeout_':
			return $elm$core$Result$Err($elm$http$Http$Timeout);
		case 'NetworkError_':
			return $elm$core$Result$Err($elm$http$Http$NetworkError);
		case 'BadStatus_':
			var metadata = response.a;
			return $elm$core$Result$Err(
				$elm$http$Http$BadStatus(metadata.statusCode));
		default:
			var body = response.b;
			return $elm$core$Result$Ok(body);
	}
};
var $author$project$Extra$System$Http$bytesExpect = function (handler) {
	return A2(
		$elm$http$Http$expectBytesResponse,
		$author$project$Extra$System$Http$mapHandler(handler),
		$author$project$Extra$System$Http$toResult);
};
var $elm$core$Maybe$map = F2(
	function (f, maybe) {
		if (maybe.$ === 'Just') {
			var value = maybe.a;
			return $elm$core$Maybe$Just(
				f(value));
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Extra$System$Http$managedUrl = F2(
	function (_v0, url) {
		var maybePrefix = _v0.a;
		return A2(
			$elm$core$Maybe$map,
			function (prefix) {
				return _Utils_ap(prefix, url);
			},
			maybePrefix);
	});
var $elm$http$Http$Request = function (a) {
	return {$: 'Request', a: a};
};
var $elm$http$Http$State = F2(
	function (reqs, subs) {
		return {reqs: reqs, subs: subs};
	});
var $elm$http$Http$init = $elm$core$Task$succeed(
	A2($elm$http$Http$State, $elm$core$Dict$empty, _List_Nil));
var $elm$core$Process$kill = _Scheduler_kill;
var $elm$core$Process$spawn = _Scheduler_spawn;
var $elm$http$Http$updateReqs = F3(
	function (router, cmds, reqs) {
		updateReqs:
		while (true) {
			if (!cmds.b) {
				return $elm$core$Task$succeed(reqs);
			} else {
				var cmd = cmds.a;
				var otherCmds = cmds.b;
				if (cmd.$ === 'Cancel') {
					var tracker = cmd.a;
					var _v2 = A2($elm$core$Dict$get, tracker, reqs);
					if (_v2.$ === 'Nothing') {
						var $temp$router = router,
							$temp$cmds = otherCmds,
							$temp$reqs = reqs;
						router = $temp$router;
						cmds = $temp$cmds;
						reqs = $temp$reqs;
						continue updateReqs;
					} else {
						var pid = _v2.a;
						return A2(
							$elm$core$Task$andThen,
							function (_v3) {
								return A3(
									$elm$http$Http$updateReqs,
									router,
									otherCmds,
									A2($elm$core$Dict$remove, tracker, reqs));
							},
							$elm$core$Process$kill(pid));
					}
				} else {
					var req = cmd.a;
					return A2(
						$elm$core$Task$andThen,
						function (pid) {
							var _v4 = req.tracker;
							if (_v4.$ === 'Nothing') {
								return A3($elm$http$Http$updateReqs, router, otherCmds, reqs);
							} else {
								var tracker = _v4.a;
								return A3(
									$elm$http$Http$updateReqs,
									router,
									otherCmds,
									A3($elm$core$Dict$insert, tracker, pid, reqs));
							}
						},
						$elm$core$Process$spawn(
							A3(
								_Http_toTask,
								router,
								$elm$core$Platform$sendToApp(router),
								req)));
				}
			}
		}
	});
var $elm$http$Http$onEffects = F4(
	function (router, cmds, subs, state) {
		return A2(
			$elm$core$Task$andThen,
			function (reqs) {
				return $elm$core$Task$succeed(
					A2($elm$http$Http$State, reqs, subs));
			},
			A3($elm$http$Http$updateReqs, router, cmds, state.reqs));
	});
var $elm$core$List$maybeCons = F3(
	function (f, mx, xs) {
		var _v0 = f(mx);
		if (_v0.$ === 'Just') {
			var x = _v0.a;
			return A2($elm$core$List$cons, x, xs);
		} else {
			return xs;
		}
	});
var $elm$core$List$filterMap = F2(
	function (f, xs) {
		return A3(
			$elm$core$List$foldr,
			$elm$core$List$maybeCons(f),
			_List_Nil,
			xs);
	});
var $elm$http$Http$maybeSend = F4(
	function (router, desiredTracker, progress, _v0) {
		var actualTracker = _v0.a;
		var toMsg = _v0.b;
		return _Utils_eq(desiredTracker, actualTracker) ? $elm$core$Maybe$Just(
			A2(
				$elm$core$Platform$sendToApp,
				router,
				toMsg(progress))) : $elm$core$Maybe$Nothing;
	});
var $elm$http$Http$onSelfMsg = F3(
	function (router, _v0, state) {
		var tracker = _v0.a;
		var progress = _v0.b;
		return A2(
			$elm$core$Task$andThen,
			function (_v1) {
				return $elm$core$Task$succeed(state);
			},
			$elm$core$Task$sequence(
				A2(
					$elm$core$List$filterMap,
					A3($elm$http$Http$maybeSend, router, tracker, progress),
					state.subs)));
	});
var $elm$http$Http$Cancel = function (a) {
	return {$: 'Cancel', a: a};
};
var $elm$http$Http$cmdMap = F2(
	function (func, cmd) {
		if (cmd.$ === 'Cancel') {
			var tracker = cmd.a;
			return $elm$http$Http$Cancel(tracker);
		} else {
			var r = cmd.a;
			return $elm$http$Http$Request(
				{
					allowCookiesFromOtherDomains: r.allowCookiesFromOtherDomains,
					body: r.body,
					expect: A2(_Http_mapExpect, func, r.expect),
					headers: r.headers,
					method: r.method,
					timeout: r.timeout,
					tracker: r.tracker,
					url: r.url
				});
		}
	});
var $elm$http$Http$MySub = F2(
	function (a, b) {
		return {$: 'MySub', a: a, b: b};
	});
var $elm$http$Http$subMap = F2(
	function (func, _v0) {
		var tracker = _v0.a;
		var toMsg = _v0.b;
		return A2(
			$elm$http$Http$MySub,
			tracker,
			A2($elm$core$Basics$composeR, toMsg, func));
	});
_Platform_effectManagers['Http'] = _Platform_createManager($elm$http$Http$init, $elm$http$Http$onEffects, $elm$http$Http$onSelfMsg, $elm$http$Http$cmdMap, $elm$http$Http$subMap);
var $elm$http$Http$command = _Platform_leaf('Http');
var $elm$http$Http$subscription = _Platform_leaf('Http');
var $elm$http$Http$request = function (r) {
	return $elm$http$Http$command(
		$elm$http$Http$Request(
			{allowCookiesFromOtherDomains: false, body: r.body, expect: r.expect, headers: r.headers, method: r.method, timeout: r.timeout, tracker: r.tracker, url: r.url}));
};
var $author$project$Extra$System$Http$withExpect = F4(
	function (expectFun, request, manager, handler) {
		var _v0 = A2($author$project$Extra$System$Http$managedUrl, manager, request.url);
		if (_v0.$ === 'Just') {
			var url = _v0.a;
			return $author$project$Extra$System$IO$liftCmdIO(
				$elm$http$Http$request(
					{
						body: request.body,
						expect: expectFun(handler),
						headers: request.headers,
						method: request.method,
						timeout: $elm$core$Maybe$Nothing,
						tracker: $elm$core$Maybe$Nothing,
						url: url
					}));
		} else {
			return handler(
				$author$project$Extra$Type$Either$Left($elm$http$Http$NetworkError));
		}
	});
var $author$project$Extra$System$Http$withBytesResponse = F3(
	function (request, manager, handler) {
		return A4($author$project$Extra$System$Http$withExpect, $author$project$Extra$System$Http$bytesExpect, request, manager, handler);
	});
var $author$project$Extra$System$File$Util$requestBytes = F3(
	function (prefix, remotePath, callback) {
		return A3(
			$author$project$Extra$System$File$Util$performRequest,
			prefix,
			remotePath,
			F2(
				function (manager, request) {
					return A3($author$project$Extra$System$Http$withBytesResponse, request, manager, callback);
				}));
	});
var $author$project$Extra$System$File$Remote$getFile = F2(
	function (prefix, filePath) {
		return A3(
			$author$project$Extra$System$File$Util$requestBytes,
			prefix,
			filePath,
			function (response) {
				if (response.$ === 'Right') {
					var body = response.a;
					return $author$project$Extra$System$IO$return(
						$elm$core$Maybe$Just(body));
				} else {
					return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
				}
			});
	});
var $author$project$Extra$System$File$Remote$fileStep = F4(
	function (prefix, name, _v0, dirPath) {
		return _Utils_Tuple2(
			dirPath,
			A2($author$project$Extra$System$File$Remote$getFile, prefix, dirPath + ('/' + name)));
	});
var $elm$json$Json$Decode$decodeString = _Json_runOnString;
var $author$project$Extra$System$File$Util$DirectoryEntry = function (a) {
	return {$: 'DirectoryEntry', a: a};
};
var $elm$core$Dict$fromList = function (assocs) {
	return A3(
		$elm$core$List$foldl,
		F2(
			function (_v0, dict) {
				var key = _v0.a;
				var value = _v0.b;
				return A3($elm$core$Dict$insert, key, value, dict);
			}),
		$elm$core$Dict$empty,
		assocs);
};
var $elm$json$Json$Decode$keyValuePairs = _Json_decodeKeyValuePairs;
var $elm$json$Json$Decode$map = _Json_map1;
var $elm$json$Json$Decode$dict = function (decoder) {
	return A2(
		$elm$json$Json$Decode$map,
		$elm$core$Dict$fromList,
		$elm$json$Json$Decode$keyValuePairs(decoder));
};
var $elm$json$Json$Decode$succeed = _Json_succeed;
var $elm$json$Json$Decode$lazy = function (thunk) {
	return A2(
		$elm$json$Json$Decode$andThen,
		thunk,
		$elm$json$Json$Decode$succeed(_Utils_Tuple0));
};
var $elm$json$Json$Decode$map2 = _Json_map2;
var $elm$json$Json$Decode$oneOf = _Json_oneOf;
var $elm$core$Tuple$pair = F2(
	function (a, b) {
		return _Utils_Tuple2(a, b);
	});
var $elm$json$Json$Decode$int = _Json_decodeInt;
var $author$project$Extra$System$File$Util$timeDecoder = A2($elm$json$Json$Decode$map, $elm$time$Time$millisToPosix, $elm$json$Json$Decode$int);
var $author$project$Extra$System$File$Util$UnreadFileEntry = F2(
	function (a, b) {
		return {$: 'UnreadFileEntry', a: a, b: b};
	});
var $author$project$Extra$System$File$Util$timeFileEntryDecoder = A3(
	$elm$json$Json$Decode$map2,
	F2(
		function (time, size) {
			return _Utils_Tuple2(
				time,
				A2($author$project$Extra$System$File$Util$UnreadFileEntry, size, _Utils_Tuple0));
		}),
	A2($elm$json$Json$Decode$index, 1, $author$project$Extra$System$File$Util$timeDecoder),
	A2($elm$json$Json$Decode$index, 0, $elm$json$Json$Decode$int));
function $author$project$Extra$System$File$Util$cyclic$directoryDecoder() {
	return A3(
		$elm$json$Json$Decode$map2,
		$elm$core$Tuple$pair,
		A2($elm$json$Json$Decode$index, 1, $author$project$Extra$System$File$Util$timeDecoder),
		A2(
			$elm$json$Json$Decode$index,
			0,
			$elm$json$Json$Decode$dict(
				$author$project$Extra$System$File$Util$cyclic$timeEntryDecoder())));
}
function $author$project$Extra$System$File$Util$cyclic$timeEntryDecoder() {
	return $elm$json$Json$Decode$oneOf(
		_List_fromArray(
			[
				$author$project$Extra$System$File$Util$timeFileEntryDecoder,
				$author$project$Extra$System$File$Util$cyclic$timeDirEntryDecoder()
			]));
}
function $author$project$Extra$System$File$Util$cyclic$timeDirEntryDecoder() {
	return A2(
		$elm$json$Json$Decode$map,
		function (_v0) {
			var time = _v0.a;
			var directory = _v0.b;
			return _Utils_Tuple2(
				time,
				$author$project$Extra$System$File$Util$DirectoryEntry(directory));
		},
		$elm$json$Json$Decode$lazy(
			function (_v1) {
				return $author$project$Extra$System$File$Util$cyclic$directoryDecoder();
			}));
}
try {
	var $author$project$Extra$System$File$Util$directoryDecoder = $author$project$Extra$System$File$Util$cyclic$directoryDecoder();
	$author$project$Extra$System$File$Util$cyclic$directoryDecoder = function () {
		return $author$project$Extra$System$File$Util$directoryDecoder;
	};
	var $author$project$Extra$System$File$Util$timeEntryDecoder = $author$project$Extra$System$File$Util$cyclic$timeEntryDecoder();
	$author$project$Extra$System$File$Util$cyclic$timeEntryDecoder = function () {
		return $author$project$Extra$System$File$Util$timeEntryDecoder;
	};
	var $author$project$Extra$System$File$Util$timeDirEntryDecoder = $author$project$Extra$System$File$Util$cyclic$timeDirEntryDecoder();
	$author$project$Extra$System$File$Util$cyclic$timeDirEntryDecoder = function () {
		return $author$project$Extra$System$File$Util$timeDirEntryDecoder;
	};
} catch ($) {
	throw 'Some top-level definitions from `Extra.System.File.Util` are causing infinite recursion:\n\n  \n      directoryDecoder\n       \n      timeEntryDecoder\n       \n      timeDirEntryDecoder\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $elm$core$Dict$foldl = F3(
	function (func, acc, dict) {
		foldl:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return acc;
			} else {
				var key = dict.b;
				var value = dict.c;
				var left = dict.d;
				var right = dict.e;
				var $temp$func = func,
					$temp$acc = A3(
					func,
					key,
					value,
					A3($elm$core$Dict$foldl, func, acc, left)),
					$temp$dict = right;
				func = $temp$func;
				acc = $temp$acc;
				dict = $temp$dict;
				continue foldl;
			}
		}
	});
var $author$project$Extra$Type$Map$foldlWithKey = F3(
	function (f, z, m) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, b, a) {
					return A3(f, a, k, b);
				}),
			z,
			m);
	});
var $author$project$Extra$System$File$Util$mapFileEntry = F4(
	function (fileStep, v, name, size) {
		var _v0 = A3(fileStep, name, size, v);
		var newV = _v0.a;
		var io = _v0.b;
		return _Utils_Tuple2(
			newV,
			A2($author$project$Extra$System$File$Util$UnreadFileEntry, size, io));
	});
var $author$project$Extra$System$File$Util$directoryFolder = F6(
	function (fileStep, beforeDirStep, afterDirStep, _v2, name, _v3) {
		var v = _v2.a;
		var directory = _v2.b;
		var time = _v3.a;
		var entry = _v3.b;
		var _v4 = A6($author$project$Extra$System$File$Util$mapEntry, fileStep, beforeDirStep, afterDirStep, v, name, entry);
		var newV = _v4.a;
		var newEntry = _v4.b;
		return _Utils_Tuple2(
			newV,
			A3(
				$author$project$Extra$Type$Map$insert,
				name,
				_Utils_Tuple2(time, newEntry),
				directory));
	});
var $author$project$Extra$System$File$Util$foldDirectory = F5(
	function (fileStep, beforeDirStep, afterDirStep, v, directory) {
		return A3(
			$author$project$Extra$Type$Map$foldlWithKey,
			A3($author$project$Extra$System$File$Util$directoryFolder, fileStep, beforeDirStep, afterDirStep),
			_Utils_Tuple2(v, $author$project$Extra$Type$Map$empty),
			directory);
	});
var $author$project$Extra$System$File$Util$mapDirEntry = F6(
	function (fileStep, beforeDirStep, afterDirStep, v, name, subDirectory) {
		var _v1 = A5(
			$author$project$Extra$System$File$Util$foldDirectory,
			fileStep,
			beforeDirStep,
			afterDirStep,
			A2(beforeDirStep, name, v),
			subDirectory);
		var newV = _v1.a;
		var newSubDirectory = _v1.b;
		return _Utils_Tuple2(
			A3(afterDirStep, name, v, newV),
			$author$project$Extra$System$File$Util$DirectoryEntry(newSubDirectory));
	});
var $author$project$Extra$System$File$Util$mapEntry = F6(
	function (fileStep, beforeDirStep, afterDirStep, v, name, entry) {
		if (entry.$ === 'UnreadFileEntry') {
			var size = entry.a;
			return A4($author$project$Extra$System$File$Util$mapFileEntry, fileStep, v, name, size);
		} else {
			var subDirectory = entry.a;
			return A6($author$project$Extra$System$File$Util$mapDirEntry, fileStep, beforeDirStep, afterDirStep, v, name, subDirectory);
		}
	});
var $elm$core$Tuple$second = function (_v0) {
	var y = _v0.b;
	return y;
};
var $author$project$Extra$System$File$Util$processUnreadFiles = F5(
	function (fileStep, beforeDirStep, afterDirStep, v, directory) {
		return A5($author$project$Extra$System$File$Util$foldDirectory, fileStep, beforeDirStep, afterDirStep, v, directory).b;
	});
var $author$project$Extra$System$File$Util$getTree = F5(
	function (fileStep, beforeDirStep, afterDirStep, v, tree) {
		var _v0 = A2($elm$json$Json$Decode$decodeString, $author$project$Extra$System$File$Util$directoryDecoder, tree);
		if (_v0.$ === 'Ok') {
			var _v1 = _v0.a;
			var time = _v1.a;
			var directory = _v1.b;
			return $author$project$Extra$System$IO$return(
				_Utils_Tuple2(
					time,
					A5($author$project$Extra$System$File$Util$processUnreadFiles, fileStep, beforeDirStep, afterDirStep, v, directory)));
		} else {
			return $author$project$Extra$System$File$Util$getTreeError;
		}
	});
var $author$project$Extra$System$File$Remote$processBody = F3(
	function (prefix, remotePath, body) {
		return A5(
			$author$project$Extra$System$File$Util$getTree,
			$author$project$Extra$System$File$Remote$fileStep(prefix),
			$author$project$Extra$System$File$Remote$beforeDirStep,
			$author$project$Extra$System$File$Remote$afterDirStep,
			remotePath,
			body);
	});
var $elm$http$Http$expectStringResponse = F2(
	function (toMsg, toResult) {
		return A3(
			_Http_expect,
			'',
			$elm$core$Basics$identity,
			A2($elm$core$Basics$composeR, toResult, toMsg));
	});
var $elm$http$Http$BadBody = function (a) {
	return {$: 'BadBody', a: a};
};
var $elm$core$Result$mapError = F2(
	function (f, result) {
		if (result.$ === 'Ok') {
			var v = result.a;
			return $elm$core$Result$Ok(v);
		} else {
			var e = result.a;
			return $elm$core$Result$Err(
				f(e));
		}
	});
var $elm$http$Http$resolve = F2(
	function (toResult, response) {
		switch (response.$) {
			case 'BadUrl_':
				var url = response.a;
				return $elm$core$Result$Err(
					$elm$http$Http$BadUrl(url));
			case 'Timeout_':
				return $elm$core$Result$Err($elm$http$Http$Timeout);
			case 'NetworkError_':
				return $elm$core$Result$Err($elm$http$Http$NetworkError);
			case 'BadStatus_':
				var metadata = response.a;
				return $elm$core$Result$Err(
					$elm$http$Http$BadStatus(metadata.statusCode));
			default:
				var body = response.b;
				return A2(
					$elm$core$Result$mapError,
					$elm$http$Http$BadBody,
					toResult(body));
		}
	});
var $elm$http$Http$expectString = function (toMsg) {
	return A2(
		$elm$http$Http$expectStringResponse,
		toMsg,
		$elm$http$Http$resolve($elm$core$Result$Ok));
};
var $author$project$Extra$System$Http$stringExpect = function (handler) {
	return $elm$http$Http$expectString(
		$author$project$Extra$System$Http$mapHandler(handler));
};
var $author$project$Extra$System$Http$withStringResponse = F3(
	function (request, manager, handler) {
		return A4($author$project$Extra$System$Http$withExpect, $author$project$Extra$System$Http$stringExpect, request, manager, handler);
	});
var $author$project$Extra$System$File$Util$requestString = F3(
	function (prefix, remotePath, callback) {
		return A3(
			$author$project$Extra$System$File$Util$performRequest,
			prefix,
			remotePath,
			F2(
				function (manager, request) {
					return A3($author$project$Extra$System$Http$withStringResponse, request, manager, callback);
				}));
	});
var $author$project$Extra$System$File$Remote$getTree = F2(
	function (prefix, remotePath) {
		return A3(
			$author$project$Extra$System$File$Util$requestString,
			prefix,
			remotePath,
			function (response) {
				if (response.$ === 'Right') {
					var body = response.a;
					return A3($author$project$Extra$System$File$Remote$processBody, prefix, remotePath, body);
				} else {
					return $author$project$Extra$System$File$Util$getTreeError;
				}
			});
	});
var $author$project$Extra$System$File$lensMountPrefix = {
	getter: function (_v0) {
		var _v1 = _v0.a;
		var x = _v1.c;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var _v3 = _v2.a;
			var ai = _v3.a;
			var bi = _v3.b;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				A3($author$project$Extra$System$File$FileSystem, ai, bi, x),
				b,
				c,
				d,
				e,
				f,
				g,
				h);
		})
};
var $elm$core$Maybe$andThen = F2(
	function (callback, maybeValue) {
		if (maybeValue.$ === 'Just') {
			var value = maybeValue.a;
			return callback(value);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Extra$System$File$DirectoryEntry = function (a) {
	return {$: 'DirectoryEntry', a: a};
};
var $author$project$Extra$System$File$MountedFileEntry = F2(
	function (a, b) {
		return {$: 'MountedFileEntry', a: a, b: b};
	});
var $elm$core$Dict$map = F2(
	function (func, dict) {
		if (dict.$ === 'RBEmpty_elm_builtin') {
			return $elm$core$Dict$RBEmpty_elm_builtin;
		} else {
			var color = dict.a;
			var key = dict.b;
			var value = dict.c;
			var left = dict.d;
			var right = dict.e;
			return A5(
				$elm$core$Dict$RBNode_elm_builtin,
				color,
				key,
				A2(func, key, value),
				A2($elm$core$Dict$map, func, left),
				A2($elm$core$Dict$map, func, right));
		}
	});
var $author$project$Extra$Type$Map$mapWithKey = $elm$core$Dict$map;
var $author$project$Extra$Type$Map$map = F2(
	function (f, m) {
		return A2(
			$author$project$Extra$Type$Map$mapWithKey,
			function (_v0) {
				return f;
			},
			m);
	});
var $elm$core$Tuple$mapSecond = F2(
	function (func, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			x,
			func(y));
	});
var $author$project$Extra$System$File$mapMountedDirectory = function (mountedDirectory) {
	return A2(
		$author$project$Extra$Type$Map$map,
		$elm$core$Tuple$mapSecond($author$project$Extra$System$File$mapMountedEntry),
		mountedDirectory);
};
var $author$project$Extra$System$File$mapMountedEntry = function (mountedEntry) {
	if (mountedEntry.$ === 'UnreadFileEntry') {
		var size = mountedEntry.a;
		var io = mountedEntry.b;
		return A2($author$project$Extra$System$File$MountedFileEntry, size, io);
	} else {
		var directory = mountedEntry.a;
		return $author$project$Extra$System$File$DirectoryEntry(
			$author$project$Extra$System$File$mapMountedDirectory(directory));
	}
};
var $author$project$Extra$System$File$mapMountedTree = function (mountedTree) {
	return A2($elm$core$Tuple$mapSecond, $author$project$Extra$System$File$mapMountedDirectory, mountedTree);
};
var $elm$core$Dict$isEmpty = function (dict) {
	if (dict.$ === 'RBEmpty_elm_builtin') {
		return true;
	} else {
		return false;
	}
};
var $author$project$Extra$Type$Map$null = $elm$core$Dict$isEmpty;
var $author$project$Extra$System$File$mountEntry = F2(
	function (_v0, _v1) {
		var time = _v0.a;
		var mountedDirectory = _v0.b;
		var directory = _v1.a;
		var fileName = _v1.b;
		var maybeEntry = _v1.c;
		if (maybeEntry.$ === 'Nothing') {
			return (fileName === '') ? ($author$project$Extra$Type$Map$null(directory) ? $elm$core$Maybe$Just(mountedDirectory) : $elm$core$Maybe$Nothing) : $elm$core$Maybe$Just(
				A3(
					$author$project$Extra$Type$Map$insert,
					fileName,
					_Utils_Tuple2(
						time,
						$author$project$Extra$System$File$DirectoryEntry(mountedDirectory)),
					directory));
		} else {
			if (maybeEntry.a.b.$ === 'DirectoryEntry') {
				var _v3 = maybeEntry.a;
				var subDirectory = _v3.b.a;
				return $author$project$Extra$Type$Map$null(subDirectory) ? $elm$core$Maybe$Just(
					A3(
						$author$project$Extra$Type$Map$insert,
						fileName,
						_Utils_Tuple2(
							time,
							$author$project$Extra$System$File$DirectoryEntry(mountedDirectory)),
						directory)) : $elm$core$Maybe$Nothing;
			} else {
				return $elm$core$Maybe$Nothing;
			}
		}
	});
var $author$project$Extra$System$IO$liftCmd = function (cmd) {
	return $author$project$Extra$System$IO$liftCmdIO(
		A2($elm$core$Platform$Cmd$map, $author$project$Extra$System$IO$return, cmd));
};
var $author$project$Extra$System$File$getTime = $author$project$Extra$System$IO$liftCmd(
	A2($elm$core$Task$perform, $elm$core$Basics$identity, $elm$time$Time$now));
var $author$project$Extra$System$File$lensRoot = {
	getter: function (_v0) {
		var _v1 = _v0.a;
		var x = _v1.a;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var _v3 = _v2.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				A3($author$project$Extra$System$File$FileSystem, x, bi, ci),
				b,
				c,
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Extra$System$IO$liftA2 = F3(
	function (f, ma, mb) {
		return A2(
			$author$project$Extra$System$IO$bind,
			ma,
			function (a) {
				return A2(
					$author$project$Extra$System$IO$bind,
					mb,
					function (b) {
						return $author$project$Extra$System$IO$return(
							A2(f, a, b));
					});
			});
	});
var $author$project$Extra$System$File$modifyNames = F2(
	function (path, f) {
		if (path.$ === 'Absolute') {
			var names = path.a;
			return $author$project$Extra$System$File$Absolute(
				f(names));
		} else {
			var names = path.a;
			return $author$project$Extra$System$File$Relative(
				f(names));
		}
	});
var $author$project$Extra$System$File$combine = F2(
	function (bPath, aPath) {
		if (aPath.$ === 'Absolute') {
			return aPath;
		} else {
			var aNames = aPath.a;
			return A2(
				$author$project$Extra$System$File$modifyNames,
				bPath,
				function (bNames) {
					return _Utils_ap(aNames, bNames);
				});
		}
	});
var $author$project$Extra$System$File$lensCwd = {
	getter: function (_v0) {
		var _v1 = _v0.a;
		var x = _v1.b;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var _v3 = _v2.a;
			var ai = _v3.a;
			var ci = _v3.c;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				A3($author$project$Extra$System$File$FileSystem, ai, x, ci),
				b,
				c,
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Extra$System$File$getCurrentDirectory = A2(
	$author$project$Extra$System$IO$rmap,
	$author$project$Extra$System$IO$get,
	function (s) {
		return $author$project$Extra$System$File$Absolute(
			$author$project$Extra$System$File$lensCwd.getter(s));
	});
var $author$project$Extra$System$File$makeAbsolute = function (path) {
	if (path.$ === 'Absolute') {
		return $author$project$Extra$System$IO$return(path);
	} else {
		return A2(
			$author$project$Extra$System$IO$rmap,
			$author$project$Extra$System$File$getCurrentDirectory,
			function (cwd) {
				return A2($author$project$Extra$System$File$combine, cwd, path);
			});
	}
};
var $author$project$Extra$System$IO$putLens = F2(
	function (lens, s1) {
		return $author$project$Extra$System$IO$modify(
			lens.setter(s1));
	});
var $author$project$Extra$Type$List$foldl = F3(
	function (f, z, l) {
		return A3(
			$elm$core$List$foldl,
			F2(
				function (a, b) {
					return A2(f, b, a);
				}),
			z,
			l);
	});
var $author$project$Extra$System$File$getNames = function (path) {
	if (path.$ === 'Absolute') {
		var names = path.a;
		return names;
	} else {
		var names = path.a;
		return names;
	}
};
var $author$project$Extra$Type$Map$lookup = $elm$core$Dict$get;
var $author$project$Extra$System$File$walkFileSystemPure = F5(
	function (createDirectories, filePath, now, callback, root) {
		var up = F2(
			function (directory, visited) {
				return A3(
					$author$project$Extra$Type$List$foldl,
					F2(
						function (changedDirectory, _v6) {
							var parentDirectory = _v6.a;
							var fileName = _v6.b;
							return A3(
								$author$project$Extra$Type$Map$insert,
								fileName,
								_Utils_Tuple2(
									now,
									$author$project$Extra$System$File$DirectoryEntry(changedDirectory)),
								parentDirectory);
						}),
					directory,
					visited);
			});
		var finishWalk = F2(
			function (visited, input) {
				var _v4 = A2(callback, input, now);
				if (_v4.a.$ === 'Just') {
					var changedDirectory = _v4.a.a;
					var result = _v4.b;
					return _Utils_Tuple2(
						result,
						A2(up, changedDirectory, visited));
				} else {
					var _v5 = _v4.a;
					var result = _v4.b;
					return _Utils_Tuple2(result, root);
				}
			});
		var down = F3(
			function (visited, fileNames, directory) {
				down:
				while (true) {
					if (!fileNames.b) {
						return A2(
							finishWalk,
							visited,
							$elm$core$Maybe$Just(
								_Utils_Tuple3(directory, '', $elm$core$Maybe$Nothing)));
					} else {
						if (!fileNames.b.b) {
							var fileName = fileNames.a;
							var _v1 = A2($author$project$Extra$Type$Map$lookup, fileName, directory);
							if (_v1.$ === 'Just') {
								var timeAndEntry = _v1.a;
								return A2(
									finishWalk,
									visited,
									$elm$core$Maybe$Just(
										_Utils_Tuple3(
											directory,
											fileName,
											$elm$core$Maybe$Just(timeAndEntry))));
							} else {
								return A2(
									finishWalk,
									visited,
									$elm$core$Maybe$Just(
										_Utils_Tuple3(directory, fileName, $elm$core$Maybe$Nothing)));
							}
						} else {
							var fileName = fileNames.a;
							var subFileNames = fileNames.b;
							var _v2 = A2($author$project$Extra$Type$Map$lookup, fileName, directory);
							if ((_v2.$ === 'Just') && (_v2.a.b.$ === 'DirectoryEntry')) {
								var _v3 = _v2.a;
								var subDirectory = _v3.b.a;
								var $temp$visited = A2(
									$elm$core$List$cons,
									_Utils_Tuple2(directory, fileName),
									visited),
									$temp$fileNames = subFileNames,
									$temp$directory = subDirectory;
								visited = $temp$visited;
								fileNames = $temp$fileNames;
								directory = $temp$directory;
								continue down;
							} else {
								if (createDirectories) {
									var $temp$visited = A2(
										$elm$core$List$cons,
										_Utils_Tuple2(directory, fileName),
										visited),
										$temp$fileNames = subFileNames,
										$temp$directory = $author$project$Extra$Type$Map$empty;
									visited = $temp$visited;
									fileNames = $temp$fileNames;
									directory = $temp$directory;
									continue down;
								} else {
									return A2(finishWalk, visited, $elm$core$Maybe$Nothing);
								}
							}
						}
					}
				}
			});
		return A3(
			down,
			_List_Nil,
			$author$project$Extra$Type$List$reverse(
				$author$project$Extra$System$File$getNames(filePath)),
			root);
	});
var $author$project$Extra$System$File$walkFileSystem = F3(
	function (createDirectories, filePath, callback) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A3(
				$author$project$Extra$System$IO$liftA2,
				$elm$core$Tuple$pair,
				$author$project$Extra$System$File$makeAbsolute(filePath),
				$author$project$Extra$System$File$getTime),
			function (_v0) {
				var absolutePath = _v0.a;
				var now = _v0.b;
				return A2(
					$author$project$Extra$System$IO$bind,
					$author$project$Extra$System$IO$get,
					function (s) {
						var root = $author$project$Extra$System$File$lensRoot.getter(s);
						var _v1 = A5($author$project$Extra$System$File$walkFileSystemPure, createDirectories, absolutePath, now, callback, root);
						var result = _v1.a;
						var newRoot = _v1.b;
						return A2(
							$author$project$Extra$System$IO$rmap,
							A2($author$project$Extra$System$IO$putLens, $author$project$Extra$System$File$lensRoot, newRoot),
							function (_v2) {
								return result;
							});
					});
			});
	});
var $author$project$Extra$System$File$mountHelper = F2(
	function (filePath, mountedTree) {
		return A3(
			$author$project$Extra$System$File$walkFileSystem,
			true,
			filePath,
			F2(
				function (maybeNode, _v0) {
					return _Utils_Tuple2(
						A2(
							$elm$core$Maybe$andThen,
							$author$project$Extra$System$File$mountEntry(
								$author$project$Extra$System$File$mapMountedTree(mountedTree)),
							maybeNode),
						_Utils_Tuple0);
				}));
	});
var $author$project$Extra$System$File$mountRemote = F2(
	function (mountPoint, filePath) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$IO$getLens($author$project$Extra$System$File$lensMountPrefix),
			function (mountPrefix) {
				return A2(
					$author$project$Extra$System$IO$bind,
					A2($author$project$Extra$System$File$Remote$getTree, mountPrefix, mountPoint),
					$author$project$Extra$System$File$mountHelper(filePath));
			});
	});
var $author$project$Extra$System$File$Static$afterDirStep = F3(
	function (_v0, _v1, afterAcc) {
		return afterAcc;
	});
var $author$project$Extra$System$File$Static$beforeDirStep = F2(
	function (_v0, acc) {
		return acc;
	});
var $elm$bytes$Bytes$Encode$getWidth = function (builder) {
	switch (builder.$) {
		case 'I8':
			return 1;
		case 'I16':
			return 2;
		case 'I32':
			return 4;
		case 'U8':
			return 1;
		case 'U16':
			return 2;
		case 'U32':
			return 4;
		case 'F32':
			return 4;
		case 'F64':
			return 8;
		case 'Seq':
			var w = builder.a;
			return w;
		case 'Utf8':
			var w = builder.a;
			return w;
		default:
			var bs = builder.a;
			return _Bytes_width(bs);
	}
};
var $elm$bytes$Bytes$LE = {$: 'LE'};
var $elm$bytes$Bytes$Encode$write = F3(
	function (builder, mb, offset) {
		switch (builder.$) {
			case 'I8':
				var n = builder.a;
				return A3(_Bytes_write_i8, mb, offset, n);
			case 'I16':
				var e = builder.a;
				var n = builder.b;
				return A4(
					_Bytes_write_i16,
					mb,
					offset,
					n,
					_Utils_eq(e, $elm$bytes$Bytes$LE));
			case 'I32':
				var e = builder.a;
				var n = builder.b;
				return A4(
					_Bytes_write_i32,
					mb,
					offset,
					n,
					_Utils_eq(e, $elm$bytes$Bytes$LE));
			case 'U8':
				var n = builder.a;
				return A3(_Bytes_write_u8, mb, offset, n);
			case 'U16':
				var e = builder.a;
				var n = builder.b;
				return A4(
					_Bytes_write_u16,
					mb,
					offset,
					n,
					_Utils_eq(e, $elm$bytes$Bytes$LE));
			case 'U32':
				var e = builder.a;
				var n = builder.b;
				return A4(
					_Bytes_write_u32,
					mb,
					offset,
					n,
					_Utils_eq(e, $elm$bytes$Bytes$LE));
			case 'F32':
				var e = builder.a;
				var n = builder.b;
				return A4(
					_Bytes_write_f32,
					mb,
					offset,
					n,
					_Utils_eq(e, $elm$bytes$Bytes$LE));
			case 'F64':
				var e = builder.a;
				var n = builder.b;
				return A4(
					_Bytes_write_f64,
					mb,
					offset,
					n,
					_Utils_eq(e, $elm$bytes$Bytes$LE));
			case 'Seq':
				var bs = builder.b;
				return A3($elm$bytes$Bytes$Encode$writeSequence, bs, mb, offset);
			case 'Utf8':
				var s = builder.b;
				return A3(_Bytes_write_string, mb, offset, s);
			default:
				var bs = builder.a;
				return A3(_Bytes_write_bytes, mb, offset, bs);
		}
	});
var $elm$bytes$Bytes$Encode$writeSequence = F3(
	function (builders, mb, offset) {
		writeSequence:
		while (true) {
			if (!builders.b) {
				return offset;
			} else {
				var b = builders.a;
				var bs = builders.b;
				var $temp$builders = bs,
					$temp$mb = mb,
					$temp$offset = A3($elm$bytes$Bytes$Encode$write, b, mb, offset);
				builders = $temp$builders;
				mb = $temp$mb;
				offset = $temp$offset;
				continue writeSequence;
			}
		}
	});
var $elm$bytes$Bytes$Decode$decode = F2(
	function (_v0, bs) {
		var decoder = _v0.a;
		return A2(_Bytes_decode, decoder, bs);
	});
var $elm$bytes$Bytes$Decode$Decoder = function (a) {
	return {$: 'Decoder', a: a};
};
var $elm$bytes$Bytes$Decode$andThen = F2(
	function (callback, _v0) {
		var decodeA = _v0.a;
		return $elm$bytes$Bytes$Decode$Decoder(
			F2(
				function (bites, offset) {
					var _v1 = A2(decodeA, bites, offset);
					var newOffset = _v1.a;
					var a = _v1.b;
					var _v2 = callback(a);
					var decodeB = _v2.a;
					return A2(decodeB, bites, newOffset);
				}));
	});
var $elm$bytes$Bytes$Decode$bytes = function (n) {
	return $elm$bytes$Bytes$Decode$Decoder(
		_Bytes_read_bytes(n));
};
var $author$project$Extra$System$File$Util$sliceDecoder = F2(
	function (offset, length) {
		return A2(
			$elm$bytes$Bytes$Decode$andThen,
			function (_v0) {
				return $elm$bytes$Bytes$Decode$bytes(length);
			},
			$elm$bytes$Bytes$Decode$bytes(offset));
	});
var $author$project$Extra$System$File$Util$sliceBytes = F3(
	function (offset, length, bytes) {
		return A2(
			$elm$bytes$Bytes$Decode$decode,
			A2($author$project$Extra$System$File$Util$sliceDecoder, offset, length),
			bytes);
	});
var $author$project$Extra$System$File$Static$fileStep = F3(
	function (_v0, size, _v1) {
		var offset = _v1.a;
		var bytes = _v1.b;
		return _Utils_Tuple2(
			_Utils_Tuple2(offset + size, bytes),
			$author$project$Extra$System$IO$return(
				A3($author$project$Extra$System$File$Util$sliceBytes, offset, size, bytes)));
	});
var $elm$bytes$Bytes$BE = {$: 'BE'};
var $elm$bytes$Bytes$Decode$map = F2(
	function (func, _v0) {
		var decodeA = _v0.a;
		return $elm$bytes$Bytes$Decode$Decoder(
			F2(
				function (bites, offset) {
					var _v1 = A2(decodeA, bites, offset);
					var aOffset = _v1.a;
					var a = _v1.b;
					return _Utils_Tuple2(
						aOffset,
						func(a));
				}));
	});
var $elm$bytes$Bytes$Decode$string = function (n) {
	return $elm$bytes$Bytes$Decode$Decoder(
		_Bytes_read_string(n));
};
var $elm$bytes$Bytes$Decode$unsignedInt32 = function (endianness) {
	return $elm$bytes$Bytes$Decode$Decoder(
		_Bytes_read_u32(
			_Utils_eq(endianness, $elm$bytes$Bytes$LE)));
};
var $author$project$Extra$System$File$Static$treeBytesDecoder = A2(
	$elm$bytes$Bytes$Decode$andThen,
	function (treeLength) {
		return A2(
			$elm$bytes$Bytes$Decode$map,
			function (tree) {
				return _Utils_Tuple2(4 + treeLength, tree);
			},
			$elm$bytes$Bytes$Decode$string(treeLength));
	},
	$elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$BE));
var $author$project$Extra$System$File$Static$processBodyBytes = function (body) {
	var _v0 = A2($elm$bytes$Bytes$Decode$decode, $author$project$Extra$System$File$Static$treeBytesDecoder, body);
	if (_v0.$ === 'Just') {
		var _v1 = _v0.a;
		var contentOffset = _v1.a;
		var tree = _v1.b;
		return A5(
			$author$project$Extra$System$File$Util$getTree,
			$author$project$Extra$System$File$Static$fileStep,
			$author$project$Extra$System$File$Static$beforeDirStep,
			$author$project$Extra$System$File$Static$afterDirStep,
			_Utils_Tuple2(contentOffset, body),
			tree);
	} else {
		return $author$project$Extra$System$File$Util$getTreeError;
	}
};
var $author$project$Extra$System$File$Static$getTree = F2(
	function (prefix, remotePath) {
		return A3(
			$author$project$Extra$System$File$Util$requestBytes,
			prefix,
			remotePath,
			function (response) {
				if (response.$ === 'Right') {
					var body = response.a;
					return $author$project$Extra$System$File$Static$processBodyBytes(body);
				} else {
					return $author$project$Extra$System$File$Util$getTreeError;
				}
			});
	});
var $author$project$Extra$System$File$mountStatic = F2(
	function (mountPoint, filePath) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A2(
				$author$project$Extra$System$File$Static$getTree,
				$elm$core$Maybe$Just(''),
				mountPoint),
			$author$project$Extra$System$File$mountHelper(filePath));
	});
var $author$project$Extra$System$IO$noOp = $author$project$Extra$System$IO$return(_Utils_Tuple0);
var $author$project$Extra$System$File$setCurrentDirectory = function (cwd) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Extra$System$File$makeAbsolute(cwd),
		function (absolutePath) {
			return A2(
				$author$project$Extra$System$IO$putLens,
				$author$project$Extra$System$File$lensCwd,
				$author$project$Extra$System$File$getNames(absolutePath));
		});
};
var $author$project$Extra$System$File$setMountPrefix = function (mountPrefix) {
	return A2($author$project$Extra$System$IO$putLens, $author$project$Extra$System$File$lensMountPrefix, mountPrefix);
};
var $author$project$Builder$Http$lensPrefix = {
	getter: function (_v0) {
		var x = _v0.b;
		return x;
	},
	setter: F2(
		function (x, _v1) {
			var a = _v1.a;
			var c = _v1.c;
			var d = _v1.d;
			var e = _v1.e;
			var f = _v1.f;
			var g = _v1.g;
			var h = _v1.h;
			return A8($author$project$Global$State, a, x, c, d, e, f, g, h);
		})
};
var $author$project$Builder$Http$setPrefix = function (prefix) {
	return A2($author$project$Extra$System$IO$putLens, $author$project$Builder$Http$lensPrefix, prefix);
};
var $author$project$Repl$Worker$flagToMsg = function (_v0) {
	var config = _v0.a;
	var val1 = _v0.b;
	var val2 = _v0.c;
	switch (config) {
		case 'httpPrefix':
			return $author$project$Builder$Http$setPrefix(
				$elm$core$Maybe$Just(val1));
		case 'mountPrefix':
			return $author$project$Extra$System$File$setMountPrefix(
				$elm$core$Maybe$Just(val1));
		case 'mountRemote':
			return A2(
				$author$project$Extra$System$File$mountRemote,
				val1,
				$author$project$Extra$System$File$fromString(val2));
		case 'mountStatic':
			return A2(
				$author$project$Extra$System$File$mountStatic,
				val1,
				$author$project$Extra$System$File$fromString(val2));
		case 'currentDir':
			return $author$project$Extra$System$File$setCurrentDirectory(
				$author$project$Extra$System$File$fromString(val1));
		case 'import':
			return A2(
				$author$project$Extra$System$IO$modifyLens,
				$author$project$Repl$Worker$lensReplMode,
				function (_v2) {
					var imports = _v2.a;
					var types = _v2.b;
					var decls = _v2.c;
					return _Utils_Tuple3(
						A3($author$project$Extra$Type$Map$insert, val1, val2 + '\n', imports),
						types,
						decls);
				});
		case 'type':
			return A2(
				$author$project$Extra$System$IO$modifyLens,
				$author$project$Repl$Worker$lensReplMode,
				function (_v3) {
					var imports = _v3.a;
					var types = _v3.b;
					var decls = _v3.c;
					return _Utils_Tuple3(
						imports,
						A3($author$project$Extra$Type$Map$insert, val1, val2 + '\n', types),
						decls);
				});
		case 'decl':
			return A2(
				$author$project$Extra$System$IO$modifyLens,
				$author$project$Repl$Worker$lensReplMode,
				function (_v4) {
					var imports = _v4.a;
					var types = _v4.b;
					var decls = _v4.c;
					return _Utils_Tuple3(
						imports,
						types,
						A3($author$project$Extra$Type$Map$insert, val1, val2 + '\n', decls));
				});
		default:
			return $author$project$Extra$System$IO$noOp;
	}
};
var $author$project$Extra$Type$List$map = $elm$core$List$map;
var $author$project$Extra$Type$List$foldr = $elm$core$List$foldr;
var $author$project$Extra$System$IO$sequence = function (ms) {
	return A3(
		$author$project$Extra$Type$List$foldr,
		F2(
			function (m, acc) {
				return A2(
					$author$project$Extra$System$IO$bind,
					m,
					function (_v0) {
						return acc;
					});
			}),
		$author$project$Extra$System$IO$noOp,
		ms);
};
var $author$project$Repl$Worker$initialMsg = function (flags) {
	return $author$project$Extra$System$IO$sequence(
		A2($author$project$Extra$Type$List$map, $author$project$Repl$Worker$flagToMsg, flags));
};
var $elm$core$Platform$Cmd$batch = _Platform_batch;
var $elm$core$Platform$Cmd$none = $elm$core$Platform$Cmd$batch(_List_Nil);
var $author$project$Repl$Worker$update = F2(
	function (msg, model) {
		update:
		while (true) {
			var _v0 = msg(model);
			switch (_v0.a.$) {
				case 'Pure':
					var newModel = _v0.b;
					return _Utils_Tuple2(newModel, $elm$core$Platform$Cmd$none);
				case 'ImpureCmd':
					var cmd = _v0.a.a;
					var newModel = _v0.b;
					return _Utils_Tuple2(newModel, cmd);
				default:
					var cont = _v0.a.a;
					var newModel = _v0.b;
					var $temp$msg = cont($elm$core$Basics$identity),
						$temp$model = newModel;
					msg = $temp$msg;
					model = $temp$model;
					continue update;
			}
		}
	});
var $author$project$Repl$Worker$init = function (flags) {
	return A2(
		$author$project$Repl$Worker$update,
		$author$project$Repl$Worker$initialMsg(flags),
		$author$project$Repl$Worker$initialModel);
};
var $elm$json$Json$Decode$list = _Json_decodeList;
var $elm$json$Json$Decode$string = _Json_decodeString;
var $elm$core$Platform$Sub$batch = _Platform_batch;
var $author$project$Repl$Api$clientRequestCodec = {
	decode: function (wire) {
		return {userInput: wire};
	},
	encode: function (_v0) {
		var userInput = _v0.userInput;
		return userInput;
	}
};
var $author$project$Extra$System$IO$liftContIO = F2(
	function (cont, s) {
		return _Utils_Tuple2(
			$author$project$Extra$System$IO$ImpureCont(cont),
			s);
	});
var $author$project$Extra$System$IO$liftCont = function (cont) {
	return $author$project$Extra$System$IO$liftContIO(
		A2($author$project$Extra$System$IO$contFmap, $author$project$Extra$System$IO$return, cont));
};
var $author$project$Extra$System$IO$Port$syncRequest = F4(
	function (requestCodec, lens, requestPort, requestOut) {
		return $author$project$Extra$System$IO$liftCont(
			function (cont) {
				return $author$project$Extra$System$IO$sequence(
					_List_fromArray(
						[
							A2(
							$author$project$Extra$System$IO$putLens,
							lens,
							$elm$core$Maybe$Just(cont)),
							$author$project$Extra$System$IO$liftCmdIO(
							requestPort(
								requestCodec.encode(requestOut)))
						]));
			});
	});
var $author$project$Extra$System$IO$Port$syncResponse = F4(
	function (responseCodec, lens, responsePort, state) {
		return responsePort(
			function (responseWire) {
				var _v0 = lens.getter(state);
				if (_v0.$ === 'Just') {
					var cont = _v0.a;
					return $author$project$Extra$System$IO$sequence(
						_List_fromArray(
							[
								A2($author$project$Extra$System$IO$putLens, lens, $elm$core$Maybe$Nothing),
								cont(
								responseCodec.decode(responseWire))
							]));
				} else {
					return $author$project$Extra$System$IO$noOp;
				}
			});
	});
var $author$project$Extra$System$IO$Port$syncRequesterFun = F5(
	function (requestCodec, responseCodec, lens, sendPort, receivePort) {
		return {
			request: A3($author$project$Extra$System$IO$Port$syncRequest, requestCodec, lens, sendPort),
			respond: A3($author$project$Extra$System$IO$Port$syncResponse, responseCodec, lens, receivePort)
		};
	});
var $author$project$Extra$System$IO$Port$syncResponderFun = F5(
	function (requestCodec, responseCodec, receivePort, sendPort, callback) {
		return receivePort(
			function (requestWire) {
				return A2(
					$author$project$Extra$System$IO$bind,
					callback(
						requestCodec.decode(requestWire)),
					function (response) {
						return $author$project$Extra$System$IO$liftCmdIO(
							sendPort(
								responseCodec.encode(response)));
					});
			});
	});
var $author$project$Extra$System$IO$Port$syncApi = F2(
	function (requestCodec, responseCodec) {
		return {
			requesterFun: A2($author$project$Extra$System$IO$Port$syncRequesterFun, requestCodec, responseCodec),
			responderFun: A2($author$project$Extra$System$IO$Port$syncResponderFun, requestCodec, responseCodec)
		};
	});
var $author$project$Repl$Api$WorkerStateRunning = function (a) {
	return {$: 'WorkerStateRunning', a: a};
};
var $author$project$Repl$Api$WorkerStateStopped = function (a) {
	return {$: 'WorkerStateStopped', a: a};
};
var $author$project$Repl$Api$workerResponseCodec = {
	decode: function (wire) {
		if (wire.a) {
			var prefill = wire.b;
			var messages = wire.c;
			return {
				messages: messages,
				workerState: $author$project$Repl$Api$WorkerStateRunning(prefill)
			};
		} else {
			var error = wire.b;
			var messages = wire.c;
			return {
				messages: messages,
				workerState: $author$project$Repl$Api$WorkerStateStopped(error)
			};
		}
	},
	encode: function (_v1) {
		var workerState = _v1.workerState;
		var messages = _v1.messages;
		if (workerState.$ === 'WorkerStateRunning') {
			var prefill = workerState.a;
			return _Utils_Tuple3(true, prefill, messages);
		} else {
			var error = workerState.a;
			return _Utils_Tuple3(false, error, messages);
		}
	}
};
var $author$project$Repl$Api$clientToWorkerApi = A2($author$project$Extra$System$IO$Port$syncApi, $author$project$Repl$Api$clientRequestCodec, $author$project$Repl$Api$workerResponseCodec);
var $author$project$Repl$Worker$receiveFromClientPort = _Platform_incomingPort('receiveFromClientPort', $elm$json$Json$Decode$string);
var $elm$json$Json$Encode$bool = _Json_wrap;
var $elm$core$Maybe$destruct = F3(
	function (_default, func, maybe) {
		if (maybe.$ === 'Just') {
			var a = maybe.a;
			return func(a);
		} else {
			return _default;
		}
	});
var $elm$json$Json$Encode$list = F2(
	function (func, entries) {
		return _Json_wrap(
			A3(
				$elm$core$List$foldl,
				_Json_addEntry(func),
				_Json_emptyArray(_Utils_Tuple0),
				entries));
	});
var $elm$json$Json$Encode$null = _Json_encodeNull;
var $elm$json$Json$Encode$string = _Json_wrap;
var $author$project$Repl$Worker$sendToClientPort = _Platform_outgoingPort(
	'sendToClientPort',
	function ($) {
		var a = $.a;
		var b = $.b;
		var c = $.c;
		return A2(
			$elm$json$Json$Encode$list,
			$elm$core$Basics$identity,
			_List_fromArray(
				[
					$elm$json$Json$Encode$bool(a),
					function ($) {
					return A3($elm$core$Maybe$destruct, $elm$json$Json$Encode$null, $elm$json$Json$Encode$string, $);
				}(b),
					$elm$json$Json$Encode$list($elm$json$Json$Encode$string)(c)
				]));
	});
var $author$project$Repl$Worker$clientToWorkerResponder = A2($author$project$Repl$Api$clientToWorkerApi.responderFun, $author$project$Repl$Worker$receiveFromClientPort, $author$project$Repl$Worker$sendToClientPort);
var $author$project$Terminal$Repl$Lines = F2(
	function (a, b) {
		return {$: 'Lines', a: a, b: b};
	});
var $author$project$Terminal$Repl$addLine = F2(
	function (line, _v0) {
		var x = _v0.a;
		var xs = _v0.b;
		return A2(
			$author$project$Terminal$Repl$Lines,
			line,
			A2($elm$core$List$cons, x, xs));
	});
var $elm$core$Basics$negate = function (n) {
	return -n;
};
var $elm$core$String$dropRight = F2(
	function (n, string) {
		return (n < 1) ? string : A3($elm$core$String$slice, 0, -n, string);
	});
var $elm$core$String$endsWith = _String_endsWith;
var $author$project$Terminal$Repl$stripLegacyBackslash = function (chars) {
	return A2($elm$core$String$endsWith, '\\', chars) ? A2($elm$core$String$dropRight, 1, chars) : chars;
};
var $author$project$Repl$Worker$addLine = F2(
	function (input, maybeLines) {
		if (maybeLines.$ === 'Nothing') {
			return A2(
				$author$project$Terminal$Repl$Lines,
				$author$project$Terminal$Repl$stripLegacyBackslash(input),
				_List_Nil);
		} else {
			var lines = maybeLines.a;
			return A2(
				$author$project$Terminal$Repl$addLine,
				$author$project$Terminal$Repl$stripLegacyBackslash(input),
				lines);
		}
	});
var $author$project$Extra$System$IO$bindSequence = F2(
	function (ms, ma) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$IO$sequence(ms),
			function (_v0) {
				return ma;
			});
	});
var $author$project$Terminal$Command$lensStdOut = {
	getter: function (_v0) {
		var _v1 = _v0.f;
		var x = _v1.b;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var _v3 = _v2.f;
			var ai = _v3.a;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				d,
				e,
				A6($author$project$Terminal$Command$LocalState, ai, x, ci, di, ei, fi),
				g,
				h);
		})
};
var $author$project$Terminal$Command$clearStdOut = A2($author$project$Extra$System$IO$putLens, $author$project$Terminal$Command$lensStdOut, _List_Nil);
var $author$project$Terminal$Command$getText = function (output) {
	if (output.$ === 'Permanent') {
		var string = output.a;
		return string;
	} else {
		var string = output.a;
		return string;
	}
};
var $author$project$Repl$Worker$collectMessages = A2(
	$author$project$Extra$System$IO$bind,
	$author$project$Extra$System$IO$getLens($author$project$Terminal$Command$lensStdOut),
	function (messages) {
		return A2(
			$author$project$Extra$System$IO$bindSequence,
			_List_fromArray(
				[$author$project$Terminal$Command$clearStdOut]),
			$author$project$Extra$System$IO$return(
				A2($author$project$Extra$Type$List$map, $author$project$Terminal$Command$getText, messages)));
	});
var $author$project$Repl$Worker$ReplRunning = F3(
	function (a, b, c) {
		return {$: 'ReplRunning', a: a, b: b, c: c};
	});
var $author$project$Terminal$Repl$Done = function (a) {
	return {$: 'Done', a: a};
};
var $author$project$Terminal$Repl$Exit = {$: 'Exit'};
var $author$project$Terminal$Repl$Help = function (a) {
	return {$: 'Help', a: a};
};
var $author$project$Terminal$Repl$Reset = {$: 'Reset'};
var $author$project$Terminal$Repl$Skip = {$: 'Skip'};
var $author$project$Terminal$Repl$Continue = function (a) {
	return {$: 'Continue', a: a};
};
var $author$project$Terminal$Repl$Decl = F2(
	function (a, b) {
		return {$: 'Decl', a: a, b: b};
	});
var $author$project$Terminal$Repl$DefStart = function (a) {
	return {$: 'DefStart', a: a};
};
var $author$project$Terminal$Repl$Expr = function (a) {
	return {$: 'Expr', a: a};
};
var $author$project$Terminal$Repl$Port = {$: 'Port'};
var $author$project$Terminal$Repl$Type = F2(
	function (a, b) {
		return {$: 'Type', a: a, b: b};
	});
var $author$project$Compiler$Parse$Primitives$Cerr = F3(
	function (a, b, c) {
		return {$: 'Cerr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Primitives$Cok = F2(
	function (a, b) {
		return {$: 'Cok', a: a, b: b};
	});
var $author$project$Compiler$Parse$Primitives$Eerr = F3(
	function (a, b, c) {
		return {$: 'Eerr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Primitives$Parser = function (a) {
	return {$: 'Parser', a: a};
};
var $author$project$Compiler$Parse$Primitives$bind = F2(
	function (_v0, callback) {
		var parserA = _v0.a;
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				var _v1 = parserA(state);
				switch (_v1.$) {
					case 'Cok':
						var a = _v1.a;
						var s = _v1.b;
						var _v2 = callback(a);
						var parserB = _v2.a;
						var _v3 = parserB(s);
						switch (_v3.$) {
							case 'Eok':
								var a_ = _v3.a;
								var s_ = _v3.b;
								return A2($author$project$Compiler$Parse$Primitives$Cok, a_, s_);
							case 'Eerr':
								var r = _v3.a;
								var c = _v3.b;
								var t = _v3.c;
								return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
							default:
								var x = _v3;
								return x;
						}
					case 'Eok':
						var a = _v1.a;
						var s = _v1.b;
						var _v4 = callback(a);
						var parserB = _v4.a;
						return parserB(s);
					case 'Cerr':
						var r = _v1.a;
						var c = _v1.b;
						var t = _v1.c;
						return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
					default:
						var r = _v1.a;
						var c = _v1.b;
						var t = _v1.c;
						return A3($author$project$Compiler$Parse$Primitives$Eerr, r, c, t);
				}
			});
	});
var $author$project$Compiler$Parse$Primitives$Eok = F2(
	function (a, b) {
		return {$: 'Eok', a: a, b: b};
	});
var $author$project$Compiler$Parse$Space$checkFreshLine = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (state) {
			var row = state.e;
			var col = state.f;
			return (col === 1) ? A2($author$project$Compiler$Parse$Primitives$Eok, _Utils_Tuple0, state) : A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
		});
};
var $author$project$Compiler$Reporting$Error$Syntax$EndlessMultiComment = {$: 'EndlessMultiComment'};
var $author$project$Compiler$Reporting$Error$Syntax$HasTab = {$: 'HasTab'};
var $author$project$Compiler$Parse$Primitives$State = F6(
	function (a, b, c, d, e, f) {
		return {$: 'State', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Compiler$Parse$Space$EndlessMultiComment = {$: 'EndlessMultiComment'};
var $author$project$Compiler$Parse$Space$Good = {$: 'Good'};
var $author$project$Compiler$Parse$Space$HasTab = {$: 'HasTab'};
var $author$project$Compiler$Parse$Space$MultiEndless = {$: 'MultiEndless'};
var $author$project$Compiler$Parse$Space$MultiGood = {$: 'MultiGood'};
var $author$project$Compiler$Parse$Space$MultiTab = {$: 'MultiTab'};
var $elm$core$Basics$ge = _Utils_ge;
var $author$project$Compiler$Parse$Primitives$getCharWidth = function (word) {
	return (word > 65535) ? 2 : 1;
};
var $elm$core$Maybe$withDefault = F2(
	function (_default, maybe) {
		if (maybe.$ === 'Just') {
			var value = maybe.a;
			return value;
		} else {
			return _default;
		}
	});
var $author$project$Compiler$Parse$Primitives$unsafeIndex = F2(
	function (src, pos) {
		return A2(
			$elm$core$Maybe$withDefault,
			0,
			A2(
				$elm$core$Maybe$map,
				A2($elm$core$Basics$composeR, $elm$core$Tuple$first, $elm$core$Char$toCode),
				$elm$core$String$uncons(
					A2($elm$core$String$dropLeft, pos, src))));
	});
var $author$project$Compiler$Parse$Primitives$isWord = F4(
	function (src, pos, end, word) {
		return (_Utils_cmp(pos, end) < 0) && _Utils_eq(
			A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
			word);
	});
var $author$project$Compiler$Parse$Space$eatMultiCommentHelp = F6(
	function (src, pos, end, row, col, openComments) {
		eatMultiCommentHelp:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(
					_Utils_Tuple2($author$project$Compiler$Parse$Space$MultiEndless, pos),
					_Utils_Tuple2(row, col));
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if (word === 10) {
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end,
						$temp$row = row + 1,
						$temp$col = 1,
						$temp$openComments = openComments;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					row = $temp$row;
					col = $temp$col;
					openComments = $temp$openComments;
					continue eatMultiCommentHelp;
				} else {
					if (word === 9) {
						return _Utils_Tuple2(
							_Utils_Tuple2($author$project$Compiler$Parse$Space$MultiTab, pos),
							_Utils_Tuple2(row, col));
					} else {
						if ((word === 45) && A4($author$project$Compiler$Parse$Primitives$isWord, src, pos + 1, end, 125)) {
							if (openComments === 1) {
								return _Utils_Tuple2(
									_Utils_Tuple2($author$project$Compiler$Parse$Space$MultiGood, pos + 2),
									_Utils_Tuple2(row, col + 2));
							} else {
								var $temp$src = src,
									$temp$pos = pos + 2,
									$temp$end = end,
									$temp$row = row,
									$temp$col = col + 2,
									$temp$openComments = openComments - 1;
								src = $temp$src;
								pos = $temp$pos;
								end = $temp$end;
								row = $temp$row;
								col = $temp$col;
								openComments = $temp$openComments;
								continue eatMultiCommentHelp;
							}
						} else {
							if ((word === 123) && A4($author$project$Compiler$Parse$Primitives$isWord, src, pos + 1, end, 45)) {
								var $temp$src = src,
									$temp$pos = pos + 2,
									$temp$end = end,
									$temp$row = row,
									$temp$col = col + 2,
									$temp$openComments = openComments + 1;
								src = $temp$src;
								pos = $temp$pos;
								end = $temp$end;
								row = $temp$row;
								col = $temp$col;
								openComments = $temp$openComments;
								continue eatMultiCommentHelp;
							} else {
								var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
								var $temp$src = src,
									$temp$pos = newPos,
									$temp$end = end,
									$temp$row = row,
									$temp$col = col + 1,
									$temp$openComments = openComments;
								src = $temp$src;
								pos = $temp$pos;
								end = $temp$end;
								row = $temp$row;
								col = $temp$col;
								openComments = $temp$openComments;
								continue eatMultiCommentHelp;
							}
						}
					}
				}
			}
		}
	});
var $author$project$Compiler$Parse$Space$eatLineComment = F5(
	function (src, pos, end, row, col) {
		eatLineComment:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(
					_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
					_Utils_Tuple2(row, col));
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if (word === 10) {
					return A5($author$project$Compiler$Parse$Space$eatSpaces, src, pos + 1, end, row + 1, 1);
				} else {
					var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
					var $temp$src = src,
						$temp$pos = newPos,
						$temp$end = end,
						$temp$row = row,
						$temp$col = col + 1;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					row = $temp$row;
					col = $temp$col;
					continue eatLineComment;
				}
			}
		}
	});
var $author$project$Compiler$Parse$Space$eatMultiComment = F5(
	function (src, pos, end, row, col) {
		var pos2 = pos + 2;
		var pos1 = pos + 1;
		if (_Utils_cmp(pos2, end) > -1) {
			return _Utils_Tuple2(
				_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
				_Utils_Tuple2(row, col));
		} else {
			if (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1) === 45) {
				if (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos2) === 124) {
					return _Utils_Tuple2(
						_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
						_Utils_Tuple2(row, col));
				} else {
					var _v1 = A6($author$project$Compiler$Parse$Space$eatMultiCommentHelp, src, pos2, end, row, col + 2, 1);
					var _v2 = _v1.a;
					var status = _v2.a;
					var newPos = _v2.b;
					var _v3 = _v1.b;
					var newRow = _v3.a;
					var newCol = _v3.b;
					switch (status.$) {
						case 'MultiGood':
							return A5($author$project$Compiler$Parse$Space$eatSpaces, src, newPos, end, newRow, newCol);
						case 'MultiTab':
							return _Utils_Tuple2(
								_Utils_Tuple2($author$project$Compiler$Parse$Space$HasTab, newPos),
								_Utils_Tuple2(newRow, newCol));
						default:
							return _Utils_Tuple2(
								_Utils_Tuple2($author$project$Compiler$Parse$Space$EndlessMultiComment, pos),
								_Utils_Tuple2(row, col));
					}
				}
			} else {
				return _Utils_Tuple2(
					_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
					_Utils_Tuple2(row, col));
			}
		}
	});
var $author$project$Compiler$Parse$Space$eatSpaces = F5(
	function (src, pos, end, row, col) {
		eatSpaces:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(
					_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
					_Utils_Tuple2(row, col));
			} else {
				var _v0 = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				switch (_v0) {
					case 32:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row,
							$temp$col = col + 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					case 10:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row + 1,
							$temp$col = 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					case 123:
						return A5($author$project$Compiler$Parse$Space$eatMultiComment, src, pos, end, row, col);
					case 45:
						var pos1 = pos + 1;
						return ((_Utils_cmp(pos1, end) < 0) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1) === 45)) ? A5($author$project$Compiler$Parse$Space$eatLineComment, src, pos + 2, end, row, col + 2) : _Utils_Tuple2(
							_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
							_Utils_Tuple2(row, col));
					case 13:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row,
							$temp$col = col;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					case 9:
						return _Utils_Tuple2(
							_Utils_Tuple2($author$project$Compiler$Parse$Space$HasTab, pos),
							_Utils_Tuple2(row, col));
					default:
						return _Utils_Tuple2(
							_Utils_Tuple2($author$project$Compiler$Parse$Space$Good, pos),
							_Utils_Tuple2(row, col));
				}
			}
		}
	});
var $author$project$Compiler$Parse$Space$chompAndCheckIndent = F2(
	function (toSpaceError, toIndentError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var _v1 = A5($author$project$Compiler$Parse$Space$eatSpaces, src, pos, end, row, col);
				var _v2 = _v1.a;
				var status = _v2.a;
				var newPos = _v2.b;
				var _v3 = _v1.b;
				var newRow = _v3.a;
				var newCol = _v3.b;
				switch (status.$) {
					case 'Good':
						if ((_Utils_cmp(newCol, indent) > 0) && (newCol > 1)) {
							var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol);
							return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, newState);
						} else {
							return A3($author$project$Compiler$Parse$Primitives$Cerr, row, col, toIndentError);
						}
					case 'HasTab':
						return A3(
							$author$project$Compiler$Parse$Primitives$Cerr,
							newRow,
							newCol,
							toSpaceError($author$project$Compiler$Reporting$Error$Syntax$HasTab));
					default:
						return A3(
							$author$project$Compiler$Parse$Primitives$Cerr,
							newRow,
							newCol,
							toSpaceError($author$project$Compiler$Reporting$Error$Syntax$EndlessMultiComment));
				}
			});
	});
var $author$project$Compiler$Reporting$Annotation$At = F2(
	function (a, b) {
		return {$: 'At', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Annotation$Region = F2(
	function (a, b) {
		return {$: 'Region', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TIndentStart = F2(
	function (a, b) {
		return {$: 'TIndentStart', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$TLambda = F2(
	function (a, b) {
		return {$: 'TLambda', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$TRecord = F2(
	function (a, b) {
		return {$: 'TRecord', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecord = F3(
	function (a, b, c) {
		return {$: 'TRecord', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordColon = F2(
	function (a, b) {
		return {$: 'TRecordColon', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordEnd = F2(
	function (a, b) {
		return {$: 'TRecordEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordField = F2(
	function (a, b) {
		return {$: 'TRecordField', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentColon = F2(
	function (a, b) {
		return {$: 'TRecordIndentColon', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentEnd = F2(
	function (a, b) {
		return {$: 'TRecordIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentField = F2(
	function (a, b) {
		return {$: 'TRecordIndentField', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentOpen = F2(
	function (a, b) {
		return {$: 'TRecordIndentOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentType = F2(
	function (a, b) {
		return {$: 'TRecordIndentType', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordOpen = F2(
	function (a, b) {
		return {$: 'TRecordOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace = F3(
	function (a, b, c) {
		return {$: 'TRecordSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TRecordType = F3(
	function (a, b, c) {
		return {$: 'TRecordType', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TSpace = F3(
	function (a, b, c) {
		return {$: 'TSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TStart = F2(
	function (a, b) {
		return {$: 'TStart', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$TTuple = F3(
	function (a, b, c) {
		return {$: 'TTuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTuple = F3(
	function (a, b, c) {
		return {$: 'TTuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleEnd = F2(
	function (a, b) {
		return {$: 'TTupleEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentEnd = F2(
	function (a, b) {
		return {$: 'TTupleIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentType1 = F2(
	function (a, b) {
		return {$: 'TTupleIndentType1', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentTypeN = F2(
	function (a, b) {
		return {$: 'TTupleIndentTypeN', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleOpen = F2(
	function (a, b) {
		return {$: 'TTupleOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleSpace = F3(
	function (a, b, c) {
		return {$: 'TTupleSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TTupleType = F3(
	function (a, b, c) {
		return {$: 'TTupleType', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$TType = F3(
	function (a, b, c) {
		return {$: 'TType', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$TTypeQual = F4(
	function (a, b, c, d) {
		return {$: 'TTypeQual', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Source$TUnit = {$: 'TUnit'};
var $author$project$Compiler$AST$Source$TVar = function (a) {
	return {$: 'TVar', a: a};
};
var $author$project$Compiler$Reporting$Annotation$Position = F2(
	function (a, b) {
		return {$: 'Position', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Annotation$at = F3(
	function (start, end, a) {
		return A2(
			$author$project$Compiler$Reporting$Annotation$At,
			A2($author$project$Compiler$Reporting$Annotation$Region, start, end),
			a);
	});
var $author$project$Compiler$Parse$Primitives$addEnd = F2(
	function (start, value) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				var row = state.e;
				var col = state.f;
				return A2(
					$author$project$Compiler$Parse$Primitives$Eok,
					A3(
						$author$project$Compiler$Reporting$Annotation$at,
						start,
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col),
						value),
					state);
			});
	});
var $author$project$Compiler$Parse$Primitives$addLocation = function (_v0) {
	var parser = _v0.a;
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (state) {
			var sr = state.e;
			var sc = state.f;
			var _v1 = parser(state);
			switch (_v1.$) {
				case 'Cok':
					var a = _v1.a;
					var s = _v1.b;
					var er = s.e;
					var ec = s.f;
					return A2(
						$author$project$Compiler$Parse$Primitives$Cok,
						A2(
							$author$project$Compiler$Reporting$Annotation$At,
							A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, sr, sc),
								A2($author$project$Compiler$Reporting$Annotation$Position, er, ec)),
							a),
						s);
				case 'Eok':
					var a = _v1.a;
					var s = _v1.b;
					var er = s.e;
					var ec = s.f;
					return A2(
						$author$project$Compiler$Parse$Primitives$Eok,
						A2(
							$author$project$Compiler$Reporting$Annotation$At,
							A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, sr, sc),
								A2($author$project$Compiler$Reporting$Annotation$Position, er, ec)),
							a),
						s);
				case 'Cerr':
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
				default:
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Eerr, r, c, t);
			}
		});
};
var $author$project$Compiler$Parse$Space$checkIndent = F2(
	function (_v0, toError) {
		var endRow = _v0.a;
		var endCol = _v0.b;
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				var indent = state.d;
				var col = state.f;
				return ((_Utils_cmp(col, indent) > 0) && (col > 1)) ? A2($author$project$Compiler$Parse$Primitives$Eok, _Utils_Tuple0, state) : A3($author$project$Compiler$Parse$Primitives$Eerr, endRow, endCol, toError);
			});
	});
var $author$project$Compiler$Parse$Space$chomp = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var _v1 = A5($author$project$Compiler$Parse$Space$eatSpaces, src, pos, end, row, col);
			var _v2 = _v1.a;
			var status = _v2.a;
			var newPos = _v2.b;
			var _v3 = _v1.b;
			var newRow = _v3.a;
			var newCol = _v3.b;
			switch (status.$) {
				case 'Good':
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, newState);
				case 'HasTab':
					return A3(
						$author$project$Compiler$Parse$Primitives$Cerr,
						newRow,
						newCol,
						toError($author$project$Compiler$Reporting$Error$Syntax$HasTab));
				default:
					return A3(
						$author$project$Compiler$Parse$Primitives$Cerr,
						newRow,
						newCol,
						toError($author$project$Compiler$Reporting$Error$Syntax$EndlessMultiComment));
			}
		});
};
var $author$project$Compiler$Parse$Variable$Qualified = F2(
	function (a, b) {
		return {$: 'Qualified', a: a, b: b};
	});
var $author$project$Compiler$Parse$Variable$Unqualified = function (a) {
	return {$: 'Unqualified', a: a};
};
var $elm$core$Char$fromCode = _Char_fromCode;
var $elm$core$Basics$modBy = _Basics_modBy;
var $miniBill$elm_unicode$Unicode$isAlpha = function (c) {
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return l(256) ? (A2(r, 65, 90) || (A2(r, 97, 122) || (e(170) || (e(181) || (e(186) || (A2(r, 192, 214) || (A2(r, 216, 246) || A2(r, 248, 255)))))))) : (l(43513) ? (l(4205) ? (l(2783) ? (l(2143) ? (l(1567) ? (l(907) ? (A2(r, 256, 705) || (A2(r, 710, 721) || (A2(r, 736, 740) || (A2(r, 880, 884) || (A2(r, 886, 887) || (A2(r, 890, 893) || (e(895) || (e(902) || (A2(r, 904, 906) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 748, 750))))))))))) : (e(908) || (A2(r, 910, 929) || (A2(r, 931, 1013) || (A2(r, 1015, 1153) || (A2(r, 1162, 1327) || (A2(r, 1329, 1366) || (e(1369) || (A2(r, 1376, 1416) || (A2(r, 1488, 1514) || A2(r, 1519, 1522))))))))))) : (l(1868) ? (A2(r, 1568, 1610) || (A2(r, 1646, 1647) || (A2(r, 1649, 1747) || (e(1749) || (A2(r, 1765, 1766) || (A2(r, 1774, 1775) || (A2(r, 1786, 1788) || (e(1791) || (e(1808) || A2(r, 1810, 1839)))))))))) : (A2(r, 1869, 1957) || (e(1969) || (A2(r, 1994, 2026) || (A2(r, 2036, 2037) || (e(2042) || (A2(r, 2048, 2069) || (e(2074) || (e(2084) || (e(2088) || A2(r, 2112, 2136)))))))))))) : (l(2543) ? (l(2436) ? (A2(r, 2144, 2154) || (A2(r, 2160, 2183) || (A2(r, 2185, 2190) || (A2(r, 2208, 2249) || (A2(r, 2308, 2361) || (e(2365) || (e(2384) || (A2(r, 2392, 2401) || A2(r, 2417, 2432))))))))) : (A2(r, 2437, 2444) || (A2(r, 2447, 2448) || (A2(r, 2451, 2472) || (A2(r, 2474, 2480) || (e(2482) || (A2(r, 2486, 2489) || (e(2493) || (e(2510) || (A2(r, 2524, 2525) || A2(r, 2527, 2529))))))))))) : (l(2653) ? (A2(r, 2544, 2545) || (e(2556) || (A2(r, 2565, 2570) || (A2(r, 2575, 2576) || (A2(r, 2579, 2600) || (A2(r, 2602, 2608) || (A2(r, 2610, 2611) || (A2(r, 2613, 2614) || (A2(r, 2616, 2617) || A2(r, 2649, 2652)))))))))) : (e(2654) || (A2(r, 2674, 2676) || (A2(r, 2693, 2701) || (A2(r, 2703, 2705) || (A2(r, 2707, 2728) || (A2(r, 2730, 2736) || (A2(r, 2738, 2739) || (A2(r, 2741, 2745) || (e(2749) || e(2768))))))))))))) : (l(3295) ? (l(2978) ? (l(2907) ? (A2(r, 2784, 2785) || (e(2809) || (A2(r, 2821, 2828) || (A2(r, 2831, 2832) || (A2(r, 2835, 2856) || (A2(r, 2858, 2864) || (A2(r, 2866, 2867) || (A2(r, 2869, 2873) || e(2877))))))))) : (A2(r, 2908, 2909) || (A2(r, 2911, 2913) || (e(2929) || (e(2947) || (A2(r, 2949, 2954) || (A2(r, 2958, 2960) || (A2(r, 2962, 2965) || (A2(r, 2969, 2970) || (e(2972) || A2(r, 2974, 2975))))))))))) : (l(3164) ? (A2(r, 2979, 2980) || (A2(r, 2984, 2986) || (A2(r, 2990, 3001) || (e(3024) || (A2(r, 3077, 3084) || (A2(r, 3086, 3088) || (A2(r, 3090, 3112) || (A2(r, 3114, 3129) || (e(3133) || A2(r, 3160, 3162)))))))))) : (e(3165) || (A2(r, 3168, 3169) || (e(3200) || (A2(r, 3205, 3212) || (A2(r, 3214, 3216) || (A2(r, 3218, 3240) || (A2(r, 3242, 3251) || (A2(r, 3253, 3257) || (e(3261) || A2(r, 3293, 3294)))))))))))) : (l(3715) ? (l(3449) ? (A2(r, 3296, 3297) || (A2(r, 3313, 3314) || (A2(r, 3332, 3340) || (A2(r, 3342, 3344) || (A2(r, 3346, 3386) || (e(3389) || (e(3406) || (A2(r, 3412, 3414) || A2(r, 3423, 3425))))))))) : (A2(r, 3450, 3455) || (A2(r, 3461, 3478) || (A2(r, 3482, 3505) || (A2(r, 3507, 3515) || (e(3517) || (A2(r, 3520, 3526) || (A2(r, 3585, 3632) || (A2(r, 3634, 3635) || (A2(r, 3648, 3654) || A2(r, 3713, 3714))))))))))) : (l(3839) ? (e(3716) || (A2(r, 3718, 3722) || (A2(r, 3724, 3747) || (e(3749) || (A2(r, 3751, 3760) || (A2(r, 3762, 3763) || (e(3773) || (A2(r, 3776, 3780) || (e(3782) || A2(r, 3804, 3807)))))))))) : (e(3840) || (A2(r, 3904, 3911) || (A2(r, 3913, 3948) || (A2(r, 3976, 3980) || (A2(r, 4096, 4138) || (e(4159) || (A2(r, 4176, 4181) || (A2(r, 4186, 4189) || (e(4193) || A2(r, 4197, 4198)))))))))))))) : (l(8133) ? (l(6175) ? (l(4807) ? (l(4687) ? (A2(r, 4206, 4208) || (A2(r, 4213, 4225) || (e(4238) || (A2(r, 4256, 4293) || (e(4295) || (e(4301) || (A2(r, 4304, 4346) || (A2(r, 4348, 4680) || A2(r, 4682, 4685))))))))) : (A2(r, 4688, 4694) || (e(4696) || (A2(r, 4698, 4701) || (A2(r, 4704, 4744) || (A2(r, 4746, 4749) || (A2(r, 4752, 4784) || (A2(r, 4786, 4789) || (A2(r, 4792, 4798) || (e(4800) || A2(r, 4802, 4805))))))))))) : (l(5791) ? (A2(r, 4808, 4822) || (A2(r, 4824, 4880) || (A2(r, 4882, 4885) || (A2(r, 4888, 4954) || (A2(r, 4992, 5007) || (A2(r, 5024, 5109) || (A2(r, 5112, 5117) || (A2(r, 5121, 5740) || (A2(r, 5743, 5759) || A2(r, 5761, 5786)))))))))) : (A2(r, 5792, 5866) || (A2(r, 5873, 5880) || (A2(r, 5888, 5905) || (A2(r, 5919, 5937) || (A2(r, 5952, 5969) || (A2(r, 5984, 5996) || (A2(r, 5998, 6000) || (A2(r, 6016, 6067) || (e(6103) || e(6108)))))))))))) : (l(7244) ? (l(6575) ? (A2(r, 6176, 6264) || (A2(r, 6272, 6276) || (A2(r, 6279, 6312) || (e(6314) || (A2(r, 6320, 6389) || (A2(r, 6400, 6430) || (A2(r, 6480, 6509) || (A2(r, 6512, 6516) || A2(r, 6528, 6571))))))))) : (A2(r, 6576, 6601) || (A2(r, 6656, 6678) || (A2(r, 6688, 6740) || (e(6823) || (A2(r, 6917, 6963) || (A2(r, 6981, 6988) || (A2(r, 7043, 7072) || (A2(r, 7086, 7087) || (A2(r, 7098, 7141) || A2(r, 7168, 7203))))))))))) : (l(7679) ? (A2(r, 7245, 7247) || (A2(r, 7258, 7293) || (A2(r, 7296, 7304) || (A2(r, 7312, 7354) || (A2(r, 7357, 7359) || (A2(r, 7401, 7404) || (A2(r, 7406, 7411) || (A2(r, 7413, 7414) || (e(7418) || A2(r, 7424, 7615)))))))))) : (A2(r, 7680, 7957) || (A2(r, 7960, 7965) || (A2(r, 7968, 8005) || (A2(r, 8008, 8013) || (A2(r, 8016, 8023) || (A2(r, 8032, 8061) || (A2(r, 8064, 8116) || (A2(r, 8118, 8124) || (e(8126) || (A2(r, 8130, 8132) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 8025, 8031))))))))))))))) : (l(12336) ? (l(8578) ? (l(8449) ? (A2(r, 8134, 8140) || (A2(r, 8144, 8147) || (A2(r, 8150, 8155) || (A2(r, 8160, 8172) || (A2(r, 8178, 8180) || (A2(r, 8182, 8188) || (e(8305) || (e(8319) || A2(r, 8336, 8348))))))))) : (e(8450) || (e(8455) || (A2(r, 8458, 8467) || (e(8469) || (A2(r, 8473, 8477) || (A2(r, 8490, 8493) || (A2(r, 8495, 8505) || (A2(r, 8508, 8511) || (A2(r, 8517, 8521) || (e(8526) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 8484, 8488))))))))))))) : (l(11679) ? (A2(r, 8579, 8580) || (A2(r, 11264, 11492) || (A2(r, 11499, 11502) || (A2(r, 11506, 11507) || (A2(r, 11520, 11557) || (e(11559) || (e(11565) || (A2(r, 11568, 11623) || (e(11631) || A2(r, 11648, 11670)))))))))) : (A2(r, 11680, 11686) || (A2(r, 11688, 11694) || (A2(r, 11696, 11702) || (A2(r, 11704, 11710) || (A2(r, 11712, 11718) || (A2(r, 11720, 11726) || (A2(r, 11728, 11734) || (A2(r, 11736, 11742) || (e(11823) || A2(r, 12293, 12294)))))))))))) : (l(42785) ? (l(13311) ? (A2(r, 12337, 12341) || (A2(r, 12347, 12348) || (A2(r, 12353, 12438) || (A2(r, 12445, 12447) || (A2(r, 12449, 12538) || (A2(r, 12540, 12543) || (A2(r, 12549, 12591) || (A2(r, 12593, 12686) || (A2(r, 12704, 12735) || A2(r, 12784, 12799)))))))))) : (A2(r, 13312, 19903) || (A2(r, 19968, 42124) || (A2(r, 42192, 42237) || (A2(r, 42240, 42508) || (A2(r, 42512, 42527) || (A2(r, 42538, 42539) || (A2(r, 42560, 42606) || (A2(r, 42623, 42653) || (A2(r, 42656, 42725) || A2(r, 42775, 42783))))))))))) : (l(43249) ? (A2(r, 42786, 42888) || (A2(r, 42891, 42954) || (A2(r, 42960, 42961) || (A2(r, 42966, 42969) || (A2(r, 42994, 43009) || (A2(r, 43011, 43013) || (A2(r, 43015, 43018) || (A2(r, 43020, 43042) || (A2(r, 43072, 43123) || (A2(r, 43138, 43187) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 42963, 42965)))))))))))) : (A2(r, 43250, 43255) || (e(43259) || (A2(r, 43261, 43262) || (A2(r, 43274, 43301) || (A2(r, 43312, 43334) || (A2(r, 43360, 43388) || (A2(r, 43396, 43442) || (e(43471) || (A2(r, 43488, 43492) || A2(r, 43494, 43503))))))))))))))) : (l(70851) ? (l(67071) ? (l(65007) ? (l(43867) ? (l(43704) ? (A2(r, 43514, 43518) || (A2(r, 43520, 43560) || (A2(r, 43584, 43586) || (A2(r, 43588, 43595) || (A2(r, 43616, 43638) || (e(43642) || (A2(r, 43646, 43695) || (e(43697) || A2(r, 43701, 43702))))))))) : (A2(r, 43705, 43709) || (A2(r, 43739, 43741) || (A2(r, 43744, 43754) || (A2(r, 43762, 43764) || (A2(r, 43777, 43782) || (A2(r, 43785, 43790) || (A2(r, 43793, 43798) || (A2(r, 43808, 43814) || (A2(r, 43816, 43822) || (A2(r, 43824, 43866) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 43712, 43714))))))))))))) : (l(64286) ? (A2(r, 43868, 43881) || (A2(r, 43888, 44002) || (A2(r, 44032, 55203) || (A2(r, 55216, 55238) || (A2(r, 55243, 55291) || (A2(r, 63744, 64109) || (A2(r, 64112, 64217) || (A2(r, 64256, 64262) || (A2(r, 64275, 64279) || e(64285)))))))))) : (A2(r, 64287, 64296) || (A2(r, 64298, 64310) || (A2(r, 64312, 64316) || (e(64318) || (A2(r, 64320, 64321) || (A2(r, 64323, 64324) || (A2(r, 64326, 64433) || (A2(r, 64467, 64829) || (A2(r, 64848, 64911) || A2(r, 64914, 64967)))))))))))) : (l(66303) ? (l(65497) ? (A2(r, 65008, 65019) || (A2(r, 65136, 65140) || (A2(r, 65142, 65276) || (A2(r, 65313, 65338) || (A2(r, 65345, 65370) || (A2(r, 65382, 65470) || (A2(r, 65474, 65479) || (A2(r, 65482, 65487) || A2(r, 65490, 65495))))))))) : (A2(r, 65498, 65500) || (A2(r, 65536, 65547) || (A2(r, 65549, 65574) || (A2(r, 65576, 65594) || (A2(r, 65596, 65597) || (A2(r, 65599, 65613) || (A2(r, 65616, 65629) || (A2(r, 65664, 65786) || (A2(r, 66176, 66204) || A2(r, 66208, 66256))))))))))) : (l(66815) ? (A2(r, 66304, 66335) || (A2(r, 66349, 66368) || (A2(r, 66370, 66377) || (A2(r, 66384, 66421) || (A2(r, 66432, 66461) || (A2(r, 66464, 66499) || (A2(r, 66504, 66511) || (A2(r, 66560, 66717) || (A2(r, 66736, 66771) || A2(r, 66776, 66811)))))))))) : (A2(r, 66816, 66855) || (A2(r, 66864, 66915) || (A2(r, 66928, 66938) || (A2(r, 66940, 66954) || (A2(r, 66956, 66962) || (A2(r, 66964, 66965) || (A2(r, 66967, 66977) || (A2(r, 66979, 66993) || (A2(r, 66995, 67001) || A2(r, 67003, 67004))))))))))))) : (l(69414) ? (l(68029) ? (l(67638) ? (A2(r, 67072, 67382) || (A2(r, 67392, 67413) || (A2(r, 67424, 67431) || (A2(r, 67456, 67461) || (A2(r, 67463, 67504) || (A2(r, 67506, 67514) || (A2(r, 67584, 67589) || (e(67592) || A2(r, 67594, 67637))))))))) : (A2(r, 67639, 67640) || (e(67644) || (A2(r, 67647, 67669) || (A2(r, 67680, 67702) || (A2(r, 67712, 67742) || (A2(r, 67808, 67826) || (A2(r, 67828, 67829) || (A2(r, 67840, 67861) || (A2(r, 67872, 67897) || A2(r, 67968, 68023))))))))))) : (l(68415) ? (A2(r, 68030, 68031) || (e(68096) || (A2(r, 68112, 68115) || (A2(r, 68117, 68119) || (A2(r, 68121, 68149) || (A2(r, 68192, 68220) || (A2(r, 68224, 68252) || (A2(r, 68288, 68295) || (A2(r, 68297, 68324) || A2(r, 68352, 68405)))))))))) : (A2(r, 68416, 68437) || (A2(r, 68448, 68466) || (A2(r, 68480, 68497) || (A2(r, 68608, 68680) || (A2(r, 68736, 68786) || (A2(r, 68800, 68850) || (A2(r, 68864, 68899) || (A2(r, 69248, 69289) || (A2(r, 69296, 69297) || A2(r, 69376, 69404)))))))))))) : (l(70206) ? (l(69839) ? (e(69415) || (A2(r, 69424, 69445) || (A2(r, 69488, 69505) || (A2(r, 69552, 69572) || (A2(r, 69600, 69622) || (A2(r, 69635, 69687) || (A2(r, 69745, 69746) || (e(69749) || A2(r, 69763, 69807))))))))) : (A2(r, 69840, 69864) || (A2(r, 69891, 69926) || (e(69956) || (e(69959) || (A2(r, 69968, 70002) || (e(70006) || (A2(r, 70019, 70066) || (A2(r, 70081, 70084) || (A2(r, 70144, 70161) || (A2(r, 70163, 70187) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 70106, 70108))))))))))))) : (l(70441) ? (A2(r, 70207, 70208) || (A2(r, 70272, 70278) || (e(70280) || (A2(r, 70282, 70285) || (A2(r, 70287, 70301) || (A2(r, 70303, 70312) || (A2(r, 70320, 70366) || (A2(r, 70405, 70412) || (A2(r, 70415, 70416) || A2(r, 70419, 70440)))))))))) : (A2(r, 70442, 70448) || (A2(r, 70450, 70451) || (A2(r, 70453, 70457) || (e(70461) || (e(70480) || (A2(r, 70493, 70497) || (A2(r, 70656, 70708) || (A2(r, 70727, 70730) || (A2(r, 70751, 70753) || A2(r, 70784, 70831)))))))))))))) : (l(113807) ? (l(73473) ? (l(72191) ? (l(71487) ? (A2(r, 70852, 70853) || (e(70855) || (A2(r, 71040, 71086) || (A2(r, 71128, 71131) || (A2(r, 71168, 71215) || (e(71236) || (A2(r, 71296, 71338) || (e(71352) || A2(r, 71424, 71450))))))))) : (A2(r, 71488, 71494) || (A2(r, 71680, 71723) || (A2(r, 71840, 71903) || (A2(r, 71935, 71942) || (e(71945) || (A2(r, 71948, 71955) || (A2(r, 71957, 71958) || (A2(r, 71960, 71983) || (A2(r, 72096, 72103) || (A2(r, 72106, 72144) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && (A2(r, 71999, 72001) || A2(r, 72161, 72163)))))))))))))) : (l(72817) ? (e(72192) || (A2(r, 72203, 72242) || (e(72250) || (e(72272) || (A2(r, 72284, 72329) || (e(72349) || (A2(r, 72368, 72440) || (A2(r, 72704, 72712) || (A2(r, 72714, 72750) || e(72768)))))))))) : (A2(r, 72818, 72847) || (A2(r, 72960, 72966) || (A2(r, 72968, 72969) || (A2(r, 72971, 73008) || (e(73030) || (A2(r, 73056, 73061) || (A2(r, 73063, 73064) || (A2(r, 73066, 73097) || (e(73112) || A2(r, 73440, 73458)))))))))))) : (l(93951) ? (l(82943) ? (e(73474) || (A2(r, 73476, 73488) || (A2(r, 73490, 73523) || (e(73648) || (A2(r, 73728, 74649) || (A2(r, 74880, 75075) || (A2(r, 77712, 77808) || (A2(r, 77824, 78895) || A2(r, 78913, 78918))))))))) : (A2(r, 82944, 83526) || (A2(r, 92160, 92728) || (A2(r, 92736, 92766) || (A2(r, 92784, 92862) || (A2(r, 92880, 92909) || (A2(r, 92928, 92975) || (A2(r, 92992, 92995) || (A2(r, 93027, 93047) || (A2(r, 93053, 93071) || A2(r, 93760, 93823))))))))))) : (l(110588) ? (A2(r, 93952, 94026) || (e(94032) || (A2(r, 94099, 94111) || (A2(r, 94176, 94177) || (e(94179) || (A2(r, 94208, 100343) || (A2(r, 100352, 101589) || (A2(r, 101632, 101640) || (A2(r, 110576, 110579) || A2(r, 110581, 110587)))))))))) : (A2(r, 110589, 110590) || (A2(r, 110592, 110882) || (e(110898) || (A2(r, 110928, 110930) || (e(110933) || (A2(r, 110948, 110951) || (A2(r, 110960, 111355) || (A2(r, 113664, 113770) || (A2(r, 113776, 113788) || A2(r, 113792, 113800))))))))))))) : (l(124111) ? (l(120145) ? (l(119996) ? (A2(r, 113808, 113817) || (A2(r, 119808, 119892) || (A2(r, 119894, 119964) || (A2(r, 119966, 119967) || (e(119970) || (A2(r, 119973, 119974) || (A2(r, 119977, 119980) || (A2(r, 119982, 119993) || e(119995))))))))) : (A2(r, 119997, 120003) || (A2(r, 120005, 120069) || (A2(r, 120071, 120074) || (A2(r, 120077, 120084) || (A2(r, 120086, 120092) || (A2(r, 120094, 120121) || (A2(r, 120123, 120126) || (A2(r, 120128, 120132) || (e(120134) || A2(r, 120138, 120144))))))))))) : (l(120745) ? (A2(r, 120146, 120485) || (A2(r, 120488, 120512) || (A2(r, 120514, 120538) || (A2(r, 120540, 120570) || (A2(r, 120572, 120596) || (A2(r, 120598, 120628) || (A2(r, 120630, 120654) || (A2(r, 120656, 120686) || (A2(r, 120688, 120712) || A2(r, 120714, 120744)))))))))) : (A2(r, 120746, 120770) || (A2(r, 120772, 120779) || (A2(r, 122624, 122654) || (A2(r, 122661, 122666) || (A2(r, 122928, 122989) || (A2(r, 123136, 123180) || (A2(r, 123191, 123197) || (e(123214) || (A2(r, 123536, 123565) || A2(r, 123584, 123627)))))))))))) : (l(126563) ? (l(126496) ? (A2(r, 124112, 124139) || (A2(r, 124896, 124902) || (A2(r, 124904, 124907) || (A2(r, 124909, 124910) || (A2(r, 124912, 124926) || (A2(r, 124928, 125124) || (A2(r, 125184, 125251) || (e(125259) || (A2(r, 126464, 126467) || A2(r, 126469, 126495)))))))))) : (A2(r, 126497, 126498) || (e(126500) || (e(126503) || (A2(r, 126505, 126514) || (A2(r, 126516, 126519) || (e(126530) || (A2(r, 126541, 126543) || (A2(r, 126545, 126546) || (e(126548) || (A2(r, 126561, 126562) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && (A2(r, 126521, 126523) || (A2(r, 126535, 126539) || A2(r, 126551, 126559))))))))))))))) : (l(126634) ? (e(126564) || (A2(r, 126567, 126570) || (A2(r, 126572, 126578) || (A2(r, 126580, 126583) || (A2(r, 126585, 126588) || (e(126590) || (A2(r, 126592, 126601) || (A2(r, 126603, 126619) || (A2(r, 126625, 126627) || A2(r, 126629, 126633)))))))))) : (A2(r, 126635, 126651) || (A2(r, 131072, 173791) || (A2(r, 173824, 177977) || (A2(r, 177984, 178205) || (A2(r, 178208, 183969) || (A2(r, 183984, 191456) || (A2(r, 191472, 192093) || (A2(r, 194560, 195101) || (A2(r, 196608, 201546) || A2(r, 201552, 205743))))))))))))))));
};
var $author$project$Compiler$Parse$Variable$getInnerWidthHelp = function (word) {
	return ((97 <= word) && (word <= 122)) ? 1 : (((65 <= word) && (word <= 90)) ? 1 : (((48 <= word) && (word <= 57)) ? 1 : ((word === 95) ? 1 : ((word < 128) ? 0 : ($miniBill$elm_unicode$Unicode$isAlpha(
		$elm$core$Char$fromCode(word)) ? $author$project$Compiler$Parse$Primitives$getCharWidth(word) : 0)))));
};
var $author$project$Compiler$Parse$Variable$getInnerWidth = F3(
	function (src, pos, end) {
		return (_Utils_cmp(pos, end) < 0) ? $author$project$Compiler$Parse$Variable$getInnerWidthHelp(
			A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos)) : 0;
	});
var $author$project$Compiler$Parse$Variable$chompInnerChars = F4(
	function (src, pos, end, col) {
		chompInnerChars:
		while (true) {
			var width = A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos, end);
			if (!width) {
				return _Utils_Tuple2(pos, col);
			} else {
				var $temp$src = src,
					$temp$pos = pos + width,
					$temp$end = end,
					$temp$col = col + 1;
				src = $temp$src;
				pos = $temp$pos;
				end = $temp$end;
				col = $temp$col;
				continue chompInnerChars;
			}
		}
	});
var $elm$core$Char$toLower = _Char_toLower;
var $elm$core$Char$toUpper = _Char_toUpper;
var $miniBill$elm_unicode$Unicode$isUpper = function (c) {
	var simple = _Utils_eq(
		$elm$core$Char$toUpper(c),
		c) && (!_Utils_eq(
		$elm$core$Char$toLower(c),
		c));
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return simple ? ((code <= 8543) || (A2(r, 8560, 9397) || A2(r, 9424, 983040))) : (l(120015) ? (l(8509) ? (A2(r, 978, 980) || (e(8450) || (e(8455) || (A2(r, 8459, 8461) || (A2(r, 8464, 8466) || (e(8469) || (A2(r, 8473, 8477) || (e(8484) || (e(8488) || (A2(r, 8490, 8493) || A2(r, 8496, 8499))))))))))) : (A2(r, 8510, 8511) || (e(8517) || (A2(r, 119808, 119833) || (A2(r, 119860, 119885) || (A2(r, 119912, 119937) || (e(119964) || (A2(r, 119966, 119967) || (e(119970) || (A2(r, 119973, 119974) || (A2(r, 119977, 119980) || A2(r, 119982, 119989)))))))))))) : (l(120223) ? (A2(r, 120016, 120041) || (A2(r, 120068, 120069) || (A2(r, 120071, 120074) || (A2(r, 120077, 120084) || (A2(r, 120086, 120092) || (A2(r, 120120, 120121) || (A2(r, 120123, 120126) || (A2(r, 120128, 120132) || (e(120134) || (A2(r, 120138, 120144) || A2(r, 120172, 120197))))))))))) : (A2(r, 120224, 120249) || (A2(r, 120276, 120301) || (A2(r, 120328, 120353) || (A2(r, 120380, 120405) || (A2(r, 120432, 120457) || (A2(r, 120488, 120512) || (A2(r, 120546, 120570) || (A2(r, 120604, 120628) || (A2(r, 120662, 120686) || (A2(r, 120720, 120744) || e(120778)))))))))))));
};
var $author$project$Compiler$Parse$Variable$getUpperWidthHelp = function (word) {
	return ((65 <= word) && (word <= 90)) ? 1 : ((word < 128) ? 0 : ($miniBill$elm_unicode$Unicode$isUpper(
		$elm$core$Char$fromCode(word)) ? $author$project$Compiler$Parse$Primitives$getCharWidth(word) : 0));
};
var $author$project$Compiler$Parse$Variable$getUpperWidth = F3(
	function (src, pos, end) {
		return (_Utils_cmp(pos, end) < 0) ? $author$project$Compiler$Parse$Variable$getUpperWidthHelp(
			A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos)) : 0;
	});
var $author$project$Compiler$Parse$Variable$chompUpper = F4(
	function (src, pos, end, col) {
		var width = A3($author$project$Compiler$Parse$Variable$getUpperWidth, src, pos, end);
		return (!width) ? _Utils_Tuple2(pos, col) : A4($author$project$Compiler$Parse$Variable$chompInnerChars, src, pos + width, end, col + 1);
	});
var $author$project$Compiler$Parse$Variable$isDot = F3(
	function (src, pos, end) {
		return (_Utils_cmp(pos, end) < 0) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) === 46);
	});
var $author$project$Compiler$Parse$Variable$foreignUpperHelp = F4(
	function (src, pos, end, col) {
		foreignUpperHelp:
		while (true) {
			var _v0 = A4($author$project$Compiler$Parse$Variable$chompUpper, src, pos, end, col);
			var newPos = _v0.a;
			var newCol = _v0.b;
			if (_Utils_eq(pos, newPos)) {
				return _Utils_Tuple3(pos, pos, col);
			} else {
				if (A3($author$project$Compiler$Parse$Variable$isDot, src, newPos, end)) {
					var $temp$src = src,
						$temp$pos = newPos + 1,
						$temp$end = end,
						$temp$col = newCol + 1;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					col = $temp$col;
					continue foreignUpperHelp;
				} else {
					return _Utils_Tuple3(pos, newPos, newCol);
				}
			}
		}
	});
var $author$project$Compiler$Data$Utf8$fromPtr = F3(
	function (src, pos, end) {
		return A3($elm$core$String$slice, pos, end, src);
	});
var $author$project$Compiler$Data$Name$fromPtr = $author$project$Compiler$Data$Utf8$fromPtr;
var $author$project$Compiler$Parse$Variable$foreignUpper = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var _v1 = A4($author$project$Compiler$Parse$Variable$foreignUpperHelp, src, pos, end, col);
			var upperStart = _v1.a;
			var upperEnd = _v1.b;
			var newCol = _v1.c;
			if (_Utils_eq(upperStart, upperEnd)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, newCol, toError);
			} else {
				var newState = A6($author$project$Compiler$Parse$Primitives$State, src, upperEnd, end, indent, row, newCol);
				var name = A3($author$project$Compiler$Data$Name$fromPtr, src, upperStart, upperEnd);
				var upperName = function () {
					if (_Utils_eq(upperStart, pos)) {
						return $author$project$Compiler$Parse$Variable$Unqualified(name);
					} else {
						var home = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, upperStart - 1);
						return A2($author$project$Compiler$Parse$Variable$Qualified, home, name);
					}
				}();
				return A2($author$project$Compiler$Parse$Primitives$Cok, upperName, newState);
			}
		});
};
var $author$project$Compiler$Parse$Primitives$getPosition = $author$project$Compiler$Parse$Primitives$Parser(
	function (state) {
		var row = state.e;
		var col = state.f;
		return A2(
			$author$project$Compiler$Parse$Primitives$Eok,
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col),
			state);
	});
var $author$project$Compiler$Parse$Primitives$inContext = F3(
	function (addContext, _v0, _v1) {
		var parserStart = _v0.a;
		var parserA = _v1.a;
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				var row = state.e;
				var col = state.f;
				var _v2 = parserStart(state);
				switch (_v2.$) {
					case 'Cok':
						var s = _v2.b;
						var _v3 = parserA(s);
						switch (_v3.$) {
							case 'Cok':
								var a = _v3.a;
								var s_ = _v3.b;
								return A2($author$project$Compiler$Parse$Primitives$Cok, a, s_);
							case 'Eok':
								var a = _v3.a;
								var s_ = _v3.b;
								return A2($author$project$Compiler$Parse$Primitives$Cok, a, s_);
							case 'Cerr':
								var r = _v3.a;
								var c = _v3.b;
								var tx = _v3.c;
								return A3(
									$author$project$Compiler$Parse$Primitives$Cerr,
									row,
									col,
									addContext(
										A2(tx, r, c)));
							default:
								var r = _v3.a;
								var c = _v3.b;
								var tx = _v3.c;
								return A3(
									$author$project$Compiler$Parse$Primitives$Cerr,
									row,
									col,
									addContext(
										A2(tx, r, c)));
						}
					case 'Eok':
						var s = _v2.b;
						var _v4 = parserA(s);
						switch (_v4.$) {
							case 'Cok':
								var a = _v4.a;
								var s_ = _v4.b;
								return A2($author$project$Compiler$Parse$Primitives$Cok, a, s_);
							case 'Eok':
								var a = _v4.a;
								var s_ = _v4.b;
								return A2($author$project$Compiler$Parse$Primitives$Eok, a, s_);
							case 'Cerr':
								var r = _v4.a;
								var c = _v4.b;
								var tx = _v4.c;
								return A3(
									$author$project$Compiler$Parse$Primitives$Cerr,
									row,
									col,
									addContext(
										A2(tx, r, c)));
							default:
								var r = _v4.a;
								var c = _v4.b;
								var tx = _v4.c;
								return A3(
									$author$project$Compiler$Parse$Primitives$Eerr,
									row,
									col,
									addContext(
										A2(tx, r, c)));
						}
					case 'Cerr':
						var r = _v2.a;
						var c = _v2.b;
						var t = _v2.c;
						return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
					default:
						var r = _v2.a;
						var c = _v2.b;
						var t = _v2.c;
						return A3($author$project$Compiler$Parse$Primitives$Eerr, r, c, t);
				}
			});
	});
var $miniBill$elm_unicode$Unicode$isLower = function (c) {
	var simple = _Utils_eq(
		$elm$core$Char$toLower(c),
		c) && (!_Utils_eq(
		$elm$core$Char$toUpper(c),
		c));
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return simple ? ((code <= 836) || (A2(r, 838, 8559) || (A2(r, 8576, 9423) || A2(r, 9450, 983040)))) : (l(43001) ? (l(8457) ? (l(590) ? (A2(r, 311, 312) || (A2(r, 396, 397) || (A2(r, 409, 411) || (A2(r, 426, 427) || (A2(r, 441, 442) || (A2(r, 445, 447) || (e(545) || A2(r, 563, 569)))))))) : (A2(r, 591, 659) || (A2(r, 661, 687) || (A2(r, 1019, 1020) || (A2(r, 1376, 1416) || (A2(r, 7424, 7467) || (A2(r, 7531, 7543) || (A2(r, 7545, 7578) || (A2(r, 7829, 7837) || e(7839)))))))))) : (l(11376) ? (e(8458) || (A2(r, 8462, 8463) || (e(8467) || (e(8495) || (e(8500) || (e(8505) || (A2(r, 8508, 8509) || A2(r, 8518, 8521)))))))) : (e(11377) || (A2(r, 11379, 11380) || (A2(r, 11382, 11387) || (A2(r, 11491, 11492) || (A2(r, 42799, 42801) || (A2(r, 42865, 42872) || (e(42894) || (A2(r, 42899, 42901) || (e(42927) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 42963, 42965))))))))))))) : (l(120353) ? (l(119994) ? (e(43002) || (A2(r, 43824, 43866) || (A2(r, 43872, 43880) || (A2(r, 119834, 119859) || (A2(r, 119886, 119892) || (A2(r, 119894, 119911) || (A2(r, 119938, 119963) || A2(r, 119990, 119993)))))))) : (e(119995) || (A2(r, 119997, 120003) || (A2(r, 120005, 120015) || (A2(r, 120042, 120067) || (A2(r, 120094, 120119) || (A2(r, 120146, 120171) || (A2(r, 120198, 120223) || (A2(r, 120250, 120275) || A2(r, 120302, 120327)))))))))) : (l(120655) ? (A2(r, 120354, 120379) || (A2(r, 120406, 120431) || (A2(r, 120458, 120485) || (A2(r, 120514, 120538) || (A2(r, 120540, 120545) || (A2(r, 120572, 120596) || (A2(r, 120598, 120603) || A2(r, 120630, 120654)))))))) : (A2(r, 120656, 120661) || (A2(r, 120688, 120712) || (A2(r, 120714, 120719) || (A2(r, 120746, 120770) || (A2(r, 120772, 120777) || (e(120779) || (A2(r, 122624, 122633) || (A2(r, 122635, 122654) || A2(r, 122661, 122666))))))))))));
};
var $author$project$Compiler$Parse$Variable$getLowerWidthHelp = function (word) {
	return ((97 <= word) && (word <= 122)) ? 1 : ((word < 128) ? 0 : ($miniBill$elm_unicode$Unicode$isLower(
		$elm$core$Char$fromCode(word)) ? $author$project$Compiler$Parse$Primitives$getCharWidth(word) : 0));
};
var $author$project$Compiler$Parse$Variable$getLowerWidth = F3(
	function (src, pos, end) {
		return (_Utils_cmp(pos, end) < 0) ? $author$project$Compiler$Parse$Variable$getLowerWidthHelp(
			A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos)) : 0;
	});
var $author$project$Compiler$Parse$Variable$chompLower = F4(
	function (src, pos, end, col) {
		var width = A3($author$project$Compiler$Parse$Variable$getLowerWidth, src, pos, end);
		return (!width) ? _Utils_Tuple2(pos, col) : A4($author$project$Compiler$Parse$Variable$chompInnerChars, src, pos + width, end, col + 1);
	});
var $elm$core$Dict$member = F2(
	function (key, dict) {
		var _v0 = A2($elm$core$Dict$get, key, dict);
		if (_v0.$ === 'Just') {
			return true;
		} else {
			return false;
		}
	});
var $elm$core$Set$member = F2(
	function (key, _v0) {
		var dict = _v0.a;
		return A2($elm$core$Dict$member, key, dict);
	});
var $author$project$Extra$Type$Set$member = $elm$core$Set$member;
var $elm$core$Set$Set_elm_builtin = function (a) {
	return {$: 'Set_elm_builtin', a: a};
};
var $elm$core$Set$empty = $elm$core$Set$Set_elm_builtin($elm$core$Dict$empty);
var $elm$core$Set$insert = F2(
	function (key, _v0) {
		var dict = _v0.a;
		return $elm$core$Set$Set_elm_builtin(
			A3($elm$core$Dict$insert, key, _Utils_Tuple0, dict));
	});
var $elm$core$Set$fromList = function (list) {
	return A3($elm$core$List$foldl, $elm$core$Set$insert, $elm$core$Set$empty, list);
};
var $author$project$Extra$Type$Set$fromList = $elm$core$Set$fromList;
var $author$project$Compiler$Parse$Variable$reservedWords = $author$project$Extra$Type$Set$fromList(
	_List_fromArray(
		['if', 'then', 'else', 'case', 'of', 'let', 'in', 'type', 'module', 'where', 'import', 'exposing', 'as', 'port']));
var $author$project$Compiler$Parse$Variable$lower = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var _v1 = A4($author$project$Compiler$Parse$Variable$chompLower, src, pos, end, col);
			var newPos = _v1.a;
			var newCol = _v1.b;
			if (_Utils_eq(pos, newPos)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
			} else {
				var name = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, newPos);
				if (A2($author$project$Extra$Type$Set$member, name, $author$project$Compiler$Parse$Variable$reservedWords)) {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				} else {
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
					return A2($author$project$Compiler$Parse$Primitives$Cok, name, newState);
				}
			}
		});
};
var $author$project$Compiler$Parse$Primitives$oneOfHelp = F3(
	function (state, toError, parsers) {
		oneOfHelp:
		while (true) {
			if (parsers.b) {
				var parser = parsers.a.a;
				var parsers_ = parsers.b;
				var _v1 = parser(state);
				if (_v1.$ === 'Eerr') {
					var $temp$state = state,
						$temp$toError = toError,
						$temp$parsers = parsers_;
					state = $temp$state;
					toError = $temp$toError;
					parsers = $temp$parsers;
					continue oneOfHelp;
				} else {
					var x = _v1;
					return x;
				}
			} else {
				var _v2 = state;
				var row = _v2.e;
				var col = _v2.f;
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
			}
		}
	});
var $author$project$Compiler$Parse$Primitives$oneOf = F2(
	function (toError, parsers) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				return A3($author$project$Compiler$Parse$Primitives$oneOfHelp, state, toError, parsers);
			});
	});
var $author$project$Compiler$Parse$Primitives$oowfHelp = F3(
	function (state, parsers, fallback) {
		oowfHelp:
		while (true) {
			if (!parsers.b) {
				return A2($author$project$Compiler$Parse$Primitives$Eok, fallback, state);
			} else {
				var parser = parsers.a.a;
				var parsers_ = parsers.b;
				var _v1 = parser(state);
				if (_v1.$ === 'Eerr') {
					var $temp$state = state,
						$temp$parsers = parsers_,
						$temp$fallback = fallback;
					state = $temp$state;
					parsers = $temp$parsers;
					fallback = $temp$fallback;
					continue oowfHelp;
				} else {
					var x = _v1;
					return x;
				}
			}
		}
	});
var $author$project$Compiler$Parse$Primitives$oneOfWithFallback = F2(
	function (parsers, fallback) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				return A3($author$project$Compiler$Parse$Primitives$oowfHelp, state, parsers, fallback);
			});
	});
var $author$project$Compiler$Parse$Primitives$return = function (value) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (state) {
			return A2($author$project$Compiler$Parse$Primitives$Eok, value, state);
		});
};
var $author$project$Compiler$Parse$Primitives$specialize = F2(
	function (addContext, _v0) {
		var parser = _v0.a;
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				var row = state.e;
				var col = state.f;
				var _v1 = parser(state);
				switch (_v1.$) {
					case 'Cok':
						var a = _v1.a;
						var s = _v1.b;
						return A2($author$project$Compiler$Parse$Primitives$Cok, a, s);
					case 'Eok':
						var a = _v1.a;
						var s = _v1.b;
						return A2($author$project$Compiler$Parse$Primitives$Eok, a, s);
					case 'Cerr':
						var r = _v1.a;
						var c = _v1.b;
						var tx = _v1.c;
						return A3(
							$author$project$Compiler$Parse$Primitives$Cerr,
							row,
							col,
							addContext(
								A2(tx, r, c)));
					default:
						var r = _v1.a;
						var c = _v1.b;
						var tx = _v1.c;
						return A3(
							$author$project$Compiler$Parse$Primitives$Eerr,
							row,
							col,
							addContext(
								A2(tx, r, c)));
				}
			});
	});
var $author$project$Compiler$Parse$Primitives$word1 = F2(
	function (word, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				if ((_Utils_cmp(pos, end) < 0) && _Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					word)) {
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, pos + 1, end, indent, row, col + 1);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, newState);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Primitives$word2 = F3(
	function (w1, w2, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos1 = pos + 1;
				if ((_Utils_cmp(pos1, end) < 0) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && _Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1),
					w2))) {
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, pos + 2, end, indent, row, col + 2);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, newState);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Type$app = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Variable$foreignUpper($author$project$Compiler$Reporting$Error$Syntax$TStart),
		function (upper) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Primitives$getPosition,
				function (upperEnd) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$TSpace),
						function (_v35) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Type$chompArgs, _List_Nil, upperEnd),
								function (_v36) {
									var args = _v36.a;
									var end = _v36.b;
									var region = A2($author$project$Compiler$Reporting$Annotation$Region, start, upperEnd);
									var tipe = function () {
										if (upper.$ === 'Unqualified') {
											var name = upper.a;
											return A3($author$project$Compiler$AST$Source$TType, region, name, args);
										} else {
											var home = upper.a;
											var name = upper.b;
											return A4($author$project$Compiler$AST$Source$TTypeQual, region, home, name, args);
										}
									}();
									return $author$project$Compiler$Parse$Primitives$return(
										_Utils_Tuple2(
											A3($author$project$Compiler$Reporting$Annotation$at, start, end, tipe),
											end));
								});
						});
				});
		});
};
var $author$project$Compiler$Parse$Type$chompArgs = F2(
	function (args, end) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TIndentStart),
					function (_v33) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Type$cyclic$term(),
							function (arg) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Primitives$getPosition,
									function (newEnd) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$TSpace),
											function (_v34) {
												return A2(
													$author$project$Compiler$Parse$Type$chompArgs,
													A2($elm$core$List$cons, arg, args),
													newEnd);
											});
									});
							});
					})
				]),
			_Utils_Tuple2(
				$author$project$Extra$Type$List$reverse(args),
				end));
	});
var $author$project$Compiler$Parse$Type$chompRecordEnd = function (fields) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$TRecordEnd,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$TRecordEnd),
				function (_v25) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentField),
						function (_v26) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Type$cyclic$chompField(),
								function (field) {
									return $author$project$Compiler$Parse$Type$chompRecordEnd(
										A2($elm$core$List$cons, field, fields));
								});
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$TRecordEnd),
				function (_v27) {
					return $author$project$Compiler$Parse$Primitives$return(
						$author$project$Extra$Type$List$reverse(fields));
				})
			]));
};
var $author$project$Compiler$Parse$Type$chompTupleEnd = F3(
	function (start, firstType, revTypes) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$TTupleEnd,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$TTupleEnd),
					function (_v19) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TTupleSpace, $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentTypeN),
							function (_v20) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$TTupleType,
										$author$project$Compiler$Parse$Type$cyclic$expression()),
									function (_v21) {
										var tipe = _v21.a;
										var end = _v21.b;
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentEnd),
											function (_v22) {
												return A3(
													$author$project$Compiler$Parse$Type$chompTupleEnd,
													start,
													firstType,
													A2($elm$core$List$cons, tipe, revTypes));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$TTupleEnd),
					function (_v23) {
						var _v24 = $author$project$Extra$Type$List$reverse(revTypes);
						if (!_v24.b) {
							return $author$project$Compiler$Parse$Primitives$return(firstType);
						} else {
							var secondType = _v24.a;
							var otherTypes = _v24.b;
							return A2(
								$author$project$Compiler$Parse$Primitives$addEnd,
								start,
								A3($author$project$Compiler$AST$Source$TTuple, firstType, secondType, otherTypes));
						}
					})
				]));
	});
function $author$project$Compiler$Parse$Type$cyclic$chompField() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$addLocation(
			$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$TRecordField)),
		function (name) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentColon),
				function (_v28) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Primitives$word1, 58, $author$project$Compiler$Reporting$Error$Syntax$TRecordColon),
						function (_v29) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentType),
								function (_v30) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2(
											$author$project$Compiler$Parse$Primitives$specialize,
											$author$project$Compiler$Reporting$Error$Syntax$TRecordType,
											$author$project$Compiler$Parse$Type$cyclic$expression()),
										function (_v31) {
											var tipe = _v31.a;
											var end = _v31.b;
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentEnd),
												function (_v32) {
													return $author$project$Compiler$Parse$Primitives$return(
														_Utils_Tuple2(name, tipe));
												});
										});
								});
						});
				});
		});
}
function $author$project$Compiler$Parse$Type$cyclic$expression() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$TStart,
					_List_fromArray(
						[
							$author$project$Compiler$Parse$Type$app(start),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Type$cyclic$term(),
							function (eterm) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Primitives$getPosition,
									function (end) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$TSpace),
											function (_v14) {
												return $author$project$Compiler$Parse$Primitives$return(
													_Utils_Tuple2(eterm, end));
											});
									});
							})
						])),
				function (term1) {
					var tipe1 = term1.a;
					var end1 = term1.b;
					return A2(
						$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Space$checkIndent, end1, $author$project$Compiler$Reporting$Error$Syntax$TIndentStart),
								function (_v15) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A3($author$project$Compiler$Parse$Primitives$word2, 45, 62, $author$project$Compiler$Reporting$Error$Syntax$TStart),
										function (_v16) {
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TSpace, $author$project$Compiler$Reporting$Error$Syntax$TIndentStart),
												function (_v17) {
													return A2(
														$author$project$Compiler$Parse$Primitives$bind,
														$author$project$Compiler$Parse$Type$cyclic$expression(),
														function (_v18) {
															var tipe2 = _v18.a;
															var end2 = _v18.b;
															var tipe = A3(
																$author$project$Compiler$Reporting$Annotation$at,
																start,
																end2,
																A2($author$project$Compiler$AST$Source$TLambda, tipe1, tipe2));
															return $author$project$Compiler$Parse$Primitives$return(
																_Utils_Tuple2(tipe, end2));
														});
												});
										});
								})
							]),
						term1);
				});
		});
}
function $author$project$Compiler$Parse$Type$cyclic$term() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$oneOf,
				$author$project$Compiler$Reporting$Error$Syntax$TStart,
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Variable$foreignUpper($author$project$Compiler$Reporting$Error$Syntax$TStart),
						function (upper) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Primitives$getPosition,
								function (end) {
									var region = A2($author$project$Compiler$Reporting$Annotation$Region, start, end);
									return $author$project$Compiler$Parse$Primitives$return(
										A2(
											$author$project$Compiler$Reporting$Annotation$At,
											region,
											function () {
												if (upper.$ === 'Unqualified') {
													var name = upper.a;
													return A3($author$project$Compiler$AST$Source$TType, region, name, _List_Nil);
												} else {
													var home = upper.a;
													var name = upper.b;
													return A4($author$project$Compiler$AST$Source$TTypeQual, region, home, name, _List_Nil);
												}
											}()));
								});
						}),
						A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$TStart),
						function (_var) {
							return A2(
								$author$project$Compiler$Parse$Primitives$addEnd,
								start,
								$author$project$Compiler$AST$Source$TVar(_var));
						}),
						A3(
						$author$project$Compiler$Parse$Primitives$inContext,
						$author$project$Compiler$Reporting$Error$Syntax$TTuple,
						A2($author$project$Compiler$Parse$Primitives$word1, 40, $author$project$Compiler$Reporting$Error$Syntax$TStart),
						A2(
							$author$project$Compiler$Parse$Primitives$oneOf,
							$author$project$Compiler$Reporting$Error$Syntax$TTupleOpen,
							_List_fromArray(
								[
									A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$TTupleOpen),
									function (_v1) {
										return A2($author$project$Compiler$Parse$Primitives$addEnd, start, $author$project$Compiler$AST$Source$TUnit);
									}),
									A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TTupleSpace, $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentType1),
									function (_v2) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2(
												$author$project$Compiler$Parse$Primitives$specialize,
												$author$project$Compiler$Reporting$Error$Syntax$TTupleType,
												$author$project$Compiler$Parse$Type$cyclic$expression()),
											function (_v3) {
												var tipe = _v3.a;
												var end = _v3.b;
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TTupleIndentEnd),
													function (_v4) {
														return A3($author$project$Compiler$Parse$Type$chompTupleEnd, start, tipe, _List_Nil);
													});
											});
									})
								]))),
						A3(
						$author$project$Compiler$Parse$Primitives$inContext,
						$author$project$Compiler$Reporting$Error$Syntax$TRecord,
						A2($author$project$Compiler$Parse$Primitives$word1, 123, $author$project$Compiler$Reporting$Error$Syntax$TStart),
						A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentOpen),
							function (_v5) {
								return A2(
									$author$project$Compiler$Parse$Primitives$oneOf,
									$author$project$Compiler$Reporting$Error$Syntax$TRecordOpen,
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$TRecordEnd),
											function (_v6) {
												return A2(
													$author$project$Compiler$Parse$Primitives$addEnd,
													start,
													A2($author$project$Compiler$AST$Source$TRecord, _List_Nil, $elm$core$Maybe$Nothing));
											}),
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Primitives$addLocation(
												$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$TRecordField)),
											function (name) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentColon),
													function (_v7) {
														return A2(
															$author$project$Compiler$Parse$Primitives$oneOf,
															$author$project$Compiler$Reporting$Error$Syntax$TRecordColon,
															_List_fromArray(
																[
																	A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	A2($author$project$Compiler$Parse$Primitives$word1, 124, $author$project$Compiler$Reporting$Error$Syntax$TRecordColon),
																	function (_v8) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentField),
																			function (_v9) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					$author$project$Compiler$Parse$Type$cyclic$chompField(),
																					function (field) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							$author$project$Compiler$Parse$Type$chompRecordEnd(
																								_List_fromArray(
																									[field])),
																							function (fields) {
																								return A2(
																									$author$project$Compiler$Parse$Primitives$addEnd,
																									start,
																									A2(
																										$author$project$Compiler$AST$Source$TRecord,
																										fields,
																										$elm$core$Maybe$Just(name)));
																							});
																					});
																			});
																	}),
																	A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	A2($author$project$Compiler$Parse$Primitives$word1, 58, $author$project$Compiler$Reporting$Error$Syntax$TRecordColon),
																	function (_v10) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentType),
																			function (_v11) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					A2(
																						$author$project$Compiler$Parse$Primitives$specialize,
																						$author$project$Compiler$Reporting$Error$Syntax$TRecordType,
																						$author$project$Compiler$Parse$Type$cyclic$expression()),
																					function (_v12) {
																						var tipe = _v12.a;
																						var end = _v12.b;
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TRecordIndentEnd),
																							function (_v13) {
																								return A2(
																									$author$project$Compiler$Parse$Primitives$bind,
																									$author$project$Compiler$Parse$Type$chompRecordEnd(
																										_List_fromArray(
																											[
																												_Utils_Tuple2(name, tipe)
																											])),
																									function (fields) {
																										return A2(
																											$author$project$Compiler$Parse$Primitives$addEnd,
																											start,
																											A2($author$project$Compiler$AST$Source$TRecord, fields, $elm$core$Maybe$Nothing));
																									});
																							});
																					});
																			});
																	})
																]));
													});
											})
										]));
							}))
					]));
		});
}
try {
	var $author$project$Compiler$Parse$Type$chompField = $author$project$Compiler$Parse$Type$cyclic$chompField();
	$author$project$Compiler$Parse$Type$cyclic$chompField = function () {
		return $author$project$Compiler$Parse$Type$chompField;
	};
	var $author$project$Compiler$Parse$Type$expression = $author$project$Compiler$Parse$Type$cyclic$expression();
	$author$project$Compiler$Parse$Type$cyclic$expression = function () {
		return $author$project$Compiler$Parse$Type$expression;
	};
	var $author$project$Compiler$Parse$Type$term = $author$project$Compiler$Parse$Type$cyclic$term();
	$author$project$Compiler$Parse$Type$cyclic$term = function () {
		return $author$project$Compiler$Parse$Type$term;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Parse.Type` are causing infinite recursion:\n\n  \n      app\n       \n      chompArgs\n       \n      chompField\n       \n      chompRecordEnd\n       \n      chompTupleEnd\n       \n      expression\n       \n      term\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Terminal$Repl$annotation = function () {
	var err_ = F3(
		function (_v7, _v8, _v9) {
			return _Utils_Tuple0;
		});
	var err = F2(
		function (_v5, _v6) {
			return _Utils_Tuple0;
		});
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Variable$lower(err),
		function (name) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
				function (_v0) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Primitives$word1, 58, err),
						function (_v1) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
								function (_v2) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2($author$project$Compiler$Parse$Primitives$specialize, err_, $author$project$Compiler$Parse$Type$expression),
										function (_v3) {
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												$author$project$Compiler$Parse$Space$checkFreshLine(err),
												function (_v4) {
													return $author$project$Compiler$Parse$Primitives$return(name);
												});
										});
								});
						});
				});
		});
}();
var $author$project$Compiler$Reporting$Error$Syntax$DeclStart = F2(
	function (a, b) {
		return {$: 'DeclStart', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclFreshLineAfterDocComment = F2(
	function (a, b) {
		return {$: 'DeclFreshLineAfterDocComment', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclSpace = F3(
	function (a, b, c) {
		return {$: 'DeclSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Comment = {$: 'Comment'};
var $author$project$Compiler$Parse$Space$docComment = F2(
	function (toExpectation, toSpaceError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos3 = pos + 3;
				if ((_Utils_cmp(pos3, end) < 1) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) === 123) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1) === 45) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2) === 124)))) {
					var col3 = col + 3;
					var _v1 = A6($author$project$Compiler$Parse$Space$eatMultiCommentHelp, src, pos3, end, row, col3, 1);
					var _v2 = _v1.a;
					var status = _v2.a;
					var newPos = _v2.b;
					var _v3 = _v1.b;
					var newRow = _v3.a;
					var newCol = _v3.b;
					switch (status.$) {
						case 'MultiGood':
							var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol);
							var comment = $author$project$Compiler$AST$Source$Comment;
							return A2($author$project$Compiler$Parse$Primitives$Cok, comment, newState);
						case 'MultiTab':
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								newRow,
								newCol,
								toSpaceError($author$project$Compiler$Reporting$Error$Syntax$HasTab));
						default:
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								row,
								col,
								toSpaceError($author$project$Compiler$Reporting$Error$Syntax$EndlessMultiComment));
					}
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
				}
			});
	});
var $author$project$Compiler$Parse$Declaration$chompDocComment = A2(
	$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
	_List_fromArray(
		[
			A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$docComment, $author$project$Compiler$Reporting$Error$Syntax$DeclStart, $author$project$Compiler$Reporting$Error$Syntax$DeclSpace),
			function (docComment) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$DeclSpace),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Reporting$Error$Syntax$DeclFreshLineAfterDocComment),
							function (_v1) {
								return $author$project$Compiler$Parse$Primitives$return(
									$elm$core$Maybe$Just(docComment));
							});
					});
			})
		]),
	$elm$core$Maybe$Nothing);
var $author$project$Compiler$AST$Source$Port = F2(
	function (a, b) {
		return {$: 'Port', a: a, b: b};
	});
var $author$project$Compiler$Parse$Declaration$Port = function (a) {
	return {$: 'Port', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$Port = F3(
	function (a, b, c) {
		return {$: 'Port', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortColon = F2(
	function (a, b) {
		return {$: 'PortColon', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortIndentColon = F2(
	function (a, b) {
		return {$: 'PortIndentColon', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortIndentName = F2(
	function (a, b) {
		return {$: 'PortIndentName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortIndentType = F2(
	function (a, b) {
		return {$: 'PortIndentType', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortName = F2(
	function (a, b) {
		return {$: 'PortName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortSpace = F3(
	function (a, b, c) {
		return {$: 'PortSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortType = F3(
	function (a, b, c) {
		return {$: 'PortType', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Keyword$k4 = F5(
	function (w1, w2, w3, w4, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos4 = pos + 4;
				if ((_Utils_cmp(pos4, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2),
					w3) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3),
					w4) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos4, end))))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos4, end, indent, row, col + 4);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$port_ = function (tx) {
	return A5($author$project$Compiler$Parse$Keyword$k4, 112, 111, 114, 116, tx);
};
var $author$project$Compiler$Parse$Declaration$portDecl = A3(
	$author$project$Compiler$Parse$Primitives$inContext,
	$author$project$Compiler$Reporting$Error$Syntax$Port,
	$author$project$Compiler$Parse$Keyword$port_($author$project$Compiler$Reporting$Error$Syntax$DeclStart),
	A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PortSpace, $author$project$Compiler$Reporting$Error$Syntax$PortIndentName),
		function (_v0) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Primitives$addLocation(
					$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$PortName)),
				function (name) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PortSpace, $author$project$Compiler$Reporting$Error$Syntax$PortIndentColon),
						function (_v1) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Primitives$word1, 58, $author$project$Compiler$Reporting$Error$Syntax$PortColon),
								function (_v2) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PortSpace, $author$project$Compiler$Reporting$Error$Syntax$PortIndentType),
										function (_v3) {
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$PortType, $author$project$Compiler$Parse$Type$expression),
												function (_v4) {
													var tipe = _v4.a;
													var end = _v4.b;
													return $author$project$Compiler$Parse$Primitives$return(
														_Utils_Tuple2(
															$author$project$Compiler$Parse$Declaration$Port(
																A2($author$project$Compiler$AST$Source$Port, name, tipe)),
															end));
												});
										});
								});
						});
				});
		}));
var $author$project$Compiler$AST$Source$Alias = F3(
	function (a, b, c) {
		return {$: 'Alias', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Declaration$Alias = function (a) {
	return {$: 'Alias', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$AliasBody = F3(
	function (a, b, c) {
		return {$: 'AliasBody', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$AliasIndentEquals = F2(
	function (a, b) {
		return {$: 'AliasIndentEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$AliasSpace = F3(
	function (a, b, c) {
		return {$: 'AliasSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DT_Alias = F3(
	function (a, b, c) {
		return {$: 'DT_Alias', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DT_IndentName = F2(
	function (a, b) {
		return {$: 'DT_IndentName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DT_Name = F2(
	function (a, b) {
		return {$: 'DT_Name', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DT_Space = F3(
	function (a, b, c) {
		return {$: 'DT_Space', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DT_Union = F3(
	function (a, b, c) {
		return {$: 'DT_Union', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclType = F3(
	function (a, b, c) {
		return {$: 'DeclType', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Union = F3(
	function (a, b, c) {
		return {$: 'Union', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Declaration$Union = function (a) {
	return {$: 'Union', a: a};
};
var $author$project$Compiler$Parse$Keyword$k5 = F6(
	function (w1, w2, w3, w4, w5, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos5 = pos + 5;
				if ((_Utils_cmp(pos5, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2),
					w3) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3),
					w4) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4),
					w5) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos5, end)))))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos5, end, indent, row, col + 5);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$alias_ = function (tx) {
	return A6($author$project$Compiler$Parse$Keyword$k5, 97, 108, 105, 97, 115, tx);
};
var $author$project$Compiler$Reporting$Error$Syntax$AliasName = F2(
	function (a, b) {
		return {$: 'AliasName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$AliasEquals = F2(
	function (a, b) {
		return {$: 'AliasEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$AliasIndentBody = F2(
	function (a, b) {
		return {$: 'AliasIndentBody', a: a, b: b};
	});
var $author$project$Compiler$Parse$Declaration$chompAliasNameToEqualsHelp = F2(
	function (name, args) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$AliasEquals,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Primitives$addLocation(
						$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$AliasEquals)),
					function (arg) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$AliasSpace, $author$project$Compiler$Reporting$Error$Syntax$AliasIndentEquals),
							function (_v0) {
								return A2(
									$author$project$Compiler$Parse$Declaration$chompAliasNameToEqualsHelp,
									name,
									A2($elm$core$List$cons, arg, args));
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$AliasEquals),
					function (_v1) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$AliasSpace, $author$project$Compiler$Reporting$Error$Syntax$AliasIndentBody),
							function (_v2) {
								return $author$project$Compiler$Parse$Primitives$return(
									_Utils_Tuple2(
										name,
										$author$project$Extra$Type$List$reverse(args)));
							});
					})
				]));
	});
var $author$project$Compiler$Parse$Variable$upper = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var _v1 = A4($author$project$Compiler$Parse$Variable$chompUpper, src, pos, end, col);
			var newPos = _v1.a;
			var newCol = _v1.b;
			if (_Utils_eq(pos, newPos)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
			} else {
				var name = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, newPos);
				return A2(
					$author$project$Compiler$Parse$Primitives$Cok,
					name,
					A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol));
			}
		});
};
var $author$project$Compiler$Parse$Declaration$chompAliasNameToEquals = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Primitives$addLocation(
		$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$AliasName)),
	function (name) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$AliasSpace, $author$project$Compiler$Reporting$Error$Syntax$AliasIndentEquals),
			function (_v0) {
				return A2($author$project$Compiler$Parse$Declaration$chompAliasNameToEqualsHelp, name, _List_Nil);
			});
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_IndentEquals = F2(
	function (a, b) {
		return {$: 'CT_IndentEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_Name = F2(
	function (a, b) {
		return {$: 'CT_Name', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_Space = F3(
	function (a, b, c) {
		return {$: 'CT_Space', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_Equals = F2(
	function (a, b) {
		return {$: 'CT_Equals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_IndentAfterEquals = F2(
	function (a, b) {
		return {$: 'CT_IndentAfterEquals', a: a, b: b};
	});
var $author$project$Compiler$Parse$Declaration$chompCustomNameToEqualsHelp = F2(
	function (name, args) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$CT_Equals,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Primitives$addLocation(
						$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$CT_Equals)),
					function (arg) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CT_Space, $author$project$Compiler$Reporting$Error$Syntax$CT_IndentEquals),
							function (_v0) {
								return A2(
									$author$project$Compiler$Parse$Declaration$chompCustomNameToEqualsHelp,
									name,
									A2($elm$core$List$cons, arg, args));
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$CT_Equals),
					function (_v1) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CT_Space, $author$project$Compiler$Reporting$Error$Syntax$CT_IndentAfterEquals),
							function (_v2) {
								return $author$project$Compiler$Parse$Primitives$return(
									_Utils_Tuple2(
										name,
										$author$project$Extra$Type$List$reverse(args)));
							});
					})
				]));
	});
var $author$project$Compiler$Parse$Declaration$chompCustomNameToEquals = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Primitives$addLocation(
		$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$CT_Name)),
	function (name) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CT_Space, $author$project$Compiler$Reporting$Error$Syntax$CT_IndentEquals),
			function (_v0) {
				return A2($author$project$Compiler$Parse$Declaration$chompCustomNameToEqualsHelp, name, _List_Nil);
			});
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_Bar = F2(
	function (a, b) {
		return {$: 'CT_Bar', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_IndentAfterBar = F2(
	function (a, b) {
		return {$: 'CT_IndentAfterBar', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_IndentBar = F2(
	function (a, b) {
		return {$: 'CT_IndentBar', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_Variant = F2(
	function (a, b) {
		return {$: 'CT_Variant', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CT_VariantArg = F3(
	function (a, b, c) {
		return {$: 'CT_VariantArg', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Type$variant = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Primitives$addLocation(
		$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$CT_Variant)),
	function (name) {
		var _v0 = name.a;
		var nameEnd = _v0.b;
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$CT_Space),
			function (_v1) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2(
						$author$project$Compiler$Parse$Primitives$specialize,
						$author$project$Compiler$Reporting$Error$Syntax$CT_VariantArg,
						A2($author$project$Compiler$Parse$Type$chompArgs, _List_Nil, nameEnd)),
					function (_v2) {
						var args = _v2.a;
						var end = _v2.b;
						return $author$project$Compiler$Parse$Primitives$return(
							_Utils_Tuple2(
								_Utils_Tuple2(name, args),
								end));
					});
			});
	});
var $author$project$Compiler$Parse$Declaration$chompVariants = F2(
	function (variants, end) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$CT_IndentBar),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 124, $author$project$Compiler$Reporting$Error$Syntax$CT_Bar),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CT_Space, $author$project$Compiler$Reporting$Error$Syntax$CT_IndentAfterBar),
									function (_v2) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Type$variant,
											function (_v3) {
												var variant = _v3.a;
												var newEnd = _v3.b;
												return A2(
													$author$project$Compiler$Parse$Declaration$chompVariants,
													A2($elm$core$List$cons, variant, variants),
													newEnd);
											});
									});
							});
					})
				]),
			_Utils_Tuple2(
				$author$project$Extra$Type$List$reverse(variants),
				end));
	});
var $author$project$Compiler$Parse$Keyword$type_ = function (tx) {
	return A5($author$project$Compiler$Parse$Keyword$k4, 116, 121, 112, 101, tx);
};
var $author$project$Compiler$Parse$Declaration$typeDecl = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$DeclType,
		$author$project$Compiler$Parse$Keyword$type_($author$project$Compiler$Reporting$Error$Syntax$DeclStart),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DT_Space, $author$project$Compiler$Reporting$Error$Syntax$DT_IndentName),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$DT_Name,
					_List_fromArray(
						[
							A3(
							$author$project$Compiler$Parse$Primitives$inContext,
							$author$project$Compiler$Reporting$Error$Syntax$DT_Alias,
							$author$project$Compiler$Parse$Keyword$alias_($author$project$Compiler$Reporting$Error$Syntax$DT_Name),
							A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$AliasSpace, $author$project$Compiler$Reporting$Error$Syntax$AliasIndentEquals),
								function (_v1) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Parse$Declaration$chompAliasNameToEquals,
										function (_v2) {
											var name = _v2.a;
											var args = _v2.b;
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$AliasBody, $author$project$Compiler$Parse$Type$expression),
												function (_v3) {
													var tipe = _v3.a;
													var end = _v3.b;
													var alias = A3(
														$author$project$Compiler$Reporting$Annotation$at,
														start,
														end,
														A3($author$project$Compiler$AST$Source$Alias, name, args, tipe));
													return $author$project$Compiler$Parse$Primitives$return(
														_Utils_Tuple2(
															$author$project$Compiler$Parse$Declaration$Alias(alias),
															end));
												});
										});
								})),
							A2(
							$author$project$Compiler$Parse$Primitives$specialize,
							$author$project$Compiler$Reporting$Error$Syntax$DT_Union,
							A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Declaration$chompCustomNameToEquals,
								function (_v4) {
									var name = _v4.a;
									var args = _v4.b;
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Parse$Type$variant,
										function (_v5) {
											var firstVariant = _v5.a;
											var firstEnd = _v5.b;
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												A2(
													$author$project$Compiler$Parse$Declaration$chompVariants,
													_List_fromArray(
														[firstVariant]),
													firstEnd),
												function (_v6) {
													var variants = _v6.a;
													var end = _v6.b;
													var union = A3(
														$author$project$Compiler$Reporting$Annotation$at,
														start,
														end,
														A3($author$project$Compiler$AST$Source$Union, name, args, variants));
													return $author$project$Compiler$Parse$Primitives$return(
														_Utils_Tuple2(
															$author$project$Compiler$Parse$Declaration$Union(union),
															end));
												});
										});
								}))
						]));
			}));
};
var $author$project$Compiler$Reporting$Error$Syntax$DeclDef = F4(
	function (a, b, c, d) {
		return {$: 'DeclDef', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefEquals = F2(
	function (a, b) {
		return {$: 'DeclDefEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentEquals = F2(
	function (a, b) {
		return {$: 'DeclDefIndentEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentType = F2(
	function (a, b) {
		return {$: 'DeclDefIndentType', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefNameRepeat = F2(
	function (a, b) {
		return {$: 'DeclDefNameRepeat', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefSpace = F3(
	function (a, b, c) {
		return {$: 'DeclDefSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefType = F3(
	function (a, b, c) {
		return {$: 'DeclDefType', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefArg = F3(
	function (a, b, c) {
		return {$: 'DeclDefArg', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefBody = F3(
	function (a, b, c) {
		return {$: 'DeclDefBody', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentBody = F2(
	function (a, b) {
		return {$: 'DeclDefIndentBody', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Value = F4(
	function (a, b, c, d) {
		return {$: 'Value', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Parse$Declaration$Value = function (a) {
	return {$: 'Value', a: a};
};
var $author$project$Compiler$AST$Source$Binops = F2(
	function (a, b) {
		return {$: 'Binops', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$CList = function (a) {
	return {$: 'CList', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$CList = F3(
	function (a, b, c) {
		return {$: 'CList', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Case = F2(
	function (a, b) {
		return {$: 'Case', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Case = F3(
	function (a, b, c) {
		return {$: 'Case', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseArrow = F2(
	function (a, b) {
		return {$: 'CaseArrow', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseBranch = F3(
	function (a, b, c) {
		return {$: 'CaseBranch', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseExpr = F3(
	function (a, b, c) {
		return {$: 'CaseExpr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseIndentArrow = F2(
	function (a, b) {
		return {$: 'CaseIndentArrow', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseIndentBranch = F2(
	function (a, b) {
		return {$: 'CaseIndentBranch', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseIndentExpr = F2(
	function (a, b) {
		return {$: 'CaseIndentExpr', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseIndentOf = F2(
	function (a, b) {
		return {$: 'CaseIndentOf', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseIndentPattern = F2(
	function (a, b) {
		return {$: 'CaseIndentPattern', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseOf = F2(
	function (a, b) {
		return {$: 'CaseOf', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CasePattern = F3(
	function (a, b, c) {
		return {$: 'CasePattern', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CasePatternAlignment = F3(
	function (a, b, c) {
		return {$: 'CasePatternAlignment', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$CaseSpace = F3(
	function (a, b, c) {
		return {$: 'CaseSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefAlignment = F3(
	function (a, b, c) {
		return {$: 'DefAlignment', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefArg = F3(
	function (a, b, c) {
		return {$: 'DefArg', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefBody = F3(
	function (a, b, c) {
		return {$: 'DefBody', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefEquals = F2(
	function (a, b) {
		return {$: 'DefEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefIndentBody = F2(
	function (a, b) {
		return {$: 'DefIndentBody', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefIndentEquals = F2(
	function (a, b) {
		return {$: 'DefIndentEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefIndentType = F2(
	function (a, b) {
		return {$: 'DefIndentType', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefSpace = F3(
	function (a, b, c) {
		return {$: 'DefSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefType = F3(
	function (a, b, c) {
		return {$: 'DefType', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Define = F4(
	function (a, b, c, d) {
		return {$: 'Define', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Source$Destruct = F2(
	function (a, b) {
		return {$: 'Destruct', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DestructBody = F3(
	function (a, b, c) {
		return {$: 'DestructBody', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DestructEquals = F2(
	function (a, b) {
		return {$: 'DestructEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DestructIndentBody = F2(
	function (a, b) {
		return {$: 'DestructIndentBody', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DestructIndentEquals = F2(
	function (a, b) {
		return {$: 'DestructIndentEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DestructPattern = F3(
	function (a, b, c) {
		return {$: 'DestructPattern', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DestructSpace = F3(
	function (a, b, c) {
		return {$: 'DestructSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Primitives$Done = function (a) {
	return {$: 'Done', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$Func = F3(
	function (a, b, c) {
		return {$: 'Func', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FuncArg = F3(
	function (a, b, c) {
		return {$: 'FuncArg', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FuncBody = F3(
	function (a, b, c) {
		return {$: 'FuncBody', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FuncIndentArg = F2(
	function (a, b) {
		return {$: 'FuncIndentArg', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FuncIndentArrow = F2(
	function (a, b) {
		return {$: 'FuncIndentArrow', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FuncIndentBody = F2(
	function (a, b) {
		return {$: 'FuncIndentBody', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FuncSpace = F3(
	function (a, b, c) {
		return {$: 'FuncSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$If = F2(
	function (a, b) {
		return {$: 'If', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$If = F3(
	function (a, b, c) {
		return {$: 'If', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfCondition = F3(
	function (a, b, c) {
		return {$: 'IfCondition', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfElse = F2(
	function (a, b) {
		return {$: 'IfElse', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfElseBranch = F3(
	function (a, b, c) {
		return {$: 'IfElseBranch', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfElseBranchStart = F2(
	function (a, b) {
		return {$: 'IfElseBranchStart', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfIndentCondition = F2(
	function (a, b) {
		return {$: 'IfIndentCondition', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfIndentElse = F2(
	function (a, b) {
		return {$: 'IfIndentElse', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfIndentElseBranch = F2(
	function (a, b) {
		return {$: 'IfIndentElseBranch', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfIndentThen = F2(
	function (a, b) {
		return {$: 'IfIndentThen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfIndentThenBranch = F2(
	function (a, b) {
		return {$: 'IfIndentThenBranch', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfSpace = F3(
	function (a, b, c) {
		return {$: 'IfSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfThen = F2(
	function (a, b) {
		return {$: 'IfThen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IfThenBranch = F3(
	function (a, b, c) {
		return {$: 'IfThenBranch', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$IndentOperatorRight = F3(
	function (a, b, c) {
		return {$: 'IndentOperatorRight', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Lambda = F2(
	function (a, b) {
		return {$: 'Lambda', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Let = F2(
	function (a, b) {
		return {$: 'Let', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Let = F3(
	function (a, b, c) {
		return {$: 'Let', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetBody = F3(
	function (a, b, c) {
		return {$: 'LetBody', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetDef = F4(
	function (a, b, c, d) {
		return {$: 'LetDef', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetDefAlignment = F2(
	function (a, b) {
		return {$: 'LetDefAlignment', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetDefName = F2(
	function (a, b) {
		return {$: 'LetDefName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetDestruct = F3(
	function (a, b, c) {
		return {$: 'LetDestruct', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetIn = F2(
	function (a, b) {
		return {$: 'LetIn', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetIndentBody = F2(
	function (a, b) {
		return {$: 'LetIndentBody', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetIndentDef = F2(
	function (a, b) {
		return {$: 'LetIndentDef', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetIndentIn = F2(
	function (a, b) {
		return {$: 'LetIndentIn', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$LetSpace = F3(
	function (a, b, c) {
		return {$: 'LetSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListEnd = F2(
	function (a, b) {
		return {$: 'ListEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListExpr = F3(
	function (a, b, c) {
		return {$: 'ListExpr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListIndentEnd = F2(
	function (a, b) {
		return {$: 'ListIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListIndentExpr = F2(
	function (a, b) {
		return {$: 'ListIndentExpr', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListIndentOpen = F2(
	function (a, b) {
		return {$: 'ListIndentOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListOpen = F2(
	function (a, b) {
		return {$: 'ListOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ListSpace = F3(
	function (a, b, c) {
		return {$: 'ListSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Primitives$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $author$project$Compiler$AST$Source$Negate = function (a) {
	return {$: 'Negate', a: a};
};
var $author$project$Compiler$AST$Source$Op = function (a) {
	return {$: 'Op', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$OperatorReserved = F3(
	function (a, b, c) {
		return {$: 'OperatorReserved', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$OperatorRight = F3(
	function (a, b, c) {
		return {$: 'OperatorRight', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Record = function (a) {
	return {$: 'Record', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$Record = F3(
	function (a, b, c) {
		return {$: 'Record', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordEnd = F2(
	function (a, b) {
		return {$: 'RecordEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordEquals = F2(
	function (a, b) {
		return {$: 'RecordEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordExpr = F3(
	function (a, b, c) {
		return {$: 'RecordExpr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordField = F2(
	function (a, b) {
		return {$: 'RecordField', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordIndentEnd = F2(
	function (a, b) {
		return {$: 'RecordIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordIndentEquals = F2(
	function (a, b) {
		return {$: 'RecordIndentEquals', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordIndentExpr = F2(
	function (a, b) {
		return {$: 'RecordIndentExpr', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordIndentField = F2(
	function (a, b) {
		return {$: 'RecordIndentField', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordIndentOpen = F2(
	function (a, b) {
		return {$: 'RecordIndentOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordOpen = F2(
	function (a, b) {
		return {$: 'RecordOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$RecordSpace = F3(
	function (a, b, c) {
		return {$: 'RecordSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Space = F3(
	function (a, b, c) {
		return {$: 'Space', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Start = F2(
	function (a, b) {
		return {$: 'Start', a: a, b: b};
	});
var $author$project$Compiler$Parse$Expression$State = F4(
	function (a, b, c, d) {
		return {$: 'State', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Source$Tuple = F3(
	function (a, b, c) {
		return {$: 'Tuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Tuple = F3(
	function (a, b, c) {
		return {$: 'Tuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleEnd = F2(
	function (a, b) {
		return {$: 'TupleEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleExpr = F3(
	function (a, b, c) {
		return {$: 'TupleExpr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleIndentEnd = F2(
	function (a, b) {
		return {$: 'TupleIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleIndentExpr1 = F2(
	function (a, b) {
		return {$: 'TupleIndentExpr1', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleIndentExprN = F2(
	function (a, b) {
		return {$: 'TupleIndentExprN', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleOperatorClose = F2(
	function (a, b) {
		return {$: 'TupleOperatorClose', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleOperatorReserved = F3(
	function (a, b, c) {
		return {$: 'TupleOperatorReserved', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$TupleSpace = F3(
	function (a, b, c) {
		return {$: 'TupleSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Unit = {$: 'Unit'};
var $author$project$Compiler$AST$Source$Update = F2(
	function (a, b) {
		return {$: 'Update', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Access = F2(
	function (a, b) {
		return {$: 'Access', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Access = F2(
	function (a, b) {
		return {$: 'Access', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Dot = F2(
	function (a, b) {
		return {$: 'Dot', a: a, b: b};
	});
var $author$project$Compiler$Parse$Expression$accessible = F2(
	function (start, expr) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 46, $author$project$Compiler$Reporting$Error$Syntax$Dot),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$getPosition,
							function (pos) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$Access),
									function (field) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Primitives$getPosition,
											function (end) {
												return A2(
													$author$project$Compiler$Parse$Expression$accessible,
													start,
													A3(
														$author$project$Compiler$Reporting$Annotation$at,
														start,
														end,
														A2(
															$author$project$Compiler$AST$Source$Access,
															expr,
															A3($author$project$Compiler$Reporting$Annotation$at, pos, end, field))));
											});
									});
							});
					})
				]),
			expr);
	});
var $author$project$Compiler$AST$Source$Accessor = function (a) {
	return {$: 'Accessor', a: a};
};
var $author$project$Compiler$Parse$Expression$accessor = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$Primitives$word1, 46, $author$project$Compiler$Reporting$Error$Syntax$Dot),
		function (_v0) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$Access),
				function (field) {
					return A2(
						$author$project$Compiler$Parse$Primitives$addEnd,
						start,
						$author$project$Compiler$AST$Source$Accessor(field));
				});
		});
};
var $author$project$Compiler$Parse$Keyword$case_ = function (tx) {
	return A5($author$project$Compiler$Parse$Keyword$k4, 99, 97, 115, 101, tx);
};
var $author$project$Compiler$Reporting$Error$Syntax$CChar = F3(
	function (a, b, c) {
		return {$: 'CChar', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Chr = function (a) {
	return {$: 'Chr', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$CharEndless = {$: 'CharEndless'};
var $author$project$Compiler$Reporting$Error$Syntax$CharEscape = function (a) {
	return {$: 'CharEscape', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$CharNotString = function (a) {
	return {$: 'CharNotString', a: a};
};
var $author$project$Compiler$Parse$String$CharEndless = function (a) {
	return {$: 'CharEndless', a: a};
};
var $author$project$Compiler$Parse$String$CharEscape = F3(
	function (a, b, c) {
		return {$: 'CharEscape', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$String$CodePoint = function (a) {
	return {$: 'CodePoint', a: a};
};
var $author$project$Compiler$Parse$String$Good = F4(
	function (a, b, c, d) {
		return {$: 'Good', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Elm$String$Slice = F2(
	function (a, b) {
		return {$: 'Slice', a: a, b: b};
	});
var $author$project$Compiler$Elm$String$Escape = function (a) {
	return {$: 'Escape', a: a};
};
var $author$project$Compiler$Parse$String$doubleQuote = $author$project$Compiler$Elm$String$Escape(34);
var $author$project$Compiler$Parse$String$EscapeEndOfFile = {$: 'EscapeEndOfFile'};
var $author$project$Compiler$Parse$String$EscapeNormal = {$: 'EscapeNormal'};
var $author$project$Compiler$Parse$String$EscapeProblem = F3(
	function (a, b, c) {
		return {$: 'EscapeProblem', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$EscapeUnknown = {$: 'EscapeUnknown'};
var $author$project$Compiler$Reporting$Error$Syntax$BadUnicodeCode = function (a) {
	return {$: 'BadUnicodeCode', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$BadUnicodeFormat = function (a) {
	return {$: 'BadUnicodeFormat', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$BadUnicodeLength = F3(
	function (a, b, c) {
		return {$: 'BadUnicodeLength', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$String$EscapeUnicode = F2(
	function (a, b) {
		return {$: 'EscapeUnicode', a: a, b: b};
	});
var $author$project$Compiler$Parse$Number$isDirtyEnd = function (word) {
	return $author$project$Compiler$Parse$Variable$getInnerWidthHelp(word) > 0;
};
var $author$project$Compiler$Parse$Number$stepHex = F2(
	function (word, acc) {
		return ((48 <= word) && (word <= 57)) ? ((16 * acc) + (word - 48)) : (((97 <= word) && (word <= 102)) ? (((16 * acc) + 10) + (word - 97)) : (((65 <= word) && (word <= 70)) ? (((16 * acc) + 10) + (word - 65)) : ($author$project$Compiler$Parse$Number$isDirtyEnd(word) ? (-2) : (-1))));
	});
var $author$project$Compiler$Parse$Number$chompHexHelp = F5(
	function (src, pos, end, answer, accumulator) {
		chompHexHelp:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(pos, answer);
			} else {
				var newAnswer = A2(
					$author$project$Compiler$Parse$Number$stepHex,
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					accumulator);
				if (newAnswer < 0) {
					return _Utils_Tuple2(
						pos,
						_Utils_eq(newAnswer, -1) ? answer : (-2));
				} else {
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end,
						$temp$answer = newAnswer,
						$temp$accumulator = newAnswer;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					answer = $temp$answer;
					accumulator = $temp$accumulator;
					continue chompHexHelp;
				}
			}
		}
	});
var $author$project$Compiler$Parse$Number$chompHex = F3(
	function (src, pos, end) {
		return A5($author$project$Compiler$Parse$Number$chompHexHelp, src, pos, end, -1, 0);
	});
var $author$project$Compiler$Parse$String$eatUnicode = F5(
	function (src, pos, end, row, col) {
		if ((_Utils_cmp(pos, end) > -1) || (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) !== 123)) {
			return A3(
				$author$project$Compiler$Parse$String$EscapeProblem,
				row,
				col,
				$author$project$Compiler$Reporting$Error$Syntax$BadUnicodeFormat(2));
		} else {
			var digitPos = pos + 1;
			var _v0 = A3($author$project$Compiler$Parse$Number$chompHex, src, digitPos, end);
			var newPos = _v0.a;
			var code = _v0.b;
			var numDigits = newPos - digitPos;
			return ((_Utils_cmp(newPos, end) > -1) || (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, newPos) !== 125)) ? A3(
				$author$project$Compiler$Parse$String$EscapeProblem,
				row,
				col,
				$author$project$Compiler$Reporting$Error$Syntax$BadUnicodeFormat((2 + newPos) - pos)) : (((code < 0) || (1114111 < code)) ? A3(
				$author$project$Compiler$Parse$String$EscapeProblem,
				row,
				col,
				$author$project$Compiler$Reporting$Error$Syntax$BadUnicodeCode((3 + newPos) - pos)) : (((numDigits < 4) || (6 < numDigits)) ? A3(
				$author$project$Compiler$Parse$String$EscapeProblem,
				row,
				col,
				A3($author$project$Compiler$Reporting$Error$Syntax$BadUnicodeLength, (3 + newPos) - pos, numDigits, code)) : A2($author$project$Compiler$Parse$String$EscapeUnicode, numDigits + 4, code)));
		}
	});
var $author$project$Compiler$Parse$String$eatEscape = F5(
	function (src, pos, end, row, col) {
		if (_Utils_cmp(pos, end) > -1) {
			return $author$project$Compiler$Parse$String$EscapeEndOfFile;
		} else {
			var _v0 = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
			switch (_v0) {
				case 110:
					return $author$project$Compiler$Parse$String$EscapeNormal;
				case 114:
					return $author$project$Compiler$Parse$String$EscapeNormal;
				case 116:
					return $author$project$Compiler$Parse$String$EscapeNormal;
				case 34:
					return $author$project$Compiler$Parse$String$EscapeNormal;
				case 39:
					return $author$project$Compiler$Parse$String$EscapeNormal;
				case 92:
					return $author$project$Compiler$Parse$String$EscapeNormal;
				case 117:
					return A5($author$project$Compiler$Parse$String$eatUnicode, src, pos + 1, end, row, col);
				default:
					return A3($author$project$Compiler$Parse$String$EscapeProblem, row, col, $author$project$Compiler$Reporting$Error$Syntax$EscapeUnknown);
			}
		}
	});
var $author$project$Compiler$Parse$String$chompChar = F7(
	function (src, pos, end, row, col, numChars, mostRecent) {
		chompChar:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return $author$project$Compiler$Parse$String$CharEndless(col);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if (word === 39) {
					return A4($author$project$Compiler$Parse$String$Good, pos + 1, col + 1, numChars, mostRecent);
				} else {
					if (word === 10) {
						return $author$project$Compiler$Parse$String$CharEndless(col);
					} else {
						if (word === 34) {
							var $temp$src = src,
								$temp$pos = pos + 1,
								$temp$end = end,
								$temp$row = row,
								$temp$col = col + 1,
								$temp$numChars = numChars + 1,
								$temp$mostRecent = $author$project$Compiler$Parse$String$doubleQuote;
							src = $temp$src;
							pos = $temp$pos;
							end = $temp$end;
							row = $temp$row;
							col = $temp$col;
							numChars = $temp$numChars;
							mostRecent = $temp$mostRecent;
							continue chompChar;
						} else {
							if (word === 92) {
								var _v0 = A5($author$project$Compiler$Parse$String$eatEscape, src, pos + 1, end, row, col);
								switch (_v0.$) {
									case 'EscapeNormal':
										var $temp$src = src,
											$temp$pos = pos + 2,
											$temp$end = end,
											$temp$row = row,
											$temp$col = col + 2,
											$temp$numChars = numChars + 1,
											$temp$mostRecent = A2($author$project$Compiler$Elm$String$Slice, pos, 2);
										src = $temp$src;
										pos = $temp$pos;
										end = $temp$end;
										row = $temp$row;
										col = $temp$col;
										numChars = $temp$numChars;
										mostRecent = $temp$mostRecent;
										continue chompChar;
									case 'EscapeUnicode':
										var delta = _v0.a;
										var code = _v0.b;
										var $temp$src = src,
											$temp$pos = pos + delta,
											$temp$end = end,
											$temp$row = row,
											$temp$col = col + delta,
											$temp$numChars = numChars + 1,
											$temp$mostRecent = $author$project$Compiler$Elm$String$CodePoint(code);
										src = $temp$src;
										pos = $temp$pos;
										end = $temp$end;
										row = $temp$row;
										col = $temp$col;
										numChars = $temp$numChars;
										mostRecent = $temp$mostRecent;
										continue chompChar;
									case 'EscapeProblem':
										var r = _v0.a;
										var c = _v0.b;
										var badEscape = _v0.c;
										return A3($author$project$Compiler$Parse$String$CharEscape, r, c, badEscape);
									default:
										return $author$project$Compiler$Parse$String$CharEndless(col);
								}
							} else {
								var width = $author$project$Compiler$Parse$Primitives$getCharWidth(word);
								var newPos = pos + width;
								var $temp$src = src,
									$temp$pos = newPos,
									$temp$end = end,
									$temp$row = row,
									$temp$col = col + 1,
									$temp$numChars = numChars + 1,
									$temp$mostRecent = A2($author$project$Compiler$Elm$String$Slice, pos, width);
								src = $temp$src;
								pos = $temp$pos;
								end = $temp$end;
								row = $temp$row;
								col = $temp$col;
								numChars = $temp$numChars;
								mostRecent = $temp$mostRecent;
								continue chompChar;
							}
						}
					}
				}
			}
		}
	});
var $elm$core$String$append = _String_append;
var $elm$core$String$cons = _String_cons;
var $elm$core$String$fromChar = function (_char) {
	return A2($elm$core$String$cons, _char, '');
};
var $elm$core$Bitwise$and = _Bitwise_and;
var $elm$core$Bitwise$shiftRightBy = _Bitwise_shiftRightBy;
var $elm$core$String$repeatHelp = F3(
	function (n, chunk, result) {
		return (n <= 0) ? result : A3(
			$elm$core$String$repeatHelp,
			n >> 1,
			_Utils_ap(chunk, chunk),
			(!(n & 1)) ? result : _Utils_ap(result, chunk));
	});
var $elm$core$String$repeat = F2(
	function (n, chunk) {
		return A3($elm$core$String$repeatHelp, n, chunk, '');
	});
var $elm$core$String$padLeft = F3(
	function (n, _char, string) {
		return _Utils_ap(
			A2(
				$elm$core$String$repeat,
				n - $elm$core$String$length(string),
				$elm$core$String$fromChar(_char)),
			string);
	});
var $elm$core$String$fromList = _String_fromList;
var $rtfeldman$elm_hex$Hex$unsafeToDigit = function (num) {
	unsafeToDigit:
	while (true) {
		switch (num) {
			case 0:
				return _Utils_chr('0');
			case 1:
				return _Utils_chr('1');
			case 2:
				return _Utils_chr('2');
			case 3:
				return _Utils_chr('3');
			case 4:
				return _Utils_chr('4');
			case 5:
				return _Utils_chr('5');
			case 6:
				return _Utils_chr('6');
			case 7:
				return _Utils_chr('7');
			case 8:
				return _Utils_chr('8');
			case 9:
				return _Utils_chr('9');
			case 10:
				return _Utils_chr('a');
			case 11:
				return _Utils_chr('b');
			case 12:
				return _Utils_chr('c');
			case 13:
				return _Utils_chr('d');
			case 14:
				return _Utils_chr('e');
			case 15:
				return _Utils_chr('f');
			default:
				var $temp$num = num;
				num = $temp$num;
				continue unsafeToDigit;
		}
	}
};
var $rtfeldman$elm_hex$Hex$unsafePositiveToDigits = F2(
	function (digits, num) {
		unsafePositiveToDigits:
		while (true) {
			if (num < 16) {
				return A2(
					$elm$core$List$cons,
					$rtfeldman$elm_hex$Hex$unsafeToDigit(num),
					digits);
			} else {
				var $temp$digits = A2(
					$elm$core$List$cons,
					$rtfeldman$elm_hex$Hex$unsafeToDigit(
						A2($elm$core$Basics$modBy, 16, num)),
					digits),
					$temp$num = (num / 16) | 0;
				digits = $temp$digits;
				num = $temp$num;
				continue unsafePositiveToDigits;
			}
		}
	});
var $rtfeldman$elm_hex$Hex$toString = function (num) {
	return $elm$core$String$fromList(
		(num < 0) ? A2(
			$elm$core$List$cons,
			_Utils_chr('-'),
			A2($rtfeldman$elm_hex$Hex$unsafePositiveToDigits, _List_Nil, -num)) : A2($rtfeldman$elm_hex$Hex$unsafePositiveToDigits, _List_Nil, num));
};
var $elm$core$String$toUpper = _String_toUpper;
var $author$project$Compiler$Elm$String$codeToString = function (code) {
	return A2(
		$elm$core$String$append,
		'\\u',
		A3(
			$elm$core$String$padLeft,
			4,
			_Utils_chr('0'),
			$elm$core$String$toUpper(
				$rtfeldman$elm_hex$Hex$toString(code))));
};
var $author$project$Compiler$Elm$String$chunkToString = F2(
	function (src, chunk) {
		switch (chunk.$) {
			case 'Slice':
				var start = chunk.a;
				var len = chunk.b;
				return A3($elm$core$String$slice, start, start + len, src);
			case 'Escape':
				var code = chunk.a;
				return A2(
					$elm$core$String$cons,
					_Utils_chr('\\'),
					$elm$core$String$fromChar(
						$elm$core$Char$fromCode(code)));
			default:
				var code = chunk.a;
				if (code < 65535) {
					return $author$project$Compiler$Elm$String$codeToString(code);
				} else {
					var rest = code - 65536;
					var lo = A2($elm$core$Basics$modBy, 1024, rest);
					var hi = (rest / 1024) | 0;
					return _Utils_ap(
						$author$project$Compiler$Elm$String$codeToString(hi + 55296),
						$author$project$Compiler$Elm$String$codeToString(lo + 56320));
				}
		}
	});
var $elm$core$String$concat = function (strings) {
	return A2($elm$core$String$join, '', strings);
};
var $author$project$Compiler$Elm$String$fromChunks = F2(
	function (src, chunks) {
		return $elm$core$String$concat(
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Elm$String$chunkToString(src),
				chunks));
	});
var $author$project$Compiler$Parse$String$placeholder = $author$project$Compiler$Elm$String$CodePoint(65533);
var $author$project$Compiler$Parse$String$character = F2(
	function (toExpectation, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				if ((_Utils_cmp(pos, end) > -1) || (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) !== 39)) {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
				} else {
					var _v1 = A7($author$project$Compiler$Parse$String$chompChar, src, pos + 1, end, row, col + 1, 0, $author$project$Compiler$Parse$String$placeholder);
					switch (_v1.$) {
						case 'Good':
							var newPos = _v1.a;
							var newCol = _v1.b;
							var numChars = _v1.c;
							var mostRecent = _v1.d;
							if (numChars !== 1) {
								return A3(
									$author$project$Compiler$Parse$Primitives$Cerr,
									row,
									col,
									toError(
										$author$project$Compiler$Reporting$Error$Syntax$CharNotString(newCol - col)));
							} else {
								var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
								var _char = A2(
									$author$project$Compiler$Elm$String$fromChunks,
									src,
									_List_fromArray(
										[mostRecent]));
								return A2($author$project$Compiler$Parse$Primitives$Cok, _char, newState);
							}
						case 'CharEndless':
							var newCol = _v1.a;
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								row,
								newCol,
								toError($author$project$Compiler$Reporting$Error$Syntax$CharEndless));
						default:
							var r = _v1.a;
							var c = _v1.b;
							var escape = _v1.c;
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								r,
								c,
								toError(
									$author$project$Compiler$Reporting$Error$Syntax$CharEscape(escape)));
					}
				}
			});
	});
var $author$project$Compiler$Parse$Expression$character = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$String$character, $author$project$Compiler$Reporting$Error$Syntax$Start, $author$project$Compiler$Reporting$Error$Syntax$CChar),
		function (chr) {
			return A2(
				$author$project$Compiler$Parse$Primitives$addEnd,
				start,
				$author$project$Compiler$AST$Source$Chr(chr));
		});
};
var $author$project$Compiler$Parse$Space$checkAligned = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (state) {
			var indent = state.d;
			var row = state.e;
			var col = state.f;
			return _Utils_eq(col, indent) ? A2($author$project$Compiler$Parse$Primitives$Eok, _Utils_Tuple0, state) : A3(
				$author$project$Compiler$Parse$Primitives$Eerr,
				row,
				col,
				toError(indent));
		});
};
var $author$project$Compiler$Reporting$Error$Syntax$FuncArrow = F2(
	function (a, b) {
		return {$: 'FuncArrow', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$PAlias = F2(
	function (a, b) {
		return {$: 'PAlias', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PAlias = F2(
	function (a, b) {
		return {$: 'PAlias', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$PCtor = F3(
	function (a, b, c) {
		return {$: 'PCtor', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$PCtorQual = F4(
	function (a, b, c, d) {
		return {$: 'PCtorQual', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PIndentAlias = F2(
	function (a, b) {
		return {$: 'PIndentAlias', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PIndentStart = F2(
	function (a, b) {
		return {$: 'PIndentStart', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$PList = function (a) {
	return {$: 'PList', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$PList = F3(
	function (a, b, c) {
		return {$: 'PList', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListEnd = F2(
	function (a, b) {
		return {$: 'PListEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListExpr = F3(
	function (a, b, c) {
		return {$: 'PListExpr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListIndentEnd = F2(
	function (a, b) {
		return {$: 'PListIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListIndentExpr = F2(
	function (a, b) {
		return {$: 'PListIndentExpr', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListIndentOpen = F2(
	function (a, b) {
		return {$: 'PListIndentOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListOpen = F2(
	function (a, b) {
		return {$: 'PListOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PListSpace = F3(
	function (a, b, c) {
		return {$: 'PListSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PSpace = F3(
	function (a, b, c) {
		return {$: 'PSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PStart = F2(
	function (a, b) {
		return {$: 'PStart', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$PTuple = F3(
	function (a, b, c) {
		return {$: 'PTuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTuple = F3(
	function (a, b, c) {
		return {$: 'PTuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleEnd = F2(
	function (a, b) {
		return {$: 'PTupleEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleExpr = F3(
	function (a, b, c) {
		return {$: 'PTupleExpr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentEnd = F2(
	function (a, b) {
		return {$: 'PTupleIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentExpr1 = F2(
	function (a, b) {
		return {$: 'PTupleIndentExpr1', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentExprN = F2(
	function (a, b) {
		return {$: 'PTupleIndentExprN', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleOpen = F2(
	function (a, b) {
		return {$: 'PTupleOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PTupleSpace = F3(
	function (a, b, c) {
		return {$: 'PTupleSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$PUnit = {$: 'PUnit'};
var $author$project$Compiler$Parse$Keyword$k2 = F3(
	function (w1, w2, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos2 = pos + 2;
				if ((_Utils_cmp(pos2, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos2, end))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos2, end, indent, row, col + 2);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$as_ = function (tx) {
	return A3($author$project$Compiler$Parse$Keyword$k2, 97, 115, tx);
};
var $author$project$Compiler$AST$Source$PCons = F2(
	function (a, b) {
		return {$: 'PCons', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Annotation$mergeRegions = F2(
	function (_v0, _v1) {
		var start = _v0.a;
		var end = _v1.b;
		return A2($author$project$Compiler$Reporting$Annotation$Region, start, end);
	});
var $author$project$Compiler$Reporting$Annotation$merge = F3(
	function (_v0, _v1, value) {
		var r1 = _v0.a;
		var r2 = _v1.a;
		return A2(
			$author$project$Compiler$Reporting$Annotation$At,
			A2($author$project$Compiler$Reporting$Annotation$mergeRegions, r1, r2),
			value);
	});
var $author$project$Compiler$Parse$Pattern$cons = F2(
	function (tl, hd) {
		return A3(
			$author$project$Compiler$Reporting$Annotation$merge,
			hd,
			tl,
			A2($author$project$Compiler$AST$Source$PCons, hd, tl));
	});
var $author$project$Compiler$AST$Source$PRecord = function (a) {
	return {$: 'PRecord', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$PRecord = F3(
	function (a, b, c) {
		return {$: 'PRecord', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordEnd = F2(
	function (a, b) {
		return {$: 'PRecordEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordField = F2(
	function (a, b) {
		return {$: 'PRecordField', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentEnd = F2(
	function (a, b) {
		return {$: 'PRecordIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentOpen = F2(
	function (a, b) {
		return {$: 'PRecordIndentOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordOpen = F2(
	function (a, b) {
		return {$: 'PRecordOpen', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordSpace = F3(
	function (a, b, c) {
		return {$: 'PRecordSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentField = F2(
	function (a, b) {
		return {$: 'PRecordIndentField', a: a, b: b};
	});
var $author$project$Compiler$Parse$Pattern$recordHelp = F2(
	function (start, vars) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$PRecordEnd,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$PRecordEnd),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentField),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Primitives$addLocation(
										$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$PRecordField)),
									function (_var) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentEnd),
											function (_v2) {
												return A2(
													$author$project$Compiler$Parse$Pattern$recordHelp,
													start,
													A2($elm$core$List$cons, _var, vars));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$PRecordEnd),
					function (_v3) {
						return A2(
							$author$project$Compiler$Parse$Primitives$addEnd,
							start,
							$author$project$Compiler$AST$Source$PRecord(
								$author$project$Extra$Type$List$reverse(vars)));
					})
				]));
	});
var $author$project$Compiler$Parse$Pattern$record = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$PRecord,
		A2($author$project$Compiler$Parse$Primitives$word1, 123, $author$project$Compiler$Reporting$Error$Syntax$PStart),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentOpen),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$PRecordOpen,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$addLocation(
								$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$PRecordField)),
							function (_var) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PRecordSpace, $author$project$Compiler$Reporting$Error$Syntax$PRecordIndentEnd),
									function (_v1) {
										return A2(
											$author$project$Compiler$Parse$Pattern$recordHelp,
											start,
											_List_fromArray(
												[_var]));
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$PRecordEnd),
							function (_v2) {
								return A2(
									$author$project$Compiler$Parse$Primitives$addEnd,
									start,
									$author$project$Compiler$AST$Source$PRecord(_List_Nil));
							})
						]));
			}));
};
var $author$project$Compiler$AST$Source$PAnything = {$: 'PAnything'};
var $author$project$Compiler$Reporting$Error$Syntax$PChar = F3(
	function (a, b, c) {
		return {$: 'PChar', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$PChr = function (a) {
	return {$: 'PChr', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$PFloat = F3(
	function (a, b, c) {
		return {$: 'PFloat', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$PInt = function (a) {
	return {$: 'PInt', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$PNumber = F3(
	function (a, b, c) {
		return {$: 'PNumber', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$PStr = function (a) {
	return {$: 'PStr', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$PString = F3(
	function (a, b, c) {
		return {$: 'PString', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$PVar = function (a) {
	return {$: 'PVar', a: a};
};
var $author$project$Compiler$Parse$Number$CFloat = function (a) {
	return {$: 'CFloat', a: a};
};
var $author$project$Compiler$Parse$Number$CInt = function (a) {
	return {$: 'CInt', a: a};
};
var $author$project$Compiler$Parse$Number$Err = F2(
	function (a, b) {
		return {$: 'Err', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$NumberEnd = {$: 'NumberEnd'};
var $author$project$Compiler$Parse$Number$OkInt = F2(
	function (a, b) {
		return {$: 'OkInt', a: a, b: b};
	});
var $author$project$Compiler$Parse$Number$OkFloat = function (a) {
	return {$: 'OkFloat', a: a};
};
var $author$project$Compiler$Parse$Number$isDecimalDigit = function (word) {
	return (word <= 57) && (word >= 48);
};
var $author$project$Compiler$Parse$Number$chompExponentHelp = F3(
	function (src, pos, end) {
		chompExponentHelp:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return $author$project$Compiler$Parse$Number$OkFloat(pos);
			} else {
				if ($author$project$Compiler$Parse$Number$isDecimalDigit(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos))) {
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					continue chompExponentHelp;
				} else {
					return $author$project$Compiler$Parse$Number$OkFloat(pos);
				}
			}
		}
	});
var $author$project$Compiler$Parse$Number$chompExponent = F3(
	function (src, pos, end) {
		if (_Utils_cmp(pos, end) > -1) {
			return A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberEnd);
		} else {
			var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
			if ($author$project$Compiler$Parse$Number$isDecimalDigit(word)) {
				return A3($author$project$Compiler$Parse$Number$chompExponentHelp, src, pos + 1, end);
			} else {
				if ((word === 43) || (word === 45)) {
					var pos1 = pos + 1;
					return ((_Utils_cmp(pos1, end) < 0) && $author$project$Compiler$Parse$Number$isDecimalDigit(
						A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1))) ? A3($author$project$Compiler$Parse$Number$chompExponentHelp, src, pos + 2, end) : A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberEnd);
				} else {
					return A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberEnd);
				}
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$NumberDot = function (a) {
	return {$: 'NumberDot', a: a};
};
var $author$project$Compiler$Parse$Number$chompFractionHelp = F3(
	function (src, pos, end) {
		chompFractionHelp:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return $author$project$Compiler$Parse$Number$OkFloat(pos);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if ($author$project$Compiler$Parse$Number$isDecimalDigit(word)) {
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					continue chompFractionHelp;
				} else {
					if ((word === 101) || (word === 69)) {
						return A3($author$project$Compiler$Parse$Number$chompExponent, src, pos + 1, end);
					} else {
						if ($author$project$Compiler$Parse$Number$isDirtyEnd(word)) {
							return A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberEnd);
						} else {
							return $author$project$Compiler$Parse$Number$OkFloat(pos);
						}
					}
				}
			}
		}
	});
var $author$project$Compiler$Parse$Number$chompFraction = F4(
	function (src, pos, end, n) {
		var pos1 = pos + 1;
		return (_Utils_cmp(pos1, end) > -1) ? A2(
			$author$project$Compiler$Parse$Number$Err,
			pos,
			$author$project$Compiler$Reporting$Error$Syntax$NumberDot(n)) : ($author$project$Compiler$Parse$Number$isDecimalDigit(
			A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1)) ? A3($author$project$Compiler$Parse$Number$chompFractionHelp, src, pos1 + 1, end) : A2(
			$author$project$Compiler$Parse$Number$Err,
			pos,
			$author$project$Compiler$Reporting$Error$Syntax$NumberDot(n)));
	});
var $author$project$Compiler$Parse$Number$chompInt = F4(
	function (src, pos, end, n) {
		chompInt:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return A2($author$project$Compiler$Parse$Number$OkInt, pos, n);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if ($author$project$Compiler$Parse$Number$isDecimalDigit(word)) {
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end,
						$temp$n = ((10 * n) + word) - 48;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					n = $temp$n;
					continue chompInt;
				} else {
					if (word === 46) {
						return A4($author$project$Compiler$Parse$Number$chompFraction, src, pos, end, n);
					} else {
						if ((word === 101) || (word === 69)) {
							return A3($author$project$Compiler$Parse$Number$chompExponent, src, pos + 1, end);
						} else {
							if ($author$project$Compiler$Parse$Number$isDirtyEnd(word)) {
								return A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberEnd);
							} else {
								return A2($author$project$Compiler$Parse$Number$OkInt, pos, n);
							}
						}
					}
				}
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$NumberNoLeadingZero = {$: 'NumberNoLeadingZero'};
var $author$project$Compiler$Reporting$Error$Syntax$NumberHexDigit = {$: 'NumberHexDigit'};
var $author$project$Compiler$Parse$Number$chompHexInt = F3(
	function (src, pos, end) {
		var _v0 = A3($author$project$Compiler$Parse$Number$chompHex, src, pos, end);
		var newPos = _v0.a;
		var answer = _v0.b;
		return (answer < 0) ? A2($author$project$Compiler$Parse$Number$Err, newPos, $author$project$Compiler$Reporting$Error$Syntax$NumberHexDigit) : A2($author$project$Compiler$Parse$Number$OkInt, newPos, answer);
	});
var $author$project$Compiler$Parse$Number$chompZero = F3(
	function (src, pos, end) {
		if (_Utils_cmp(pos, end) > -1) {
			return A2($author$project$Compiler$Parse$Number$OkInt, pos, 0);
		} else {
			var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
			return (word === 120) ? A3($author$project$Compiler$Parse$Number$chompHexInt, src, pos + 1, end) : ((word === 46) ? A4($author$project$Compiler$Parse$Number$chompFraction, src, pos, end, 0) : ($author$project$Compiler$Parse$Number$isDecimalDigit(word) ? A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberNoLeadingZero) : ($author$project$Compiler$Parse$Number$isDirtyEnd(word) ? A2($author$project$Compiler$Parse$Number$Err, pos, $author$project$Compiler$Reporting$Error$Syntax$NumberEnd) : A2($author$project$Compiler$Parse$Number$OkInt, pos, 0))));
		}
	});
var $author$project$Compiler$Elm$Float$fromPtr = $author$project$Compiler$Data$Utf8$fromPtr;
var $elm$core$Basics$not = _Basics_not;
var $author$project$Compiler$Parse$Number$number = F2(
	function (toExpectation, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				if (_Utils_cmp(pos, end) > -1) {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
				} else {
					var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
					if (!$author$project$Compiler$Parse$Number$isDecimalDigit(word)) {
						return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
					} else {
						var outcome = (word === 48) ? A3($author$project$Compiler$Parse$Number$chompZero, src, pos + 1, end) : A4($author$project$Compiler$Parse$Number$chompInt, src, pos + 1, end, word - 48);
						switch (outcome.$) {
							case 'Err':
								var newPos = outcome.a;
								var problem = outcome.b;
								var newCol = (col + newPos) - pos;
								return A3(
									$author$project$Compiler$Parse$Primitives$Cerr,
									row,
									newCol,
									toError(problem));
							case 'OkInt':
								var newPos = outcome.a;
								var n = outcome.b;
								var newCol = (col + newPos) - pos;
								var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
								var integer = $author$project$Compiler$Parse$Number$CInt(n);
								return A2($author$project$Compiler$Parse$Primitives$Cok, integer, newState);
							default:
								var newPos = outcome.a;
								var newCol = (col + newPos) - pos;
								var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
								var copy = A3($author$project$Compiler$Elm$Float$fromPtr, src, pos, newPos);
								var _float = $author$project$Compiler$Parse$Number$CFloat(copy);
								return A2($author$project$Compiler$Parse$Primitives$Cok, _float, newState);
						}
					}
				}
			});
	});
var $author$project$Compiler$Data$Utf8$size = $elm$core$String$length;
var $author$project$Compiler$Parse$String$COk = F4(
	function (a, b, c, d) {
		return {$: 'COk', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Data$Utf8$empty = '';
var $author$project$Compiler$Parse$String$isDoubleQuote = F3(
	function (src, pos, end) {
		return (_Utils_cmp(pos, end) < 0) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) === 34);
	});
var $author$project$Compiler$Parse$String$CErr = F3(
	function (a, b, c) {
		return {$: 'CErr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Multi = {$: 'StringEndless_Multi'};
var $author$project$Compiler$Reporting$Error$Syntax$StringEscape = function (a) {
	return {$: 'StringEscape', a: a};
};
var $author$project$Compiler$Parse$String$addEscape = F4(
	function (chunk, start, end, revChunks) {
		return _Utils_eq(start, end) ? A2($elm$core$List$cons, chunk, revChunks) : A2(
			$elm$core$List$cons,
			chunk,
			A2(
				$elm$core$List$cons,
				A2($author$project$Compiler$Elm$String$Slice, start, end - start),
				revChunks));
	});
var $author$project$Compiler$Parse$String$carriageReturn = $author$project$Compiler$Elm$String$Escape(114);
var $author$project$Compiler$Parse$String$finalize = F4(
	function (src, start, end, revChunks) {
		return A2(
			$author$project$Compiler$Elm$String$fromChunks,
			src,
			$author$project$Extra$Type$List$reverse(
				_Utils_eq(start, end) ? revChunks : A2(
					$elm$core$List$cons,
					A2($author$project$Compiler$Elm$String$Slice, start, end - start),
					revChunks)));
	});
var $author$project$Compiler$Parse$String$newline = $author$project$Compiler$Elm$String$Escape(110);
var $author$project$Compiler$Parse$String$singleQuote = $author$project$Compiler$Elm$String$Escape(39);
var $author$project$Compiler$Parse$String$multiString = F9(
	function (src, pos, end, row, col, initialPos, sr, sc, revChunks) {
		multiString:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return A3($author$project$Compiler$Parse$String$CErr, sr, sc, $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Multi);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if ((word === 34) && (A3($author$project$Compiler$Parse$String$isDoubleQuote, src, pos + 1, end) && A3($author$project$Compiler$Parse$String$isDoubleQuote, src, pos + 2, end))) {
					return A4(
						$author$project$Compiler$Parse$String$COk,
						pos + 3,
						row,
						col + 3,
						A4($author$project$Compiler$Parse$String$finalize, src, initialPos, pos, revChunks));
				} else {
					if (word === 39) {
						var pos1 = pos + 1;
						return A9(
							$author$project$Compiler$Parse$String$multiString,
							src,
							pos1,
							end,
							row,
							col + 1,
							pos1,
							sr,
							sc,
							A4($author$project$Compiler$Parse$String$addEscape, $author$project$Compiler$Parse$String$singleQuote, initialPos, pos, revChunks));
					} else {
						if (word === 10) {
							var pos1 = pos + 1;
							return A9(
								$author$project$Compiler$Parse$String$multiString,
								src,
								pos1,
								end,
								row + 1,
								1,
								pos1,
								sr,
								sc,
								A4($author$project$Compiler$Parse$String$addEscape, $author$project$Compiler$Parse$String$newline, initialPos, pos, revChunks));
						} else {
							if (word === 13) {
								var pos1 = pos + 1;
								return A9(
									$author$project$Compiler$Parse$String$multiString,
									src,
									pos1,
									end,
									row,
									col,
									pos1,
									sr,
									sc,
									A4($author$project$Compiler$Parse$String$addEscape, $author$project$Compiler$Parse$String$carriageReturn, initialPos, pos, revChunks));
							} else {
								if (word === 92) {
									var _v0 = A5($author$project$Compiler$Parse$String$eatEscape, src, pos + 1, end, row, col);
									switch (_v0.$) {
										case 'EscapeNormal':
											var $temp$src = src,
												$temp$pos = pos + 2,
												$temp$end = end,
												$temp$row = row,
												$temp$col = col + 2,
												$temp$initialPos = initialPos,
												$temp$sr = sr,
												$temp$sc = sc,
												$temp$revChunks = revChunks;
											src = $temp$src;
											pos = $temp$pos;
											end = $temp$end;
											row = $temp$row;
											col = $temp$col;
											initialPos = $temp$initialPos;
											sr = $temp$sr;
											sc = $temp$sc;
											revChunks = $temp$revChunks;
											continue multiString;
										case 'EscapeUnicode':
											var delta = _v0.a;
											var code = _v0.b;
											var newPos = pos + delta;
											return A9(
												$author$project$Compiler$Parse$String$multiString,
												src,
												newPos,
												end,
												row,
												col + delta,
												newPos,
												sr,
												sc,
												A4(
													$author$project$Compiler$Parse$String$addEscape,
													$author$project$Compiler$Elm$String$CodePoint(code),
													initialPos,
													pos,
													revChunks));
										case 'EscapeProblem':
											var r = _v0.a;
											var c = _v0.b;
											var x = _v0.c;
											return A3(
												$author$project$Compiler$Parse$String$CErr,
												r,
												c,
												$author$project$Compiler$Reporting$Error$Syntax$StringEscape(x));
										default:
											return A3($author$project$Compiler$Parse$String$CErr, sr, sc, $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Multi);
									}
								} else {
									var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
									var $temp$src = src,
										$temp$pos = newPos,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 1,
										$temp$initialPos = initialPos,
										$temp$sr = sr,
										$temp$sc = sc,
										$temp$revChunks = revChunks;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									initialPos = $temp$initialPos;
									sr = $temp$sr;
									sc = $temp$sc;
									revChunks = $temp$revChunks;
									continue multiString;
								}
							}
						}
					}
				}
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Single = {$: 'StringEndless_Single'};
var $author$project$Compiler$Parse$String$singleString = F7(
	function (src, pos, end, row, col, initialPos, revChunks) {
		singleString:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return A3($author$project$Compiler$Parse$String$CErr, row, col, $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Single);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if (word === 34) {
					return A4(
						$author$project$Compiler$Parse$String$COk,
						pos + 1,
						row,
						col + 1,
						A4($author$project$Compiler$Parse$String$finalize, src, initialPos, pos, revChunks));
				} else {
					if (word === 10) {
						return A3($author$project$Compiler$Parse$String$CErr, row, col, $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Single);
					} else {
						if (word === 39) {
							var newPos = pos + 1;
							return A7(
								$author$project$Compiler$Parse$String$singleString,
								src,
								newPos,
								end,
								row,
								col + 1,
								newPos,
								A4($author$project$Compiler$Parse$String$addEscape, $author$project$Compiler$Parse$String$singleQuote, initialPos, pos, revChunks));
						} else {
							if (word === 92) {
								var _v0 = A5($author$project$Compiler$Parse$String$eatEscape, src, pos + 1, end, row, col);
								switch (_v0.$) {
									case 'EscapeNormal':
										var $temp$src = src,
											$temp$pos = pos + 2,
											$temp$end = end,
											$temp$row = row,
											$temp$col = col + 2,
											$temp$initialPos = initialPos,
											$temp$revChunks = revChunks;
										src = $temp$src;
										pos = $temp$pos;
										end = $temp$end;
										row = $temp$row;
										col = $temp$col;
										initialPos = $temp$initialPos;
										revChunks = $temp$revChunks;
										continue singleString;
									case 'EscapeUnicode':
										var delta = _v0.a;
										var code = _v0.b;
										var newPos = pos + delta;
										return A7(
											$author$project$Compiler$Parse$String$singleString,
											src,
											newPos,
											end,
											row,
											col + delta,
											newPos,
											A4(
												$author$project$Compiler$Parse$String$addEscape,
												$author$project$Compiler$Elm$String$CodePoint(code),
												initialPos,
												pos,
												revChunks));
									case 'EscapeProblem':
										var r = _v0.a;
										var c = _v0.b;
										var x = _v0.c;
										return A3(
											$author$project$Compiler$Parse$String$CErr,
											r,
											c,
											$author$project$Compiler$Reporting$Error$Syntax$StringEscape(x));
									default:
										return A3($author$project$Compiler$Parse$String$CErr, row, col + 1, $author$project$Compiler$Reporting$Error$Syntax$StringEndless_Single);
								}
							} else {
								var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
								var $temp$src = src,
									$temp$pos = newPos,
									$temp$end = end,
									$temp$row = row,
									$temp$col = col + 1,
									$temp$initialPos = initialPos,
									$temp$revChunks = revChunks;
								src = $temp$src;
								pos = $temp$pos;
								end = $temp$end;
								row = $temp$row;
								col = $temp$col;
								initialPos = $temp$initialPos;
								revChunks = $temp$revChunks;
								continue singleString;
							}
						}
					}
				}
			}
		}
	});
var $author$project$Compiler$Parse$String$string = F2(
	function (toExpectation, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				if (A3($author$project$Compiler$Parse$String$isDoubleQuote, src, pos, end)) {
					var pos1 = pos + 1;
					var _v1 = function () {
						if (A3($author$project$Compiler$Parse$String$isDoubleQuote, src, pos1, end)) {
							var pos2 = pos + 2;
							if (A3($author$project$Compiler$Parse$String$isDoubleQuote, src, pos2, end)) {
								var pos3 = pos + 3;
								var col3 = col + 3;
								return A9($author$project$Compiler$Parse$String$multiString, src, pos3, end, row, col3, pos3, row, col, _List_Nil);
							} else {
								return A4($author$project$Compiler$Parse$String$COk, pos2, row, col + 2, $author$project$Compiler$Data$Utf8$empty);
							}
						} else {
							return A7($author$project$Compiler$Parse$String$singleString, src, pos1, end, row, col + 1, pos1, _List_Nil);
						}
					}();
					if (_v1.$ === 'COk') {
						var newPos = _v1.a;
						var newRow = _v1.b;
						var newCol = _v1.c;
						var utf8 = _v1.d;
						var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol);
						return A2($author$project$Compiler$Parse$Primitives$Cok, utf8, newState);
					} else {
						var r = _v1.a;
						var c = _v1.b;
						var x = _v1.c;
						return A3(
							$author$project$Compiler$Parse$Primitives$Cerr,
							r,
							c,
							toError(x));
					}
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
				}
			});
	});
var $author$project$Compiler$Reporting$Error$Syntax$PWildcardNotVar = F4(
	function (a, b, c, d) {
		return {$: 'PWildcardNotVar', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Parse$Pattern$wildcard = $author$project$Compiler$Parse$Primitives$Parser(
	function (_v0) {
		var src = _v0.a;
		var pos = _v0.b;
		var end = _v0.c;
		var indent = _v0.d;
		var row = _v0.e;
		var col = _v0.f;
		if (_Utils_eq(pos, end) || (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) !== 95)) {
			return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $author$project$Compiler$Reporting$Error$Syntax$PStart);
		} else {
			var newPos = pos + 1;
			var newCol = col + 1;
			if (A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, newPos, end) > 0) {
				var _v1 = A4($author$project$Compiler$Parse$Variable$chompInnerChars, src, newPos, end, newCol);
				var badPos = _v1.a;
				var badCol = _v1.b;
				return A3(
					$author$project$Compiler$Parse$Primitives$Cerr,
					row,
					col,
					A2(
						$author$project$Compiler$Reporting$Error$Syntax$PWildcardNotVar,
						A3($author$project$Compiler$Data$Name$fromPtr, src, pos, badPos),
						badCol - col));
			} else {
				var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
				return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, newState);
			}
		}
	});
var $author$project$Compiler$Parse$Pattern$termHelp = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$PStart,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Pattern$wildcard,
				function (_v0) {
					return A2($author$project$Compiler$Parse$Primitives$addEnd, start, $author$project$Compiler$AST$Source$PAnything);
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$PStart),
				function (name) {
					return A2(
						$author$project$Compiler$Parse$Primitives$addEnd,
						start,
						$author$project$Compiler$AST$Source$PVar(name));
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Variable$foreignUpper($author$project$Compiler$Reporting$Error$Syntax$PStart),
				function (upper) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Primitives$getPosition,
						function (end) {
							var region = A2($author$project$Compiler$Reporting$Annotation$Region, start, end);
							return $author$project$Compiler$Parse$Primitives$return(
								A3(
									$author$project$Compiler$Reporting$Annotation$at,
									start,
									end,
									function () {
										if (upper.$ === 'Unqualified') {
											var name = upper.a;
											return A3($author$project$Compiler$AST$Source$PCtor, region, name, _List_Nil);
										} else {
											var home = upper.a;
											var name = upper.b;
											return A4($author$project$Compiler$AST$Source$PCtorQual, region, home, name, _List_Nil);
										}
									}()));
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Number$number, $author$project$Compiler$Reporting$Error$Syntax$PStart, $author$project$Compiler$Reporting$Error$Syntax$PNumber),
				function (number) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Primitives$getPosition,
						function (end) {
							if (number.$ === 'CInt') {
								var _int = number.a;
								return $author$project$Compiler$Parse$Primitives$return(
									A3(
										$author$project$Compiler$Reporting$Annotation$at,
										start,
										end,
										$author$project$Compiler$AST$Source$PInt(_int)));
							} else {
								var _float = number.a;
								return $author$project$Compiler$Parse$Primitives$Parser(
									function (_v3) {
										var row = _v3.e;
										var col = _v3.f;
										var width = $author$project$Compiler$Data$Utf8$size(_float);
										return A3(
											$author$project$Compiler$Parse$Primitives$Cerr,
											row,
											col - width,
											$author$project$Compiler$Reporting$Error$Syntax$PFloat(width));
									});
							}
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$String$string, $author$project$Compiler$Reporting$Error$Syntax$PStart, $author$project$Compiler$Reporting$Error$Syntax$PString),
				function (str) {
					return A2(
						$author$project$Compiler$Parse$Primitives$addEnd,
						start,
						$author$project$Compiler$AST$Source$PStr(str));
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$String$character, $author$project$Compiler$Reporting$Error$Syntax$PStart, $author$project$Compiler$Reporting$Error$Syntax$PChar),
				function (chr) {
					return A2(
						$author$project$Compiler$Parse$Primitives$addEnd,
						start,
						$author$project$Compiler$AST$Source$PChr(chr));
				})
			]));
};
var $author$project$Compiler$Parse$Pattern$exprHelp = F3(
	function (start, revPatterns, _v24) {
		var pattern = _v24.a;
		var end = _v24.b;
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PIndentStart),
					function (_v25) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A3($author$project$Compiler$Parse$Primitives$word2, 58, 58, $author$project$Compiler$Reporting$Error$Syntax$PStart),
							function (_v26) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PSpace, $author$project$Compiler$Reporting$Error$Syntax$PIndentStart),
									function (_v27) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Pattern$cyclic$exprPart(),
											function (ePart) {
												return A3(
													$author$project$Compiler$Parse$Pattern$exprHelp,
													start,
													A2($elm$core$List$cons, pattern, revPatterns),
													ePart);
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PIndentStart),
					function (_v28) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Keyword$as_($author$project$Compiler$Reporting$Error$Syntax$PStart),
							function (_v29) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PSpace, $author$project$Compiler$Reporting$Error$Syntax$PIndentAlias),
									function (_v30) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Primitives$getPosition,
											function (nameStart) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$PAlias),
													function (name) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															$author$project$Compiler$Parse$Primitives$getPosition,
															function (newEnd) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$PSpace),
																	function (_v31) {
																		var alias = A3($author$project$Compiler$Reporting$Annotation$at, nameStart, newEnd, name);
																		return $author$project$Compiler$Parse$Primitives$return(
																			_Utils_Tuple2(
																				A3(
																					$author$project$Compiler$Reporting$Annotation$at,
																					start,
																					newEnd,
																					A2(
																						$author$project$Compiler$AST$Source$PAlias,
																						A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Parse$Pattern$cons, pattern, revPatterns),
																						alias)),
																				newEnd));
																	});
															});
													});
											});
									});
							});
					})
				]),
			_Utils_Tuple2(
				A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Parse$Pattern$cons, pattern, revPatterns),
				end));
	});
var $author$project$Compiler$Parse$Pattern$exprTermHelp = F4(
	function (region, upper, start, revArgs) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Primitives$getPosition,
			function (end) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$PSpace),
					function (_v19) {
						return A2(
							$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
							_List_fromArray(
								[
									A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PIndentStart),
									function (_v20) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Pattern$cyclic$term(),
											function (arg) {
												return A4(
													$author$project$Compiler$Parse$Pattern$exprTermHelp,
													region,
													upper,
													start,
													A2($elm$core$List$cons, arg, revArgs));
											});
									})
								]),
							_Utils_Tuple2(
								A3(
									$author$project$Compiler$Reporting$Annotation$at,
									start,
									end,
									function () {
										if (upper.$ === 'Unqualified') {
											var name = upper.a;
											return A3(
												$author$project$Compiler$AST$Source$PCtor,
												region,
												name,
												$author$project$Extra$Type$List$reverse(revArgs));
										} else {
											var home = upper.a;
											var name = upper.b;
											return A4(
												$author$project$Compiler$AST$Source$PCtorQual,
												region,
												home,
												name,
												$author$project$Extra$Type$List$reverse(revArgs));
										}
									}()),
								end));
					});
			});
	});
var $author$project$Compiler$Parse$Pattern$list = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$PList,
		A2($author$project$Compiler$Parse$Primitives$word1, 91, $author$project$Compiler$Reporting$Error$Syntax$PStart),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PListSpace, $author$project$Compiler$Reporting$Error$Syntax$PListIndentOpen),
			function (_v15) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$PListOpen,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2(
								$author$project$Compiler$Parse$Primitives$specialize,
								$author$project$Compiler$Reporting$Error$Syntax$PListExpr,
								$author$project$Compiler$Parse$Pattern$cyclic$expression()),
							function (_v16) {
								var pattern = _v16.a;
								var end = _v16.b;
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PListIndentEnd),
									function (_v17) {
										return A2(
											$author$project$Compiler$Parse$Pattern$listHelp,
											start,
											_List_fromArray(
												[pattern]));
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 93, $author$project$Compiler$Reporting$Error$Syntax$PListEnd),
							function (_v18) {
								return A2(
									$author$project$Compiler$Parse$Primitives$addEnd,
									start,
									$author$project$Compiler$AST$Source$PList(_List_Nil));
							})
						]));
			}));
};
var $author$project$Compiler$Parse$Pattern$listHelp = F2(
	function (start, patterns) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$PListEnd,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$PListEnd),
					function (_v10) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PListSpace, $author$project$Compiler$Reporting$Error$Syntax$PListIndentExpr),
							function (_v11) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$PListExpr,
										$author$project$Compiler$Parse$Pattern$cyclic$expression()),
									function (_v12) {
										var pattern = _v12.a;
										var end = _v12.b;
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PListIndentEnd),
											function (_v13) {
												return A2(
													$author$project$Compiler$Parse$Pattern$listHelp,
													start,
													A2($elm$core$List$cons, pattern, patterns));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 93, $author$project$Compiler$Reporting$Error$Syntax$PListEnd),
					function (_v14) {
						return A2(
							$author$project$Compiler$Parse$Primitives$addEnd,
							start,
							$author$project$Compiler$AST$Source$PList(
								$author$project$Extra$Type$List$reverse(patterns)));
					})
				]));
	});
var $author$project$Compiler$Parse$Pattern$tuple = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$PTuple,
		A2($author$project$Compiler$Parse$Primitives$word1, 40, $author$project$Compiler$Reporting$Error$Syntax$PStart),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PTupleSpace, $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentExpr1),
			function (_v6) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$PTupleOpen,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2(
								$author$project$Compiler$Parse$Primitives$specialize,
								$author$project$Compiler$Reporting$Error$Syntax$PTupleExpr,
								$author$project$Compiler$Parse$Pattern$cyclic$expression()),
							function (_v7) {
								var pattern = _v7.a;
								var end = _v7.b;
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentEnd),
									function (_v8) {
										return A3($author$project$Compiler$Parse$Pattern$tupleHelp, start, pattern, _List_Nil);
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$PTupleEnd),
							function (_v9) {
								return A2($author$project$Compiler$Parse$Primitives$addEnd, start, $author$project$Compiler$AST$Source$PUnit);
							})
						]));
			}));
};
var $author$project$Compiler$Parse$Pattern$tupleHelp = F3(
	function (start, firstPattern, revPatterns) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$PTupleEnd,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$PTupleEnd),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$PTupleSpace, $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentExprN),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$PTupleExpr,
										$author$project$Compiler$Parse$Pattern$cyclic$expression()),
									function (_v2) {
										var pattern = _v2.a;
										var end = _v2.b;
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$PTupleIndentEnd),
											function (_v3) {
												return A3(
													$author$project$Compiler$Parse$Pattern$tupleHelp,
													start,
													firstPattern,
													A2($elm$core$List$cons, pattern, revPatterns));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$PTupleEnd),
					function (_v4) {
						var _v5 = $author$project$Extra$Type$List$reverse(revPatterns);
						if (!_v5.b) {
							return $author$project$Compiler$Parse$Primitives$return(firstPattern);
						} else {
							var secondPattern = _v5.a;
							var otherPatterns = _v5.b;
							return A2(
								$author$project$Compiler$Parse$Primitives$addEnd,
								start,
								A3($author$project$Compiler$AST$Source$PTuple, firstPattern, secondPattern, otherPatterns));
						}
					})
				]));
	});
function $author$project$Compiler$Parse$Pattern$cyclic$exprPart() {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$PStart,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Primitives$getPosition,
				function (start) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Variable$foreignUpper($author$project$Compiler$Reporting$Error$Syntax$PStart),
						function (upper) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Primitives$getPosition,
								function (end) {
									return A4(
										$author$project$Compiler$Parse$Pattern$exprTermHelp,
										A2($author$project$Compiler$Reporting$Annotation$Region, start, end),
										upper,
										start,
										_List_Nil);
								});
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Pattern$cyclic$term(),
				function (eterm) {
					var _v22 = eterm.a;
					var end = _v22.b;
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$PSpace),
						function (_v23) {
							return $author$project$Compiler$Parse$Primitives$return(
								_Utils_Tuple2(eterm, end));
						});
				})
			]));
}
function $author$project$Compiler$Parse$Pattern$cyclic$expression() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Pattern$cyclic$exprPart(),
				function (ePart) {
					return A3($author$project$Compiler$Parse$Pattern$exprHelp, start, _List_Nil, ePart);
				});
		});
}
function $author$project$Compiler$Parse$Pattern$cyclic$term() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$oneOf,
				$author$project$Compiler$Reporting$Error$Syntax$PStart,
				_List_fromArray(
					[
						$author$project$Compiler$Parse$Pattern$record(start),
						$author$project$Compiler$Parse$Pattern$tuple(start),
						$author$project$Compiler$Parse$Pattern$list(start),
						$author$project$Compiler$Parse$Pattern$termHelp(start)
					]));
		});
}
try {
	var $author$project$Compiler$Parse$Pattern$exprPart = $author$project$Compiler$Parse$Pattern$cyclic$exprPart();
	$author$project$Compiler$Parse$Pattern$cyclic$exprPart = function () {
		return $author$project$Compiler$Parse$Pattern$exprPart;
	};
	var $author$project$Compiler$Parse$Pattern$expression = $author$project$Compiler$Parse$Pattern$cyclic$expression();
	$author$project$Compiler$Parse$Pattern$cyclic$expression = function () {
		return $author$project$Compiler$Parse$Pattern$expression;
	};
	var $author$project$Compiler$Parse$Pattern$term = $author$project$Compiler$Parse$Pattern$cyclic$term();
	$author$project$Compiler$Parse$Pattern$cyclic$term = function () {
		return $author$project$Compiler$Parse$Pattern$term;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Parse.Pattern` are causing infinite recursion:\n\n  \n      exprHelp\n       \n      exprPart\n       \n      exprTermHelp\n       \n      expression\n       \n      list\n       \n      listHelp\n       \n      term\n       \n      tuple\n       \n      tupleHelp\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$Parse$Expression$chompArgs = function (revArgs) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$FuncArrow,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$FuncArg, $author$project$Compiler$Parse$Pattern$term),
				function (arg) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$FuncSpace, $author$project$Compiler$Reporting$Error$Syntax$FuncIndentArrow),
						function (_v0) {
							return $author$project$Compiler$Parse$Expression$chompArgs(
								A2($elm$core$List$cons, arg, revArgs));
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A3($author$project$Compiler$Parse$Primitives$word2, 45, 62, $author$project$Compiler$Reporting$Error$Syntax$FuncArrow),
				function (_v1) {
					return $author$project$Compiler$Parse$Primitives$return(revArgs);
				})
			]));
};
var $author$project$Compiler$Reporting$Error$Syntax$DefNameMatch = F3(
	function (a, b, c) {
		return {$: 'DefNameMatch', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$DefNameRepeat = F2(
	function (a, b) {
		return {$: 'DefNameRepeat', a: a, b: b};
	});
var $author$project$Compiler$Parse$Expression$chompMatchingName = function (expectedName) {
	var _v0 = $author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$DefNameRepeat);
	var parserL = _v0.a;
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (state) {
			var sr = state.e;
			var sc = state.f;
			var _v1 = parserL(state);
			switch (_v1.$) {
				case 'Cok':
					var name = _v1.a;
					var newState = _v1.b;
					var er = newState.e;
					var ec = newState.f;
					return _Utils_eq(expectedName, name) ? A2(
						$author$project$Compiler$Parse$Primitives$Cok,
						A2(
							$author$project$Compiler$Reporting$Annotation$At,
							A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, sr, sc),
								A2($author$project$Compiler$Reporting$Annotation$Position, er, ec)),
							name),
						newState) : A3(
						$author$project$Compiler$Parse$Primitives$Cerr,
						sr,
						sc,
						$author$project$Compiler$Reporting$Error$Syntax$DefNameMatch(name));
				case 'Eok':
					var name = _v1.a;
					var newState = _v1.b;
					var er = newState.e;
					var ec = newState.f;
					return _Utils_eq(expectedName, name) ? A2(
						$author$project$Compiler$Parse$Primitives$Eok,
						A2(
							$author$project$Compiler$Reporting$Annotation$At,
							A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, sr, sc),
								A2($author$project$Compiler$Reporting$Annotation$Position, er, ec)),
							name),
						newState) : A3(
						$author$project$Compiler$Parse$Primitives$Eerr,
						sr,
						sc,
						$author$project$Compiler$Reporting$Error$Syntax$DefNameMatch(name));
				case 'Cerr':
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
				default:
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Eerr, r, c, t);
			}
		});
};
var $author$project$Compiler$Parse$Keyword$else_ = function (tx) {
	return A5($author$project$Compiler$Parse$Keyword$k4, 101, 108, 115, 101, tx);
};
var $author$project$Compiler$Parse$Primitives$fmap = F2(
	function (f, _v0) {
		var parser = _v0.a;
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				var _v1 = parser(state);
				switch (_v1.$) {
					case 'Cok':
						var a = _v1.a;
						var s = _v1.b;
						return A2(
							$author$project$Compiler$Parse$Primitives$Cok,
							f(a),
							s);
					case 'Eok':
						var a = _v1.a;
						var s = _v1.b;
						return A2(
							$author$project$Compiler$Parse$Primitives$Eok,
							f(a),
							s);
					case 'Cerr':
						var r = _v1.a;
						var c = _v1.b;
						var t = _v1.c;
						return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
					default:
						var r = _v1.a;
						var c = _v1.b;
						var t = _v1.c;
						return A3($author$project$Compiler$Parse$Primitives$Eerr, r, c, t);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$if_ = function (tx) {
	return A3($author$project$Compiler$Parse$Keyword$k2, 105, 102, tx);
};
var $author$project$Compiler$Parse$Keyword$in_ = function (tx) {
	return A3($author$project$Compiler$Parse$Keyword$k2, 105, 110, tx);
};
var $author$project$Compiler$Parse$Keyword$k3 = F4(
	function (w1, w2, w3, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos3 = pos + 3;
				if ((_Utils_cmp(pos3, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2),
					w3) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos3, end)))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos3, end, indent, row, col + 3);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$let_ = function (tx) {
	return A4($author$project$Compiler$Parse$Keyword$k3, 108, 101, 116, tx);
};
var $author$project$Compiler$Parse$Primitives$loopHelp = F5(
	function (callback, state, loopState, eok, eerr) {
		loopHelp:
		while (true) {
			var _v0 = callback(loopState);
			var parser = _v0.a;
			var _v1 = parser(state);
			switch (_v1.$) {
				case 'Cok':
					if (_v1.a.$ === 'Loop') {
						var newLoopState = _v1.a.a;
						var newState = _v1.b;
						var $temp$callback = callback,
							$temp$state = newState,
							$temp$loopState = newLoopState,
							$temp$eok = $author$project$Compiler$Parse$Primitives$Cok,
							$temp$eerr = $author$project$Compiler$Parse$Primitives$Cerr;
						callback = $temp$callback;
						state = $temp$state;
						loopState = $temp$loopState;
						eok = $temp$eok;
						eerr = $temp$eerr;
						continue loopHelp;
					} else {
						var a = _v1.a.a;
						var newState = _v1.b;
						return A2($author$project$Compiler$Parse$Primitives$Cok, a, newState);
					}
				case 'Eok':
					if (_v1.a.$ === 'Loop') {
						var newLoopState = _v1.a.a;
						var newState = _v1.b;
						var $temp$callback = callback,
							$temp$state = newState,
							$temp$loopState = newLoopState,
							$temp$eok = eok,
							$temp$eerr = eerr;
						callback = $temp$callback;
						state = $temp$state;
						loopState = $temp$loopState;
						eok = $temp$eok;
						eerr = $temp$eerr;
						continue loopHelp;
					} else {
						var a = _v1.a.a;
						var newState = _v1.b;
						return A2(eok, a, newState);
					}
				case 'Cerr':
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
				default:
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3(eerr, r, c, t);
			}
		}
	});
var $author$project$Compiler$Parse$Primitives$loop = F2(
	function (callback, loopState) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (state) {
				return A5($author$project$Compiler$Parse$Primitives$loopHelp, callback, state, loopState, $author$project$Compiler$Parse$Primitives$Eok, $author$project$Compiler$Parse$Primitives$Eerr);
			});
	});
var $author$project$Compiler$AST$Source$CFloat = function (a) {
	return {$: 'CFloat', a: a};
};
var $author$project$Compiler$AST$Source$CInt = function (a) {
	return {$: 'CInt', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$Number = F3(
	function (a, b, c) {
		return {$: 'Number', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Expression$number = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$Number$number, $author$project$Compiler$Reporting$Error$Syntax$Start, $author$project$Compiler$Reporting$Error$Syntax$Number),
		function (nmbr) {
			return A2(
				$author$project$Compiler$Parse$Primitives$addEnd,
				start,
				function () {
					if (nmbr.$ === 'CInt') {
						var _int = nmbr.a;
						return $author$project$Compiler$AST$Source$CInt(_int);
					} else {
						var _float = nmbr.a;
						return $author$project$Compiler$AST$Source$CFloat(_float);
					}
				}());
		});
};
var $author$project$Compiler$Parse$Keyword$of_ = function (tx) {
	return A3($author$project$Compiler$Parse$Keyword$k2, 111, 102, tx);
};
var $author$project$Compiler$Parse$Symbol$BadArrow = {$: 'BadArrow'};
var $author$project$Compiler$Parse$Symbol$BadDot = {$: 'BadDot'};
var $author$project$Compiler$Parse$Symbol$BadEquals = {$: 'BadEquals'};
var $author$project$Compiler$Parse$Symbol$BadHasType = {$: 'BadHasType'};
var $author$project$Compiler$Parse$Symbol$BadPipe = {$: 'BadPipe'};
var $elm$core$String$foldr = _String_foldr;
var $elm$core$String$toList = function (string) {
	return A3($elm$core$String$foldr, $elm$core$List$cons, _List_Nil, string);
};
var $author$project$Compiler$Parse$Symbol$binopCharSet = $author$project$Extra$Type$Set$fromList(
	A2(
		$author$project$Extra$Type$List$map,
		$elm$core$Char$toCode,
		$elm$core$String$toList('+-/*=.<>:&|^?%!')));
var $author$project$Compiler$Parse$Symbol$isBinopCharHelp = function (word) {
	return (word < 128) && A2($author$project$Extra$Type$Set$member, word, $author$project$Compiler$Parse$Symbol$binopCharSet);
};
var $author$project$Compiler$Parse$Symbol$chompOps = F3(
	function (src, pos, end) {
		chompOps:
		while (true) {
			if ((_Utils_cmp(pos, end) < 0) && $author$project$Compiler$Parse$Symbol$isBinopCharHelp(
				A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos))) {
				var $temp$src = src,
					$temp$pos = pos + 1,
					$temp$end = end;
				src = $temp$src;
				pos = $temp$pos;
				end = $temp$end;
				continue chompOps;
			} else {
				return pos;
			}
		}
	});
var $author$project$Compiler$Parse$Symbol$operator = F2(
	function (toExpectation, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var newPos = A3($author$project$Compiler$Parse$Symbol$chompOps, src, pos, end);
				if (_Utils_eq(pos, newPos)) {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
				} else {
					var _v1 = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, newPos);
					switch (_v1) {
						case '.':
							return A3(
								$author$project$Compiler$Parse$Primitives$Eerr,
								row,
								col,
								toError($author$project$Compiler$Parse$Symbol$BadDot));
						case '|':
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								row,
								col,
								toError($author$project$Compiler$Parse$Symbol$BadPipe));
						case '->':
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								row,
								col,
								toError($author$project$Compiler$Parse$Symbol$BadArrow));
						case '=':
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								row,
								col,
								toError($author$project$Compiler$Parse$Symbol$BadEquals));
						case ':':
							return A3(
								$author$project$Compiler$Parse$Primitives$Cerr,
								row,
								col,
								toError($author$project$Compiler$Parse$Symbol$BadHasType));
						default:
							var op = _v1;
							var newCol = (col + newPos) - pos;
							var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
							return A2($author$project$Compiler$Parse$Primitives$Cok, op, newState);
					}
				}
			});
	});
var $author$project$Compiler$AST$Source$Shader = F2(
	function (a, b) {
		return {$: 'Shader', a: a, b: b};
	});
var $author$project$Compiler$AST$Utils$Shader$Source = function (a) {
	return {$: 'Source', a: a};
};
var $author$project$Compiler$AST$Utils$Shader$escape = function (chars) {
	escape:
	while (true) {
		var _v0 = $elm$core$String$uncons(chars);
		if (_v0.$ === 'Nothing') {
			return '';
		} else {
			var _v1 = _v0.a;
			var c = _v1.a;
			var cs = _v1.b;
			if (_Utils_eq(
				c,
				_Utils_chr('\u000D'))) {
				var $temp$chars = cs;
				chars = $temp$chars;
				continue escape;
			} else {
				if (_Utils_eq(
					c,
					_Utils_chr('\n'))) {
					return A2(
						$elm$core$String$cons,
						_Utils_chr('\\'),
						A2(
							$elm$core$String$cons,
							_Utils_chr('n'),
							$author$project$Compiler$AST$Utils$Shader$escape(cs)));
				} else {
					if (_Utils_eq(
						c,
						_Utils_chr('\"'))) {
						return A2(
							$elm$core$String$cons,
							_Utils_chr('\\'),
							A2(
								$elm$core$String$cons,
								_Utils_chr('\"'),
								$author$project$Compiler$AST$Utils$Shader$escape(cs)));
					} else {
						if (_Utils_eq(
							c,
							_Utils_chr('\''))) {
							return A2(
								$elm$core$String$cons,
								_Utils_chr('\\'),
								A2(
									$elm$core$String$cons,
									_Utils_chr('\''),
									$author$project$Compiler$AST$Utils$Shader$escape(cs)));
						} else {
							if (_Utils_eq(
								c,
								_Utils_chr('\\'))) {
								return A2(
									$elm$core$String$cons,
									_Utils_chr('\\'),
									A2(
										$elm$core$String$cons,
										_Utils_chr('\\'),
										$author$project$Compiler$AST$Utils$Shader$escape(cs)));
							} else {
								return A2(
									$elm$core$String$cons,
									c,
									$author$project$Compiler$AST$Utils$Shader$escape(cs));
							}
						}
					}
				}
			}
		}
	}
};
var $author$project$Compiler$AST$Utils$Shader$fromChars = function (chars) {
	return $author$project$Compiler$AST$Utils$Shader$Source(
		$author$project$Compiler$AST$Utils$Shader$escape(chars));
};
var $author$project$Compiler$Reporting$Error$Syntax$EndlessShader = F2(
	function (a, b) {
		return {$: 'EndlessShader', a: a, b: b};
	});
var $author$project$Compiler$Parse$Shader$Good = {$: 'Good'};
var $author$project$Compiler$Parse$Shader$Unending = {$: 'Unending'};
var $author$project$Compiler$Parse$Shader$eatShader = F5(
	function (src, pos, end, row, col) {
		eatShader:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(
					_Utils_Tuple2($author$project$Compiler$Parse$Shader$Unending, pos),
					_Utils_Tuple2(row, col));
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if ((word === 124) && A4($author$project$Compiler$Parse$Primitives$isWord, src, pos + 1, end, 93)) {
					return _Utils_Tuple2(
						_Utils_Tuple2($author$project$Compiler$Parse$Shader$Good, pos),
						_Utils_Tuple2(row, col));
				} else {
					if (word === 10) {
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row + 1,
							$temp$col = 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatShader;
					} else {
						var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
						var $temp$src = src,
							$temp$pos = newPos,
							$temp$end = end,
							$temp$row = row,
							$temp$col = col + 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatShader;
					}
				}
			}
		}
	});
var $author$project$Compiler$Parse$Shader$parseBlock = $author$project$Compiler$Parse$Primitives$Parser(
	function (_v0) {
		var src = _v0.a;
		var pos = _v0.b;
		var end = _v0.c;
		var indent = _v0.d;
		var row = _v0.e;
		var col = _v0.f;
		var pos6 = pos + 6;
		if ((_Utils_cmp(pos6, end) < 1) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) === 91) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1) === 103) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2) === 108) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3) === 115) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4) === 108) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 5) === 124))))))) {
			var _v1 = A5($author$project$Compiler$Parse$Shader$eatShader, src, pos6, end, row, col + 6);
			var _v2 = _v1.a;
			var status = _v2.a;
			var newPos = _v2.b;
			var _v3 = _v1.b;
			var newRow = _v3.a;
			var newCol = _v3.b;
			if (status.$ === 'Good') {
				var off = pos6;
				var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos + 2, end, indent, newRow, newCol + 2);
				var len = newPos - pos6;
				var block = A3($elm$core$String$slice, off, off + len, src);
				return A2($author$project$Compiler$Parse$Primitives$Cok, block, newState);
			} else {
				return A3($author$project$Compiler$Parse$Primitives$Cerr, row, col, $author$project$Compiler$Reporting$Error$Syntax$EndlessShader);
			}
		} else {
			return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $author$project$Compiler$Reporting$Error$Syntax$Start);
		}
	});
var $author$project$Compiler$AST$Utils$Shader$Types = F3(
	function (a, b, c) {
		return {$: 'Types', a: a, b: b, c: c};
	});
var $author$project$Extra$Type$Set$empty = $elm$core$Set$empty;
var $author$project$Compiler$Parse$Shader$parseGlsl = F3(
	function (_v0, _v1, _v2) {
		return $author$project$Compiler$Parse$Primitives$return(
			A3($author$project$Compiler$AST$Utils$Shader$Types, $author$project$Extra$Type$Set$empty, $author$project$Extra$Type$Set$empty, $author$project$Extra$Type$Set$empty));
	});
var $author$project$Compiler$Parse$Shader$shader = function (start) {
	var row = start.a;
	var col = start.b;
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Shader$parseBlock,
		function (block) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A3($author$project$Compiler$Parse$Shader$parseGlsl, row, col, block),
				function (shdr) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Primitives$getPosition,
						function (end) {
							return $author$project$Compiler$Parse$Primitives$return(
								A3(
									$author$project$Compiler$Reporting$Annotation$at,
									start,
									end,
									A2(
										$author$project$Compiler$AST$Source$Shader,
										$author$project$Compiler$AST$Utils$Shader$fromChars(block),
										shdr)));
						});
				});
		});
};
var $author$project$Compiler$Reporting$Error$Syntax$CString = F3(
	function (a, b, c) {
		return {$: 'CString', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$Str = function (a) {
	return {$: 'Str', a: a};
};
var $author$project$Compiler$Parse$Expression$string = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$String$string, $author$project$Compiler$Reporting$Error$Syntax$Start, $author$project$Compiler$Reporting$Error$Syntax$CString),
		function (str) {
			return A2(
				$author$project$Compiler$Parse$Primitives$addEnd,
				start,
				$author$project$Compiler$AST$Source$Str(str));
		});
};
var $author$project$Compiler$Parse$Keyword$then_ = function (tx) {
	return A5($author$project$Compiler$Parse$Keyword$k4, 116, 104, 101, 110, tx);
};
var $author$project$Compiler$AST$Source$Call = F2(
	function (a, b) {
		return {$: 'Call', a: a, b: b};
	});
var $author$project$Compiler$Parse$Expression$toCall = F2(
	function (func, revArgs) {
		if (!revArgs.b) {
			return func;
		} else {
			var lastArg = revArgs.a;
			return A3(
				$author$project$Compiler$Reporting$Annotation$merge,
				func,
				lastArg,
				A2(
					$author$project$Compiler$AST$Source$Call,
					func,
					$author$project$Extra$Type$List$reverse(revArgs)));
		}
	});
var $author$project$Compiler$AST$Source$Var = F2(
	function (a, b) {
		return {$: 'Var', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$VarQual = F3(
	function (a, b, c) {
		return {$: 'VarQual', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Source$CapVar = {$: 'CapVar'};
var $author$project$Compiler$AST$Source$LowVar = {$: 'LowVar'};
var $author$project$Compiler$Parse$Variable$foreignAlphaHelp = F4(
	function (src, pos, end, col) {
		foreignAlphaHelp:
		while (true) {
			var _v0 = A4($author$project$Compiler$Parse$Variable$chompLower, src, pos, end, col);
			var lowerPos = _v0.a;
			var lowerCol = _v0.b;
			if (_Utils_cmp(pos, lowerPos) < 0) {
				return _Utils_Tuple2(
					_Utils_Tuple2(pos, lowerPos),
					_Utils_Tuple2(lowerCol, $author$project$Compiler$AST$Source$LowVar));
			} else {
				var _v1 = A4($author$project$Compiler$Parse$Variable$chompUpper, src, pos, end, col);
				var upperPos = _v1.a;
				var upperCol = _v1.b;
				if (_Utils_eq(pos, upperPos)) {
					return _Utils_Tuple2(
						_Utils_Tuple2(pos, pos),
						_Utils_Tuple2(col, $author$project$Compiler$AST$Source$CapVar));
				} else {
					if (A3($author$project$Compiler$Parse$Variable$isDot, src, upperPos, end)) {
						var $temp$src = src,
							$temp$pos = upperPos + 1,
							$temp$end = end,
							$temp$col = upperCol + 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						col = $temp$col;
						continue foreignAlphaHelp;
					} else {
						return _Utils_Tuple2(
							_Utils_Tuple2(pos, upperPos),
							_Utils_Tuple2(upperCol, $author$project$Compiler$AST$Source$CapVar));
					}
				}
			}
		}
	});
var $author$project$Compiler$Parse$Variable$foreignAlpha = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var _v1 = A4($author$project$Compiler$Parse$Variable$foreignAlphaHelp, src, pos, end, col);
			var _v2 = _v1.a;
			var alphaStart = _v2.a;
			var alphaEnd = _v2.b;
			var _v3 = _v1.b;
			var newCol = _v3.a;
			var varType = _v3.b;
			if (_Utils_eq(alphaStart, alphaEnd)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, newCol, toError);
			} else {
				var newState = A6($author$project$Compiler$Parse$Primitives$State, src, alphaEnd, end, indent, row, newCol);
				var name = A3($author$project$Compiler$Data$Name$fromPtr, src, alphaStart, alphaEnd);
				if (_Utils_eq(alphaStart, pos)) {
					return A2($author$project$Extra$Type$Set$member, name, $author$project$Compiler$Parse$Variable$reservedWords) ? A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError) : A2(
						$author$project$Compiler$Parse$Primitives$Cok,
						A2($author$project$Compiler$AST$Source$Var, varType, name),
						newState);
				} else {
					var home = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, alphaStart - 1);
					return A2(
						$author$project$Compiler$Parse$Primitives$Cok,
						A3($author$project$Compiler$AST$Source$VarQual, varType, home, name),
						newState);
				}
			}
		});
};
var $author$project$Compiler$Parse$Expression$variable = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Variable$foreignAlpha($author$project$Compiler$Reporting$Error$Syntax$Start),
		function (_var) {
			return A2($author$project$Compiler$Parse$Primitives$addEnd, start, _var);
		});
};
var $author$project$Compiler$Parse$Primitives$withBacksetIndent = F2(
	function (backset, _v0) {
		var parser = _v0.a;
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v1) {
				var src = _v1.a;
				var pos = _v1.b;
				var end = _v1.c;
				var oldIndent = _v1.d;
				var row = _v1.e;
				var col = _v1.f;
				var _v2 = parser(
					A6($author$project$Compiler$Parse$Primitives$State, src, pos, end, col - backset, row, col));
				switch (_v2.$) {
					case 'Cok':
						var a = _v2.a;
						var _v3 = _v2.b;
						var s = _v3.a;
						var p = _v3.b;
						var e = _v3.c;
						var r = _v3.e;
						var c = _v3.f;
						return A2(
							$author$project$Compiler$Parse$Primitives$Cok,
							a,
							A6($author$project$Compiler$Parse$Primitives$State, s, p, e, oldIndent, r, c));
					case 'Eok':
						var a = _v2.a;
						var _v4 = _v2.b;
						var s = _v4.a;
						var p = _v4.b;
						var e = _v4.c;
						var r = _v4.e;
						var c = _v4.f;
						return A2(
							$author$project$Compiler$Parse$Primitives$Eok,
							a,
							A6($author$project$Compiler$Parse$Primitives$State, s, p, e, oldIndent, r, c));
					default:
						var x = _v2;
						return x;
				}
			});
	});
var $author$project$Compiler$Parse$Primitives$withIndent = function (_v0) {
	var parser = _v0.a;
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v1) {
			var src = _v1.a;
			var pos = _v1.b;
			var end = _v1.c;
			var oldIndent = _v1.d;
			var row = _v1.e;
			var col = _v1.f;
			var _v2 = parser(
				A6($author$project$Compiler$Parse$Primitives$State, src, pos, end, col, row, col));
			switch (_v2.$) {
				case 'Cok':
					var a = _v2.a;
					var _v3 = _v2.b;
					var s = _v3.a;
					var p = _v3.b;
					var e = _v3.c;
					var r = _v3.e;
					var c = _v3.f;
					return A2(
						$author$project$Compiler$Parse$Primitives$Cok,
						a,
						A6($author$project$Compiler$Parse$Primitives$State, s, p, e, oldIndent, r, c));
				case 'Eok':
					var a = _v2.a;
					var _v4 = _v2.b;
					var s = _v4.a;
					var p = _v4.b;
					var e = _v4.c;
					var r = _v4.e;
					var c = _v4.f;
					return A2(
						$author$project$Compiler$Parse$Primitives$Eok,
						a,
						A6($author$project$Compiler$Parse$Primitives$State, s, p, e, oldIndent, r, c));
				default:
					var x = _v2;
					return x;
			}
		});
};
var $author$project$Compiler$Parse$Expression$case_ = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$Case,
		$author$project$Compiler$Parse$Keyword$case_($author$project$Compiler$Reporting$Error$Syntax$Start),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CaseSpace, $author$project$Compiler$Reporting$Error$Syntax$CaseIndentExpr),
			function (_v103) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2(
						$author$project$Compiler$Parse$Primitives$specialize,
						$author$project$Compiler$Reporting$Error$Syntax$CaseExpr,
						$author$project$Compiler$Parse$Expression$cyclic$expression()),
					function (_v104) {
						var expr = _v104.a;
						var exprEnd = _v104.b;
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$checkIndent, exprEnd, $author$project$Compiler$Reporting$Error$Syntax$CaseIndentOf),
							function (_v105) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Keyword$of_($author$project$Compiler$Reporting$Error$Syntax$CaseOf),
									function (_v106) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CaseSpace, $author$project$Compiler$Reporting$Error$Syntax$CaseIndentPattern),
											function (_v107) {
												return $author$project$Compiler$Parse$Primitives$withIndent(
													A2(
														$author$project$Compiler$Parse$Primitives$bind,
														$author$project$Compiler$Parse$Expression$cyclic$chompBranch(),
														function (_v108) {
															var firstBranch = _v108.a;
															var firstEnd = _v108.b;
															return A2(
																$author$project$Compiler$Parse$Primitives$bind,
																A2(
																	$author$project$Compiler$Parse$Expression$chompCaseEnd,
																	_List_fromArray(
																		[firstBranch]),
																	firstEnd),
																function (_v109) {
																	var branches = _v109.a;
																	var end = _v109.b;
																	return $author$project$Compiler$Parse$Primitives$return(
																		_Utils_Tuple2(
																			A3(
																				$author$project$Compiler$Reporting$Annotation$at,
																				start,
																				end,
																				A2($author$project$Compiler$AST$Source$Case, expr, branches)),
																			end));
																});
														}));
											});
									});
							});
					});
			}));
};
var $author$project$Compiler$Parse$Expression$chompCaseEnd = F2(
	function (branches, end) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Space$checkAligned($author$project$Compiler$Reporting$Error$Syntax$CasePatternAlignment),
					function (_v96) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Expression$cyclic$chompBranch(),
							function (_v97) {
								var branch = _v97.a;
								var newEnd = _v97.b;
								return A2(
									$author$project$Compiler$Parse$Expression$chompCaseEnd,
									A2($elm$core$List$cons, branch, branches),
									newEnd);
							});
					})
				]),
			_Utils_Tuple2(
				$author$project$Extra$Type$List$reverse(branches),
				end));
	});
var $author$project$Compiler$Parse$Expression$chompDefArgsAndBody = F4(
	function (start, name, tipe, revArgs) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$DefEquals,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$DefArg, $author$project$Compiler$Parse$Pattern$term),
					function (arg) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DefSpace, $author$project$Compiler$Reporting$Error$Syntax$DefIndentEquals),
							function (_v92) {
								return A4(
									$author$project$Compiler$Parse$Expression$chompDefArgsAndBody,
									start,
									name,
									tipe,
									A2($elm$core$List$cons, arg, revArgs));
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$DefEquals),
					function (_v93) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DefSpace, $author$project$Compiler$Reporting$Error$Syntax$DefIndentBody),
							function (_v94) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$DefBody,
										$author$project$Compiler$Parse$Expression$cyclic$expression()),
									function (_v95) {
										var body = _v95.a;
										var end = _v95.b;
										return $author$project$Compiler$Parse$Primitives$return(
											_Utils_Tuple2(
												A3(
													$author$project$Compiler$Reporting$Annotation$at,
													start,
													end,
													A4(
														$author$project$Compiler$AST$Source$Define,
														name,
														$author$project$Extra$Type$List$reverse(revArgs),
														body,
														tipe)),
												end));
									});
							});
					})
				]));
	});
var $author$project$Compiler$Parse$Expression$chompExprEnd = F2(
	function (start, _v82) {
		var ops = _v82.a;
		var expr = _v82.b;
		var args = _v82.c;
		var end = _v82.d;
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$Start),
					function (_v83) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Expression$cyclic$term(),
							function (arg) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Primitives$getPosition,
									function (newEnd) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$Space),
											function (_v84) {
												return A2(
													$author$project$Compiler$Parse$Expression$chompExprEnd,
													start,
													A4(
														$author$project$Compiler$Parse$Expression$State,
														ops,
														expr,
														A2($elm$core$List$cons, arg, args),
														newEnd));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$Start),
					function (_v85) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$addLocation(
								A2($author$project$Compiler$Parse$Symbol$operator, $author$project$Compiler$Reporting$Error$Syntax$Start, $author$project$Compiler$Reporting$Error$Syntax$OperatorReserved)),
							function (op) {
								var _v86 = op.a;
								var opStart = _v86.a;
								var opEnd = _v86.b;
								var opName = op.b;
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Space$chompAndCheckIndent,
										$author$project$Compiler$Reporting$Error$Syntax$Space,
										$author$project$Compiler$Reporting$Error$Syntax$IndentOperatorRight(opName)),
									function (_v87) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Primitives$getPosition,
											function (newStart) {
												if (('-' === opName) && ((!_Utils_eq(end, opStart)) && _Utils_eq(opEnd, newStart))) {
													return A2(
														$author$project$Compiler$Parse$Primitives$bind,
														$author$project$Compiler$Parse$Expression$cyclic$term(),
														function (negatedExpr) {
															return A2(
																$author$project$Compiler$Parse$Primitives$bind,
																$author$project$Compiler$Parse$Primitives$getPosition,
																function (newEnd) {
																	return A2(
																		$author$project$Compiler$Parse$Primitives$bind,
																		$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$Space),
																		function (_v88) {
																			var arg = A3(
																				$author$project$Compiler$Reporting$Annotation$at,
																				opStart,
																				newEnd,
																				$author$project$Compiler$AST$Source$Negate(negatedExpr));
																			return A2(
																				$author$project$Compiler$Parse$Expression$chompExprEnd,
																				start,
																				A4(
																					$author$project$Compiler$Parse$Expression$State,
																					ops,
																					expr,
																					A2($elm$core$List$cons, arg, args),
																					newEnd));
																		});
																});
														});
												} else {
													var err = $author$project$Compiler$Reporting$Error$Syntax$OperatorRight(opName);
													return A2(
														$author$project$Compiler$Parse$Primitives$oneOf,
														err,
														_List_fromArray(
															[
																A2(
																$author$project$Compiler$Parse$Primitives$bind,
																$author$project$Compiler$Parse$Expression$possiblyNegativeTerm(newStart),
																function (newExpr) {
																	return A2(
																		$author$project$Compiler$Parse$Primitives$bind,
																		$author$project$Compiler$Parse$Primitives$getPosition,
																		function (newEnd) {
																			return A2(
																				$author$project$Compiler$Parse$Primitives$bind,
																				$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$Space),
																				function (_v89) {
																					var newOps = A2(
																						$elm$core$List$cons,
																						_Utils_Tuple2(
																							A2($author$project$Compiler$Parse$Expression$toCall, expr, args),
																							op),
																						ops);
																					return A2(
																						$author$project$Compiler$Parse$Expression$chompExprEnd,
																						start,
																						A4($author$project$Compiler$Parse$Expression$State, newOps, newExpr, _List_Nil, newEnd));
																				});
																		});
																}),
																A2(
																$author$project$Compiler$Parse$Primitives$bind,
																A2(
																	$author$project$Compiler$Parse$Primitives$oneOf,
																	err,
																	_List_fromArray(
																		[
																			$author$project$Compiler$Parse$Expression$let_(newStart),
																			$author$project$Compiler$Parse$Expression$case_(newStart),
																			$author$project$Compiler$Parse$Expression$if_(newStart),
																			$author$project$Compiler$Parse$Expression$function(newStart)
																		])),
																function (_v90) {
																	var newLast = _v90.a;
																	var newEnd = _v90.b;
																	var newOps = A2(
																		$elm$core$List$cons,
																		_Utils_Tuple2(
																			A2($author$project$Compiler$Parse$Expression$toCall, expr, args),
																			op),
																		ops);
																	var finalExpr = A2(
																		$author$project$Compiler$AST$Source$Binops,
																		$author$project$Extra$Type$List$reverse(newOps),
																		newLast);
																	return $author$project$Compiler$Parse$Primitives$return(
																		_Utils_Tuple2(
																			A3($author$project$Compiler$Reporting$Annotation$at, start, newEnd, finalExpr),
																			newEnd));
																})
															]));
												}
											});
									});
							});
					})
				]),
			function () {
				if (!ops.b) {
					return _Utils_Tuple2(
						A2($author$project$Compiler$Parse$Expression$toCall, expr, args),
						end);
				} else {
					return _Utils_Tuple2(
						A3(
							$author$project$Compiler$Reporting$Annotation$at,
							start,
							end,
							A2(
								$author$project$Compiler$AST$Source$Binops,
								$author$project$Extra$Type$List$reverse(ops),
								A2($author$project$Compiler$Parse$Expression$toCall, expr, args))),
						end);
				}
			}());
	});
var $author$project$Compiler$Parse$Expression$chompFields = function (fields) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$RecordEnd,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$RecordEnd),
				function (_v74) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentField),
						function (_v75) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Expression$cyclic$chompField(),
								function (f) {
									return $author$project$Compiler$Parse$Expression$chompFields(
										A2($elm$core$List$cons, f, fields));
								});
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$RecordEnd),
				function (_v76) {
					return $author$project$Compiler$Parse$Primitives$return(
						$author$project$Extra$Type$List$reverse(fields));
				})
			]));
};
var $author$project$Compiler$Parse$Expression$chompIfEnd = F2(
	function (start, branches) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$IfSpace, $author$project$Compiler$Reporting$Error$Syntax$IfIndentCondition),
			function (_v63) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2(
						$author$project$Compiler$Parse$Primitives$specialize,
						$author$project$Compiler$Reporting$Error$Syntax$IfCondition,
						$author$project$Compiler$Parse$Expression$cyclic$expression()),
					function (_v64) {
						var condition = _v64.a;
						var condEnd = _v64.b;
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$checkIndent, condEnd, $author$project$Compiler$Reporting$Error$Syntax$IfIndentThen),
							function (_v65) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Keyword$then_($author$project$Compiler$Reporting$Error$Syntax$IfThen),
									function (_v66) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$IfSpace, $author$project$Compiler$Reporting$Error$Syntax$IfIndentThenBranch),
											function (_v67) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2(
														$author$project$Compiler$Parse$Primitives$specialize,
														$author$project$Compiler$Reporting$Error$Syntax$IfThenBranch,
														$author$project$Compiler$Parse$Expression$cyclic$expression()),
													function (_v68) {
														var thenBranch = _v68.a;
														var thenEnd = _v68.b;
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Space$checkIndent, thenEnd, $author$project$Compiler$Reporting$Error$Syntax$IfIndentElse),
															function (_v69) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Keyword$else_($author$project$Compiler$Reporting$Error$Syntax$IfElse),
																	function (_v70) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$IfSpace, $author$project$Compiler$Reporting$Error$Syntax$IfIndentElseBranch),
																			function (_v71) {
																				var newBranches = A2(
																					$elm$core$List$cons,
																					_Utils_Tuple2(condition, thenBranch),
																					branches);
																				return A2(
																					$author$project$Compiler$Parse$Primitives$oneOf,
																					$author$project$Compiler$Reporting$Error$Syntax$IfElseBranchStart,
																					_List_fromArray(
																						[
																							A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							$author$project$Compiler$Parse$Keyword$if_($author$project$Compiler$Reporting$Error$Syntax$IfElseBranchStart),
																							function (_v72) {
																								return A2($author$project$Compiler$Parse$Expression$chompIfEnd, start, newBranches);
																							}),
																							A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							A2(
																								$author$project$Compiler$Parse$Primitives$specialize,
																								$author$project$Compiler$Reporting$Error$Syntax$IfElseBranch,
																								$author$project$Compiler$Parse$Expression$cyclic$expression()),
																							function (_v73) {
																								var elseBranch = _v73.a;
																								var elseEnd = _v73.b;
																								var ifExpr = A2(
																									$author$project$Compiler$AST$Source$If,
																									$author$project$Extra$Type$List$reverse(newBranches),
																									elseBranch);
																								return $author$project$Compiler$Parse$Primitives$return(
																									_Utils_Tuple2(
																										A3($author$project$Compiler$Reporting$Annotation$at, start, elseEnd, ifExpr),
																										elseEnd));
																							})
																						]));
																			});
																	});
															});
													});
											});
									});
							});
					});
			});
	});
var $author$project$Compiler$Parse$Expression$chompLetDefs = F2(
	function (revDefs, end) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Space$checkAligned(
						function (_v60) {
							return $author$project$Compiler$Reporting$Error$Syntax$LetDefAlignment;
						}),
					function (_v61) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Expression$cyclic$chompLetDef(),
							function (_v62) {
								var def = _v62.a;
								var newEnd = _v62.b;
								return A2(
									$author$project$Compiler$Parse$Expression$chompLetDefs,
									A2($elm$core$List$cons, def, revDefs),
									newEnd);
							});
					})
				]),
			_Utils_Tuple2(
				$author$project$Extra$Type$List$reverse(revDefs),
				end));
	});
var $author$project$Compiler$Parse$Expression$chompListEnd = F2(
	function (start, entries) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$ListEnd,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$ListEnd),
					function (_v55) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ListSpace, $author$project$Compiler$Reporting$Error$Syntax$ListIndentExpr),
							function (_v56) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$ListExpr,
										$author$project$Compiler$Parse$Expression$cyclic$expression()),
									function (_v57) {
										var entry = _v57.a;
										var end = _v57.b;
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$ListIndentEnd),
											function (_v58) {
												return $author$project$Compiler$Parse$Primitives$return(
													$author$project$Compiler$Parse$Primitives$Loop(
														A2($elm$core$List$cons, entry, entries)));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 93, $author$project$Compiler$Reporting$Error$Syntax$ListEnd),
					function (_v59) {
						return A2(
							$author$project$Compiler$Parse$Primitives$fmap,
							$author$project$Compiler$Parse$Primitives$Done,
							A2(
								$author$project$Compiler$Parse$Primitives$addEnd,
								start,
								$author$project$Compiler$AST$Source$CList(
									$author$project$Extra$Type$List$reverse(entries))));
					})
				]));
	});
var $author$project$Compiler$Parse$Expression$chompTupleEnd = F3(
	function (start, firstExpr, revExprs) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$TupleEnd,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$TupleEnd),
					function (_v49) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TupleSpace, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentExprN),
							function (_v50) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$TupleExpr,
										$author$project$Compiler$Parse$Expression$cyclic$expression()),
									function (_v51) {
										var entry = _v51.a;
										var end = _v51.b;
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentEnd),
											function (_v52) {
												return A3(
													$author$project$Compiler$Parse$Expression$chompTupleEnd,
													start,
													firstExpr,
													A2($elm$core$List$cons, entry, revExprs));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$TupleEnd),
					function (_v53) {
						var _v54 = $author$project$Extra$Type$List$reverse(revExprs);
						if (!_v54.b) {
							return $author$project$Compiler$Parse$Primitives$return(firstExpr);
						} else {
							var secondExpr = _v54.a;
							var otherExprs = _v54.b;
							return A2(
								$author$project$Compiler$Parse$Primitives$addEnd,
								start,
								A3($author$project$Compiler$AST$Source$Tuple, firstExpr, secondExpr, otherExprs));
						}
					})
				]));
	});
var $author$project$Compiler$Parse$Expression$function = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$Func,
		A2($author$project$Compiler$Parse$Primitives$word1, 92, $author$project$Compiler$Reporting$Error$Syntax$Start),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$FuncSpace, $author$project$Compiler$Reporting$Error$Syntax$FuncIndentArg),
			function (_v33) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$FuncArg, $author$project$Compiler$Parse$Pattern$term),
					function (arg) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$FuncSpace, $author$project$Compiler$Reporting$Error$Syntax$FuncIndentArrow),
							function (_v34) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Expression$chompArgs(
										_List_fromArray(
											[arg])),
									function (revArgs) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$FuncSpace, $author$project$Compiler$Reporting$Error$Syntax$FuncIndentBody),
											function (_v35) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2(
														$author$project$Compiler$Parse$Primitives$specialize,
														$author$project$Compiler$Reporting$Error$Syntax$FuncBody,
														$author$project$Compiler$Parse$Expression$cyclic$expression()),
													function (_v36) {
														var body = _v36.a;
														var end = _v36.b;
														var funcExpr = A2(
															$author$project$Compiler$AST$Source$Lambda,
															$author$project$Extra$Type$List$reverse(revArgs),
															body);
														return $author$project$Compiler$Parse$Primitives$return(
															_Utils_Tuple2(
																A3($author$project$Compiler$Reporting$Annotation$at, start, end, funcExpr),
																end));
													});
											});
									});
							});
					});
			}));
};
var $author$project$Compiler$Parse$Expression$if_ = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$If,
		$author$project$Compiler$Parse$Keyword$if_($author$project$Compiler$Reporting$Error$Syntax$Start),
		A2($author$project$Compiler$Parse$Expression$chompIfEnd, start, _List_Nil));
};
var $author$project$Compiler$Parse$Expression$let_ = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$Let,
		$author$project$Compiler$Parse$Keyword$let_($author$project$Compiler$Reporting$Error$Syntax$Start),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2(
				$author$project$Compiler$Parse$Primitives$withBacksetIndent,
				3,
				A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$LetSpace, $author$project$Compiler$Reporting$Error$Syntax$LetIndentDef),
					function (_v26) {
						return $author$project$Compiler$Parse$Primitives$withIndent(
							A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Expression$cyclic$chompLetDef(),
								function (_v27) {
									var def = _v27.a;
									var end = _v27.b;
									return A2(
										$author$project$Compiler$Parse$Expression$chompLetDefs,
										_List_fromArray(
											[def]),
										end);
								}));
					})),
			function (_v28) {
				var defs = _v28.a;
				var defsEnd = _v28.b;
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$checkIndent, defsEnd, $author$project$Compiler$Reporting$Error$Syntax$LetIndentIn),
					function (_v29) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Keyword$in_($author$project$Compiler$Reporting$Error$Syntax$LetIn),
							function (_v30) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$LetSpace, $author$project$Compiler$Reporting$Error$Syntax$LetIndentBody),
									function (_v31) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2(
												$author$project$Compiler$Parse$Primitives$specialize,
												$author$project$Compiler$Reporting$Error$Syntax$LetBody,
												$author$project$Compiler$Parse$Expression$cyclic$expression()),
											function (_v32) {
												var body = _v32.a;
												var end = _v32.b;
												return $author$project$Compiler$Parse$Primitives$return(
													_Utils_Tuple2(
														A3(
															$author$project$Compiler$Reporting$Annotation$at,
															start,
															end,
															A2($author$project$Compiler$AST$Source$Let, defs, body)),
														end));
											});
									});
							});
					});
			}));
};
var $author$project$Compiler$Parse$Expression$list = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$CList,
		A2($author$project$Compiler$Parse$Primitives$word1, 91, $author$project$Compiler$Reporting$Error$Syntax$Start),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ListSpace, $author$project$Compiler$Reporting$Error$Syntax$ListIndentOpen),
			function (_v22) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$ListOpen,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2(
								$author$project$Compiler$Parse$Primitives$specialize,
								$author$project$Compiler$Reporting$Error$Syntax$ListExpr,
								$author$project$Compiler$Parse$Expression$cyclic$expression()),
							function (_v23) {
								var entry = _v23.a;
								var end = _v23.b;
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$ListIndentEnd),
									function (_v24) {
										return A2(
											$author$project$Compiler$Parse$Primitives$loop,
											$author$project$Compiler$Parse$Expression$chompListEnd(start),
											_List_fromArray(
												[entry]));
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 93, $author$project$Compiler$Reporting$Error$Syntax$ListOpen),
							function (_v25) {
								return A2(
									$author$project$Compiler$Parse$Primitives$addEnd,
									start,
									$author$project$Compiler$AST$Source$CList(_List_Nil));
							})
						]));
			}));
};
var $author$project$Compiler$Parse$Expression$possiblyNegativeTerm = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$Start,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 45, $author$project$Compiler$Reporting$Error$Syntax$Start),
				function (_v21) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Expression$cyclic$term(),
						function (expr) {
							return A2(
								$author$project$Compiler$Parse$Primitives$addEnd,
								start,
								$author$project$Compiler$AST$Source$Negate(expr));
						});
				}),
				$author$project$Compiler$Parse$Expression$cyclic$term()
			]));
};
var $author$project$Compiler$Parse$Expression$record = function (start) {
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$Record,
		A2($author$project$Compiler$Parse$Primitives$word1, 123, $author$project$Compiler$Reporting$Error$Syntax$Start),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentOpen),
			function (_v12) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$RecordOpen,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$RecordOpen),
							function (_v13) {
								return A2(
									$author$project$Compiler$Parse$Primitives$addEnd,
									start,
									$author$project$Compiler$AST$Source$Record(_List_Nil));
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$addLocation(
								$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$RecordField)),
							function (starter) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentEquals),
									function (_v14) {
										return A2(
											$author$project$Compiler$Parse$Primitives$oneOf,
											$author$project$Compiler$Reporting$Error$Syntax$RecordEquals,
											_List_fromArray(
												[
													A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 124, $author$project$Compiler$Reporting$Error$Syntax$RecordEquals),
													function (_v15) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentField),
															function (_v16) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Expression$cyclic$chompField(),
																	function (firstField) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			$author$project$Compiler$Parse$Expression$chompFields(
																				_List_fromArray(
																					[firstField])),
																			function (fields) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$addEnd,
																					start,
																					A2($author$project$Compiler$AST$Source$Update, starter, fields));
																			});
																	});
															});
													}),
													A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$RecordEquals),
													function (_v17) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentExpr),
															function (_v18) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	A2(
																		$author$project$Compiler$Parse$Primitives$specialize,
																		$author$project$Compiler$Reporting$Error$Syntax$RecordExpr,
																		$author$project$Compiler$Parse$Expression$cyclic$expression()),
																	function (_v19) {
																		var value = _v19.a;
																		var end = _v19.b;
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentEnd),
																			function (_v20) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					$author$project$Compiler$Parse$Expression$chompFields(
																						_List_fromArray(
																							[
																								_Utils_Tuple2(starter, value)
																							])),
																					function (fields) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$addEnd,
																							start,
																							$author$project$Compiler$AST$Source$Record(fields));
																					});
																			});
																	});
															});
													})
												]));
									});
							})
						]));
			}));
};
var $author$project$Compiler$Parse$Expression$tuple = function (start) {
	var row = start.a;
	var col = start.b;
	return A3(
		$author$project$Compiler$Parse$Primitives$inContext,
		$author$project$Compiler$Reporting$Error$Syntax$Tuple,
		A2($author$project$Compiler$Parse$Primitives$word1, 40, $author$project$Compiler$Reporting$Error$Syntax$Start),
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Primitives$getPosition,
			function (before) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$TupleSpace, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentExpr1),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$getPosition,
							function (after) {
								return (!_Utils_eq(before, after)) ? A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Reporting$Error$Syntax$TupleExpr,
										$author$project$Compiler$Parse$Expression$cyclic$expression()),
									function (_v1) {
										var entry = _v1.a;
										var end = _v1.b;
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentEnd),
											function (_v2) {
												return A3($author$project$Compiler$Parse$Expression$chompTupleEnd, start, entry, _List_Nil);
											});
									}) : A2(
									$author$project$Compiler$Parse$Primitives$oneOf,
									$author$project$Compiler$Reporting$Error$Syntax$TupleIndentExpr1,
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Symbol$operator, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentExpr1, $author$project$Compiler$Reporting$Error$Syntax$TupleOperatorReserved),
											function (op) {
												return (op === '-') ? A2(
													$author$project$Compiler$Parse$Primitives$oneOf,
													$author$project$Compiler$Reporting$Error$Syntax$TupleOperatorClose,
													_List_fromArray(
														[
															A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$TupleOperatorClose),
															function (_v3) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$addEnd,
																	start,
																	$author$project$Compiler$AST$Source$Op(op));
															}),
															A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2(
																$author$project$Compiler$Parse$Primitives$specialize,
																$author$project$Compiler$Reporting$Error$Syntax$TupleExpr,
																A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Expression$cyclic$term(),
																	function (negatedExpr) {
																		var _v4 = negatedExpr.a;
																		var end = _v4.b;
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$Space),
																			function (_v5) {
																				var exprStart = A2($author$project$Compiler$Reporting$Annotation$Position, row, col + 2);
																				var expr = A3(
																					$author$project$Compiler$Reporting$Annotation$at,
																					exprStart,
																					end,
																					$author$project$Compiler$AST$Source$Negate(negatedExpr));
																				return A2(
																					$author$project$Compiler$Parse$Expression$chompExprEnd,
																					exprStart,
																					A4($author$project$Compiler$Parse$Expression$State, _List_Nil, expr, _List_Nil, end));
																			});
																	})),
															function (_v6) {
																var entry = _v6.a;
																var end = _v6.b;
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentEnd),
																	function (_v7) {
																		return A3($author$project$Compiler$Parse$Expression$chompTupleEnd, start, entry, _List_Nil);
																	});
															})
														])) : A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$TupleOperatorClose),
													function (_v8) {
														return A2(
															$author$project$Compiler$Parse$Primitives$addEnd,
															start,
															$author$project$Compiler$AST$Source$Op(op));
													});
											}),
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentExpr1),
											function (_v9) {
												return A2($author$project$Compiler$Parse$Primitives$addEnd, start, $author$project$Compiler$AST$Source$Unit);
											}),
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2(
												$author$project$Compiler$Parse$Primitives$specialize,
												$author$project$Compiler$Reporting$Error$Syntax$TupleExpr,
												$author$project$Compiler$Parse$Expression$cyclic$expression()),
											function (_v10) {
												var entry = _v10.a;
												var end = _v10.b;
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$TupleIndentEnd),
													function (_v11) {
														return A3($author$project$Compiler$Parse$Expression$chompTupleEnd, start, entry, _List_Nil);
													});
											})
										]));
							});
					});
			}));
};
function $author$project$Compiler$Parse$Expression$cyclic$chompBranch() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$CasePattern, $author$project$Compiler$Parse$Pattern$expression),
		function (_v98) {
			var pattern = _v98.a;
			var patternEnd = _v98.b;
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Space$checkIndent, patternEnd, $author$project$Compiler$Reporting$Error$Syntax$CaseIndentArrow),
				function (_v99) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A3($author$project$Compiler$Parse$Primitives$word2, 45, 62, $author$project$Compiler$Reporting$Error$Syntax$CaseArrow),
						function (_v100) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$CaseSpace, $author$project$Compiler$Reporting$Error$Syntax$CaseIndentBranch),
								function (_v101) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2(
											$author$project$Compiler$Parse$Primitives$specialize,
											$author$project$Compiler$Reporting$Error$Syntax$CaseBranch,
											$author$project$Compiler$Parse$Expression$cyclic$expression()),
										function (_v102) {
											var branchExpr = _v102.a;
											var end = _v102.b;
											return $author$project$Compiler$Parse$Primitives$return(
												_Utils_Tuple2(
													_Utils_Tuple2(pattern, branchExpr),
													end));
										});
								});
						});
				});
		});
}
function $author$project$Compiler$Parse$Expression$cyclic$chompField() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$addLocation(
			$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$RecordField)),
		function (key) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentEquals),
				function (_v77) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$RecordEquals),
						function (_v78) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$RecordSpace, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentExpr),
								function (_v79) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2(
											$author$project$Compiler$Parse$Primitives$specialize,
											$author$project$Compiler$Reporting$Error$Syntax$RecordExpr,
											$author$project$Compiler$Parse$Expression$cyclic$expression()),
										function (_v80) {
											var value = _v80.a;
											var end = _v80.b;
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$RecordIndentEnd),
												function (_v81) {
													return $author$project$Compiler$Parse$Primitives$return(
														_Utils_Tuple2(key, value));
												});
										});
								});
						});
				});
		});
}
function $author$project$Compiler$Parse$Expression$cyclic$chompLetDef() {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$LetDefName,
		_List_fromArray(
			[
				$author$project$Compiler$Parse$Expression$cyclic$definition(),
				$author$project$Compiler$Parse$Expression$cyclic$destructure()
			]));
}
function $author$project$Compiler$Parse$Expression$cyclic$definition() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$addLocation(
			$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$LetDefName)),
		function (aname) {
			var _v42 = aname.a;
			var start = _v42.a;
			var name = aname.b;
			return A2(
				$author$project$Compiler$Parse$Primitives$specialize,
				$author$project$Compiler$Reporting$Error$Syntax$LetDef(name),
				A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DefSpace, $author$project$Compiler$Reporting$Error$Syntax$DefIndentEquals),
					function (_v43) {
						return A2(
							$author$project$Compiler$Parse$Primitives$oneOf,
							$author$project$Compiler$Reporting$Error$Syntax$DefEquals,
							_List_fromArray(
								[
									A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Primitives$word1, 58, $author$project$Compiler$Reporting$Error$Syntax$DefEquals),
									function (_v44) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DefSpace, $author$project$Compiler$Reporting$Error$Syntax$DefIndentType),
											function (_v45) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$DefType, $author$project$Compiler$Parse$Type$expression),
													function (_v46) {
														var tipe = _v46.a;
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															$author$project$Compiler$Parse$Space$checkAligned($author$project$Compiler$Reporting$Error$Syntax$DefAlignment),
															function (_v47) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Expression$chompMatchingName(name),
																	function (defName) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DefSpace, $author$project$Compiler$Reporting$Error$Syntax$DefIndentEquals),
																			function (_v48) {
																				return A4(
																					$author$project$Compiler$Parse$Expression$chompDefArgsAndBody,
																					start,
																					defName,
																					$elm$core$Maybe$Just(tipe),
																					_List_Nil);
																			});
																	});
															});
													});
											});
									}),
									A4($author$project$Compiler$Parse$Expression$chompDefArgsAndBody, start, aname, $elm$core$Maybe$Nothing, _List_Nil)
								]));
					}));
		});
}
function $author$project$Compiler$Parse$Expression$cyclic$destructure() {
	return A2(
		$author$project$Compiler$Parse$Primitives$specialize,
		$author$project$Compiler$Reporting$Error$Syntax$LetDestruct,
		A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Primitives$getPosition,
			function (start) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$DestructPattern, $author$project$Compiler$Parse$Pattern$term),
					function (pattern) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DestructSpace, $author$project$Compiler$Reporting$Error$Syntax$DestructIndentEquals),
							function (_v38) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$DestructEquals),
									function (_v39) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DestructSpace, $author$project$Compiler$Reporting$Error$Syntax$DestructIndentBody),
											function (_v40) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2(
														$author$project$Compiler$Parse$Primitives$specialize,
														$author$project$Compiler$Reporting$Error$Syntax$DestructBody,
														$author$project$Compiler$Parse$Expression$cyclic$expression()),
													function (_v41) {
														var expr = _v41.a;
														var end = _v41.b;
														return $author$project$Compiler$Parse$Primitives$return(
															_Utils_Tuple2(
																A3(
																	$author$project$Compiler$Reporting$Annotation$at,
																	start,
																	end,
																	A2($author$project$Compiler$AST$Source$Destruct, pattern, expr)),
																end));
													});
											});
									});
							});
					});
			}));
}
function $author$project$Compiler$Parse$Expression$cyclic$expression() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$oneOf,
				$author$project$Compiler$Reporting$Error$Syntax$Start,
				_List_fromArray(
					[
						$author$project$Compiler$Parse$Expression$let_(start),
						$author$project$Compiler$Parse$Expression$if_(start),
						$author$project$Compiler$Parse$Expression$case_(start),
						$author$project$Compiler$Parse$Expression$function(start),
						A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Expression$possiblyNegativeTerm(start),
						function (expr) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Primitives$getPosition,
								function (end) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$Space),
										function (_v37) {
											return A2(
												$author$project$Compiler$Parse$Expression$chompExprEnd,
												start,
												A4($author$project$Compiler$Parse$Expression$State, _List_Nil, expr, _List_Nil, end));
										});
								});
						})
					]));
		});
}
function $author$project$Compiler$Parse$Expression$cyclic$term() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$oneOf,
				$author$project$Compiler$Reporting$Error$Syntax$Start,
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Expression$variable(start),
						$author$project$Compiler$Parse$Expression$accessible(start)),
						$author$project$Compiler$Parse$Expression$string(start),
						$author$project$Compiler$Parse$Expression$number(start),
						$author$project$Compiler$Parse$Shader$shader(start),
						$author$project$Compiler$Parse$Expression$list(start),
						A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Expression$record(start),
						$author$project$Compiler$Parse$Expression$accessible(start)),
						A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Expression$tuple(start),
						$author$project$Compiler$Parse$Expression$accessible(start)),
						$author$project$Compiler$Parse$Expression$accessor(start),
						$author$project$Compiler$Parse$Expression$character(start)
					]));
		});
}
try {
	var $author$project$Compiler$Parse$Expression$chompBranch = $author$project$Compiler$Parse$Expression$cyclic$chompBranch();
	$author$project$Compiler$Parse$Expression$cyclic$chompBranch = function () {
		return $author$project$Compiler$Parse$Expression$chompBranch;
	};
	var $author$project$Compiler$Parse$Expression$chompField = $author$project$Compiler$Parse$Expression$cyclic$chompField();
	$author$project$Compiler$Parse$Expression$cyclic$chompField = function () {
		return $author$project$Compiler$Parse$Expression$chompField;
	};
	var $author$project$Compiler$Parse$Expression$chompLetDef = $author$project$Compiler$Parse$Expression$cyclic$chompLetDef();
	$author$project$Compiler$Parse$Expression$cyclic$chompLetDef = function () {
		return $author$project$Compiler$Parse$Expression$chompLetDef;
	};
	var $author$project$Compiler$Parse$Expression$definition = $author$project$Compiler$Parse$Expression$cyclic$definition();
	$author$project$Compiler$Parse$Expression$cyclic$definition = function () {
		return $author$project$Compiler$Parse$Expression$definition;
	};
	var $author$project$Compiler$Parse$Expression$destructure = $author$project$Compiler$Parse$Expression$cyclic$destructure();
	$author$project$Compiler$Parse$Expression$cyclic$destructure = function () {
		return $author$project$Compiler$Parse$Expression$destructure;
	};
	var $author$project$Compiler$Parse$Expression$expression = $author$project$Compiler$Parse$Expression$cyclic$expression();
	$author$project$Compiler$Parse$Expression$cyclic$expression = function () {
		return $author$project$Compiler$Parse$Expression$expression;
	};
	var $author$project$Compiler$Parse$Expression$term = $author$project$Compiler$Parse$Expression$cyclic$term();
	$author$project$Compiler$Parse$Expression$cyclic$term = function () {
		return $author$project$Compiler$Parse$Expression$term;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Parse.Expression` are causing infinite recursion:\n\n  \n      case_\n       \n      chompBranch\n       \n      chompCaseEnd\n       \n      chompDefArgsAndBody\n       \n      chompExprEnd\n       \n      chompField\n       \n      chompFields\n       \n      chompIfEnd\n       \n      chompLetDef\n       \n      chompLetDefs\n       \n      chompListEnd\n       \n      chompTupleEnd\n       \n      definition\n       \n      destructure\n       \n      expression\n       \n      function\n       \n      if_\n       \n      let_\n       \n      list\n       \n      possiblyNegativeTerm\n       \n      record\n       \n      term\n       \n      tuple\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$Parse$Declaration$chompDefArgsAndBody = F4(
	function (start, name, tipe, revArgs) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$DeclDefEquals,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$DeclDefArg, $author$project$Compiler$Parse$Pattern$term),
					function (arg) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DeclDefSpace, $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentEquals),
							function (_v0) {
								return A4(
									$author$project$Compiler$Parse$Declaration$chompDefArgsAndBody,
									start,
									name,
									tipe,
									A2($elm$core$List$cons, arg, revArgs));
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$DeclDefEquals),
					function (_v1) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DeclDefSpace, $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentBody),
							function (_v2) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$DeclDefBody, $author$project$Compiler$Parse$Expression$expression),
									function (_v3) {
										var body = _v3.a;
										var end = _v3.b;
										var value = A4(
											$author$project$Compiler$AST$Source$Value,
											name,
											$author$project$Extra$Type$List$reverse(revArgs),
											body,
											tipe);
										var avalue = A3($author$project$Compiler$Reporting$Annotation$at, start, end, value);
										return $author$project$Compiler$Parse$Primitives$return(
											_Utils_Tuple2(
												$author$project$Compiler$Parse$Declaration$Value(avalue),
												end));
									});
							});
					})
				]));
	});
var $author$project$Compiler$Reporting$Error$Syntax$DeclDefNameMatch = F3(
	function (a, b, c) {
		return {$: 'DeclDefNameMatch', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Declaration$chompMatchingName = function (expectedName) {
	var _v0 = $author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$DeclDefNameRepeat);
	var parserL = _v0.a;
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (state) {
			var sr = state.e;
			var sc = state.f;
			var _v1 = parserL(state);
			switch (_v1.$) {
				case 'Cok':
					var name = _v1.a;
					var newState = _v1.b;
					var er = newState.e;
					var ec = newState.f;
					return _Utils_eq(expectedName, name) ? A2(
						$author$project$Compiler$Parse$Primitives$Cok,
						A2(
							$author$project$Compiler$Reporting$Annotation$At,
							A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, sr, sc),
								A2($author$project$Compiler$Reporting$Annotation$Position, er, ec)),
							name),
						newState) : A3(
						$author$project$Compiler$Parse$Primitives$Cerr,
						sr,
						sc,
						$author$project$Compiler$Reporting$Error$Syntax$DeclDefNameMatch(name));
				case 'Eok':
					var name = _v1.a;
					var newState = _v1.b;
					var er = newState.e;
					var ec = newState.f;
					return _Utils_eq(expectedName, name) ? A2(
						$author$project$Compiler$Parse$Primitives$Eok,
						A2(
							$author$project$Compiler$Reporting$Annotation$At,
							A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, sr, sc),
								A2($author$project$Compiler$Reporting$Annotation$Position, er, ec)),
							name),
						newState) : A3(
						$author$project$Compiler$Parse$Primitives$Eerr,
						sr,
						sc,
						$author$project$Compiler$Reporting$Error$Syntax$DeclDefNameMatch(name));
				case 'Cerr':
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Cerr, r, c, t);
				default:
					var r = _v1.a;
					var c = _v1.b;
					var t = _v1.c;
					return A3($author$project$Compiler$Parse$Primitives$Eerr, r, c, t);
			}
		});
};
var $author$project$Compiler$Parse$Declaration$valueDecl = function (start) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$DeclStart),
		function (name) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Primitives$getPosition,
				function (end) {
					return A2(
						$author$project$Compiler$Parse$Primitives$specialize,
						$author$project$Compiler$Reporting$Error$Syntax$DeclDef(name),
						A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DeclDefSpace, $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentEquals),
							function (_v0) {
								return A2(
									$author$project$Compiler$Parse$Primitives$oneOf,
									$author$project$Compiler$Reporting$Error$Syntax$DeclDefEquals,
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Primitives$word1, 58, $author$project$Compiler$Reporting$Error$Syntax$DeclDefEquals),
											function (_v1) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DeclDefSpace, $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentType),
													function (_v2) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$DeclDefType, $author$project$Compiler$Parse$Type$expression),
															function (_v3) {
																var tipe = _v3.a;
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Reporting$Error$Syntax$DeclDefNameRepeat),
																	function (_v4) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			$author$project$Compiler$Parse$Declaration$chompMatchingName(name),
																			function (defName) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$DeclDefSpace, $author$project$Compiler$Reporting$Error$Syntax$DeclDefIndentEquals),
																					function (_v5) {
																						return A4(
																							$author$project$Compiler$Parse$Declaration$chompDefArgsAndBody,
																							start,
																							defName,
																							$elm$core$Maybe$Just(tipe),
																							_List_Nil);
																					});
																			});
																	});
															});
													});
											}),
											A4(
											$author$project$Compiler$Parse$Declaration$chompDefArgsAndBody,
											start,
											A3($author$project$Compiler$Reporting$Annotation$at, start, end, name),
											$elm$core$Maybe$Nothing,
											_List_Nil)
										]));
							}));
				});
		});
};
var $author$project$Compiler$Parse$Declaration$declaration = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Declaration$chompDocComment,
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Primitives$getPosition,
			function (start) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$DeclStart,
					_List_fromArray(
						[
							$author$project$Compiler$Parse$Declaration$typeDecl(start),
							$author$project$Compiler$Parse$Declaration$portDecl,
							$author$project$Compiler$Parse$Declaration$valueDecl(start)
						]));
			});
	});
var $author$project$Compiler$Parse$Primitives$toErr = F3(
	function (row, col, toError) {
		return $author$project$Extra$Type$Either$Left(
			A2(toError, row, col));
	});
var $author$project$Compiler$Parse$Primitives$toOk = F3(
	function (toBadEnd, a, _v0) {
		var pos = _v0.b;
		var end = _v0.c;
		var row = _v0.e;
		var col = _v0.f;
		return _Utils_eq(pos, end) ? $author$project$Extra$Type$Either$Right(a) : $author$project$Extra$Type$Either$Left(
			A2(toBadEnd, row, col));
	});
var $author$project$Compiler$Parse$Primitives$fromByteString = F3(
	function (_v0, toBadEnd, fptr) {
		var parser = _v0.a;
		var toOk_ = $author$project$Compiler$Parse$Primitives$toOk(toBadEnd);
		var pos = 0;
		var end = $elm$core$String$length(fptr);
		var result = parser(
			A6($author$project$Compiler$Parse$Primitives$State, fptr, pos, end, 0, 1, 1));
		switch (result.$) {
			case 'Cok':
				var a = result.a;
				var s = result.b;
				return A2(toOk_, a, s);
			case 'Eok':
				var a = result.a;
				var s = result.b;
				return A2(toOk_, a, s);
			case 'Cerr':
				var r = result.a;
				var c = result.b;
				var t = result.c;
				return A3($author$project$Compiler$Parse$Primitives$toErr, r, c, t);
			default:
				var r = result.a;
				var c = result.b;
				var t = result.c;
				return A3($author$project$Compiler$Parse$Primitives$toErr, r, c, t);
		}
	});
var $author$project$Terminal$Repl$Indent = {$: 'Indent'};
var $author$project$Terminal$Repl$endsWithBlankLine = function (_v0) {
	var prev = _v0.a;
	return A2(
		$elm$core$String$all,
		$elm$core$Basics$eq(
			_Utils_chr(' ')),
		prev);
};
var $elm$core$List$isEmpty = function (xs) {
	if (!xs.b) {
		return true;
	} else {
		return false;
	}
};
var $author$project$Extra$Type$List$null = $elm$core$List$isEmpty;
var $author$project$Terminal$Repl$isSingleLine = function (_v0) {
	var rev = _v0.b;
	return $author$project$Extra$Type$List$null(rev);
};
var $author$project$Terminal$Repl$ifDone = F2(
	function (lines, input) {
		return ($author$project$Terminal$Repl$isSingleLine(lines) || $author$project$Terminal$Repl$endsWithBlankLine(lines)) ? $author$project$Terminal$Repl$Done(input) : $author$project$Terminal$Repl$Continue($author$project$Terminal$Repl$Indent);
	});
var $author$project$Terminal$Repl$ifFail = F2(
	function (lines, input) {
		return $author$project$Terminal$Repl$endsWithBlankLine(lines) ? $author$project$Terminal$Repl$Done(input) : $author$project$Terminal$Repl$Continue($author$project$Terminal$Repl$Indent);
	});
var $author$project$Terminal$Repl$linesToByteString = function (_v0) {
	var prev = _v0.a;
	var rev = _v0.b;
	return A2(
		$elm$core$String$join,
		'\n',
		$author$project$Extra$Type$List$reverse(
			A2($elm$core$List$cons, prev, rev))) + '\n';
};
var $author$project$Terminal$Repl$getFirstLine = function (_v0) {
	getFirstLine:
	while (true) {
		var x = _v0.a;
		var xs = _v0.b;
		if (!xs.b) {
			return x;
		} else {
			var y = xs.a;
			var ys = xs.b;
			var $temp$_v0 = A2($author$project$Terminal$Repl$Lines, y, ys);
			_v0 = $temp$_v0;
			continue getFirstLine;
		}
	}
};
var $miniBill$elm_unicode$Unicode$isAlphaNum = function (c) {
	var code = $elm$core$Char$toCode(c);
	var e = function (hex) {
		return _Utils_eq(hex, code);
	};
	var l = function (hex) {
		return _Utils_cmp(code, hex) < 0;
	};
	var r = F2(
		function (from, to) {
			return (_Utils_cmp(from, code) < 1) && (_Utils_cmp(code, to) < 1);
		});
	return l(256) ? (A2(r, 48, 57) || (A2(r, 65, 90) || (A2(r, 97, 122) || (e(170) || (A2(r, 178, 179) || (e(181) || (A2(r, 185, 186) || (A2(r, 188, 190) || (A2(r, 192, 214) || (A2(r, 216, 246) || A2(r, 248, 255))))))))))) : (l(43700) ? (l(4347) ? (l(2868) ? (l(2364) ? (l(1648) ? (l(930) ? (A2(r, 256, 705) || (A2(r, 710, 721) || (A2(r, 736, 740) || (A2(r, 880, 884) || (A2(r, 886, 887) || (A2(r, 890, 893) || (e(895) || (e(902) || (A2(r, 904, 906) || (e(908) || (A2(r, 910, 929) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 748, 750))))))))))))) : (A2(r, 931, 1013) || (A2(r, 1015, 1153) || (A2(r, 1162, 1327) || (A2(r, 1329, 1366) || (e(1369) || (A2(r, 1376, 1416) || (A2(r, 1488, 1514) || (A2(r, 1519, 1522) || (A2(r, 1568, 1610) || (A2(r, 1632, 1641) || A2(r, 1646, 1647)))))))))))) : (l(2041) ? (A2(r, 1649, 1747) || (e(1749) || (A2(r, 1765, 1766) || (A2(r, 1774, 1788) || (e(1791) || (e(1808) || (A2(r, 1810, 1839) || (A2(r, 1869, 1957) || (e(1969) || (A2(r, 1984, 2026) || A2(r, 2036, 2037))))))))))) : (e(2042) || (A2(r, 2048, 2069) || (e(2074) || (e(2084) || (e(2088) || (A2(r, 2112, 2136) || (A2(r, 2144, 2154) || (A2(r, 2160, 2183) || (A2(r, 2185, 2190) || (A2(r, 2208, 2249) || A2(r, 2308, 2361))))))))))))) : (l(2609) ? (l(2492) ? (e(2365) || (e(2384) || (A2(r, 2392, 2401) || (A2(r, 2406, 2415) || (A2(r, 2417, 2432) || (A2(r, 2437, 2444) || (A2(r, 2447, 2448) || (A2(r, 2451, 2472) || (A2(r, 2474, 2480) || (e(2482) || A2(r, 2486, 2489))))))))))) : (e(2493) || (e(2510) || (A2(r, 2524, 2525) || (A2(r, 2527, 2529) || (A2(r, 2534, 2545) || (A2(r, 2548, 2553) || (e(2556) || (A2(r, 2565, 2570) || (A2(r, 2575, 2576) || (A2(r, 2579, 2600) || A2(r, 2602, 2608)))))))))))) : (l(2737) ? (A2(r, 2610, 2611) || (A2(r, 2613, 2614) || (A2(r, 2616, 2617) || (A2(r, 2649, 2652) || (e(2654) || (A2(r, 2662, 2671) || (A2(r, 2674, 2676) || (A2(r, 2693, 2701) || (A2(r, 2703, 2705) || (A2(r, 2707, 2728) || A2(r, 2730, 2736))))))))))) : (A2(r, 2738, 2739) || (A2(r, 2741, 2745) || (e(2749) || (e(2768) || (A2(r, 2784, 2785) || (A2(r, 2790, 2799) || (e(2809) || (A2(r, 2821, 2828) || (A2(r, 2831, 2832) || (A2(r, 2835, 2856) || (A2(r, 2858, 2864) || A2(r, 2866, 2867))))))))))))))) : (l(3411) ? (l(3132) ? (l(2971) ? (A2(r, 2869, 2873) || (e(2877) || (A2(r, 2908, 2909) || (A2(r, 2911, 2913) || (A2(r, 2918, 2927) || (A2(r, 2929, 2935) || (e(2947) || (A2(r, 2949, 2954) || (A2(r, 2958, 2960) || (A2(r, 2962, 2965) || A2(r, 2969, 2970))))))))))) : (e(2972) || (A2(r, 2974, 2975) || (A2(r, 2979, 2980) || (A2(r, 2984, 2986) || (A2(r, 2990, 3001) || (e(3024) || (A2(r, 3046, 3058) || (A2(r, 3077, 3084) || (A2(r, 3086, 3088) || (A2(r, 3090, 3112) || A2(r, 3114, 3129)))))))))))) : (l(3252) ? (e(3133) || (A2(r, 3160, 3162) || (e(3165) || (A2(r, 3168, 3169) || (A2(r, 3174, 3183) || (A2(r, 3192, 3198) || (e(3200) || (A2(r, 3205, 3212) || (A2(r, 3214, 3216) || (A2(r, 3218, 3240) || A2(r, 3242, 3251))))))))))) : (A2(r, 3253, 3257) || (e(3261) || (A2(r, 3293, 3294) || (A2(r, 3296, 3297) || (A2(r, 3302, 3311) || (A2(r, 3313, 3314) || (A2(r, 3332, 3340) || (A2(r, 3342, 3344) || (A2(r, 3346, 3386) || (e(3389) || e(3406))))))))))))) : (l(3775) ? (l(3633) ? (A2(r, 3412, 3414) || (A2(r, 3416, 3425) || (A2(r, 3430, 3448) || (A2(r, 3450, 3455) || (A2(r, 3461, 3478) || (A2(r, 3482, 3505) || (A2(r, 3507, 3515) || (e(3517) || (A2(r, 3520, 3526) || (A2(r, 3558, 3567) || A2(r, 3585, 3632))))))))))) : (A2(r, 3634, 3635) || (A2(r, 3648, 3654) || (A2(r, 3664, 3673) || (A2(r, 3713, 3714) || (e(3716) || (A2(r, 3718, 3722) || (A2(r, 3724, 3747) || (e(3749) || (A2(r, 3751, 3760) || (A2(r, 3762, 3763) || e(3773)))))))))))) : (l(4175) ? (A2(r, 3776, 3780) || (e(3782) || (A2(r, 3792, 3801) || (A2(r, 3804, 3807) || (e(3840) || (A2(r, 3872, 3891) || (A2(r, 3904, 3911) || (A2(r, 3913, 3948) || (A2(r, 3976, 3980) || (A2(r, 4096, 4138) || A2(r, 4159, 4169))))))))))) : (A2(r, 4176, 4181) || (A2(r, 4186, 4189) || (e(4193) || (A2(r, 4197, 4198) || (A2(r, 4206, 4208) || (A2(r, 4213, 4225) || (e(4238) || (A2(r, 4240, 4249) || (A2(r, 4256, 4293) || (e(4295) || (e(4301) || A2(r, 4304, 4346)))))))))))))))) : (l(8454) ? (l(6527) ? (l(5760) ? (l(4801) ? (A2(r, 4348, 4680) || (A2(r, 4682, 4685) || (A2(r, 4688, 4694) || (e(4696) || (A2(r, 4698, 4701) || (A2(r, 4704, 4744) || (A2(r, 4746, 4749) || (A2(r, 4752, 4784) || (A2(r, 4786, 4789) || (A2(r, 4792, 4798) || e(4800))))))))))) : (A2(r, 4802, 4805) || (A2(r, 4808, 4822) || (A2(r, 4824, 4880) || (A2(r, 4882, 4885) || (A2(r, 4888, 4954) || (A2(r, 4969, 4988) || (A2(r, 4992, 5007) || (A2(r, 5024, 5109) || (A2(r, 5112, 5117) || (A2(r, 5121, 5740) || A2(r, 5743, 5759)))))))))))) : (l(6111) ? (A2(r, 5761, 5786) || (A2(r, 5792, 5866) || (A2(r, 5870, 5880) || (A2(r, 5888, 5905) || (A2(r, 5919, 5937) || (A2(r, 5952, 5969) || (A2(r, 5984, 5996) || (A2(r, 5998, 6000) || (A2(r, 6016, 6067) || (e(6103) || e(6108))))))))))) : (A2(r, 6112, 6121) || (A2(r, 6128, 6137) || (A2(r, 6160, 6169) || (A2(r, 6176, 6264) || (A2(r, 6272, 6276) || (A2(r, 6279, 6312) || (e(6314) || (A2(r, 6320, 6389) || (A2(r, 6400, 6430) || (A2(r, 6470, 6509) || A2(r, 6512, 6516))))))))))))) : (l(7417) ? (l(7042) ? (A2(r, 6528, 6571) || (A2(r, 6576, 6601) || (A2(r, 6608, 6618) || (A2(r, 6656, 6678) || (A2(r, 6688, 6740) || (A2(r, 6784, 6793) || (A2(r, 6800, 6809) || (e(6823) || (A2(r, 6917, 6963) || (A2(r, 6981, 6988) || A2(r, 6992, 7001))))))))))) : (A2(r, 7043, 7072) || (A2(r, 7086, 7141) || (A2(r, 7168, 7203) || (A2(r, 7232, 7241) || (A2(r, 7245, 7293) || (A2(r, 7296, 7304) || (A2(r, 7312, 7354) || (A2(r, 7357, 7359) || (A2(r, 7401, 7404) || (A2(r, 7406, 7411) || A2(r, 7413, 7414)))))))))))) : (l(8129) ? (e(7418) || (A2(r, 7424, 7615) || (A2(r, 7680, 7957) || (A2(r, 7960, 7965) || (A2(r, 7968, 8005) || (A2(r, 8008, 8013) || (A2(r, 8016, 8023) || (A2(r, 8032, 8061) || (A2(r, 8064, 8116) || (A2(r, 8118, 8124) || (e(8126) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 8025, 8031))))))))))))) : (A2(r, 8130, 8132) || (A2(r, 8134, 8140) || (A2(r, 8144, 8147) || (A2(r, 8150, 8155) || (A2(r, 8160, 8172) || (A2(r, 8178, 8180) || (A2(r, 8182, 8188) || (A2(r, 8304, 8305) || (A2(r, 8308, 8313) || (A2(r, 8319, 8329) || (A2(r, 8336, 8348) || e(8450))))))))))))))) : (l(12783) ? (l(11647) ? (l(9449) ? (e(8455) || (A2(r, 8458, 8467) || (e(8469) || (A2(r, 8473, 8477) || (A2(r, 8490, 8493) || (A2(r, 8495, 8505) || (A2(r, 8508, 8511) || (A2(r, 8517, 8521) || (e(8526) || (A2(r, 8528, 8585) || (A2(r, 9312, 9371) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 8484, 8488))))))))))))) : (A2(r, 9450, 9471) || (A2(r, 10102, 10131) || (A2(r, 11264, 11492) || (A2(r, 11499, 11502) || (A2(r, 11506, 11507) || (e(11517) || (A2(r, 11520, 11557) || (e(11559) || (e(11565) || (A2(r, 11568, 11623) || e(11631)))))))))))) : (l(12320) ? (A2(r, 11648, 11670) || (A2(r, 11680, 11686) || (A2(r, 11688, 11694) || (A2(r, 11696, 11702) || (A2(r, 11704, 11710) || (A2(r, 11712, 11718) || (A2(r, 11720, 11726) || (A2(r, 11728, 11734) || (A2(r, 11736, 11742) || (e(11823) || A2(r, 12293, 12295))))))))))) : (A2(r, 12321, 12329) || (A2(r, 12337, 12341) || (A2(r, 12344, 12348) || (A2(r, 12353, 12438) || (A2(r, 12445, 12447) || (A2(r, 12449, 12538) || (A2(r, 12540, 12543) || (A2(r, 12549, 12591) || (A2(r, 12593, 12686) || (A2(r, 12690, 12693) || A2(r, 12704, 12735))))))))))))) : (l(43019) ? (l(42559) ? (A2(r, 12784, 12799) || (A2(r, 12832, 12841) || (A2(r, 12872, 12879) || (A2(r, 12881, 12895) || (A2(r, 12928, 12937) || (A2(r, 12977, 12991) || (A2(r, 13312, 19903) || (A2(r, 19968, 42124) || (A2(r, 42192, 42237) || (A2(r, 42240, 42508) || A2(r, 42512, 42539))))))))))) : (A2(r, 42560, 42606) || (A2(r, 42623, 42653) || (A2(r, 42656, 42735) || (A2(r, 42775, 42783) || (A2(r, 42786, 42888) || (A2(r, 42891, 42954) || (A2(r, 42960, 42961) || (A2(r, 42966, 42969) || (A2(r, 42994, 43009) || (A2(r, 43011, 43013) || (A2(r, 43015, 43018) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && A2(r, 42963, 42965)))))))))))))) : (l(43395) ? (A2(r, 43020, 43042) || (A2(r, 43056, 43061) || (A2(r, 43072, 43123) || (A2(r, 43138, 43187) || (A2(r, 43216, 43225) || (A2(r, 43250, 43255) || (e(43259) || (A2(r, 43261, 43262) || (A2(r, 43264, 43301) || (A2(r, 43312, 43334) || A2(r, 43360, 43388))))))))))) : (A2(r, 43396, 43442) || (A2(r, 43471, 43481) || (A2(r, 43488, 43492) || (A2(r, 43494, 43518) || (A2(r, 43520, 43560) || (A2(r, 43584, 43586) || (A2(r, 43588, 43595) || (A2(r, 43600, 43609) || (A2(r, 43616, 43638) || (e(43642) || (A2(r, 43646, 43695) || e(43697))))))))))))))))) : (l(71351) ? (l(67671) ? (l(65548) ? (l(64286) ? (l(43867) ? (A2(r, 43701, 43702) || (A2(r, 43705, 43709) || (A2(r, 43739, 43741) || (A2(r, 43744, 43754) || (A2(r, 43762, 43764) || (A2(r, 43777, 43782) || (A2(r, 43785, 43790) || (A2(r, 43793, 43798) || (A2(r, 43808, 43814) || (A2(r, 43816, 43822) || (A2(r, 43824, 43866) || ((!A2($elm$core$Basics$modBy, 2, code)) && A2(r, 43712, 43714))))))))))))) : (A2(r, 43868, 43881) || (A2(r, 43888, 44002) || (A2(r, 44016, 44025) || (A2(r, 44032, 55203) || (A2(r, 55216, 55238) || (A2(r, 55243, 55291) || (A2(r, 63744, 64109) || (A2(r, 64112, 64217) || (A2(r, 64256, 64262) || (A2(r, 64275, 64279) || e(64285)))))))))))) : (l(65135) ? (A2(r, 64287, 64296) || (A2(r, 64298, 64310) || (A2(r, 64312, 64316) || (e(64318) || (A2(r, 64320, 64321) || (A2(r, 64323, 64324) || (A2(r, 64326, 64433) || (A2(r, 64467, 64829) || (A2(r, 64848, 64911) || (A2(r, 64914, 64967) || A2(r, 65008, 65019))))))))))) : (A2(r, 65136, 65140) || (A2(r, 65142, 65276) || (A2(r, 65296, 65305) || (A2(r, 65313, 65338) || (A2(r, 65345, 65370) || (A2(r, 65382, 65470) || (A2(r, 65474, 65479) || (A2(r, 65482, 65487) || (A2(r, 65490, 65495) || (A2(r, 65498, 65500) || A2(r, 65536, 65547))))))))))))) : (l(66775) ? (l(66272) ? (A2(r, 65549, 65574) || (A2(r, 65576, 65594) || (A2(r, 65596, 65597) || (A2(r, 65599, 65613) || (A2(r, 65616, 65629) || (A2(r, 65664, 65786) || (A2(r, 65799, 65843) || (A2(r, 65856, 65912) || (A2(r, 65930, 65931) || (A2(r, 66176, 66204) || A2(r, 66208, 66256))))))))))) : (A2(r, 66273, 66299) || (A2(r, 66304, 66339) || (A2(r, 66349, 66378) || (A2(r, 66384, 66421) || (A2(r, 66432, 66461) || (A2(r, 66464, 66499) || (A2(r, 66504, 66511) || (A2(r, 66513, 66517) || (A2(r, 66560, 66717) || (A2(r, 66720, 66729) || A2(r, 66736, 66771)))))))))))) : (l(67071) ? (A2(r, 66776, 66811) || (A2(r, 66816, 66855) || (A2(r, 66864, 66915) || (A2(r, 66928, 66938) || (A2(r, 66940, 66954) || (A2(r, 66956, 66962) || (A2(r, 66964, 66965) || (A2(r, 66967, 66977) || (A2(r, 66979, 66993) || (A2(r, 66995, 67001) || A2(r, 67003, 67004))))))))))) : (A2(r, 67072, 67382) || (A2(r, 67392, 67413) || (A2(r, 67424, 67431) || (A2(r, 67456, 67461) || (A2(r, 67463, 67504) || (A2(r, 67506, 67514) || (A2(r, 67584, 67589) || (e(67592) || (A2(r, 67594, 67637) || (A2(r, 67639, 67640) || (e(67644) || A2(r, 67647, 67669))))))))))))))) : (l(69871) ? (l(68471) ? (l(68116) ? (A2(r, 67672, 67702) || (A2(r, 67705, 67742) || (A2(r, 67751, 67759) || (A2(r, 67808, 67826) || (A2(r, 67828, 67829) || (A2(r, 67835, 67867) || (A2(r, 67872, 67897) || (A2(r, 67968, 68023) || (A2(r, 68028, 68047) || (A2(r, 68050, 68096) || A2(r, 68112, 68115))))))))))) : (A2(r, 68117, 68119) || (A2(r, 68121, 68149) || (A2(r, 68160, 68168) || (A2(r, 68192, 68222) || (A2(r, 68224, 68255) || (A2(r, 68288, 68295) || (A2(r, 68297, 68324) || (A2(r, 68331, 68335) || (A2(r, 68352, 68405) || (A2(r, 68416, 68437) || A2(r, 68440, 68466)))))))))))) : (l(69423) ? (A2(r, 68472, 68497) || (A2(r, 68521, 68527) || (A2(r, 68608, 68680) || (A2(r, 68736, 68786) || (A2(r, 68800, 68850) || (A2(r, 68858, 68899) || (A2(r, 68912, 68921) || (A2(r, 69216, 69246) || (A2(r, 69248, 69289) || (A2(r, 69296, 69297) || A2(r, 69376, 69415))))))))))) : (A2(r, 69424, 69445) || (A2(r, 69457, 69460) || (A2(r, 69488, 69505) || (A2(r, 69552, 69579) || (A2(r, 69600, 69622) || (A2(r, 69635, 69687) || (A2(r, 69714, 69743) || (A2(r, 69745, 69746) || (e(69749) || (A2(r, 69763, 69807) || A2(r, 69840, 69864))))))))))))) : (l(70404) ? (l(70112) ? (A2(r, 69872, 69881) || (A2(r, 69891, 69926) || (A2(r, 69942, 69951) || (e(69956) || (e(69959) || (A2(r, 69968, 70002) || (e(70006) || (A2(r, 70019, 70066) || (A2(r, 70081, 70084) || (A2(r, 70096, 70106) || e(70108))))))))))) : (A2(r, 70113, 70132) || (A2(r, 70144, 70161) || (A2(r, 70163, 70187) || (A2(r, 70207, 70208) || (A2(r, 70272, 70278) || (e(70280) || (A2(r, 70282, 70285) || (A2(r, 70287, 70301) || (A2(r, 70303, 70312) || (A2(r, 70320, 70366) || A2(r, 70384, 70393)))))))))))) : (l(70735) ? (A2(r, 70405, 70412) || (A2(r, 70415, 70416) || (A2(r, 70419, 70440) || (A2(r, 70442, 70448) || (A2(r, 70450, 70451) || (A2(r, 70453, 70457) || (e(70461) || (e(70480) || (A2(r, 70493, 70497) || (A2(r, 70656, 70708) || A2(r, 70727, 70730))))))))))) : (A2(r, 70736, 70745) || (A2(r, 70751, 70753) || (A2(r, 70784, 70831) || (A2(r, 70852, 70853) || (e(70855) || (A2(r, 70864, 70873) || (A2(r, 71040, 71086) || (A2(r, 71128, 71131) || (A2(r, 71168, 71215) || (e(71236) || (A2(r, 71248, 71257) || A2(r, 71296, 71338)))))))))))))))) : (l(119893) ? (l(73727) ? (l(72703) ? (l(71959) ? (e(71352) || (A2(r, 71360, 71369) || (A2(r, 71424, 71450) || (A2(r, 71472, 71483) || (A2(r, 71488, 71494) || (A2(r, 71680, 71723) || (A2(r, 71840, 71922) || (A2(r, 71935, 71942) || (e(71945) || (A2(r, 71948, 71955) || A2(r, 71957, 71958))))))))))) : (A2(r, 71960, 71983) || (A2(r, 72016, 72025) || (A2(r, 72096, 72103) || (A2(r, 72106, 72144) || (e(72192) || (A2(r, 72203, 72242) || (e(72250) || (e(72272) || (A2(r, 72284, 72329) || (e(72349) || (A2(r, 72368, 72440) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && (A2(r, 71999, 72001) || A2(r, 72161, 72163))))))))))))))) : (l(73062) ? (A2(r, 72704, 72712) || (A2(r, 72714, 72750) || (e(72768) || (A2(r, 72784, 72812) || (A2(r, 72818, 72847) || (A2(r, 72960, 72966) || (A2(r, 72968, 72969) || (A2(r, 72971, 73008) || (e(73030) || (A2(r, 73040, 73049) || A2(r, 73056, 73061))))))))))) : (A2(r, 73063, 73064) || (A2(r, 73066, 73097) || (e(73112) || (A2(r, 73120, 73129) || (A2(r, 73440, 73458) || (e(73474) || (A2(r, 73476, 73488) || (A2(r, 73490, 73523) || (A2(r, 73552, 73561) || (e(73648) || A2(r, 73664, 73684))))))))))))) : (l(94098) ? (l(92863) ? (A2(r, 73728, 74649) || (A2(r, 74752, 74862) || (A2(r, 74880, 75075) || (A2(r, 77712, 77808) || (A2(r, 77824, 78895) || (A2(r, 78913, 78918) || (A2(r, 82944, 83526) || (A2(r, 92160, 92728) || (A2(r, 92736, 92766) || (A2(r, 92768, 92777) || A2(r, 92784, 92862))))))))))) : (A2(r, 92864, 92873) || (A2(r, 92880, 92909) || (A2(r, 92928, 92975) || (A2(r, 92992, 92995) || (A2(r, 93008, 93017) || (A2(r, 93019, 93025) || (A2(r, 93027, 93047) || (A2(r, 93053, 93071) || (A2(r, 93760, 93846) || (A2(r, 93952, 94026) || e(94032)))))))))))) : (l(110927) ? (A2(r, 94099, 94111) || (A2(r, 94176, 94177) || (e(94179) || (A2(r, 94208, 100343) || (A2(r, 100352, 101589) || (A2(r, 101632, 101640) || (A2(r, 110576, 110579) || (A2(r, 110581, 110587) || (A2(r, 110589, 110590) || (A2(r, 110592, 110882) || e(110898))))))))))) : (A2(r, 110928, 110930) || (e(110933) || (A2(r, 110948, 110951) || (A2(r, 110960, 111355) || (A2(r, 113664, 113770) || (A2(r, 113776, 113788) || (A2(r, 113792, 113800) || (A2(r, 113808, 113817) || (A2(r, 119488, 119507) || (A2(r, 119520, 119539) || (A2(r, 119648, 119672) || A2(r, 119808, 119892))))))))))))))) : (l(124911) ? (l(120597) ? (l(120085) ? (A2(r, 119894, 119964) || (A2(r, 119966, 119967) || (e(119970) || (A2(r, 119973, 119974) || (A2(r, 119977, 119980) || (A2(r, 119982, 119993) || (e(119995) || (A2(r, 119997, 120003) || (A2(r, 120005, 120069) || (A2(r, 120071, 120074) || A2(r, 120077, 120084))))))))))) : (A2(r, 120086, 120092) || (A2(r, 120094, 120121) || (A2(r, 120123, 120126) || (A2(r, 120128, 120132) || (e(120134) || (A2(r, 120138, 120144) || (A2(r, 120146, 120485) || (A2(r, 120488, 120512) || (A2(r, 120514, 120538) || (A2(r, 120540, 120570) || A2(r, 120572, 120596)))))))))))) : (l(123135) ? (A2(r, 120598, 120628) || (A2(r, 120630, 120654) || (A2(r, 120656, 120686) || (A2(r, 120688, 120712) || (A2(r, 120714, 120744) || (A2(r, 120746, 120770) || (A2(r, 120772, 120779) || (A2(r, 120782, 120831) || (A2(r, 122624, 122654) || (A2(r, 122661, 122666) || A2(r, 122928, 122989))))))))))) : (A2(r, 123136, 123180) || (A2(r, 123191, 123197) || (A2(r, 123200, 123209) || (e(123214) || (A2(r, 123536, 123565) || (A2(r, 123584, 123627) || (A2(r, 123632, 123641) || (A2(r, 124112, 124139) || (A2(r, 124144, 124153) || (A2(r, 124896, 124902) || (A2(r, 124904, 124907) || A2(r, 124909, 124910)))))))))))))) : (l(126560) ? (l(126463) ? (A2(r, 124912, 124926) || (A2(r, 124928, 125124) || (A2(r, 125127, 125135) || (A2(r, 125184, 125251) || (e(125259) || (A2(r, 125264, 125273) || (A2(r, 126065, 126123) || (A2(r, 126125, 126127) || (A2(r, 126129, 126132) || (A2(r, 126209, 126253) || A2(r, 126255, 126269))))))))))) : (A2(r, 126464, 126467) || (A2(r, 126469, 126495) || (A2(r, 126497, 126498) || (e(126500) || (e(126503) || (A2(r, 126505, 126514) || (A2(r, 126516, 126519) || (e(126530) || (A2(r, 126541, 126543) || (A2(r, 126545, 126546) || (e(126548) || ((A2($elm$core$Basics$modBy, 2, code) === 1) && (A2(r, 126521, 126523) || (A2(r, 126535, 126539) || A2(r, 126551, 126559)))))))))))))))) : (l(126634) ? (A2(r, 126561, 126562) || (e(126564) || (A2(r, 126567, 126570) || (A2(r, 126572, 126578) || (A2(r, 126580, 126583) || (A2(r, 126585, 126588) || (e(126590) || (A2(r, 126592, 126601) || (A2(r, 126603, 126619) || (A2(r, 126625, 126627) || A2(r, 126629, 126633))))))))))) : (A2(r, 126635, 126651) || (A2(r, 127232, 127244) || (A2(r, 130032, 130041) || (A2(r, 131072, 173791) || (A2(r, 173824, 177977) || (A2(r, 177984, 178205) || (A2(r, 178208, 183969) || (A2(r, 183984, 191456) || (A2(r, 191472, 192093) || (A2(r, 194560, 195101) || (A2(r, 196608, 201546) || A2(r, 201552, 205743))))))))))))))))));
};
var $author$project$Terminal$Repl$startsWithKeyword = F2(
	function (keyword, lines) {
		var line = $author$project$Terminal$Repl$getFirstLine(lines);
		return A2($elm$core$String$startsWith, keyword, line) && function () {
			var _v0 = $elm$core$String$uncons(
				A2(
					$elm$core$String$dropLeft,
					$elm$core$String$length(keyword),
					line));
			if (_v0.$ === 'Nothing') {
				return true;
			} else {
				var _v1 = _v0.a;
				var c = _v1.a;
				return !$miniBill$elm_unicode$Unicode$isAlphaNum(c);
			}
		}();
	});
var $author$project$Compiler$Reporting$Error$Syntax$Declarations = function (a) {
	return {$: 'Declarations', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$ParseError = function (a) {
	return {$: 'ParseError', a: a};
};
var $author$project$Compiler$Reporting$Report$Report = F3(
	function (a, b, c) {
		return {$: 'Report', a: a, b: b, c: c};
	});
var $the_sett$elm_pretty_printer$Internals$Text = F2(
	function (a, b) {
		return {$: 'Text', a: a, b: b};
	});
var $the_sett$elm_pretty_printer$Pretty$taggedString = F2(
	function (val, tag) {
		return A2(
			$the_sett$elm_pretty_printer$Internals$Text,
			val,
			$elm$core$Maybe$Just(tag));
	});
var $author$project$Extra$Data$Pretty$cyanS = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.cyan;
		});
};
var $author$project$Compiler$Reporting$Doc$cyanS = $author$project$Extra$Data$Pretty$cyanS;
var $the_sett$elm_pretty_printer$Pretty$string = function (val) {
	return A2($the_sett$elm_pretty_printer$Internals$Text, val, $elm$core$Maybe$Nothing);
};
var $author$project$Extra$Data$Pretty$text = $the_sett$elm_pretty_printer$Pretty$string;
var $author$project$Compiler$Reporting$Doc$fromChars = $author$project$Extra$Data$Pretty$text;
var $author$project$Compiler$Reporting$Doc$d = $author$project$Compiler$Reporting$Doc$fromChars;
var $the_sett$elm_pretty_printer$Internals$Concatenate = F2(
	function (a, b) {
		return {$: 'Concatenate', a: a, b: b};
	});
var $the_sett$elm_pretty_printer$Pretty$append = F2(
	function (doc1, doc2) {
		return A2(
			$the_sett$elm_pretty_printer$Internals$Concatenate,
			function (_v0) {
				return doc1;
			},
			function (_v1) {
				return doc2;
			});
	});
var $the_sett$elm_pretty_printer$Internals$Empty = {$: 'Empty'};
var $the_sett$elm_pretty_printer$Pretty$empty = $the_sett$elm_pretty_printer$Internals$Empty;
var $author$project$Extra$Data$Pretty$empty = $the_sett$elm_pretty_printer$Pretty$empty;
var $author$project$Extra$Data$Pretty$hcat = function (docs) {
	if (!docs.b) {
		return $author$project$Extra$Data$Pretty$empty;
	} else {
		if (!docs.b.b) {
			var doc = docs.a;
			return doc;
		} else {
			var doc = docs.a;
			var docs_ = docs.b;
			return A2(
				$the_sett$elm_pretty_printer$Pretty$append,
				doc,
				$author$project$Extra$Data$Pretty$hcat(docs_));
		}
	}
};
var $author$project$Compiler$Reporting$Doc$hcat = $author$project$Extra$Data$Pretty$hcat;
var $author$project$Compiler$Reporting$Doc$da = $author$project$Compiler$Reporting$Doc$hcat;
var $the_sett$elm_pretty_printer$Internals$Column = function (a) {
	return {$: 'Column', a: a};
};
var $the_sett$elm_pretty_printer$Internals$Nest = F2(
	function (a, b) {
		return {$: 'Nest', a: a, b: b};
	});
var $the_sett$elm_pretty_printer$Internals$Nesting = function (a) {
	return {$: 'Nesting', a: a};
};
var $the_sett$elm_pretty_printer$Internals$Union = F2(
	function (a, b) {
		return {$: 'Union', a: a, b: b};
	});
var $the_sett$elm_pretty_printer$Internals$updateTag = F2(
	function (updateFn, doc) {
		switch (doc.$) {
			case 'Concatenate':
				var doc1 = doc.a;
				var doc2 = doc.b;
				return A2(
					$the_sett$elm_pretty_printer$Internals$Concatenate,
					function (_v1) {
						return A2(
							$the_sett$elm_pretty_printer$Internals$updateTag,
							updateFn,
							doc1(_Utils_Tuple0));
					},
					function (_v2) {
						return A2(
							$the_sett$elm_pretty_printer$Internals$updateTag,
							updateFn,
							doc2(_Utils_Tuple0));
					});
			case 'Nest':
				var i = doc.a;
				var doc1 = doc.b;
				return A2(
					$the_sett$elm_pretty_printer$Internals$Nest,
					i,
					function (_v3) {
						return A2(
							$the_sett$elm_pretty_printer$Internals$updateTag,
							updateFn,
							doc1(_Utils_Tuple0));
					});
			case 'Text':
				var text = doc.a;
				var maybeTag = doc.b;
				return A2(
					$the_sett$elm_pretty_printer$Internals$Text,
					text,
					A2(updateFn, text, maybeTag));
			case 'Union':
				var doc1 = doc.a;
				var doc2 = doc.b;
				return A2(
					$the_sett$elm_pretty_printer$Internals$Union,
					A2($the_sett$elm_pretty_printer$Internals$updateTag, updateFn, doc1),
					A2($the_sett$elm_pretty_printer$Internals$updateTag, updateFn, doc2));
			case 'Nesting':
				var fn = doc.a;
				return $the_sett$elm_pretty_printer$Internals$Nesting(
					function (i) {
						return A2(
							$the_sett$elm_pretty_printer$Internals$updateTag,
							updateFn,
							fn(i));
					});
			case 'Column':
				var fn = doc.a;
				return $the_sett$elm_pretty_printer$Internals$Column(
					function (i) {
						return A2(
							$the_sett$elm_pretty_printer$Internals$updateTag,
							updateFn,
							fn(i));
					});
			default:
				var x = doc;
				return x;
		}
	});
var $the_sett$elm_pretty_printer$Pretty$updateTag = $the_sett$elm_pretty_printer$Internals$updateTag;
var $the_sett$elm_pretty_printer$Pretty$setTag = function (tag) {
	return $the_sett$elm_pretty_printer$Pretty$updateTag(
		F2(
			function (_v0, _v1) {
				return $elm$core$Maybe$Just(tag);
			}));
};
var $author$project$Extra$Data$Pretty$dullyellow = $the_sett$elm_pretty_printer$Pretty$setTag(
	function ($) {
		return $.dullyellow;
	});
var $author$project$Compiler$Reporting$Doc$dullyellow = $author$project$Extra$Data$Pretty$dullyellow;
var $the_sett$elm_pretty_printer$Pretty$join = F2(
	function (sep, docs) {
		join:
		while (true) {
			if (!docs.b) {
				return $the_sett$elm_pretty_printer$Pretty$empty;
			} else {
				if (docs.a.$ === 'Empty') {
					var _v1 = docs.a;
					var ds = docs.b;
					var $temp$sep = sep,
						$temp$docs = ds;
					sep = $temp$sep;
					docs = $temp$docs;
					continue join;
				} else {
					var d = docs.a;
					var ds = docs.b;
					var step = F2(
						function (x, rest) {
							if (x.$ === 'Empty') {
								return rest;
							} else {
								var doc = x;
								return A2(
									$the_sett$elm_pretty_printer$Pretty$append,
									sep,
									A2($the_sett$elm_pretty_printer$Pretty$append, doc, rest));
							}
						});
					var spersed = A3($elm$core$List$foldr, step, $the_sett$elm_pretty_printer$Pretty$empty, ds);
					return A2($the_sett$elm_pretty_printer$Pretty$append, d, spersed);
				}
			}
		}
	});
var $the_sett$elm_pretty_printer$Internals$flatten = function (doc) {
	flatten:
	while (true) {
		switch (doc.$) {
			case 'Concatenate':
				var doc1 = doc.a;
				var doc2 = doc.b;
				return A2(
					$the_sett$elm_pretty_printer$Internals$Concatenate,
					function (_v1) {
						return $the_sett$elm_pretty_printer$Internals$flatten(
							doc1(_Utils_Tuple0));
					},
					function (_v2) {
						return $the_sett$elm_pretty_printer$Internals$flatten(
							doc2(_Utils_Tuple0));
					});
			case 'Nest':
				var i = doc.a;
				var doc1 = doc.b;
				return A2(
					$the_sett$elm_pretty_printer$Internals$Nest,
					i,
					function (_v3) {
						return $the_sett$elm_pretty_printer$Internals$flatten(
							doc1(_Utils_Tuple0));
					});
			case 'Union':
				var doc1 = doc.a;
				var doc2 = doc.b;
				var $temp$doc = doc1;
				doc = $temp$doc;
				continue flatten;
			case 'Line':
				var hsep = doc.a;
				return A2($the_sett$elm_pretty_printer$Internals$Text, hsep, $elm$core$Maybe$Nothing);
			case 'Nesting':
				var fn = doc.a;
				var $temp$doc = fn(0);
				doc = $temp$doc;
				continue flatten;
			case 'Column':
				var fn = doc.a;
				var $temp$doc = fn(0);
				doc = $temp$doc;
				continue flatten;
			default:
				var x = doc;
				return x;
		}
	}
};
var $the_sett$elm_pretty_printer$Pretty$group = function (doc) {
	return A2(
		$the_sett$elm_pretty_printer$Internals$Union,
		$the_sett$elm_pretty_printer$Internals$flatten(doc),
		doc);
};
var $the_sett$elm_pretty_printer$Internals$Line = F2(
	function (a, b) {
		return {$: 'Line', a: a, b: b};
	});
var $the_sett$elm_pretty_printer$Pretty$line = A2($the_sett$elm_pretty_printer$Internals$Line, ' ', '');
var $the_sett$elm_pretty_printer$Pretty$softline = $the_sett$elm_pretty_printer$Pretty$group($the_sett$elm_pretty_printer$Pretty$line);
var $the_sett$elm_pretty_printer$Pretty$softlines = $the_sett$elm_pretty_printer$Pretty$join($the_sett$elm_pretty_printer$Pretty$softline);
var $author$project$Extra$Data$Pretty$fillSep = $the_sett$elm_pretty_printer$Pretty$softlines;
var $author$project$Compiler$Reporting$Doc$fillSep = $author$project$Extra$Data$Pretty$fillSep;
var $author$project$Compiler$Reporting$Doc$fromName = function (name) {
	return $author$project$Extra$Data$Pretty$text(name);
};
var $author$project$Extra$Data$Pretty$green = $the_sett$elm_pretty_printer$Pretty$setTag(
	function ($) {
		return $.green;
	});
var $author$project$Compiler$Reporting$Doc$green = $author$project$Extra$Data$Pretty$green;
var $the_sett$elm_pretty_printer$Internals$copy = F2(
	function (i, s) {
		return (!i) ? '' : _Utils_ap(
			s,
			A2($the_sett$elm_pretty_printer$Internals$copy, i - 1, s));
	});
var $the_sett$elm_pretty_printer$Pretty$column = $the_sett$elm_pretty_printer$Internals$Column;
var $the_sett$elm_pretty_printer$Pretty$nest = F2(
	function (depth, doc) {
		return A2(
			$the_sett$elm_pretty_printer$Internals$Nest,
			depth,
			function (_v0) {
				return doc;
			});
	});
var $the_sett$elm_pretty_printer$Pretty$nesting = $the_sett$elm_pretty_printer$Internals$Nesting;
var $the_sett$elm_pretty_printer$Pretty$align = function (doc) {
	return $the_sett$elm_pretty_printer$Pretty$column(
		function (currentColumn) {
			return $the_sett$elm_pretty_printer$Pretty$nesting(
				function (indentLvl) {
					return A2($the_sett$elm_pretty_printer$Pretty$nest, currentColumn - indentLvl, doc);
				});
		});
};
var $the_sett$elm_pretty_printer$Pretty$hang = F2(
	function (spaces, doc) {
		return $the_sett$elm_pretty_printer$Pretty$align(
			A2($the_sett$elm_pretty_printer$Pretty$nest, spaces, doc));
	});
var $the_sett$elm_pretty_printer$Pretty$indent = F2(
	function (spaces, doc) {
		return A2(
			$the_sett$elm_pretty_printer$Pretty$hang,
			spaces,
			A2(
				$the_sett$elm_pretty_printer$Pretty$append,
				$the_sett$elm_pretty_printer$Pretty$string(
					A2($the_sett$elm_pretty_printer$Internals$copy, spaces, ' ')),
				doc));
	});
var $author$project$Extra$Data$Pretty$indent = F2(
	function (n, doc) {
		return A2($the_sett$elm_pretty_printer$Pretty$indent, n, doc);
	});
var $author$project$Compiler$Reporting$Doc$indent = $author$project$Extra$Data$Pretty$indent;
var $author$project$Compiler$Elm$Version$Version = F3(
	function (a, b, c) {
		return {$: 'Version', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Version$compiler = A3($author$project$Compiler$Elm$Version$Version, 0, 19, 1);
var $author$project$Compiler$Elm$Version$toChars = function (_v0) {
	var major = _v0.a;
	var minor = _v0.b;
	var patch = _v0.c;
	return $elm$core$String$fromInt(major) + ('.' + ($elm$core$String$fromInt(minor) + ('.' + $elm$core$String$fromInt(patch))));
};
var $author$project$Compiler$Reporting$Doc$makeLink = function (fileName) {
	return '<https://elm-lang.org/' + ($author$project$Compiler$Elm$Version$toChars($author$project$Compiler$Elm$Version$compiler) + ('/' + (fileName + '>')));
};
var $author$project$Extra$Data$Pretty$underline = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.underline;
		});
};
var $elm$core$String$words = _String_words;
var $author$project$Compiler$Reporting$Doc$link = F4(
	function (word, before, fileName, after) {
		return $author$project$Extra$Data$Pretty$fillSep(
			A2(
				$elm$core$List$cons,
				$author$project$Extra$Data$Pretty$hcat(
					_List_fromArray(
						[
							$author$project$Extra$Data$Pretty$underline(word),
							$author$project$Extra$Data$Pretty$text(':')
						])),
				_Utils_ap(
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Extra$Data$Pretty$text,
						$elm$core$String$words(before)),
					A2(
						$elm$core$List$cons,
						$author$project$Extra$Data$Pretty$text(
							$author$project$Compiler$Reporting$Doc$makeLink(fileName)),
						A2(
							$author$project$Extra$Type$List$map,
							$author$project$Extra$Data$Pretty$text,
							$elm$core$String$words(after))))));
	});
var $author$project$Compiler$Reporting$Doc$reflow = function (paragraph) {
	return $author$project$Extra$Data$Pretty$fillSep(
		A2(
			$author$project$Extra$Type$List$map,
			$author$project$Extra$Data$Pretty$text,
			$elm$core$String$words(paragraph)));
};
var $elm$core$List$intersperse = F2(
	function (sep, xs) {
		if (!xs.b) {
			return _List_Nil;
		} else {
			var hd = xs.a;
			var tl = xs.b;
			var step = F2(
				function (x, rest) {
					return A2(
						$elm$core$List$cons,
						sep,
						A2($elm$core$List$cons, x, rest));
				});
			var spersed = A3($elm$core$List$foldr, step, _List_Nil, tl);
			return A2($elm$core$List$cons, hd, spersed);
		}
	});
var $author$project$Extra$Type$List$intersperse = $elm$core$List$intersperse;
var $the_sett$elm_pretty_printer$Pretty$tightline = A2($the_sett$elm_pretty_printer$Internals$Line, '', '');
var $author$project$Extra$Data$Pretty$vcat = $the_sett$elm_pretty_printer$Pretty$join($the_sett$elm_pretty_printer$Pretty$tightline);
var $author$project$Compiler$Reporting$Doc$stack = function (docs) {
	return $author$project$Extra$Data$Pretty$vcat(
		A2(
			$author$project$Extra$Type$List$intersperse,
			$author$project$Extra$Data$Pretty$text(''),
			docs));
};
var $author$project$Compiler$Reporting$Doc$toFancyNote = function (chunks) {
	return $author$project$Extra$Data$Pretty$fillSep(
		A2(
			$elm$core$List$cons,
			$author$project$Extra$Data$Pretty$hcat(
				_List_fromArray(
					[
						$author$project$Extra$Data$Pretty$underline('Note'),
						$author$project$Extra$Data$Pretty$text(':')
					])),
			chunks));
};
var $author$project$Compiler$Reporting$Doc$toSimpleNote = function (message) {
	return $author$project$Compiler$Reporting$Doc$toFancyNote(
		A2(
			$author$project$Extra$Type$List$map,
			$author$project$Extra$Data$Pretty$text,
			$elm$core$String$words(message)));
};
var $author$project$Compiler$Reporting$Error$Syntax$noteForPortsInPackage = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('One of the major goals of the package ecosystem is to be completely written' + (' in Elm. This means when you install an Elm package, you can be sure you are safe' + (' from security issues on install and that you are not going to get any runtime' + (' exceptions coming from your new dependency. This design also sets the ecosystem' + (' up to target other platforms more easily (like mobile phones, WebAssembly, etc.)' + ' since no community code explicitly depends on JavaScript even existing.'))))),
			$author$project$Compiler$Reporting$Doc$reflow('Given that overall goal, allowing ports in packages would lead to some pretty' + (' surprising behavior. If ports were allowed in packages, you could install a' + (' package but not realize that it brings in an indirect dependency that defines a' + (' port. Now you have a program that does not work and the fix is to realize that' + (' some JavaScript needs to be added for a dependency you did not even know about.' + (' That would be extremely frustrating! \"So why not allow the package author to' + (' include the necessary JS code as well?\" Now we are back in conflict with our' + ' overall goal to keep all community packages free from runtime exceptions.')))))))
		]));
var $author$project$Compiler$Elm$ModuleName$toChars = $elm$core$Basics$identity;
var $author$project$Extra$Data$Pretty$dullyellowS = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.dullyellow;
		});
};
var $author$project$Compiler$Reporting$Doc$dullyellowS = $author$project$Extra$Data$Pretty$dullyellowS;
var $author$project$Compiler$Reporting$Doc$reflowLink = F3(
	function (before, fileName, after) {
		return $author$project$Extra$Data$Pretty$fillSep(
			_Utils_ap(
				A2(
					$author$project$Extra$Type$List$map,
					$author$project$Extra$Data$Pretty$text,
					$elm$core$String$words(before)),
				A2(
					$elm$core$List$cons,
					$author$project$Extra$Data$Pretty$text(
						$author$project$Compiler$Reporting$Doc$makeLink(fileName)),
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Extra$Data$Pretty$text,
						$elm$core$String$words(after)))));
	});
var $author$project$Extra$Data$Pretty$blue = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.blue;
		});
};
var $author$project$Compiler$Reporting$Doc$blue = $author$project$Extra$Data$Pretty$blue;
var $elm$core$List$any = F2(
	function (isOkay, list) {
		any:
		while (true) {
			if (!list.b) {
				return false;
			} else {
				var x = list.a;
				var xs = list.b;
				if (isOkay(x)) {
					return true;
				} else {
					var $temp$isOkay = isOkay,
						$temp$list = xs;
					isOkay = $temp$isOkay;
					list = $temp$list;
					continue any;
				}
			}
		}
	});
var $elm$core$List$member = F2(
	function (x, xs) {
		return A2(
			$elm$core$List$any,
			function (a) {
				return _Utils_eq(a, x);
			},
			xs);
	});
var $author$project$Extra$Type$List$elem = $elm$core$List$member;
var $author$project$Extra$Data$Pretty$greenS = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.green;
		});
};
var $author$project$Compiler$Reporting$Doc$greenS = $author$project$Extra$Data$Pretty$greenS;
var $elm$core$String$map = _String_map;
var $author$project$Compiler$Reporting$Error$Syntax$toRegion = F2(
	function (row, col) {
		var pos = A2($author$project$Compiler$Reporting$Annotation$Position, row, col);
		return A2($author$project$Compiler$Reporting$Annotation$Region, pos, pos);
	});
var $author$project$Extra$Data$Pretty$redS = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.red;
		});
};
var $author$project$Compiler$Reporting$Doc$redS = $author$project$Extra$Data$Pretty$redS;
var $author$project$Compiler$Reporting$Render$Code$addLineNumber = F6(
	function (addZigZag, width, start, end, n, line) {
		var spacer = (addZigZag && ((_Utils_cmp(start, n) < 1) && (_Utils_cmp(n, end) < 1))) ? $author$project$Compiler$Reporting$Doc$redS('>') : $author$project$Compiler$Reporting$Doc$fromChars(' ');
		var number = $elm$core$String$fromInt(n);
		var lineNumber = A2(
			$elm$core$String$repeat,
			width - $elm$core$String$length(number),
			' ') + (number + '|');
		return $author$project$Compiler$Reporting$Doc$hcat(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$fromChars(lineNumber),
					spacer,
					line
				]));
	});
var $author$project$Compiler$Reporting$Render$Code$drawLine = F5(
	function (addZigZag, width, startLine, endLine, _v0) {
		var n = _v0.a;
		var line = _v0.b;
		return A6(
			$author$project$Compiler$Reporting$Render$Code$addLineNumber,
			addZigZag,
			width,
			startLine,
			endLine,
			n,
			$author$project$Compiler$Reporting$Doc$fromChars(line));
	});
var $author$project$Compiler$Reporting$Doc$vcat = $author$project$Extra$Data$Pretty$vcat;
var $author$project$Compiler$Reporting$Render$Code$drawLines = F5(
	function (addZigZag, width, _v0, sourceLines, finalLine) {
		var _v1 = _v0.a;
		var startLine = _v1.a;
		var _v2 = _v0.b;
		var endLine = _v2.a;
		return $author$project$Compiler$Reporting$Doc$vcat(
			_Utils_ap(
				A2(
					$author$project$Extra$Type$List$map,
					A4($author$project$Compiler$Reporting$Render$Code$drawLine, addZigZag, width, startLine, endLine),
					sourceLines),
				_List_fromArray(
					[finalLine])));
	});
var $elm$core$List$drop = F2(
	function (n, list) {
		drop:
		while (true) {
			if (n <= 0) {
				return list;
			} else {
				if (!list.b) {
					return list;
				} else {
					var x = list.a;
					var xs = list.b;
					var $temp$n = n - 1,
						$temp$list = xs;
					n = $temp$n;
					list = $temp$list;
					continue drop;
				}
			}
		}
	});
var $author$project$Extra$Type$List$drop = $elm$core$List$drop;
var $elm$core$Debug$todo = _Debug_todo;
var $author$project$Extra$Type$List$head = function (l) {
	if (l.b) {
		var h = l.a;
		return h;
	} else {
		return _Debug_todo(
			'Extra.Type.List',
			{
				start: {line: 188, column: 13},
				end: {line: 188, column: 23}
			})('Extra.Type.List_.head: empty list');
	}
};
var $author$project$Extra$Type$List$last = function (l) {
	return $author$project$Extra$Type$List$head(
		$author$project$Extra$Type$List$reverse(l));
};
var $author$project$Compiler$Reporting$Render$Code$makeUnderline = F3(
	function (width, realEndLine, _v0) {
		var _v1 = _v0.a;
		var start = _v1.a;
		var c1 = _v1.b;
		var _v2 = _v0.b;
		var end = _v2.a;
		var c2 = _v2.b;
		if ((!_Utils_eq(start, end)) || (_Utils_cmp(end, realEndLine) < 0)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var zigzag = A2(
				$elm$core$String$repeat,
				A2($elm$core$Basics$max, 1, c2 - c1),
				'^');
			var spaces = A2($elm$core$String$repeat, (c1 + width) + 1, ' ');
			return $elm$core$Maybe$Just(
				$author$project$Compiler$Reporting$Doc$hcat(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$fromChars(spaces),
							$author$project$Compiler$Reporting$Doc$redS(zigzag)
						])));
		}
	});
var $elm$core$List$takeReverse = F3(
	function (n, list, kept) {
		takeReverse:
		while (true) {
			if (n <= 0) {
				return kept;
			} else {
				if (!list.b) {
					return kept;
				} else {
					var x = list.a;
					var xs = list.b;
					var $temp$n = n - 1,
						$temp$list = xs,
						$temp$kept = A2($elm$core$List$cons, x, kept);
					n = $temp$n;
					list = $temp$list;
					kept = $temp$kept;
					continue takeReverse;
				}
			}
		}
	});
var $elm$core$List$takeTailRec = F2(
	function (n, list) {
		return $elm$core$List$reverse(
			A3($elm$core$List$takeReverse, n, list, _List_Nil));
	});
var $elm$core$List$takeFast = F3(
	function (ctr, n, list) {
		if (n <= 0) {
			return _List_Nil;
		} else {
			var _v0 = _Utils_Tuple2(n, list);
			_v0$1:
			while (true) {
				_v0$5:
				while (true) {
					if (!_v0.b.b) {
						return list;
					} else {
						if (_v0.b.b.b) {
							switch (_v0.a) {
								case 1:
									break _v0$1;
								case 2:
									var _v2 = _v0.b;
									var x = _v2.a;
									var _v3 = _v2.b;
									var y = _v3.a;
									return _List_fromArray(
										[x, y]);
								case 3:
									if (_v0.b.b.b.b) {
										var _v4 = _v0.b;
										var x = _v4.a;
										var _v5 = _v4.b;
										var y = _v5.a;
										var _v6 = _v5.b;
										var z = _v6.a;
										return _List_fromArray(
											[x, y, z]);
									} else {
										break _v0$5;
									}
								default:
									if (_v0.b.b.b.b && _v0.b.b.b.b.b) {
										var _v7 = _v0.b;
										var x = _v7.a;
										var _v8 = _v7.b;
										var y = _v8.a;
										var _v9 = _v8.b;
										var z = _v9.a;
										var _v10 = _v9.b;
										var w = _v10.a;
										var tl = _v10.b;
										return (ctr > 1000) ? A2(
											$elm$core$List$cons,
											x,
											A2(
												$elm$core$List$cons,
												y,
												A2(
													$elm$core$List$cons,
													z,
													A2(
														$elm$core$List$cons,
														w,
														A2($elm$core$List$takeTailRec, n - 4, tl))))) : A2(
											$elm$core$List$cons,
											x,
											A2(
												$elm$core$List$cons,
												y,
												A2(
													$elm$core$List$cons,
													z,
													A2(
														$elm$core$List$cons,
														w,
														A3($elm$core$List$takeFast, ctr + 1, n - 4, tl)))));
									} else {
										break _v0$5;
									}
							}
						} else {
							if (_v0.a === 1) {
								break _v0$1;
							} else {
								break _v0$5;
							}
						}
					}
				}
				return list;
			}
			var _v1 = _v0.b;
			var x = _v1.a;
			return _List_fromArray(
				[x]);
		}
	});
var $elm$core$List$take = F2(
	function (n, list) {
		return A3($elm$core$List$takeFast, 0, n, list);
	});
var $author$project$Extra$Type$List$take = $elm$core$List$take;
var $author$project$Compiler$Reporting$Render$Code$render = F3(
	function (_v0, region, maybeSubRegion) {
		var sourceLines = _v0.a;
		var _v1 = region.a;
		var startLine = _v1.a;
		var _v2 = region.b;
		var endLine = _v2.a;
		var smallerRegion = A2($elm$core$Maybe$withDefault, region, maybeSubRegion);
		var relevantLines = A2(
			$author$project$Extra$Type$List$take,
			(1 + endLine) - startLine,
			A2($author$project$Extra$Type$List$drop, startLine - 1, sourceLines));
		var width = $elm$core$String$length(
			$elm$core$String$fromInt(
				$author$project$Extra$Type$List$last(relevantLines).a));
		var _v3 = A3($author$project$Compiler$Reporting$Render$Code$makeUnderline, width, endLine, smallerRegion);
		if (_v3.$ === 'Nothing') {
			return A5(
				$author$project$Compiler$Reporting$Render$Code$drawLines,
				true,
				width,
				smallerRegion,
				relevantLines,
				$author$project$Compiler$Reporting$Doc$fromChars(''));
		} else {
			var underline = _v3.a;
			return A5($author$project$Compiler$Reporting$Render$Code$drawLines, false, width, smallerRegion, relevantLines, underline);
		}
	});
var $author$project$Compiler$Reporting$Render$Code$toSnippet = F4(
	function (source, region, highlight, _v0) {
		var preHint = _v0.a;
		var postHint = _v0.b;
		return $author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					preHint,
					$author$project$Compiler$Reporting$Doc$fromChars(''),
					A3($author$project$Compiler$Reporting$Render$Code$render, source, region, highlight),
					postHint
				]));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toDeclStartReportOther = F3(
	function (source, row, col) {
		var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'WEIRD DECLARATION',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				region,
				$elm$core$Maybe$Nothing,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I am trying to parse a declaration, but I am getting stuck here:'),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('When a line has no spaces at the beginning, I expect it to be a declaration like one of these:'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$vcat(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
											$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
											$author$project$Compiler$Reporting$Doc$hcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('  '),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
													$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
												])),
											$author$project$Compiler$Reporting$Doc$fromChars(''),
											$author$project$Compiler$Reporting$Doc$hcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$cyanS('type'),
													$author$project$Compiler$Reporting$Doc$fromChars(' User = Anonymous | LoggedIn String')
												]))
										]))),
								$author$project$Compiler$Reporting$Doc$reflow('Try to make your declaration look like one of those? Or if this is not' + ' supposed to be a declaration, try adding some spaces before it?')
							])))));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion = F3(
	function (row, col, keyword) {
		return A2(
			$author$project$Compiler$Reporting$Annotation$Region,
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col),
			A2(
				$author$project$Compiler$Reporting$Annotation$Position,
				row,
				col + $elm$core$String$length(keyword)));
	});
var $author$project$Compiler$Reporting$Render$Code$Close = F2(
	function (a, b) {
		return {$: 'Close', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Render$Code$Operator = function (a) {
	return {$: 'Operator', a: a};
};
var $author$project$Compiler$Reporting$Render$Code$Other = function (a) {
	return {$: 'Other', a: a};
};
var $author$project$Compiler$Reporting$Render$Code$Upper = F2(
	function (a, b) {
		return {$: 'Upper', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Render$Code$Keyword = function (a) {
	return {$: 'Keyword', a: a};
};
var $author$project$Compiler$Reporting$Render$Code$Lower = F2(
	function (a, b) {
		return {$: 'Lower', a: a, b: b};
	});
var $author$project$Compiler$Parse$Variable$isInner = function (_char) {
	return $author$project$Compiler$Parse$Variable$getInnerWidthHelp(
		$elm$core$Char$toCode(_char)) > 0;
};
var $author$project$Extra$Type$String$takeWhile = F2(
	function (predicate, string) {
		var go = F2(
			function (rest, acc) {
				go:
				while (true) {
					var _v0 = $elm$core$String$uncons(rest);
					if (_v0.$ === 'Nothing') {
						return acc;
					} else {
						var _v1 = _v0.a;
						var _char = _v1.a;
						var rest_ = _v1.b;
						if (predicate(_char)) {
							var $temp$rest = rest_,
								$temp$acc = _Utils_ap(
								acc,
								$elm$core$String$fromChar(_char));
							rest = $temp$rest;
							acc = $temp$acc;
							continue go;
						} else {
							return acc;
						}
					}
				}
			});
		return A2(go, string, '');
	});
var $author$project$Compiler$Reporting$Render$Code$detectKeywords = F2(
	function (c, rest) {
		var cs = A2($author$project$Extra$Type$String$takeWhile, $author$project$Compiler$Parse$Variable$isInner, rest);
		var name = A2($elm$core$String$cons, c, cs);
		return A2($author$project$Extra$Type$Set$member, name, $author$project$Compiler$Parse$Variable$reservedWords) ? $author$project$Compiler$Reporting$Render$Code$Keyword(name) : A2($author$project$Compiler$Reporting$Render$Code$Lower, c, name);
	});
var $author$project$Compiler$Parse$Symbol$isBinopChar = function (_char) {
	return $author$project$Compiler$Parse$Symbol$isBinopCharHelp(
		$elm$core$Char$toCode(_char));
};
var $author$project$Compiler$Parse$Variable$isLower = function (_char) {
	return $author$project$Compiler$Parse$Variable$getLowerWidthHelp(
		$elm$core$Char$toCode(_char)) > 0;
};
var $author$project$Compiler$Parse$Variable$isUpper = function (_char) {
	return $author$project$Compiler$Parse$Variable$getUpperWidthHelp(
		$elm$core$Char$toCode(_char)) > 0;
};
var $author$project$Extra$Type$List$lookup = F2(
	function (key, l) {
		lookup:
		while (true) {
			if (!l.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var _v1 = l.a;
				var k = _v1.a;
				var b = _v1.b;
				var rest = l.b;
				if (_Utils_eq(key, k)) {
					return $elm$core$Maybe$Just(b);
				} else {
					var $temp$key = key,
						$temp$l = rest;
					key = $temp$key;
					l = $temp$l;
					continue lookup;
				}
			}
		}
	});
var $author$project$Compiler$Reporting$Render$Code$whatIsNext = F3(
	function (_v0, row, col) {
		var sourceLines = _v0.a;
		var _v1 = A2($author$project$Extra$Type$List$lookup, row, sourceLines);
		if (_v1.$ === 'Nothing') {
			return $author$project$Compiler$Reporting$Render$Code$Other($elm$core$Maybe$Nothing);
		} else {
			var line = _v1.a;
			var _v2 = $elm$core$String$uncons(
				A2($elm$core$String$dropLeft, col - 1, line));
			if (_v2.$ === 'Nothing') {
				return $author$project$Compiler$Reporting$Render$Code$Other($elm$core$Maybe$Nothing);
			} else {
				var _v3 = _v2.a;
				var c = _v3.a;
				var cs = _v3.b;
				return $author$project$Compiler$Parse$Variable$isUpper(c) ? A2(
					$author$project$Compiler$Reporting$Render$Code$Upper,
					c,
					A2($author$project$Extra$Type$String$takeWhile, $author$project$Compiler$Parse$Variable$isInner, cs)) : ($author$project$Compiler$Parse$Variable$isLower(c) ? A2($author$project$Compiler$Reporting$Render$Code$detectKeywords, c, cs) : ($author$project$Compiler$Parse$Symbol$isBinopChar(c) ? $author$project$Compiler$Reporting$Render$Code$Operator(
					A2(
						$elm$core$String$cons,
						c,
						A2($author$project$Extra$Type$String$takeWhile, $author$project$Compiler$Parse$Symbol$isBinopChar, cs))) : (_Utils_eq(
					c,
					_Utils_chr(')')) ? A2(
					$author$project$Compiler$Reporting$Render$Code$Close,
					'parenthesis',
					_Utils_chr(')')) : (_Utils_eq(
					c,
					_Utils_chr(']')) ? A2(
					$author$project$Compiler$Reporting$Render$Code$Close,
					'square bracket',
					_Utils_chr(']')) : (_Utils_eq(
					c,
					_Utils_chr('}')) ? A2(
					$author$project$Compiler$Reporting$Render$Code$Close,
					'curly brace',
					_Utils_chr('}')) : $author$project$Compiler$Reporting$Render$Code$Other(
					$elm$core$Maybe$Just(c)))))));
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toDeclStartReport = F3(
	function (source, row, col) {
		var _v0 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
		_v0$4:
		while (true) {
			switch (_v0.$) {
				case 'Close':
					var term = _v0.a;
					var bracket = _v0.b;
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'STRAY ' + A2($elm$core$String$map, $elm$core$Char$toUpper, term),
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see a ' + (term + ' here:')),
								$author$project$Compiler$Reporting$Doc$reflow(
									'This ' + (A2($elm$core$String$cons, bracket, ' does not match up with an earlier open ') + (term + '. Try deleting it?'))))));
				case 'Keyword':
					var keyword = _v0.a;
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to run into the `' + (keyword + '` keyword here:')),
								function () {
									switch (keyword) {
										case 'import':
											return $author$project$Compiler$Reporting$Doc$reflow('It is reserved for declaring imports at the top of your module. If you want' + (' another import, try moving it up top with the other imports. If you want to' + ' define a value or function, try changing the name to something else!'));
										case 'case':
											return $author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('It is reserved for writing `case` expressions. Try using a different name?'),
														$author$project$Compiler$Reporting$Doc$toSimpleNote('If you are trying to write a `case` expression, it needs to be part of a' + ' definition. So you could write something like this instead:'),
														A2(
														$author$project$Compiler$Reporting$Doc$indent,
														4,
														$author$project$Compiler$Reporting$Doc$vcat(
															_List_fromArray(
																[
																	A2(
																	$author$project$Compiler$Reporting$Doc$indent,
																	0,
																	$author$project$Compiler$Reporting$Doc$fillSep(
																		_List_fromArray(
																			[
																				$author$project$Compiler$Reporting$Doc$fromChars('getWidth'),
																				$author$project$Compiler$Reporting$Doc$fromChars('maybeWidth'),
																				$author$project$Compiler$Reporting$Doc$fromChars('=')
																			]))),
																	A2(
																	$author$project$Compiler$Reporting$Doc$indent,
																	2,
																	$author$project$Compiler$Reporting$Doc$fillSep(
																		_List_fromArray(
																			[
																				$author$project$Compiler$Reporting$Doc$cyanS('case'),
																				$author$project$Compiler$Reporting$Doc$fromChars('maybeWidth'),
																				$author$project$Compiler$Reporting$Doc$cyanS('of')
																			]))),
																	A2(
																	$author$project$Compiler$Reporting$Doc$indent,
																	4,
																	$author$project$Compiler$Reporting$Doc$fillSep(
																		_List_fromArray(
																			[
																				$author$project$Compiler$Reporting$Doc$blue('Just'),
																				$author$project$Compiler$Reporting$Doc$fromChars('width'),
																				$author$project$Compiler$Reporting$Doc$fromChars('->')
																			]))),
																	A2(
																	$author$project$Compiler$Reporting$Doc$indent,
																	6,
																	$author$project$Compiler$Reporting$Doc$fillSep(
																		_List_fromArray(
																			[
																				$author$project$Compiler$Reporting$Doc$fromChars('width'),
																				$author$project$Compiler$Reporting$Doc$fromChars('+'),
																				$author$project$Compiler$Reporting$Doc$dullyellowS('200')
																			]))),
																	$author$project$Compiler$Reporting$Doc$fromChars(''),
																	A2(
																	$author$project$Compiler$Reporting$Doc$indent,
																	4,
																	$author$project$Compiler$Reporting$Doc$fillSep(
																		_List_fromArray(
																			[
																				$author$project$Compiler$Reporting$Doc$blue('Nothing'),
																				$author$project$Compiler$Reporting$Doc$fromChars('->')
																			]))),
																	A2(
																	$author$project$Compiler$Reporting$Doc$indent,
																	6,
																	$author$project$Compiler$Reporting$Doc$fillSep(
																		_List_fromArray(
																			[
																				$author$project$Compiler$Reporting$Doc$dullyellowS('400')
																			])))
																]))),
														$author$project$Compiler$Reporting$Doc$reflow('This defines a `getWidth` function that you can use elsewhere in your program.')
													]));
										case 'if':
											return $author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('It is reserved for writing `if` expressions. Try using a different name?'),
														$author$project$Compiler$Reporting$Doc$toSimpleNote('If you are trying to write an `if` expression, it needs to be part of a' + ' definition. So you could write something like this instead:'),
														A2(
														$author$project$Compiler$Reporting$Doc$indent,
														4,
														$author$project$Compiler$Reporting$Doc$vcat(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
																	$author$project$Compiler$Reporting$Doc$fillSep(
																	_List_fromArray(
																		[
																			$author$project$Compiler$Reporting$Doc$fromChars(' '),
																			$author$project$Compiler$Reporting$Doc$cyanS('if'),
																			$author$project$Compiler$Reporting$Doc$fromChars('name'),
																			$author$project$Compiler$Reporting$Doc$fromChars('=='),
																			$author$project$Compiler$Reporting$Doc$dullyellowS('\"Abraham Lincoln\"'),
																			$author$project$Compiler$Reporting$Doc$cyanS('then'),
																			$author$project$Compiler$Reporting$Doc$dullyellowS('\"Greetings Mr. President.\"'),
																			$author$project$Compiler$Reporting$Doc$cyanS('else'),
																			$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hey!\"')
																		]))
																]))),
														$author$project$Compiler$Reporting$Doc$reflow('This defines a `reviewPowerLevel` function that you can use elsewhere in your program.')
													]));
										default:
											return $author$project$Compiler$Reporting$Doc$reflow('It is a reserved word. Try changing the name to something else?');
									}
								}())));
				case 'Upper':
					var c = _v0.a;
					var cs = _v0.b;
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNEXPECTED CAPITAL LETTER',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('Declarations always start with a lower-case letter, so I am getting stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Try a name like'),
													$author$project$Compiler$Reporting$Doc$greenS(
													A2(
														$elm$core$String$cons,
														$elm$core$Char$toLower(c),
														cs)),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												])),
											$author$project$Compiler$Reporting$Doc$toSimpleNote('Here are a couple valid declarations for reference:'),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											4,
											$author$project$Compiler$Reporting$Doc$vcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
														$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
														$author$project$Compiler$Reporting$Doc$hcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('  '),
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
															])),
														$author$project$Compiler$Reporting$Doc$fromChars(''),
														$author$project$Compiler$Reporting$Doc$hcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$cyanS('type'),
																$author$project$Compiler$Reporting$Doc$fromChars(' User = Anonymous | LoggedIn String')
															]))
													]))),
											$author$project$Compiler$Reporting$Doc$reflow('Notice that they always start with a lower-case letter. Capitalization matters!')
										])))));
				case 'Other':
					if (_v0.a.$ === 'Just') {
						var _char = _v0.a.a;
						if (A2(
							$author$project$Extra$Type$List$elem,
							_char,
							_List_fromArray(
								[
									_Utils_chr('('),
									_Utils_chr('{'),
									_Utils_chr('['),
									_Utils_chr('+'),
									_Utils_chr('-'),
									_Utils_chr('*'),
									_Utils_chr('/'),
									_Utils_chr('^'),
									_Utils_chr('&'),
									_Utils_chr('|'),
									_Utils_chr('\"'),
									_Utils_chr('\''),
									_Utils_chr('!'),
									_Utils_chr('@'),
									_Utils_chr('#'),
									_Utils_chr('$'),
									_Utils_chr('%')
								]))) {
							var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED SYMBOL',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow(
											'I am getting stuck because this line starts with the ' + ($elm$core$String$fromChar(_char) + ' symbol:')),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('When a line has no spaces at the beginning, I expect it to be a declaration like one of these:'),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
																$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
																$author$project$Compiler$Reporting$Doc$hcat(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$fromChars('  '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																		$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																	])),
																$author$project$Compiler$Reporting$Doc$fromChars(''),
																$author$project$Compiler$Reporting$Doc$hcat(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$cyanS('type'),
																		$author$project$Compiler$Reporting$Doc$fromChars(' User = Anonymous | LoggedIn String')
																	]))
															]))),
													$author$project$Compiler$Reporting$Doc$reflow('If this is not supposed to be a declaration, try adding some spaces before it?')
												])))));
						} else {
							return A3($author$project$Compiler$Reporting$Error$Syntax$toDeclStartReportOther, source, row, col);
						}
					} else {
						break _v0$4;
					}
				default:
					break _v0$4;
			}
		}
		return A3($author$project$Compiler$Reporting$Error$Syntax$toDeclStartReportOther, source, row, col);
	});
var $author$project$Compiler$Reporting$Error$Syntax$InDef = F3(
	function (a, b, c) {
		return {$: 'InDef', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PArg = {$: 'PArg'};
var $author$project$Compiler$Reporting$Error$Syntax$TC_Annotation = function (a) {
	return {$: 'TC_Annotation', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$declDefNote = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$reflow('Here is a valid definition (with a type annotation) for reference:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
						$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('  '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
								$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
							]))
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('The top line (called a \"type annotation\") is optional. You can leave it off' + (' if you want. As you get more comfortable with Elm and as your project grows,' + (' it becomes more and more valuable to add them though! They work great as' + ' compiler-verified documentation, and they often improve error messages!')))
		]));
var $author$project$Compiler$Reporting$Error$Syntax$InDestruct = F2(
	function (a, b) {
		return {$: 'InDestruct', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$InNode = F4(
	function (a, b, c, d) {
		return {$: 'InNode', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Syntax$NBranch = {$: 'NBranch'};
var $author$project$Compiler$Reporting$Error$Syntax$NCase = {$: 'NCase'};
var $author$project$Compiler$Reporting$Error$Syntax$NCond = {$: 'NCond'};
var $author$project$Compiler$Reporting$Error$Syntax$NElse = {$: 'NElse'};
var $author$project$Compiler$Reporting$Error$Syntax$NFunc = {$: 'NFunc'};
var $author$project$Compiler$Reporting$Error$Syntax$NList = {$: 'NList'};
var $author$project$Compiler$Reporting$Error$Syntax$NParens = {$: 'NParens'};
var $author$project$Compiler$Reporting$Error$Syntax$NRecord = {$: 'NRecord'};
var $author$project$Compiler$Reporting$Error$Syntax$NThen = {$: 'NThen'};
var $author$project$Compiler$Reporting$Error$Syntax$PCase = {$: 'PCase'};
var $author$project$Compiler$Reporting$Error$Syntax$PLet = {$: 'PLet'};
var $author$project$Compiler$Reporting$Error$Syntax$defNote = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$reflow('Here is a valid definition (with a type annotation) for reference:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
						$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('  '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
								$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
							]))
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('The top line (called a \"type annotation\") is optional. You can leave it off' + (' if you want. As you get more comfortable with Elm and as your project grows,' + (' it becomes more and more valuable to add them though! They work great as' + ' compiler-verified documentation, and they often improve error messages!')))
		]));
var $author$project$Extra$Type$Maybe$bind = F2(
	function (ma, f) {
		return A2($elm$core$Maybe$andThen, f, ma);
	});
var $author$project$Extra$Type$String$dropWhile = F2(
	function (predicate, string) {
		dropWhile:
		while (true) {
			var _v0 = $elm$core$String$uncons(string);
			if (_v0.$ === 'Nothing') {
				return string;
			} else {
				var _v1 = _v0.a;
				var _char = _v1.a;
				var rest = _v1.b;
				if (predicate(_char)) {
					var $temp$predicate = predicate,
						$temp$string = rest;
					predicate = $temp$predicate;
					string = $temp$string;
					continue dropWhile;
				} else {
					return string;
				}
			}
		}
	});
var $author$project$Compiler$Reporting$Render$Code$nextLineStartsWithCloseCurly = F2(
	function (_v0, row) {
		var sourceLines = _v0.a;
		return A2(
			$author$project$Extra$Type$Maybe$bind,
			A2($author$project$Extra$Type$List$lookup, row + 1, sourceLines),
			function (line) {
				var _v1 = $elm$core$String$uncons(
					A2(
						$author$project$Extra$Type$String$dropWhile,
						$elm$core$Basics$eq(
							_Utils_chr(' ')),
						line));
				if ((_v1.$ === 'Just') && ('}' === _v1.a.a.valueOf())) {
					var _v2 = _v1.a;
					return $elm$core$Maybe$Just(
						_Utils_Tuple2(
							row + 1,
							1 + $elm$core$String$length(
								A2(
									$author$project$Extra$Type$String$takeWhile,
									$elm$core$Basics$eq(
										_Utils_chr(' ')),
									line))));
				} else {
					return $elm$core$Maybe$Nothing;
				}
			});
	});
var $author$project$Compiler$Reporting$Render$Code$startsWithKeyword = F2(
	function (restOfLine, keyword) {
		return A2($elm$core$String$startsWith, keyword, restOfLine) && function () {
			var _v0 = $elm$core$String$uncons(
				A2(
					$elm$core$String$dropLeft,
					$elm$core$String$length(keyword),
					restOfLine));
			if (_v0.$ === 'Nothing') {
				return true;
			} else {
				var _v1 = _v0.a;
				var c = _v1.a;
				return !$author$project$Compiler$Parse$Variable$isInner(c);
			}
		}();
	});
var $author$project$Compiler$Reporting$Render$Code$nextLineStartsWithKeyword = F3(
	function (keyword, _v0, row) {
		var sourceLines = _v0.a;
		return A2(
			$author$project$Extra$Type$Maybe$bind,
			A2($author$project$Extra$Type$List$lookup, row + 1, sourceLines),
			function (line) {
				return A2(
					$author$project$Compiler$Reporting$Render$Code$startsWithKeyword,
					A2(
						$author$project$Extra$Type$String$dropWhile,
						$elm$core$Basics$eq(
							_Utils_chr(' ')),
						line),
					keyword) ? $elm$core$Maybe$Just(
					_Utils_Tuple2(
						row + 1,
						1 + $elm$core$String$length(
							A2(
								$author$project$Extra$Type$String$takeWhile,
								$elm$core$Basics$eq(
									_Utils_chr(' ')),
								line)))) : $elm$core$Maybe$Nothing;
			});
	});
var $author$project$Compiler$Reporting$Error$Syntax$noteForCaseIndentError = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('Sometimes I get confused by indentation, so try to make your `case` look' + ' something like this:'),
			$author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cyanS('case'),
								$author$project$Compiler$Reporting$Doc$fromChars('maybeWidth'),
								$author$project$Compiler$Reporting$Doc$cyanS('of')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$blue('Just'),
								$author$project$Compiler$Reporting$Doc$reflow('width ->')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					8,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('width +'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('200')
							]))),
					$author$project$Compiler$Reporting$Doc$fromChars(''),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$blue('Nothing'),
								$author$project$Compiler$Reporting$Doc$fromChars('->')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					8,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$dullyellowS('400')
							])))
				])),
			$author$project$Compiler$Reporting$Doc$reflow('Notice the indentation! Patterns are aligned with each other. Same indentation.' + (' The expressions after each arrow are all indented a bit more than the patterns.' + ' That is important!'))
		]));
var $author$project$Compiler$Reporting$Error$Syntax$noteForRecordError = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('If you are trying to define a record across multiple lines, I recommend using this format:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('{ name = '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"Alice\"')
							])),
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars(', age = '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('42')
							])),
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars(', height = '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('1.75')
							])),
						$author$project$Compiler$Reporting$Doc$fromChars('}')
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
		]));
var $author$project$Compiler$Reporting$Error$Syntax$noteForRecordIndentError = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('I may be confused by indentation. For example, if you are trying to define' + ' a record across multiple lines, I recommend using this format:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('{ name = '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"Alice\"')
							])),
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars(', age = '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('42')
							])),
						$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars(', height = '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('1.75')
							])),
						$author$project$Compiler$Reporting$Doc$fromChars('}')
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem!')
		]));
var $author$project$Compiler$Reporting$Error$Syntax$toWiderRegion = F3(
	function (row, col, extra) {
		return A2(
			$author$project$Compiler$Reporting$Annotation$Region,
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col),
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col + extra));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toEscapeReport = F4(
	function (source, escape, row, col) {
		switch (escape.$) {
			case 'EscapeUnknown':
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 2);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNKNOWN ESCAPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Backslashes always start escaped characters, but I do not recognize this one:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Valid escape characters include:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\n'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\r'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\t'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\\"'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\\''),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\\\'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\u{003D}')
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Do you want one of those instead? Maybe you need \\\\ to escape a backslash?'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('The last style lets encode ANY character by its Unicode code' + (' point. That means \\u{0009} and \\t are the same. You can use' + ' that style for anything not covered by the other six escapes!'))
									])))));
			case 'BadUnicodeFormat':
				var width = escape.a;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, width);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD UNICODE ESCAPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I ran into an invalid Unicode escape:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Here are some examples of valid Unicode escapes:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\u{0041}'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\u{03BB}'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\u{6728}'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\\u{1F60A}')
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that the code point is always surrounded by curly braces.' + ' Maybe you are missing the opening or closing curly brace?')
									])))));
			case 'BadUnicodeCode':
				var width = escape.a;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, width);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD UNICODE ESCAPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('This is not a valid code point:'),
							$author$project$Compiler$Reporting$Doc$reflow('The valid code points are between 0 and 10FFFF inclusive.'))));
			default:
				var width = escape.a;
				var numDigits = escape.b;
				var badCode = escape.c;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, width);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD UNICODE ESCAPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						(numDigits < 4) ? _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Every code point needs at least four digits:'),
							function () {
								var goodCode = _Utils_ap(
									A2($elm$core$String$repeat, 4 - numDigits, '0'),
									A2(
										$elm$core$String$map,
										$elm$core$Char$toUpper,
										$rtfeldman$elm_hex$Hex$toString(badCode)));
								var suggestion = '\\u{' + (goodCode + '}');
								return $author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fromChars('Try'),
											$author$project$Compiler$Reporting$Doc$greenS(suggestion),
											$author$project$Compiler$Reporting$Doc$fromChars('instead?')
										]));
							}()) : _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('This code point has too many digits:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Valid code points are between'),
										$author$project$Compiler$Reporting$Doc$greenS('\\u{0000}'),
										$author$project$Compiler$Reporting$Doc$fromChars('and'),
										$author$project$Compiler$Reporting$Doc$hcat(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$greenS('\\u{10FFFF}'),
												$author$project$Compiler$Reporting$Doc$fromChars(',')
											])),
										$author$project$Compiler$Reporting$Doc$reflow('so try trimming any leading zeros until'),
										$author$project$Compiler$Reporting$Doc$reflow('you have between four and six digits.')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toCharReport = F4(
	function (source, _char, row, col) {
		switch (_char.$) {
			case 'CharEndless':
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MISSING SINGLE QUOTE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I thought I was parsing a character, but I got to the end of' + ' the line without seeing the closing single quote:'),
							$author$project$Compiler$Reporting$Doc$reflow('Add a closing single quote here!'))));
			case 'CharEscape':
				var escape = _char.a;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toEscapeReport, source, escape, row, col);
			default:
				var width = _char.a;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, width);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'NEEDS DOUBLE QUOTES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$fromChars('The following string uses single quotes:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fromChars('Please switch to double quotes instead:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$hcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('\'this\''),
													$author$project$Compiler$Reporting$Doc$fromChars(' => '),
													$author$project$Compiler$Reporting$Doc$greenS('\"this\"')
												]))),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Elm uses double quotes for strings like \"hello\", whereas it uses single' + (' quotes for individual characters like \'a\' and \'\'. This distinction helps with' + (' code like (String.any (\\c -> c == \'X\') \"90210\") where you are inspecting' + ' individual characters.')))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toNumberReport = F4(
	function (source, number, row, col) {
		var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
		switch (number.$) {
			case 'NumberEnd':
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'WEIRD NUMBER',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I thought I was reading a number, but I ran into some weird stuff here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I recognize numbers in the following formats:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('42'),
													$author$project$Compiler$Reporting$Doc$fromChars('3.14'),
													$author$project$Compiler$Reporting$Doc$fromChars('6.022e23'),
													$author$project$Compiler$Reporting$Doc$fromChars('0x002B')
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('So is there a way to write it like one of those?')
									])))));
			case 'NumberDot':
				var _int = number.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'WEIRD NUMBER',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Numbers cannot end with a dot like this:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Switching to'),
										$author$project$Compiler$Reporting$Doc$greenS(
										$elm$core$String$fromInt(_int)),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$greenS(
										$elm$core$String$fromInt(_int) + '.0'),
										$author$project$Compiler$Reporting$Doc$reflow('will work though!')
									])))));
			case 'NumberHexDigit':
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'WEIRD HEXIDECIMAL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I thought I was reading a hexidecimal number until I got here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Valid hexidecimal digits include 0123456789abcdefABCDEF, so I can' + ' only recognize things like this:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('0x2B'),
													$author$project$Compiler$Reporting$Doc$fromChars('0x002B'),
													$author$project$Compiler$Reporting$Doc$fromChars('0x00ffb3')
												])))
									])))));
			default:
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'LEADING ZEROS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I do not accept numbers with leading zeros:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Just delete the leading zeros and it should work!'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Some languages let you to specify octal numbers by adding a leading zero.' + (' So in C, writing 0111 is the same as writing 73. Some people are used to' + (' that, but others probably want it to equal 111. Either path is going to' + (' surprise people from certain backgrounds, so Elm tries to avoid this whole' + ' situation.'))))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$getDefName = function (context) {
	getDefName:
	while (true) {
		switch (context.$) {
			case 'InDestruct':
				return $elm$core$Maybe$Nothing;
			case 'InDef':
				var name = context.a;
				return $elm$core$Maybe$Just(name);
			default:
				var c = context.d;
				var $temp$context = c;
				context = $temp$context;
				continue getDefName;
		}
	}
};
var $author$project$Compiler$Reporting$Error$Syntax$isWithin = F2(
	function (desiredNode, context) {
		switch (context.$) {
			case 'InDestruct':
				return false;
			case 'InDef':
				return false;
			default:
				var actualNode = context.a;
				return _Utils_eq(desiredNode, actualNode);
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$noteForCaseError = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('Here is an example of a valid `case` expression for reference.'),
			$author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cyanS('case'),
								$author$project$Compiler$Reporting$Doc$fromChars('maybeWidth'),
								$author$project$Compiler$Reporting$Doc$cyanS('of')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$blue('Just'),
								$author$project$Compiler$Reporting$Doc$reflow('width ->')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					8,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('width +'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('200')
							]))),
					$author$project$Compiler$Reporting$Doc$fromChars(''),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$blue('Nothing'),
								$author$project$Compiler$Reporting$Doc$fromChars('->')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					8,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$dullyellowS('400')
							])))
				])),
			$author$project$Compiler$Reporting$Doc$reflow('Notice the indentation. Each pattern is aligned, and each branch is indented' + ' a bit more than the corresponding pattern. That is important!')
		]));
var $author$project$Compiler$Reporting$Error$Syntax$toOperatorReport = F5(
	function (source, context, operator, row, col) {
		switch (operator.$) {
			case 'BadDot':
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED SYMBOL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$fromChars('I was not expecting this dot:'),
							$author$project$Compiler$Reporting$Doc$reflow('Dots are for record access and decimal points, so' + (' they cannot float around on their own. Maybe' + ' there is some extra whitespace?')))));
			case 'BadPipe':
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED SYMBOL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was not expecting this vertical bar:'),
							$author$project$Compiler$Reporting$Doc$reflow('Vertical bars should only appear in custom type declarations. Maybe you want || instead?'))));
			case 'BadArrow':
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 2);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED ARROW',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						A2($author$project$Compiler$Reporting$Error$Syntax$isWithin, $author$project$Compiler$Reporting$Error$Syntax$NCase, context) ? _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am parsing a `case` expression right now, but this arrow is confusing me:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Maybe the `of` keyword is missing on a previous line?'),
										$author$project$Compiler$Reporting$Error$Syntax$noteForCaseError
									]))) : (A2($author$project$Compiler$Reporting$Error$Syntax$isWithin, $author$project$Compiler$Reporting$Error$Syntax$NBranch, context) ? _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am parsing a `case` expression right now, but this arrow is confusing me:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('It makes sense to see arrows around here, so I suspect it is something earlier. Maybe this pattern is indented a bit farther than the previous patterns?'),
										$author$project$Compiler$Reporting$Error$Syntax$noteForCaseIndentError
									]))) : _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing an expression when I got stuck on this arrow:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fromChars('Arrows should only appear in `case` expressions and anonymous functions.\n' + 'Maybe it was supposed to be a > sign instead?'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('The syntax for anonymous functions is (\\x -> x + 1) so the arguments all appear' + ' after the backslash and before the arrow. Maybe a backslash is missing earlier?')
									]))))));
			case 'BadEquals':
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED EQUALS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see this equals sign:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Maybe you want == instead? To check if two values are equal?'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote(
										function () {
											if (A2($author$project$Compiler$Reporting$Error$Syntax$isWithin, $author$project$Compiler$Reporting$Error$Syntax$NRecord, context)) {
												return 'Records look like { x = 3, y = 4 } with the equals sign right' + ' after the field name. So maybe you forgot a comma?';
											} else {
												var _v1 = $author$project$Compiler$Reporting$Error$Syntax$getDefName(context);
												if (_v1.$ === 'Nothing') {
													return 'I may be getting confused by your indentation. I need all definitions to be indented' + (' exactly the same amount, so if this is meant to be a new definition, it may have too' + ' many spaces in front of it.');
												} else {
													var name = _v1.a;
													return 'I may be getting confused by your indentation. I think I am still parsing the `' + (name + ('` definition. Is this supposed to be part of a definition' + (' after that? If so, the problem may be a bit before the equals sign. I need all' + (' definitions to be indented exactly the same amount, so the problem may be that' + ' this new definition has too many spaces in front of it.'))));
												}
											}
										}())
									])))));
			default:
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED SYMBOL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to run into the \"has type\" symbol here:'),
							function () {
								var _v2 = $author$project$Compiler$Reporting$Error$Syntax$getDefName(context);
								if (_v2.$ === 'Nothing') {
									return $author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
												$author$project$Compiler$Reporting$Doc$greenS('::'),
												$author$project$Compiler$Reporting$Doc$fromChars('instead?'),
												$author$project$Compiler$Reporting$Doc$reflow('To put something on the front of a list?')
											]));
								} else {
									var name = _v2.a;
									return $author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
														$author$project$Compiler$Reporting$Doc$greenS('::'),
														$author$project$Compiler$Reporting$Doc$fromChars('instead?'),
														$author$project$Compiler$Reporting$Doc$reflow('To put something on the front of a list?')
													])),
												$author$project$Compiler$Reporting$Doc$toSimpleNote('The single colon is reserved for type annotations and record types, but I think' + (' I am parsing the definition of `' + (name + '` right now.'))),
												$author$project$Compiler$Reporting$Doc$toSimpleNote('I may be getting confused by your indentation. Is this supposed to be part of' + (' a type annotation AFTER the `' + (name + ('` definition? If so,' + (' the problem may be a bit before the \"has type\" symbol. I need all definitions to' + (' be exactly aligned (with exactly the same indentation) so the problem may be that' + ' this new definition is indented a bit too much.'))))))
											]));
								}
							}())));
		}
	});
var $author$project$Compiler$Reporting$Doc$toFancyHint = function (chunks) {
	return $author$project$Extra$Data$Pretty$fillSep(
		A2(
			$elm$core$List$cons,
			$author$project$Extra$Data$Pretty$hcat(
				_List_fromArray(
					[
						$author$project$Extra$Data$Pretty$underline('Hint'),
						$author$project$Extra$Data$Pretty$text(':')
					])),
			chunks));
};
var $author$project$Compiler$Reporting$Doc$toSimpleHint = function (message) {
	return $author$project$Compiler$Reporting$Doc$toFancyHint(
		A2(
			$author$project$Extra$Type$List$map,
			$author$project$Extra$Data$Pretty$text,
			$elm$core$String$words(message)));
};
var $author$project$Compiler$Reporting$Error$Syntax$toSpaceReport = F4(
	function (source, space, row, col) {
		if (space.$ === 'HasTab') {
			var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
			return A3(
				$author$project$Compiler$Reporting$Report$Report,
				'NO TABS',
				region,
				A4(
					$author$project$Compiler$Reporting$Render$Code$toSnippet,
					source,
					region,
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I ran into a tab, but tabs are not allowed in Elm files.'),
						$author$project$Compiler$Reporting$Doc$reflow('Replace the tab with spaces.'))));
		} else {
			var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 2);
			return A3(
				$author$project$Compiler$Reporting$Report$Report,
				'ENDLESS COMMENT',
				region,
				A4(
					$author$project$Compiler$Reporting$Render$Code$toSnippet,
					source,
					region,
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I cannot find the end of this multi-line comment:'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$reflow('Add a -} somewhere after this to end the comment.'),
									$author$project$Compiler$Reporting$Doc$toSimpleHint('Multi-line comments can be nested in Elm, so {- {- -} -} is a comment' + (' that happens to contain another comment. Like parentheses and curly braces,' + ' the start and end markers must always be balanced. Maybe that is the problem?'))
								])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport = F6(
	function (source, row, col, startRow, startCol, message) {
		var surroundings = A2(
			$author$project$Compiler$Reporting$Annotation$Region,
			A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
		var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'UNFINISHED RECORD PATTERN',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				surroundings,
				$elm$core$Maybe$Just(region),
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a record pattern, but I got stuck here:'),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								message,
								$author$project$Compiler$Reporting$Doc$toFancyHint(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('A record pattern looks like'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('{x,y}'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('{name,age}'),
										$author$project$Compiler$Reporting$Doc$reflow('where you list the field names you want to access.')
									]))
							])))));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toPRecordReport = F4(
	function (source, record, startRow, startCol) {
		switch (record.$) {
			case 'PRecordOpen':
				var row = record.a;
				var col = record.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a field name next.'));
			case 'PRecordEnd':
				var row = record.a;
				var col = record.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing curly brace next.'),
								$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('}'),
								$author$project$Compiler$Reporting$Doc$fromChars('here?')
							])));
			case 'PRecordField':
				var row = record.a;
				var col = record.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v1.$ === 'Keyword') {
					var keyword = _v1.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see `' + (keyword + '` as a record field name:')),
								$author$project$Compiler$Reporting$Doc$reflow('This is a reserved word, not available for variable names. Try another name!'))));
				} else {
					return A6(
						$author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport,
						source,
						row,
						col,
						startRow,
						startCol,
						$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a field name next.'));
				}
			case 'PRecordSpace':
				var space = record.a;
				var row = record.b;
				var col = record.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'PRecordIndentOpen':
				var row = record.a;
				var col = record.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a field name next.'));
			case 'PRecordIndentEnd':
				var row = record.a;
				var col = record.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing curly brace next.'),
								$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('}'),
								$author$project$Compiler$Reporting$Doc$fromChars('here?')
							])));
			default:
				var row = record.a;
				var col = record.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishRecordPatternReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a field name next.'));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toStringReport = F4(
	function (source, string, row, col) {
		switch (string.$) {
			case 'StringEndless_Single':
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'ENDLESS STRING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got to the end of the line without seeing the closing double quote:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Strings look like'),
												$author$project$Compiler$Reporting$Doc$greenS('\"this\"'),
												$author$project$Compiler$Reporting$Doc$reflow('with double'),
												$author$project$Compiler$Reporting$Doc$reflow('quotes on each end. Is the closing double'),
												$author$project$Compiler$Reporting$Doc$reflow('quote missing in your code?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('For a string that spans multiple lines, you can use the multi-line string' + ' syntax like this:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"\"\"'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('# Multi-line Strings'),
													$author$project$Compiler$Reporting$Doc$dullyellowS(''),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- start with triple double quotes'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- write whatever you want'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- no need to escape newlines or double quotes'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- end with triple double quotes'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"\"\"')
												])))
									])))));
			case 'StringEndless_Multi':
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 3);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'ENDLESS STRING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot find the end of this multi-line string:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Add a \"\"\" somewhere after this to end the string.'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Here is a valid multi-line string for reference:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"\"\"'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('# Multi-line Strings'),
													$author$project$Compiler$Reporting$Doc$dullyellowS(''),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- start with triple double quotes'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- write whatever you want'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- no need to escape newlines or double quotes'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('- end with triple double quotes'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"\"\"')
												])))
									])))));
			default:
				var escape = string.a;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toEscapeReport, source, escape, row, col);
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toPListReport = F5(
	function (source, context, list, startRow, startCol) {
		switch (list.$) {
			case 'PListOpen':
				var row = list.a;
				var col = list.b;
				var _v9 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v9.$ === 'Keyword') {
					var keyword = _v9.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + '` to name an element of a list:')),
								$author$project$Compiler$Reporting$Doc$reflow('This is a reserved word though! Try using some other name?'))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED LIST PATTERN',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just saw an open square bracket, but then I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
											$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
											$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
										])))));
				}
			case 'PListEnd':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting a closing square bracket to end this list pattern:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
										$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
										$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
									])))));
			case 'PListExpr':
				var pattern = list.a;
				var row = list.b;
				var col = list.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, context, pattern, row, col);
			case 'PListSpace':
				var space = list.a;
				var row = list.b;
				var col = list.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'PListIndentOpen':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw an open square bracket, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe there is something next, but it is not indented enough?')
									])))));
			case 'PListIndentEnd':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting a closing square bracket to end this list pattern:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have a closing square bracket but it is not indented enough?')
									])))));
			default:
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a list pattern, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see another pattern next. Maybe a variable name.'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe there is more to this pattern but it is not indented enough?')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toPTupleReport = F5(
	function (source, context, tuple, startRow, startCol) {
		switch (tuple.$) {
			case 'PTupleOpen':
				var row = tuple.a;
				var col = tuple.b;
				var _v6 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v6.$ === 'Keyword') {
					var keyword = _v6.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + '` as a variable name:')),
								$author$project$Compiler$Reporting$Doc$reflow('This is a reserved word! Try using some other name?'))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED PARENTHESES',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just saw an open parenthesis, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a pattern next.'),
											$author$project$Compiler$Reporting$Doc$reflow('Maybe it will end up being something'),
											$author$project$Compiler$Reporting$Doc$fromChars('like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('(x,y)'),
											$author$project$Compiler$Reporting$Doc$fromChars('or'),
											$author$project$Compiler$Reporting$Doc$hcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('(name, _)'),
													$author$project$Compiler$Reporting$Doc$fromChars('?')
												]))
										])))));
				}
			case 'PTupleEnd':
				var row = tuple.a;
				var col = tuple.b;
				var _v7 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				switch (_v7.$) {
					case 'Keyword':
						var keyword = _v7.a;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'RESERVED WORD',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I ran into a reserved word in this pattern:'),
									$author$project$Compiler$Reporting$Doc$reflow('The `' + (keyword + '` keyword is reserved. Try using a different name instead!')))));
					case 'Operator':
						var op = _v7.a;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, op);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'UNEXPECTED SYMBOL',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I ran into the ' + (op + ' symbol unexpectedly in this pattern:')),
									$author$project$Compiler$Reporting$Doc$reflow('Only the :: symbol that works in patterns. It is useful if you' + (' are pattern matching on lists, trying to get the first element' + ' off the front. Did you want that instead?')))));
					case 'Close':
						var term = _v7.a;
						var bracket = _v7.b;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'STRAY ' + A2($elm$core$String$map, $elm$core$Char$toUpper, term),
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I ran into a an unexpected ' + (term + ' in this pattern:')),
									$author$project$Compiler$Reporting$Doc$reflow(
										'This ' + (A2($elm$core$String$cons, bracket, ' does not match up with an earlier open ') + (term + '. Try deleting it?'))))));
					default:
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'UNFINISHED PARENTHESES',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a pattern, but I got stuck here:'),
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting a closing parenthesis next, so'),
												$author$project$Compiler$Reporting$Doc$reflow('try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
											])))));
				}
			case 'PTupleExpr':
				var pattern = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, context, pattern, row, col);
			case 'PTupleSpace':
				var space = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'PTupleIndentEnd':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting a closing parenthesis next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have a closing parenthesis but it is not indented enough?')
									])))));
			case 'PTupleIndentExpr1':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw an open parenthesis, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a pattern next.'),
										$author$project$Compiler$Reporting$Doc$reflow('Maybe it will end up being something'),
										$author$project$Compiler$Reporting$Doc$fromChars('like'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('(x,y)'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$hcat(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$dullyellowS('(name, _)'),
												$author$project$Compiler$Reporting$Doc$fromChars('?')
											]))
									])))));
			default:
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED TUPLE PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a tuple pattern, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a pattern next.'),
												$author$project$Compiler$Reporting$Doc$reflow('I am expecting the final result to be something'),
												$author$project$Compiler$Reporting$Doc$fromChars('like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(x,y)'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('(name, _)'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													]))
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so the problem' + ' may be that the next part is not indented enough?')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toPatternReport = F5(
	function (source, context, pattern, startRow, startCol) {
		switch (pattern.$) {
			case 'PRecord':
				var record = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toPRecordReport, source, record, row, col);
			case 'PTuple':
				var tuple = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPTupleReport, source, context, tuple, row, col);
			case 'PList':
				var list = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPListReport, source, context, list, row, col);
			case 'PStart':
				var row = pattern.a;
				var col = pattern.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				_v1$2:
				while (true) {
					switch (_v1.$) {
						case 'Keyword':
							var keyword = _v1.a;
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
							var inThisThing = function () {
								switch (context.$) {
									case 'PArg':
										return 'as an argument';
									case 'PCase':
										return 'in this pattern';
									default:
										return 'in this pattern';
								}
							}();
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'RESERVED WORD',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` ' + (inThisThing + ':')))),
										$author$project$Compiler$Reporting$Doc$reflow('This is a reserved word! Try using some other name?'))));
						case 'Operator':
							if (_v1.a === '-') {
								var surroundings = A2(
									$author$project$Compiler$Reporting$Annotation$Region,
									A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
									A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
								var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'UNEXPECTED SYMBOL',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										surroundings,
										$elm$core$Maybe$Just(region),
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('I ran into a minus sign unexpectedly in this pattern:'),
											$author$project$Compiler$Reporting$Doc$reflow('It is not possible to pattern match on negative numbers at this' + ' time. Try using an `if` expression for that sort of thing for now.'))));
							} else {
								break _v1$2;
							}
						default:
							break _v1$2;
					}
				}
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I wanted to parse a pattern next, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I am not sure why I am getting stuck exactly.'),
										$author$project$Compiler$Reporting$Doc$reflow('I just know that I want a pattern next.'),
										$author$project$Compiler$Reporting$Doc$reflow('Something as simple as'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('maybeHeight'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('result'),
										$author$project$Compiler$Reporting$Doc$reflow('would work!')
									])))));
			case 'PChar':
				var _char = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toCharReport, source, _char, row, col);
			case 'PString':
				var string = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toStringReport, source, string, row, col);
			case 'PNumber':
				var number = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toNumberReport, source, number, row, col);
			case 'PFloat':
				var width = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, width);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot pattern match with floating point numbers:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Equality on floats can be unreliable, so you usually want'),
										$author$project$Compiler$Reporting$Doc$reflow('to check that they are nearby with some sort of'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('(abs (actual - expected) < 0.001)'),
										$author$project$Compiler$Reporting$Doc$fromChars('check.')
									])))));
			case 'PAlias':
				var row = pattern.a;
				var col = pattern.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a variable name after the `as` keyword:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('The `as` keyword lets you write patterns like'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('(('),
														$author$project$Compiler$Reporting$Doc$dullyellowS('x'),
														$author$project$Compiler$Reporting$Doc$fromChars(','),
														$author$project$Compiler$Reporting$Doc$dullyellowS('y'),
														$author$project$Compiler$Reporting$Doc$fromChars(') '),
														$author$project$Compiler$Reporting$Doc$cyanS('as'),
														$author$project$Compiler$Reporting$Doc$dullyellowS(' point'),
														$author$project$Compiler$Reporting$Doc$fromChars(')')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('so you can refer to individual parts of the tuple with'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('x'),
												$author$project$Compiler$Reporting$Doc$fromChars('and'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('y'),
												$author$project$Compiler$Reporting$Doc$reflow('or you refer to the whole'),
												$author$project$Compiler$Reporting$Doc$reflow('thing with'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('point'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													]))
											])),
										$author$project$Compiler$Reporting$Doc$reflow('So I was expecting to see a variable name after the `as` keyword here. Sometimes' + (' people just want to use `as` as a variable name though. Try using a different name' + ' in that case!'))
									])))));
			case 'PWildcardNotVar':
				var name = pattern.a;
				var width = pattern.b;
				var row = pattern.c;
				var col = pattern.d;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, width);
				var examples = function () {
					var _v3 = $elm$core$String$uncons(
						A2(
							$author$project$Extra$Type$String$dropWhile,
							$elm$core$Basics$eq(
								_Utils_chr('_')),
							name));
					if (_v3.$ === 'Nothing') {
						return _List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$dullyellowS('x'),
								$author$project$Compiler$Reporting$Doc$fromChars('or'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('age')
							]);
					} else {
						var _v4 = _v3.a;
						var c = _v4.a;
						var cs = _v4.b;
						return _List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$dullyellowS(
								A2(
									$elm$core$String$cons,
									$elm$core$Char$toLower(c),
									cs))
							]);
					}
				}();
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Variable names cannot start with underscores like this:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_Utils_ap(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('You can either have an underscore like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('_'),
											$author$project$Compiler$Reporting$Doc$fromChars('to'),
											$author$project$Compiler$Reporting$Doc$reflow('ignore the value, or you can have a name like')
										]),
									_Utils_ap(
										examples,
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('to use the matched value.')
											])))))));
			case 'PSpace':
				var space = pattern.a;
				var row = pattern.b;
				var col = pattern.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'PIndentStart':
				var row = pattern.a;
				var col = pattern.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I wanted to parse a pattern next, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I am not sure why I am getting stuck exactly.'),
												$author$project$Compiler$Reporting$Doc$reflow('I just know that I want a pattern next.'),
												$author$project$Compiler$Reporting$Doc$reflow('Something as simple as'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('maybeHeight'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('result'),
												$author$project$Compiler$Reporting$Doc$reflow('would work!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation. If you think there is a pattern next, maybe' + ' it needs to be indented a bit more?')
									])))));
			default:
				var row = pattern.a;
				var col = pattern.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a variable name after the `as` keyword:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('The `as` keyword lets you write patterns like'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('(('),
														$author$project$Compiler$Reporting$Doc$dullyellowS('x'),
														$author$project$Compiler$Reporting$Doc$fromChars(','),
														$author$project$Compiler$Reporting$Doc$dullyellowS('y'),
														$author$project$Compiler$Reporting$Doc$fromChars(') '),
														$author$project$Compiler$Reporting$Doc$cyanS('as'),
														$author$project$Compiler$Reporting$Doc$dullyellowS(' point'),
														$author$project$Compiler$Reporting$Doc$fromChars(')')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('so you can refer to individual parts of the tuple with'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('x'),
												$author$project$Compiler$Reporting$Doc$fromChars('and'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('y'),
												$author$project$Compiler$Reporting$Doc$reflow('or you refer to the whole'),
												$author$project$Compiler$Reporting$Doc$reflow('thing with'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('point.')
											])),
										$author$project$Compiler$Reporting$Doc$reflow('So I was expecting to see a variable name after the `as` keyword here. Sometimes' + (' people just want to use `as` as a variable name though. Try using a different name' + ' in that case!'))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeError = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('If you are trying to define a record type across multiple lines, I recommend using this format:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fromChars('{ name : String'),
						$author$project$Compiler$Reporting$Doc$fromChars(', age : Int'),
						$author$project$Compiler$Reporting$Doc$fromChars(', height : Float'),
						$author$project$Compiler$Reporting$Doc$fromChars('}')
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
		]));
var $author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeIndentError = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('I may be confused by indentation. For example, if you are trying to define' + ' a record type across multiple lines, I recommend using this format:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fromChars('{ name : String'),
						$author$project$Compiler$Reporting$Doc$fromChars(', age : Int'),
						$author$project$Compiler$Reporting$Doc$fromChars(', height : Float'),
						$author$project$Compiler$Reporting$Doc$fromChars('}')
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
		]));
var $author$project$Compiler$Reporting$Error$Syntax$toTRecordReport = F5(
	function (source, context, record, startRow, startCol) {
		switch (record.$) {
			case 'TRecordOpen':
				var row = record.a;
				var col = record.b;
				var _v8 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v8.$ === 'Keyword') {
					var keyword = _v8.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just started parsing a record type, but I got stuck on this field name:'),
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a field name, but' + ' that is a reserved word. Try using a different name!'))))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED RECORD TYPE',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just started parsing a record type, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('Record types look like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('{ name : String, age : Int },'),
											$author$project$Compiler$Reporting$Doc$reflow('so I was expecting to see a field name next.')
										])))));
				}
			case 'TRecordEnd':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing curly brace before this,'),
												$author$project$Compiler$Reporting$Doc$reflow('so try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('}'),
												$author$project$Compiler$Reporting$Doc$reflow('and see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('When I get stuck like this, it usually means that there is a missing parenthesis' + ' or bracket somewhere earlier. It could also be a stray keyword or operator.')
									])))));
			case 'TRecordField':
				var row = record.a;
				var col = record.b;
				var _v9 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				_v9$3:
				while (true) {
					switch (_v9.$) {
						case 'Keyword':
							var keyword = _v9.a;
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'RESERVED WORD',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck on this field name:'),
										$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a field name, but' + ' that is a reserved word. Try using a different name!'))))));
						case 'Other':
							if ((_v9.a.$ === 'Just') && (',' === _v9.a.a.valueOf())) {
								var surroundings = A2(
									$author$project$Compiler$Reporting$Annotation$Region,
									A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
									A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
								var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'EXTRA COMMA',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										surroundings,
										$elm$core$Maybe$Just(region),
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck here:'),
											$author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('I am seeing two commas in a row. This is the second one!'),
														$author$project$Compiler$Reporting$Doc$reflow('Just delete one of the commas and you should be all set!'),
														$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeError
													])))));
							} else {
								break _v9$3;
							}
						case 'Close':
							if ('}' === _v9.b.valueOf()) {
								var surroundings = A2(
									$author$project$Compiler$Reporting$Annotation$Region,
									A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
									A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
								var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'EXTRA COMMA',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										surroundings,
										$elm$core$Maybe$Just(region),
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck here:'),
											$author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('Trailing commas are not allowed in record types. Try deleting the comma that' + ' appears before this closing curly brace.'),
														$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeError
													])))));
							} else {
								break _v9$3;
							}
						default:
							break _v9$3;
					}
				}
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see another record field defined next,'),
												$author$project$Compiler$Reporting$Doc$reflow('so I am looking for a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('userName'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('plantHeight'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													]))
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeError
									])))));
			case 'TRecordColon':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I just saw a field name, so I was expecting to see'),
												$author$project$Compiler$Reporting$Doc$reflow('a colon next. So try putting an'),
												$author$project$Compiler$Reporting$Doc$greenS(':'),
												$author$project$Compiler$Reporting$Doc$reflow('sign here?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeError
									])))));
			case 'TRecordType':
				var tipe = record.a;
				var row = record.b;
				var col = record.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTypeReport, source, context, tipe, row, col);
			case 'TRecordSpace':
				var space = record.a;
				var row = record.b;
				var col = record.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'TRecordIndentOpen':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the opening curly brace of a record type, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I am expecting a record like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('{ name : String, age : Int }'),
												$author$project$Compiler$Reporting$Doc$fromChars('here.'),
												$author$project$Compiler$Reporting$Doc$reflow('Try defining some fields of your own?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeIndentError
									])))));
			case 'TRecordIndentEnd':
				var row = record.a;
				var col = record.b;
				var _v10 = A2($author$project$Compiler$Reporting$Render$Code$nextLineStartsWithCloseCurly, source, row);
				if (_v10.$ === 'Just') {
					var _v11 = _v10.a;
					var curlyRow = _v11.a;
					var curlyCol = _v11.b;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, curlyRow, curlyCol));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, curlyRow, curlyCol);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'NEED MORE INDENTATION',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a record type, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I need this curly brace to be indented more. Try adding some spaces before it!'),
											$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeError
										])))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED RECORD TYPE',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a record type, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing curly brace next.'),
													$author$project$Compiler$Reporting$Doc$reflow('Try putting a'),
													$author$project$Compiler$Reporting$Doc$greenS('}'),
													$author$project$Compiler$Reporting$Doc$reflow('next and see if that helps?')
												])),
											$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeIndentError
										])))));
				}
			case 'TRecordIndentField':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, but I got stuck after that last comma:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Trailing commas are not allowed in record types, so the fix may be to' + (' delete that last comma? Or maybe you were in the middle of defining' + ' an additional field?')),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeIndentError
									])))));
			case 'TRecordIndentColon':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type. I just saw a record' + ' field, so I was expecting to see a colon next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try putting an'),
												$author$project$Compiler$Reporting$Doc$greenS(':'),
												$author$project$Compiler$Reporting$Doc$reflow('followed by a type?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeIndentError
									])))));
			default:
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record type, and I was expecting to run into a type next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try putting something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
												$author$project$Compiler$Reporting$Doc$reflow('for now?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordTypeIndentError
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toTTupleReport = F5(
	function (source, context, tuple, startRow, startCol) {
		switch (tuple.$) {
			case 'TTupleOpen':
				var row = tuple.a;
				var col = tuple.b;
				var _v6 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v6.$ === 'Keyword') {
					var keyword = _v6.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I ran into a reserved word unexpectedly:'),
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a variable name, but ' + ' it is a reserved word. Try using a different name!'))))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED PARENTHESES',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just saw an open parenthesis, so I was expecting to see a type next.'),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('Something like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('(Maybe Int)'),
											$author$project$Compiler$Reporting$Doc$fromChars('or'),
											$author$project$Compiler$Reporting$Doc$hcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('(List Person)'),
													$author$project$Compiler$Reporting$Doc$fromChars('.')
												])),
											$author$project$Compiler$Reporting$Doc$reflow('Anything where you are putting parentheses around normal types.')
										])))));
				}
			case 'TTupleEnd':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing parenthesis next, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get stuck when I run into keywords, operators, parentheses, or brackets' + (' unexpectedly. So there may be some earlier syntax trouble (like extra parenthesis' + ' or missing brackets) that is confusing me.'))
									])))));
			case 'TTupleType':
				var tipe = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTypeReport, source, context, tipe, row, col);
			case 'TTupleSpace':
				var space = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'TTupleIndentType1':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw an open parenthesis, so I was expecting to see a type next.'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(Maybe Int)'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('(List Person)'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Anything where you are putting parentheses around normal types.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have a type but it is not indented enough?')
									])))));
			case 'TTupleIndentTypeN':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED TUPLE TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I think I am in the middle of parsing a tuple type. I just saw a comma, so I was expecting to see a type next.'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('A tuple type looks like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(Float,Float)'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('(String,Int)'),
														$author$project$Compiler$Reporting$Doc$fromChars(',')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('so I think there is a type missing here?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have an expression but it is not indented enough?')
									])))));
			default:
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing parenthesis next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have a closing parenthesis but it is not indented enough?')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toTypeReport = F5(
	function (source, context, tipe, startRow, startCol) {
		switch (tipe.$) {
			case 'TRecord':
				var record = tipe.a;
				var row = tipe.b;
				var col = tipe.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTRecordReport, source, context, record, row, col);
			case 'TTuple':
				var tuple = tipe.a;
				var row = tipe.b;
				var col = tipe.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTTupleReport, source, context, tuple, row, col);
			case 'TStart':
				var row = tipe.a;
				var col = tipe.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v1.$ === 'Keyword') {
					var keyword = _v1.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type next, but I got stuck on this reserved word:'),
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a type variable, but ' + ' it is a reserved word. Try using a different name!'))))));
				} else {
					var thing = function () {
						switch (context.$) {
							case 'TC_Annotation':
								return 'type annotation';
							case 'TC_CustomType':
								return 'custom type';
							case 'TC_TypeAlias':
								return 'type alias';
							default:
								return 'port';
						}
					}();
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var something = function () {
						switch (context.$) {
							case 'TC_Annotation':
								var name = context.a;
								return 'the `' + (name + '` type annotation');
							case 'TC_CustomType':
								return 'a custom type';
							case 'TC_TypeAlias':
								return 'a type alias';
							default:
								return 'a port';
						}
					}();
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'PROBLEM IN ' + A2($elm$core$String$map, $elm$core$Char$toUpper, thing),
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing ' + (something + ', but I got stuck here:')),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type next.'),
											$author$project$Compiler$Reporting$Doc$reflow('Try putting'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
											$author$project$Compiler$Reporting$Doc$fromChars('or'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
											$author$project$Compiler$Reporting$Doc$fromChars('for'),
											$author$project$Compiler$Reporting$Doc$fromChars('now?')
										])))));
				}
			case 'TSpace':
				var space = tipe.a;
				var row = tipe.b;
				var col = tipe.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			default:
				var row = tipe.a;
				var col = tipe.b;
				var thing = function () {
					switch (context.$) {
						case 'TC_Annotation':
							return 'type annotation';
						case 'TC_CustomType':
							return 'custom type';
						case 'TC_TypeAlias':
							return 'type alias';
						default:
							return 'port';
					}
				}();
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED ' + A2($elm$core$String$map, $elm$core$Char$toUpper, thing),
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a ' + (thing + ', but I got stuck here:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type next.'),
												$author$project$Compiler$Reporting$Doc$reflow('Try putting'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
												$author$project$Compiler$Reporting$Doc$fromChars('for'),
												$author$project$Compiler$Reporting$Doc$fromChars('now?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation. If you think there is already a type' + ' next, maybe it is not indented enough?')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport = F6(
	function (source, row, col, startRow, startCol, message) {
		var surroundings = A2(
			$author$project$Compiler$Reporting$Annotation$Region,
			A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
		var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'UNFINISHED CASE',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				surroundings,
				$elm$core$Maybe$Just(region),
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a `case` expression, but I got stuck here:'),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[message, $author$project$Compiler$Reporting$Error$Syntax$noteForCaseError])))));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toUnfinishLetReport = F6(
	function (source, row, col, startRow, startCol, message) {
		var surroundings = A2(
			$author$project$Compiler$Reporting$Annotation$Region,
			A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
			A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
		var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'UNFINISHED LET',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				surroundings,
				$elm$core$Maybe$Just(region),
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a `let` expression, but I got stuck here:'),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								message,
								$author$project$Compiler$Reporting$Doc$toSimpleNote('Here is an example with a valid `let` expression for reference:'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$vcat(
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											0,
											$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('viewPerson person =')
													]))),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											2,
											$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$cyanS('let')
													]))),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											4,
											$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('fullName =')
													]))),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											6,
											$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('person.firstName ++'),
														$author$project$Compiler$Reporting$Doc$dullyellowS('\" \"'),
														$author$project$Compiler$Reporting$Doc$reflow('++ person.lastName')
													]))),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											2,
											$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$cyanS('in')
													]))),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											2,
											$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('div [] [ text fullName ]')
													])))
										]))),
								$author$project$Compiler$Reporting$Doc$reflow('Here we defined a `viewPerson` function that turns a person into some HTML. We use' + (' a `let` expression to define the `fullName` we want to show. Notice the indentation! The' + (' `fullName` is indented more than the `let` keyword, and the actual value of `fullName` is' + ' indented a bit more than that. That is important!')))
							])))));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toCaseReport = F5(
	function (source, context, case_, startRow, startCol) {
		switch (case_.$) {
			case 'CaseSpace':
				var space = case_.a;
				var row = case_.b;
				var col = case_.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'CaseOf':
				var row = case_.a;
				var col = case_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('of'),
								$author$project$Compiler$Reporting$Doc$reflow('keyword next.')
							])));
			case 'CasePattern':
				var pattern = case_.a;
				var row = case_.b;
				var col = case_.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, $author$project$Compiler$Reporting$Error$Syntax$PCase, pattern, row, col);
			case 'CaseArrow':
				var row = case_.a;
				var col = case_.b;
				var _v34 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				_v34$3:
				while (true) {
					switch (_v34.$) {
						case 'Keyword':
							var keyword = _v34.a;
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'RESERVED WORD',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a `case` expression, but I got stuck here:'),
										$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` in one of your' + ' patterns, but it is a reserved word. Try using a different name?'))))));
						case 'Operator':
							switch (_v34.a) {
								case ':':
									var surroundings = A2(
										$author$project$Compiler$Reporting$Annotation$Region,
										A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
										A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
									var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
									return A3(
										$author$project$Compiler$Reporting$Report$Report,
										'UNEXPECTED OPERATOR',
										region,
										A4(
											$author$project$Compiler$Reporting$Render$Code$toSnippet,
											source,
											surroundings,
											$elm$core$Maybe$Just(region),
											_Utils_Tuple2(
												$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a `case` expression, but I got stuck here:'),
												$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$reflow('I am seeing'),
															$author$project$Compiler$Reporting$Doc$dullyellowS(':'),
															$author$project$Compiler$Reporting$Doc$reflow('but maybe you want'),
															$author$project$Compiler$Reporting$Doc$greenS('::'),
															$author$project$Compiler$Reporting$Doc$fromChars('instead?'),
															$author$project$Compiler$Reporting$Doc$reflow('For pattern matching on lists?')
														])))));
								case '=':
									var surroundings = A2(
										$author$project$Compiler$Reporting$Annotation$Region,
										A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
										A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
									var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
									return A3(
										$author$project$Compiler$Reporting$Report$Report,
										'UNEXPECTED OPERATOR',
										region,
										A4(
											$author$project$Compiler$Reporting$Render$Code$toSnippet,
											source,
											surroundings,
											$elm$core$Maybe$Just(region),
											_Utils_Tuple2(
												$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a `case` expression, but I got stuck here:'),
												$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$reflow('I am seeing'),
															$author$project$Compiler$Reporting$Doc$dullyellowS('='),
															$author$project$Compiler$Reporting$Doc$reflow('but maybe you want'),
															$author$project$Compiler$Reporting$Doc$greenS('->'),
															$author$project$Compiler$Reporting$Doc$fromChars('instead?')
														])))));
								default:
									break _v34$3;
							}
						default:
							break _v34$3;
					}
				}
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MISSING ARROW',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a `case` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an arrow next.'),
										$author$project$Compiler$Reporting$Error$Syntax$noteForCaseIndentError
									])))));
			case 'CaseExpr':
				var expr = case_.a;
				var row = case_.b;
				var col = case_.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NCase, startRow, startCol, context),
					expr,
					row,
					col);
			case 'CaseBranch':
				var expr = case_.a;
				var row = case_.b;
				var col = case_.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NBranch, startRow, startCol, context),
					expr,
					row,
					col);
			case 'CaseIndentOf':
				var row = case_.a;
				var col = case_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('of'),
								$author$project$Compiler$Reporting$Doc$reflow('keyword next.')
							])));
			case 'CaseIndentExpr':
				var row = case_.a;
				var col = case_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a expression next.'));
			case 'CaseIndentPattern':
				var row = case_.a;
				var col = case_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a pattern next.'));
			case 'CaseIndentArrow':
				var row = case_.a;
				var col = case_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I just saw a pattern, so I was expecting'),
								$author$project$Compiler$Reporting$Doc$reflow('to see a'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('->'),
								$author$project$Compiler$Reporting$Doc$fromChars('next.')
							])));
			case 'CaseIndentBranch':
				var row = case_.a;
				var col = case_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. What should I do when' + ' I run into this particular pattern?'));
			default:
				var indent = case_.a;
				var row = case_.b;
				var col = case_.c;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishCaseReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow(
						'I suspect this is a pattern that is not indented far enough? (' + ($elm$core$String$fromInt(indent) + ' spaces)')));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toExprReport = F5(
	function (source, context, expr, startRow, startCol) {
		switch (expr.$) {
			case 'Let':
				var let_ = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toLetReport, source, context, let_, row, col);
			case 'Case':
				var case_ = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toCaseReport, source, context, case_, row, col);
			case 'If':
				var if_ = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toIfReport, source, context, if_, row, col);
			case 'CList':
				var list = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toListReport, source, context, list, row, col);
			case 'Record':
				var record = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toRecordReport, source, context, record, row, col);
			case 'Tuple':
				var tuple = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTupleReport, source, context, tuple, row, col);
			case 'Func':
				var func = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toFuncReport, source, context, func, row, col);
			case 'Dot':
				var row = expr.a;
				var col = expr.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING RECORD ACCESSOR',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a record accessor here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Something like'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('.name'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('.price'),
										$author$project$Compiler$Reporting$Doc$reflow('that accesses a value from a record.')
									])))));
			case 'Access':
				var row = expr.a;
				var col = expr.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING RECORD ACCESSOR',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am trying to parse a record accessor here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('.name'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('.price'),
												$author$project$Compiler$Reporting$Doc$reflow('that accesses a value from a record.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Record field names must start with a lower case letter!')
									])))));
			case 'OperatorRight':
				var op = expr.a;
				var row = expr.b;
				var col = expr.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				var isMath = A2(
					$author$project$Extra$Type$List$elem,
					op,
					_List_fromArray(
						['-', '+', '*', '/', '^']));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MISSING EXPRESSION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								'I just saw a ' + (op + (' ' + ((isMath ? 'sign' : 'operator') + ', so I am getting stuck here:')))),
							isMath ? $author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next.'),
										$author$project$Compiler$Reporting$Doc$reflow('Something like'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('42'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('1000'),
										$author$project$Compiler$Reporting$Doc$reflow('that makes sense with a'),
										$author$project$Compiler$Reporting$Doc$fromName(op),
										$author$project$Compiler$Reporting$Doc$fromChars('sign.')
									])) : (((op === '&&') || (op === '||')) ? $author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next.'),
										$author$project$Compiler$Reporting$Doc$reflow('Something like'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('True'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('False'),
										$author$project$Compiler$Reporting$Doc$reflow('that makes sense with boolean logic.')
									])) : ((op === '|>') ? $author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a function next.') : ((op === '<|') ? $author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an argument next.') : $author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next.')))))));
			case 'OperatorReserved':
				var operator = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toOperatorReport, source, context, operator, row, col);
			case 'Start':
				var row = expr.a;
				var col = expr.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				var _v22 = function () {
					switch (context.$) {
						case 'InDestruct':
							var r = context.a;
							var c = context.b;
							return _Utils_Tuple3(r, c, 'a definition');
						case 'InDef':
							var name = context.a;
							var r = context.b;
							var c = context.c;
							return _Utils_Tuple3(r, c, 'the `' + (name + '` definition'));
						default:
							switch (context.a.$) {
								case 'NRecord':
									var _v24 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'a record');
								case 'NParens':
									var _v25 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'some parentheses');
								case 'NList':
									var _v26 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'a list');
								case 'NFunc':
									var _v27 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'an anonymous function');
								case 'NCond':
									var _v28 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'an `if` expression');
								case 'NThen':
									var _v29 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'an `if` expression');
								case 'NElse':
									var _v30 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'an `if` expression');
								case 'NCase':
									var _v31 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'a `case` expression');
								default:
									var _v32 = context.a;
									var r = context.b;
									var c = context.c;
									return _Utils_Tuple3(r, c, 'a `case` expression');
							}
					}
				}();
				var contextRow = _v22.a;
				var contextCol = _v22.b;
				var aThing = _v22.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, contextRow, contextCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MISSING EXPRESSION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing ' + (aThing + ', but I got stuck here:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('42'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('\"hello\"'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Once there is something there, I can probably'),
												$author$project$Compiler$Reporting$Doc$reflow('give a more specific hint!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('This can also happen if I run into reserved words like `let` or `as` unexpectedly.' + (' Or if I run into operators in unexpected spots. Point is, there are a' + ' couple ways I can get confused and give sort of weird advice!'))
									])))));
			case 'CChar':
				var _char = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toCharReport, source, _char, row, col);
			case 'CString':
				var string = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toStringReport, source, string, row, col);
			case 'Number':
				var number = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toNumberReport, source, number, row, col);
			case 'Space':
				var space = expr.a;
				var row = expr.b;
				var col = expr.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'EndlessShader':
				var row = expr.a;
				var col = expr.b;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 6);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'ENDLESS SHADER',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot find the end of this shader:'),
							$author$project$Compiler$Reporting$Doc$reflow('Add a |] somewhere after this to end the shader.'))));
			default:
				var op = expr.a;
				var row = expr.b;
				var col = expr.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MISSING EXPRESSION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression after this ' + (op + ' operator:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('You can just put anything for now, like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('42'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('\"hello\"'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Once there is something there, I can probably'),
												$author$project$Compiler$Reporting$Doc$reflow('give a more specific hint!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I may be getting confused by your indentation? The easiest way to make sure' + (' this is not an indentation problem is to put the expression on the right of' + (' the ' + (op + ' operator on the same line.'))))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toFuncReport = F5(
	function (source, context, func, startRow, startCol) {
		switch (func.$) {
			case 'FuncSpace':
				var space = func.a;
				var row = func.b;
				var col = func.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'FuncArg':
				var pattern = func.a;
				var row = func.b;
				var col = func.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, $author$project$Compiler$Reporting$Error$Syntax$PArg, pattern, row, col);
			case 'FuncBody':
				var expr = func.a;
				var row = func.b;
				var col = func.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NFunc, startRow, startCol, context),
					expr,
					row,
					col);
			case 'FuncArrow':
				var row = func.a;
				var col = func.b;
				var _v20 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v20.$ === 'Keyword') {
					var keyword = _v20.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was parsing an anonymous function, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as an argument, but' + ' it is a reserved word in this language. Try using a different argument name!'))))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED ANONYMOUS FUNCTION',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just saw the beginning of an anonymous function, so I was expecting to see an arrow next:'),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('The syntax for anonymous functions is'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('(\\x -> x + 1)'),
											$author$project$Compiler$Reporting$Doc$reflow('so I am missing the arrow and the body of the function.')
										])))));
				}
			case 'FuncIndentArg':
				var row = func.a;
				var col = func.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MISSING ARGUMENT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the beginning of an anonymous function, so I was expecting to see an argument next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('x'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('name'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Anything that starts with a lower case letter!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('The syntax for anonymous functions is (\\x -> x + 1) where the backslash' + (' is meant to look a bit like a lambda if you squint. This visual pun seemed' + ' like a better idea at the time!'))
									])))));
			case 'FuncIndentArrow':
				var row = func.a;
				var col = func.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED ANONYMOUS FUNCTION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the beginning of an anonymous function, so I was expecting to see an arrow next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('The syntax for anonymous functions is'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(\\x -> x + 1)'),
												$author$project$Compiler$Reporting$Doc$reflow('so I am missing the arrow and the body of the function.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('It is possible that I am confused about indetation! I generally recommend' + (' switching to named functions if the definition cannot fit inline nicely, so' + (' either (1) try to fit the whole anonymous function on one line or (2) break' + ' the whole thing out into a named function. Things tend to be clearer that way!')))
									])))));
			default:
				var row = func.a;
				var col = func.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED ANONYMOUS FUNCTION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the body of your anonymous function next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('The syntax for anonymous functions is'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(\\x -> x + 1)'),
												$author$project$Compiler$Reporting$Doc$reflow('so I am missing all the stuff after the arrow!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('It is possible that I am confused about indetation! I generally recommend' + (' switching to named functions if the definition cannot fit inline nicely, so' + (' either (1) try to fit the whole anonymous function on one line or (2) break' + ' the whole thing out into a named function. Things tend to be clearer that way!')))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toIfReport = F5(
	function (source, context, if_, startRow, startCol) {
		switch (if_.$) {
			case 'IfSpace':
				var space = if_.a;
				var row = if_.b;
				var col = if_.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'IfThen':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see more of this `if` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the'),
										$author$project$Compiler$Reporting$Doc$cyanS('then'),
										$author$project$Compiler$Reporting$Doc$reflow('keyword next.')
									])))));
			case 'IfElse':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see more of this `if` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the'),
										$author$project$Compiler$Reporting$Doc$cyanS('else'),
										$author$project$Compiler$Reporting$Doc$reflow('keyword next.')
									])))));
			case 'IfElseBranchStart':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the start of an `else` branch, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. Maybe it is not filled in yet?'))));
			case 'IfCondition':
				var expr = if_.a;
				var row = if_.b;
				var col = if_.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NCond, startRow, startCol, context),
					expr,
					row,
					col);
			case 'IfThenBranch':
				var expr = if_.a;
				var row = if_.b;
				var col = if_.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NThen, startRow, startCol, context),
					expr,
					row,
					col);
			case 'IfElseBranch':
				var expr = if_.a;
				var row = if_.b;
				var col = if_.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NElse, startRow, startCol, context),
					expr,
					row,
					col);
			case 'IfIndentCondition':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see more of this `if` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('x < 0'),
												$author$project$Compiler$Reporting$Doc$reflow('that evaluates to True or False.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can be confused by indentation. Maybe something is not indented enough?')
									])))));
			case 'IfIndentThen':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see more of this `if` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the'),
												$author$project$Compiler$Reporting$Doc$cyanS('then'),
												$author$project$Compiler$Reporting$Doc$reflow('keyword next.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can be confused by indentation. Maybe something is not indented enough?')
									])))));
			case 'IfIndentThenBranch':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck after the start of this `then` branch:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. Maybe it is not filled in yet?'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can be confused by indentation, so if the `then` branch is already' + ' present, it may not be indented enough for me to recognize it.')
									])))));
			case 'IfIndentElseBranch':
				var row = if_.a;
				var col = if_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IF',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck after the start of this `else` branch:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. Maybe it is not filled in yet?'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can be confused by indentation, so if the `else` branch is already' + ' present, it may not be indented enough for me to recognize it.')
									])))));
			default:
				var row = if_.a;
				var col = if_.b;
				var _v17 = A3($author$project$Compiler$Reporting$Render$Code$nextLineStartsWithKeyword, 'else', source, row);
				if (_v17.$ === 'Just') {
					var _v18 = _v17.a;
					var elseRow = _v18.a;
					var elseCol = _v18.b;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, elseRow, elseCol));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, elseRow, elseCol, 4);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'WEIRD ELSE BRANCH',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through an `if` expression when I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I think this'),
											$author$project$Compiler$Reporting$Doc$cyanS('else'),
											$author$project$Compiler$Reporting$Doc$reflow('keyword needs to be indented more.'),
											$author$project$Compiler$Reporting$Doc$reflow('Try adding some spaces before it.')
										])))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED IF',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an `else` branch after this:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I know what to do when the condition is True,'),
													$author$project$Compiler$Reporting$Doc$reflow('but what happens when it is False?'),
													$author$project$Compiler$Reporting$Doc$reflow('Add an'),
													$author$project$Compiler$Reporting$Doc$cyanS('else'),
													$author$project$Compiler$Reporting$Doc$reflow('branch to handle that scenario!')
												]))
										])))));
				}
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toLetDefReport = F5(
	function (source, name, def, startRow, startCol) {
		switch (def.$) {
			case 'DefSpace':
				var space = def.a;
				var row = def.b;
				var col = def.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'DefType':
				var tipe = def.a;
				var row = def.b;
				var col = def.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toTypeReport,
					source,
					$author$project$Compiler$Reporting$Error$Syntax$TC_Annotation(name),
					tipe,
					row,
					col);
			case 'DefNameRepeat':
				var row = def.a;
				var col = def.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the type annotation for `' + (name + '` so I was expecting to see its definition here:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Type annotations always appear directly above the relevant' + ' definition, without anything else in between.'),
										$author$project$Compiler$Reporting$Error$Syntax$defNote
									])))));
			case 'DefNameMatch':
				var defName = def.a;
				var row = def.b;
				var col = def.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'NAME MISMATCH',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw a type annotation for `' + (name + ('`, but it is followed by a definition for `' + (defName + '`:')))),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('These names do not match! Is there a typo?'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS(defName),
													$author$project$Compiler$Reporting$Doc$fromChars('->'),
													$author$project$Compiler$Reporting$Doc$greenS(name)
												])))
									])))));
			case 'DefArg':
				var pattern = def.a;
				var row = def.b;
				var col = def.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, $author$project$Compiler$Reporting$Error$Syntax$PArg, pattern, row, col);
			case 'DefEquals':
				var row = def.a;
				var col = def.b;
				var _v14 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				switch (_v14.$) {
					case 'Keyword':
						var keyword = _v14.a;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'RESERVED WORD',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('The name'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('`'),
														$author$project$Compiler$Reporting$Doc$cyanS(keyword),
														$author$project$Compiler$Reporting$Doc$fromChars('`')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('is reserved in Elm, so it cannot'),
												$author$project$Compiler$Reporting$Doc$reflow('be used as an argument here:')
											])),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try renaming it to something else.'),
												function () {
												if (keyword === 'as') {
													return $author$project$Compiler$Reporting$Doc$toFancyNote(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$reflow('This keyword is reserved for pattern matches like'),
																$author$project$Compiler$Reporting$Doc$fromChars('((x,y)'),
																$author$project$Compiler$Reporting$Doc$cyanS('as'),
																$author$project$Compiler$Reporting$Doc$reflow('point) where you want to name a tuple and'),
																$author$project$Compiler$Reporting$Doc$reflow('the values it contains.')
															]));
												} else {
													return $author$project$Compiler$Reporting$Doc$toSimpleNote('The `' + (keyword + '` keyword has a special meaning in Elm, so it can only be used in certain situations.'));
												}
											}()
											])))));
					case 'Operator':
						if (_v14.a === '->') {
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 2);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'MISSING COLON?',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see an arrow here:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$reflow('This usually means a'),
															$author$project$Compiler$Reporting$Doc$greenS(':'),
															$author$project$Compiler$Reporting$Doc$reflow('is missing a bit earlier in'),
															$author$project$Compiler$Reporting$Doc$reflow('a type annotation. It could be something else though, so'),
															$author$project$Compiler$Reporting$Doc$reflow('here is a valid definition for reference:')
														])),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
																$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
																$author$project$Compiler$Reporting$Doc$hcat(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$fromChars('  '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																		$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																	]))
															]))),
													$author$project$Compiler$Reporting$Doc$reflow('Try to use that format with your `' + (name + '` definition!'))
												])))));
						} else {
							var op = _v14.a;
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, op);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED SYMBOL',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see this symbol here:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I am not sure what is going wrong exactly, so here is a valid' + ' definition (with an optional type annotation) for reference:'),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
																$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
																$author$project$Compiler$Reporting$Doc$hcat(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$fromChars('  '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																		$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																	]))
															]))),
													$author$project$Compiler$Reporting$Doc$reflow('Try to use that format with your `' + (name + '` definition!'))
												])))));
						}
					default:
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'PROBLEM IN DEFINITION',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I am not sure what is going wrong exactly, so here is a valid' + ' definition (with an optional type annotation) for reference:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$vcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
															$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
															$author$project$Compiler$Reporting$Doc$hcat(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$fromChars('  '),
																	$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																	$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																	$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																]))
														]))),
												$author$project$Compiler$Reporting$Doc$reflow('Try to use that format!')
											])))));
				}
			case 'DefBody':
				var expr = def.a;
				var row = def.b;
				var col = def.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A3($author$project$Compiler$Reporting$Error$Syntax$InDef, name, startRow, startCol),
					expr,
					row,
					col);
			case 'DefIndentEquals':
				var row = def.a;
				var col = def.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an argument or an equals sign next.'),
										$author$project$Compiler$Reporting$Error$Syntax$defNote
									])))));
			case 'DefIndentType':
				var row = def.a;
				var col = def.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` type annotation:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I just saw a colon, so I am expecting to see a type next.'),
										$author$project$Compiler$Reporting$Error$Syntax$defNote
									])))));
			case 'DefIndentBody':
				var row = def.a;
				var col = def.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. What is it equal to?'),
										$author$project$Compiler$Reporting$Error$Syntax$declDefNote
									])))));
			default:
				var indent = def.a;
				var row = def.b;
				var col = def.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				var offset = indent - col;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
							$author$project$Compiler$Reporting$Doc$reflow(
								'I just saw a type annotation indented ' + ($elm$core$String$fromInt(indent) + (' spaces, so I was' + (' expecting to see the corresponding definition next with the exact same amount' + (' of indentation. It looks like this line needs ' + ($elm$core$String$fromInt(offset) + (' more ' + (((offset === 1) ? 'space' : 'spaces') + '?')))))))))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toLetDestructReport = F4(
	function (source, destruct, startRow, startCol) {
		switch (destruct.$) {
			case 'DestructSpace':
				var space = destruct.a;
				var row = destruct.b;
				var col = destruct.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'DestructPattern':
				var pattern = destruct.a;
				var row = destruct.b;
				var col = destruct.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, $author$project$Compiler$Reporting$Error$Syntax$PLet, pattern, row, col);
			case 'DestructEquals':
				var row = destruct.a;
				var col = destruct.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck trying to parse this definition:'),
							function () {
								var _v12 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
								if ((_v12.$ === 'Operator') && (_v12.a === ':')) {
									return $author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an equals sign next, followed by an expression' + ' telling me what to compute.'),
												$author$project$Compiler$Reporting$Doc$toSimpleNote('It looks like you may be trying to write a type annotation? It is not' + (' possible to add type annotations on destructuring definitions like this.' + (' You can assign a name to the overall structure, put a type annotation on' + ' that, and then destructure separately though.')))
											]));
								} else {
									return $author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an equals sign next, followed by an expression' + ' telling me what to compute.');
								}
							}())));
			case 'DestructBody':
				var expr = destruct.a;
				var row = destruct.b;
				var col = destruct.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A2($author$project$Compiler$Reporting$Error$Syntax$InDestruct, startRow, startCol),
					expr,
					row,
					col);
			case 'DestructIndentEquals':
				var row = destruct.a;
				var col = destruct.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck trying to parse this definition:'),
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an equals sign next, followed by an expression' + ' telling me what to compute.'))));
			default:
				var row = destruct.a;
				var col = destruct.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing this definition:'),
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. What is it equal to?'))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toLetReport = F5(
	function (source, context, let_, startRow, startCol) {
		switch (let_.$) {
			case 'LetSpace':
				var space = let_.a;
				var row = let_.b;
				var col = let_.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'LetIn':
				var row = let_.a;
				var col = let_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'LET PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a `let` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Based on the indentation, I was expecting to see the'),
												$author$project$Compiler$Reporting$Doc$cyanS('in'),
												$author$project$Compiler$Reporting$Doc$reflow('keyword next. Is there a typo?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('This can also happen if you are trying to define another value within the `let` but' + (' it is not indented enough. Make sure each definition has exactly the same amount of' + ' spaces before it. They should line up exactly!'))
									])))));
			case 'LetDefAlignment':
				var row = let_.a;
				var col = let_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'LET PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a `let` expression, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Based on the indentation, I was expecting to see the'),
												$author$project$Compiler$Reporting$Doc$cyanS('in'),
												$author$project$Compiler$Reporting$Doc$reflow('keyword next. Is there a typo?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('This can also happen if you are trying to define another value within the `let` but' + (' it is not indented enough. Make sure each definition has exactly the same amount of' + ' spaces before it. They should line up exactly!'))
									])))));
			case 'LetDefName':
				var row = let_.a;
				var col = let_.b;
				var _v10 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v10.$ === 'Keyword') {
					var keyword = _v10.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a `let` expression, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a variable name, but' + ' it is a reserved word! Try using a different name instead.'))))));
				} else {
					return A6(
						$author$project$Compiler$Reporting$Error$Syntax$toUnfinishLetReport,
						source,
						row,
						col,
						startRow,
						startCol,
						$author$project$Compiler$Reporting$Doc$reflow('I was expecting the name of a definition next.'));
				}
			case 'LetDef':
				var name = let_.a;
				var def = let_.b;
				var row = let_.c;
				var col = let_.d;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toLetDefReport, source, name, def, row, col);
			case 'LetDestruct':
				var destruct = let_.a;
				var row = let_.b;
				var col = let_.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toLetDestructReport, source, destruct, row, col);
			case 'LetBody':
				var expr = let_.a;
				var row = let_.b;
				var col = let_.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toExprReport, source, context, expr, row, col);
			case 'LetIndentDef':
				var row = let_.a;
				var col = let_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishLetReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting a value to be defined here.'));
			case 'LetIndentIn':
				var row = let_.a;
				var col = let_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishLetReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the'),
								$author$project$Compiler$Reporting$Doc$cyanS('in'),
								$author$project$Compiler$Reporting$Doc$reflow('keyword next.'),
								$author$project$Compiler$Reporting$Doc$reflow('Or maybe more of that expression?')
							])));
			default:
				var row = let_.a;
				var col = let_.b;
				return A6(
					$author$project$Compiler$Reporting$Error$Syntax$toUnfinishLetReport,
					source,
					row,
					col,
					startRow,
					startCol,
					$author$project$Compiler$Reporting$Doc$reflow('I was expecting an expression next. Tell me what should happen with the value you just defined!'));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toListReport = F5(
	function (source, context, list, startRow, startCol) {
		switch (list.$) {
			case 'ListSpace':
				var space = list.a;
				var row = list.b;
				var col = list.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'ListOpen':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a list, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing square bracket before this,'),
												$author$project$Compiler$Reporting$Doc$reflow('so try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
												$author$project$Compiler$Reporting$Doc$reflow('and see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('When I get stuck like this, it usually means that there is a missing parenthesis' + ' or bracket somewhere earlier. It could also be a stray keyword or operator.')
									])))));
			case 'ListExpr':
				var expr = list.a;
				var row = list.b;
				var col = list.c;
				if (expr.$ === 'Start') {
					var r = expr.a;
					var c = expr.b;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, r, c));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, r, c);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED LIST',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see another list entry after that last comma:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('Trailing commas are not allowed in lists, so the fix may be to delete the comma?'),
											$author$project$Compiler$Reporting$Doc$toSimpleNote('I recommend using the following format for lists that span multiple lines:'),
											A2(
											$author$project$Compiler$Reporting$Doc$indent,
											4,
											$author$project$Compiler$Reporting$Doc$vcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$hcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('[ '),
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"Alice\"')
															])),
														$author$project$Compiler$Reporting$Doc$hcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars(', '),
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"Bob\"')
															])),
														$author$project$Compiler$Reporting$Doc$hcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars(', '),
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"Chuck\"')
															])),
														$author$project$Compiler$Reporting$Doc$fromChars(']')
													]))),
											$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
										])))));
				} else {
					return A5(
						$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
						source,
						A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NList, startRow, startCol, context),
						expr,
						row,
						col);
				}
			case 'ListEnd':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a list, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing square bracket before this,'),
												$author$project$Compiler$Reporting$Doc$reflow('so try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
												$author$project$Compiler$Reporting$Doc$reflow('and see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('When I get stuck like this, it usually means that there is a missing parenthesis' + ' or bracket somewhere earlier. It could also be a stray keyword or operator.')
									])))));
			case 'ListIndentOpen':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot find the end of this list:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('You could change it to something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('[3,4,5]'),
												$author$project$Compiler$Reporting$Doc$reflow('or even just'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('[]'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Anything where there is an open and close square brace,'),
												$author$project$Compiler$Reporting$Doc$reflow('and where the elements of the list are separated by commas.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I may be confused by indentation. For example, if you are trying to define' + ' a list across multiple lines, I recommend using this format:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('[ '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Alice\"')
														])),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars(', '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Bob\"')
														])),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars(', '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Chuck\"')
														])),
													$author$project$Compiler$Reporting$Doc$fromChars(']')
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
									])))));
			case 'ListIndentEnd':
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot find the end of this list:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('You can just add a closing'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(']'),
												$author$project$Compiler$Reporting$Doc$reflow('right here, and I will be all set!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I may be confused by indentation. For example, if you are trying to define' + ' a list across multiple lines, I recommend using this format:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('[ '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Alice\"')
														])),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars(', '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Bob\"')
														])),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars(', '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Chuck\"')
														])),
													$author$project$Compiler$Reporting$Doc$fromChars(']')
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
									])))));
			default:
				var row = list.a;
				var col = list.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED LIST',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see another list entry after this comma:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Trailing commas are not allowed in lists, so the fix may be to delete the comma?'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I recommend using the following format for lists that span multiple lines:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('[ '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Alice\"')
														])),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars(', '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Bob\"')
														])),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars(', '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Chuck\"')
														])),
													$author$project$Compiler$Reporting$Doc$fromChars(']')
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that each line starts with some indentation. Usually two or four spaces.' + ' This is the stylistic convention in the Elm ecosystem.')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toRecordReport = F5(
	function (source, context, record, startRow, startCol) {
		switch (record.$) {
			case 'RecordOpen':
				var row = record.a;
				var col = record.b;
				var _v3 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v3.$ === 'Keyword') {
					var keyword = _v3.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just started parsing a record, but I got stuck on this field name:'),
								$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a field name, but' + ' that is a reserved word. Try using a different name!'))))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'PROBLEM IN RECORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just started parsing a record, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a record field defined next,'),
													$author$project$Compiler$Reporting$Doc$reflow('so I am looking for a name like'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('userName'),
													$author$project$Compiler$Reporting$Doc$fromChars('or'),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$dullyellowS('plantHeight'),
															$author$project$Compiler$Reporting$Doc$fromChars('.')
														]))
												])),
											$author$project$Compiler$Reporting$Doc$toSimpleNote('Field names must start with a lower-case letter. After that, you can use' + ' any sequence of letters, numbers, and underscores.'),
											$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
										])))));
				}
			case 'RecordEnd':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing curly brace before this,'),
												$author$project$Compiler$Reporting$Doc$reflow('so try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('}'),
												$author$project$Compiler$Reporting$Doc$reflow('and see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('When I get stuck like this, it usually means that there is a missing parenthesis' + ' or bracket somewhere earlier. It could also be a stray keyword or operator.')
									])))));
			case 'RecordField':
				var row = record.a;
				var col = record.b;
				var _v4 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				_v4$3:
				while (true) {
					switch (_v4.$) {
						case 'Keyword':
							var keyword = _v4.a;
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'RESERVED WORD',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck on this field name:'),
										$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to use `' + (keyword + ('` as a field name, but' + ' that is a reserved word. Try using a different name!'))))));
						case 'Other':
							if ((_v4.a.$ === 'Just') && (',' === _v4.a.a.valueOf())) {
								var surroundings = A2(
									$author$project$Compiler$Reporting$Annotation$Region,
									A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
									A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
								var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'EXTRA COMMA',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										surroundings,
										$elm$core$Maybe$Just(region),
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck here:'),
											$author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('I am seeing two commas in a row. This is the second one!'),
														$author$project$Compiler$Reporting$Doc$reflow('Just delete one of the commas and you should be all set!'),
														$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
													])))));
							} else {
								break _v4$3;
							}
						case 'Close':
							if ('}' === _v4.b.valueOf()) {
								var surroundings = A2(
									$author$project$Compiler$Reporting$Annotation$Region,
									A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
									A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
								var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'EXTRA COMMA',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										surroundings,
										$elm$core$Maybe$Just(region),
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck here:'),
											$author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('Trailing commas are not allowed in records. Try deleting the comma that appears' + ' before this closing curly brace.'),
														$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
													])))));
							} else {
								break _v4$3;
							}
						default:
							break _v4$3;
					}
				}
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see another record field defined next,'),
												$author$project$Compiler$Reporting$Doc$reflow('so I am looking for a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('userName'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('plantHeight'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													]))
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Field names must start with a lower-case letter. After that, you can use' + ' any sequence of letters, numbers, and underscores.'),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
									])))));
			case 'RecordEquals':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I just saw a field name, so I was expecting to see'),
												$author$project$Compiler$Reporting$Doc$reflow('an equals sign next. So try putting an'),
												$author$project$Compiler$Reporting$Doc$greenS('='),
												$author$project$Compiler$Reporting$Doc$reflow('sign here?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
									])))));
			case 'RecordExpr':
				var expr = record.a;
				var row = record.b;
				var col = record.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NRecord, startRow, startCol, context),
					expr,
					row,
					col);
			case 'RecordSpace':
				var space = record.a;
				var row = record.b;
				var col = record.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'RecordIndentOpen':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the opening curly brace of a record, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I am expecting a record like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('{ x = 3, y = 4 }'),
												$author$project$Compiler$Reporting$Doc$fromChars('here.'),
												$author$project$Compiler$Reporting$Doc$reflow('Try defining some fields of your own?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordIndentError
									])))));
			case 'RecordIndentEnd':
				var row = record.a;
				var col = record.b;
				var _v5 = A2($author$project$Compiler$Reporting$Render$Code$nextLineStartsWithCloseCurly, source, row);
				if (_v5.$ === 'Just') {
					var _v6 = _v5.a;
					var curlyRow = _v6.a;
					var curlyCol = _v6.b;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, curlyRow, curlyCol));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, curlyRow, curlyCol);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'NEED MORE INDENTATION',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a record, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I need this curly brace to be indented more. Try adding some spaces before it!'),
											$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
										])))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNFINISHED RECORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing a record, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing curly brace next.'),
													$author$project$Compiler$Reporting$Doc$reflow('Try putting a'),
													$author$project$Compiler$Reporting$Doc$greenS('}'),
													$author$project$Compiler$Reporting$Doc$reflow('next and see if that helps?')
												])),
											$author$project$Compiler$Reporting$Error$Syntax$noteForRecordIndentError
										])))));
				}
			case 'RecordIndentField':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, but I got stuck after that last comma:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Trailing commas are not allowed in records, so the fix mxyay be to' + (' delete that last comma? Or maybe you were in the middle of defining' + ' an additional field?')),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordError
									])))));
			case 'RecordIndentEquals':
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record. I just saw a record' + ' field, so I was expecting to see an equals sign next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try putting an'),
												$author$project$Compiler$Reporting$Doc$greenS('='),
												$author$project$Compiler$Reporting$Doc$reflow('followed by an expression?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordIndentError
									])))));
			default:
				var row = record.a;
				var col = record.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED RECORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a record, and I was expecting to run into an expression next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try putting something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('42'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('\"hello\"'),
												$author$project$Compiler$Reporting$Doc$reflow('for now?')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForRecordIndentError
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toTupleReport = F5(
	function (source, context, tuple, startRow, startCol) {
		switch (tuple.$) {
			case 'TupleExpr':
				var expr = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A4($author$project$Compiler$Reporting$Error$Syntax$InNode, $author$project$Compiler$Reporting$Error$Syntax$NParens, startRow, startCol, context),
					expr,
					row,
					col);
			case 'TupleSpace':
				var space = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'TupleEnd':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing parentheses next, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get stuck when I run into keywords, operators, parentheses, or brackets' + (' unexpectedly. So there may be some earlier syntax trouble (like extra parenthesis' + ' or missing brackets) that is confusing me.'))
									])))));
			case 'TupleOperatorClose':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED OPERATOR FUNCTION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting a closing parenthesis here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I think I am parsing an operator function right now, so I am expecting to see' + (' something like (+) or (&&) where an operator is surrounded by parentheses with' + ' no extra spaces.'))
									])))));
			case 'TupleOperatorReserved':
				var operator = tuple.a;
				var row = tuple.b;
				var col = tuple.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED SYMBOL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I ran into an unexpected symbol here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								function () {
									switch (operator.$) {
										case 'BadDot':
											return _List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Maybe you wanted a record accessor like'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('.x'),
													$author$project$Compiler$Reporting$Doc$fromChars('or'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('.name'),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												]);
										case 'BadPipe':
											return _List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('Try'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(||)'),
													$author$project$Compiler$Reporting$Doc$reflow('instead? To turn boolean OR into a function?')
												]);
										case 'BadArrow':
											return _List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Maybe you wanted'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(>)'),
													$author$project$Compiler$Reporting$Doc$fromChars('or'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(>=)'),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												]);
										case 'BadEquals':
											return _List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('Try'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(==)'),
													$author$project$Compiler$Reporting$Doc$reflow('instead? To make a function that checks equality?')
												]);
										default:
											return _List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('Try'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(::)'),
													$author$project$Compiler$Reporting$Doc$reflow('instead? To add values to the front of lists?')
												]);
									}
								}()))));
			case 'TupleIndentExpr1':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw an open parenthesis, so I was expecting to see an expression next.'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(4 + 5)'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('(String.reverse \"desserts\")'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Anything where you are putting parentheses around normal expressions.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have an expression but it is not indented enough?')
									])))));
			case 'TupleIndentExprN':
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED TUPLE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I think I am in the middle of parsing a tuple. I just saw a comma, so I was expecting to see an expression next.'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('A tuple looks like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('(3,4)'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('(\"Tom\",42)'),
														$author$project$Compiler$Reporting$Doc$fromChars(',')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('so I think there is an expression missing here?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have an expression but it is not indented enough?')
									])))));
			default:
				var row = tuple.a;
				var col = tuple.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PARENTHESES',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a closing parenthesis next:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('to see if that helps!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused by indentation in cases like this, so' + ' maybe you have a closing parenthesis but it is not indented enough?')
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toDeclDefReport = F5(
	function (source, name, declDef, startRow, startCol) {
		switch (declDef.$) {
			case 'DeclDefSpace':
				var space = declDef.a;
				var row = declDef.b;
				var col = declDef.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'DeclDefEquals':
				var row = declDef.a;
				var col = declDef.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				switch (_v1.$) {
					case 'Keyword':
						var keyword = _v1.a;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'RESERVED WORD',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$fromChars('The'),
												$author$project$Compiler$Reporting$Doc$fromChars('name'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('`'),
														$author$project$Compiler$Reporting$Doc$cyanS(keyword),
														$author$project$Compiler$Reporting$Doc$fromChars('`')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('is reserved in Elm, so it cannot'),
												$author$project$Compiler$Reporting$Doc$reflow('be used as an argument here:')
											])),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Try renaming it to something else.'),
												function () {
												if (keyword === 'as') {
													return $author$project$Compiler$Reporting$Doc$toFancyNote(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$reflow('This keyword is reserved for pattern matches like'),
																$author$project$Compiler$Reporting$Doc$fromChars('((x,y)'),
																$author$project$Compiler$Reporting$Doc$cyanS('as'),
																$author$project$Compiler$Reporting$Doc$reflow('point) where you want to name a tuple and'),
																$author$project$Compiler$Reporting$Doc$reflow('the values it contains.')
															]));
												} else {
													return $author$project$Compiler$Reporting$Doc$toSimpleNote('The `' + (keyword + '` keyword has a special meaning in Elm, so it can only be used in certain situations.'));
												}
											}()
											])))));
					case 'Operator':
						if (_v1.a === '->') {
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toWiderRegion, row, col, 2);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'MISSING COLON?',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see an arrow here:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$reflow('This usually means a'),
															$author$project$Compiler$Reporting$Doc$greenS(':'),
															$author$project$Compiler$Reporting$Doc$reflow('is missing a bit earlier in'),
															$author$project$Compiler$Reporting$Doc$reflow('a type annotation. It could be something else though, so'),
															$author$project$Compiler$Reporting$Doc$reflow('here is a valid definition for reference:')
														])),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
																$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
																$author$project$Compiler$Reporting$Doc$hcat(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$fromChars('  '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																		$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																	]))
															]))),
													$author$project$Compiler$Reporting$Doc$reflow('Try to use that format with your `' + (name + '` definition!'))
												])))));
						} else {
							var op = _v1.a;
							var surroundings = A2(
								$author$project$Compiler$Reporting$Annotation$Region,
								A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
								A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
							var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, op);
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED SYMBOL',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									surroundings,
									$elm$core$Maybe$Just(region),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see this symbol here:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I am not sure what is going wrong exactly, so here is a valid' + ' definition (with an optional type annotation) for reference:'),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
																$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
																$author$project$Compiler$Reporting$Doc$hcat(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$fromChars('  '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																		$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																		$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																	]))
															]))),
													$author$project$Compiler$Reporting$Doc$reflow('Try to use that format with your `' + (name + '` definition!'))
												])))));
						}
					default:
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'PROBLEM IN DEFINITION',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I am not sure what is going wrong exactly, so here is a valid' + ' definition (with an optional type annotation) for reference:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$vcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('greet : String -> String'),
															$author$project$Compiler$Reporting$Doc$fromChars('greet name ='),
															$author$project$Compiler$Reporting$Doc$hcat(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$fromChars('  '),
																	$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello \"'),
																	$author$project$Compiler$Reporting$Doc$fromChars(' ++ name ++ '),
																	$author$project$Compiler$Reporting$Doc$dullyellowS('\"!\"')
																]))
														]))),
												$author$project$Compiler$Reporting$Doc$reflow('Try to use that format!')
											])))));
				}
			case 'DeclDefType':
				var tipe = declDef.a;
				var row = declDef.b;
				var col = declDef.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toTypeReport,
					source,
					$author$project$Compiler$Reporting$Error$Syntax$TC_Annotation(name),
					tipe,
					row,
					col);
			case 'DeclDefArg':
				var pattern = declDef.a;
				var row = declDef.b;
				var col = declDef.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toPatternReport, source, $author$project$Compiler$Reporting$Error$Syntax$PArg, pattern, row, col);
			case 'DeclDefBody':
				var expr = declDef.a;
				var row = declDef.b;
				var col = declDef.c;
				return A5(
					$author$project$Compiler$Reporting$Error$Syntax$toExprReport,
					source,
					A3($author$project$Compiler$Reporting$Error$Syntax$InDef, name, startRow, startCol),
					expr,
					row,
					col);
			case 'DeclDefNameRepeat':
				var row = declDef.a;
				var col = declDef.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the type annotation for `' + (name + '` so I was expecting to see its definition here:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Type annotations always appear directly above the relevant' + ' definition, without anything else in between. (Not even doc comments!)'),
										$author$project$Compiler$Reporting$Error$Syntax$declDefNote
									])))));
			case 'DeclDefNameMatch':
				var defName = declDef.a;
				var row = declDef.b;
				var col = declDef.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'NAME MISMATCH',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw a type annotation for `' + (name + ('`, but it is followed by a definition for `' + (defName + '`:')))),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('These names do not match! Is there a typo?'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS(defName),
													$author$project$Compiler$Reporting$Doc$fromChars('->'),
													$author$project$Compiler$Reporting$Doc$greenS(name)
												])))
									])))));
			case 'DeclDefIndentType':
				var row = declDef.a;
				var col = declDef.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` type annotation:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I just saw a colon, so I am expecting to see a type next.'),
										$author$project$Compiler$Reporting$Error$Syntax$declDefNote
									])))));
			case 'DeclDefIndentEquals':
				var row = declDef.a;
				var col = declDef.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an argument or an equals sign next.'),
										$author$project$Compiler$Reporting$Error$Syntax$declDefNote
									])))));
			default:
				var row = declDef.a;
				var col = declDef.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing the `' + (name + '` definition:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an expression next. What is it equal to?'),
										$author$project$Compiler$Reporting$Error$Syntax$declDefNote
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$customTypeNote = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('Here is an example of a valid `type` declaration for reference:'),
			$author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cyanS('type'),
								$author$project$Compiler$Reporting$Doc$fromChars('Status')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('='),
								$author$project$Compiler$Reporting$Doc$fromChars('Failure')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('|'),
								$author$project$Compiler$Reporting$Doc$fromChars('Waiting')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('|'),
								$author$project$Compiler$Reporting$Doc$fromChars('Success'),
								$author$project$Compiler$Reporting$Doc$fromChars('String')
							])))
				])),
			$author$project$Compiler$Reporting$Doc$reflow('This defines a new `Status` type with three variants. This could be useful if' + (' we are waiting for an HTTP request. Maybe we start with `Waiting` and then' + (' switch to `Failure` or `Success \"message from server\"` depending on how' + (' things go. Notice that the Success variant has some associated data, allowing' + ' us to store a String if the request goes well!'))))
		]));
var $author$project$Compiler$Reporting$Error$Syntax$TC_CustomType = {$: 'TC_CustomType'};
var $author$project$Compiler$Reporting$Error$Syntax$toCustomTypeReport = F4(
	function (source, customType, startRow, startCol) {
		switch (customType.$) {
			case 'CT_Space':
				var space = customType.a;
				var row = customType.b;
				var col = customType.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'CT_Name':
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING TYPE NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I think I am parsing a type declaration, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Status'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Style'),
												$author$project$Compiler$Reporting$Doc$reflow('next. Just make sure it is a name that starts with a capital letter!')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			case 'CT_Equals':
				var row = customType.a;
				var col = customType.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v1.$ === 'Keyword') {
					var keyword = _v1.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I ran into a reserved word unexpectedly while parsing this custom type:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying use `' + (keyword + '` as a type variable, but it is a reserved word. Try using a different name?')),
											$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
										])))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'PROBLEM IN CUSTOM TYPE',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type variable or an equals sign next.'),
											$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
										])))));
				}
			case 'CT_Bar':
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN CUSTOM TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a vertical bar like | next.'),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			case 'CT_Variant':
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN CUSTOM TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a variant name next.'),
												$author$project$Compiler$Reporting$Doc$reflow('Something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Success'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$hcat(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$dullyellowS('Sandwich'),
														$author$project$Compiler$Reporting$Doc$fromChars('.')
													])),
												$author$project$Compiler$Reporting$Doc$reflow('Any name that starts with a capital letter really!')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			case 'CT_VariantArg':
				var tipe = customType.a;
				var row = customType.b;
				var col = customType.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTypeReport, source, $author$project$Compiler$Reporting$Error$Syntax$TC_CustomType, tipe, row, col);
			case 'CT_IndentEquals':
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED CUSTOM TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type variable or an equals sign next.'),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			case 'CT_IndentBar':
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED CUSTOM TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a vertical bar like | next.'),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			case 'CT_IndentAfterBar':
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED CUSTOM TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I just saw a vertical bar, so I was expecting to see another variant defined next.'),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			default:
				var row = customType.a;
				var col = customType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED CUSTOM TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a custom type, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I just saw an equals sign, so I was expecting to see the first variant defined next.'),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$TC_TypeAlias = {$: 'TC_TypeAlias'};
var $author$project$Compiler$Reporting$Error$Syntax$typeAliasNote = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('Here is an example of a valid `type alias` for reference:'),
			$author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cyanS('type'),
								$author$project$Compiler$Reporting$Doc$cyanS('alias'),
								$author$project$Compiler$Reporting$Doc$fromChars('Person'),
								$author$project$Compiler$Reporting$Doc$fromChars('=')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$vcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('{ name : String'),
								$author$project$Compiler$Reporting$Doc$fromChars(', age : Int'),
								$author$project$Compiler$Reporting$Doc$fromChars(', height : Float'),
								$author$project$Compiler$Reporting$Doc$fromChars('}')
							])))
				])),
			$author$project$Compiler$Reporting$Doc$reflow('This would let us use `Person` as a shorthand for that record type. Using this' + (' shorthand makes type annotations much easier to read, and makes changing code' + ' easier if you decide later that there is more to a person than age and height!'))
		]));
var $author$project$Compiler$Reporting$Error$Syntax$toTypeAliasReport = F4(
	function (source, typeAlias, startRow, startCol) {
		switch (typeAlias.$) {
			case 'AliasSpace':
				var space = typeAlias.a;
				var row = typeAlias.b;
				var col = typeAlias.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'AliasName':
				var row = typeAlias.a;
				var col = typeAlias.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING TYPE ALIAS NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a type alias, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Person'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Point'),
												$author$project$Compiler$Reporting$Doc$reflow('next. Just make sure it is a name that starts with a capital letter!')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$typeAliasNote
									])))));
			case 'AliasEquals':
				var row = typeAlias.a;
				var col = typeAlias.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v1.$ === 'Keyword') {
					var keyword = _v1.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I ran into a reserved word unexpectedly while parsing this type alias:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying use `' + (keyword + '` as a type variable, but it is a reserved word. Try using a different name?')),
											$author$project$Compiler$Reporting$Error$Syntax$typeAliasNote
										])))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'PROBLEM IN TYPE ALIAS',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a type alias, but I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type variable or an equals sign next.'),
											$author$project$Compiler$Reporting$Error$Syntax$typeAliasNote
										])))));
				}
			case 'AliasBody':
				var tipe = typeAlias.a;
				var row = typeAlias.b;
				var col = typeAlias.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTypeReport, source, $author$project$Compiler$Reporting$Error$Syntax$TC_TypeAlias, tipe, row, col);
			case 'AliasIndentEquals':
				var row = typeAlias.a;
				var col = typeAlias.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED TYPE ALIAS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a type alias, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type variable or an equals sign next.'),
										$author$project$Compiler$Reporting$Error$Syntax$typeAliasNote
									])))));
			default:
				var row = typeAlias.a;
				var col = typeAlias.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED TYPE ALIAS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing a type alias, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type next. Something as simple'),
												$author$project$Compiler$Reporting$Doc$fromChars('as'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
												$author$project$Compiler$Reporting$Doc$fromChars('would'),
												$author$project$Compiler$Reporting$Doc$fromChars('work!')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$typeAliasNote
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toDeclTypeReport = F4(
	function (source, declType, startRow, startCol) {
		switch (declType.$) {
			case 'DT_Space':
				var space = declType.a;
				var row = declType.b;
				var col = declType.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'DT_Name':
				var row = declType.a;
				var col = declType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING TYPE NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I think I am parsing a type declaration, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Status'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Style'),
												$author$project$Compiler$Reporting$Doc$reflow('next. Just make sure it is a name that starts with a capital letter!')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
			case 'DT_Alias':
				var typeAlias = declType.a;
				var row = declType.b;
				var col = declType.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toTypeAliasReport, source, typeAlias, row, col);
			case 'DT_Union':
				var customType = declType.a;
				var row = declType.b;
				var col = declType.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toCustomTypeReport, source, customType, row, col);
			default:
				var row = declType.a;
				var col = declType.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING TYPE NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I think I am parsing a type declaration, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Status'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Style'),
												$author$project$Compiler$Reporting$Doc$reflow('next. Just make sure it is a name that starts with a capital letter!')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$customTypeNote
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$TC_Port = {$: 'TC_Port'};
var $author$project$Compiler$Reporting$Error$Syntax$portNote = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('Here are some example `port` declarations for reference:'),
			A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cyanS('port'),
								$author$project$Compiler$Reporting$Doc$fromChars('send'),
								$author$project$Compiler$Reporting$Doc$fromChars(':'),
								$author$project$Compiler$Reporting$Doc$fromChars('String -> Cmd msg')
							])),
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cyanS('port'),
								$author$project$Compiler$Reporting$Doc$fromChars('receive'),
								$author$project$Compiler$Reporting$Doc$fromChars(':'),
								$author$project$Compiler$Reporting$Doc$fromChars('(String -> msg) -> Sub msg')
							]))
					]))),
			$author$project$Compiler$Reporting$Doc$reflow('The first line defines a `send` port so you can send strings out to JavaScript.' + (' Maybe you send them on a WebSocket or put them into IndexedDB. The second line' + (' defines a `receive` port so you can receive strings from JavaScript. Maybe you' + (' get receive messages when new WebSocket messages come in or when the IndexedDB' + ' is changed for some external reason.'))))
		]));
var $author$project$Compiler$Reporting$Error$Syntax$toPortReport = F4(
	function (source, port_, startRow, startCol) {
		switch (port_.$) {
			case 'PortSpace':
				var space = port_.a;
				var row = port_.b;
				var col = port_.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'PortName':
				var row = port_.a;
				var col = port_.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				if (_v1.$ === 'Keyword') {
					var keyword = _v1.a;
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'RESERVED WORD',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I cannot handle ports with names like this:'),
								$author$project$Compiler$Reporting$Doc$reflow('You are trying to make a port named `' + (keyword + '` but that is a reserved word. Try using some other name?')))));
				} else {
					var surroundings = A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
					var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'PORT PROBLEM',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							surroundings,
							$elm$core$Maybe$Just(region),
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('I just saw the start of a `port` declaration, but then I got stuck here:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a name like'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('send'),
													$author$project$Compiler$Reporting$Doc$fromChars('or'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('receive'),
													$author$project$Compiler$Reporting$Doc$fromChars('next.'),
													$author$project$Compiler$Reporting$Doc$reflow('Something that starts with a lower-case letter.')
												])),
											$author$project$Compiler$Reporting$Error$Syntax$portNote
										])))));
				}
			case 'PortColon':
				var row = port_.a;
				var col = port_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PORT PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the start of a `port` declaration, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a colon next. And then a type that tells me' + ' what type of values are going to flow through.'),
										$author$project$Compiler$Reporting$Error$Syntax$portNote
									])))));
			case 'PortType':
				var tipe = port_.a;
				var row = port_.b;
				var col = port_.c;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toTypeReport, source, $author$project$Compiler$Reporting$Error$Syntax$TC_Port, tipe, row, col);
			case 'PortIndentName':
				var row = port_.a;
				var col = port_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the start of a `port` declaration, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a name like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('send'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('receive'),
												$author$project$Compiler$Reporting$Doc$fromChars('next.'),
												$author$project$Compiler$Reporting$Doc$reflow('Something that starts with a lower-case letter.')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$portNote
									])))));
			case 'PortIndentColon':
				var row = port_.a;
				var col = port_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the start of a `port` declaration, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a colon next. And then a type that tells me' + ' what type of values are going to flow through.'),
										$author$project$Compiler$Reporting$Error$Syntax$portNote
									])))));
			default:
				var row = port_.a;
				var col = port_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw the start of a `port` declaration, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a type next. Here are examples of outgoing and' + ' incoming ports for reference:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('port'),
															$author$project$Compiler$Reporting$Doc$fromChars('send'),
															$author$project$Compiler$Reporting$Doc$fromChars(':'),
															$author$project$Compiler$Reporting$Doc$fromChars('String -> Cmd msg')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('port'),
															$author$project$Compiler$Reporting$Doc$fromChars('receive'),
															$author$project$Compiler$Reporting$Doc$fromChars(':'),
															$author$project$Compiler$Reporting$Doc$fromChars('(String -> msg) -> Sub msg')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('The first line defines a `send` port so you can send strings out to JavaScript.' + (' Maybe you send them on a WebSocket or put them into IndexedDB. The second line' + (' defines a `receive` port so you can receive strings from JavaScript. Maybe you' + (' get receive messages when new WebSocket messages come in or when an entry in' + ' IndexedDB changes for some external reason.'))))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toDeclarationsReport = F2(
	function (source, decl) {
		switch (decl.$) {
			case 'DeclStart':
				var row = decl.a;
				var col = decl.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toDeclStartReport, source, row, col);
			case 'DeclSpace':
				var space = decl.a;
				var row = decl.b;
				var col = decl.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'Port':
				var port_ = decl.a;
				var row = decl.b;
				var col = decl.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toPortReport, source, port_, row, col);
			case 'DeclType':
				var declType = decl.a;
				var row = decl.b;
				var col = decl.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toDeclTypeReport, source, declType, row, col);
			case 'DeclDef':
				var name = decl.a;
				var declDef = decl.b;
				var row = decl.c;
				var col = decl.d;
				return A5($author$project$Compiler$Reporting$Error$Syntax$toDeclDefReport, source, name, declDef, row, col);
			default:
				var row = decl.a;
				var col = decl.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING DECLARATION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw a doc comment, but then I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the corresponding declaration next, starting on a fresh' + ' line with no indentation.'))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toExposingReport = F4(
	function (source, exposing_, startRow, startCol) {
		switch (exposing_.$) {
			case 'ExposingSpace':
				var space = exposing_.a;
				var row = exposing_.b;
				var col = exposing_.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'ExposingStart':
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN EXPOSING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I want to parse exposed values, but I am getting stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Exposed values are always surrounded by parentheses.'),
												$author$project$Compiler$Reporting$Doc$reflow('So try adding a'),
												$author$project$Compiler$Reporting$Doc$greenS('('),
												$author$project$Compiler$Reporting$Doc$fromChars('here?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Here are some valid examples of `exposing` for reference:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(Html, div, text)')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('If you are getting tripped up, you can just expose everything for now. It should' + ' get easier to make an explicit exposing list as you see more examples in the wild.')
									])))));
			case 'ExposingValue':
				var row = exposing_.a;
				var col = exposing_.b;
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				switch (_v1.$) {
					case 'Keyword':
						var keyword = _v1.a;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'RESERVED WORD',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this reserved word:'),
									$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to expose `' + (keyword + '` but that is a reserved word. Is there a typo?')))));
					case 'Operator':
						var op = _v1.a;
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, op);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'UNEXPECTED SYMBOL',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this symbol:'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('If you are trying to expose an operator, add parentheses around it like this:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$dullyellowS(op),
															$author$project$Compiler$Reporting$Doc$fromChars(' -> '),
															$author$project$Compiler$Reporting$Doc$greenS('(' + (op + ')'))
														])))
											])))));
					default:
						var surroundings = A2(
							$author$project$Compiler$Reporting$Annotation$Region,
							A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
							A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
						var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'PROBLEM IN EXPOSING',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								surroundings,
								$elm$core$Maybe$Just(region),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I got stuck while parsing these exposed values:'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I do not have an exact recommendation, so here are some valid examples' + ' of `exposing` for reference:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$vcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fillSep(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$cyanS('import'),
																	$author$project$Compiler$Reporting$Doc$fromChars('Html'),
																	$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
																	$author$project$Compiler$Reporting$Doc$fromChars('(..)')
																])),
															$author$project$Compiler$Reporting$Doc$fillSep(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$cyanS('import'),
																	$author$project$Compiler$Reporting$Doc$fromChars('Basics'),
																	$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
																	$author$project$Compiler$Reporting$Doc$fromChars('(Int, Float, Bool(..), (+), not, sqrt)')
																]))
														]))),
												$author$project$Compiler$Reporting$Doc$reflow('These examples show how to expose types, variants, operators, and functions. Everything' + ' should be some permutation of these examples, just with different names.')
											])))));
				}
			case 'ExposingOperator':
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN EXPOSING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I just saw an open parenthesis, so I was expecting an operator next:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('It is possible to expose operators, so I was expecting'),
										$author$project$Compiler$Reporting$Doc$reflow('to see something like'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('(+)'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('(|=)'),
										$author$project$Compiler$Reporting$Doc$fromChars('or'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('(||)'),
										$author$project$Compiler$Reporting$Doc$reflow('after I saw that open parenthesis.')
									])))));
			case 'ExposingOperatorReserved':
				var op = exposing_.a;
				var row = exposing_.b;
				var col = exposing_.c;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'RESERVED SYMBOL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot expose this as an operator:'),
							function () {
								switch (op.$) {
									case 'BadDot':
										return $author$project$Compiler$Reporting$Doc$reflow('Try getting rid of this entry? Maybe I can give you a better hint after that?');
									case 'BadPipe':
										return $author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(||)'),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												]));
									case 'BadArrow':
										return $author$project$Compiler$Reporting$Doc$reflow('Try getting rid of this entry? Maybe I can give you a better hint after that?');
									case 'BadEquals':
										return $author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(==)'),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												]));
									default:
										return $author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('(::)'),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												]));
								}
							}())));
			case 'ExposingOperatorRightParen':
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM IN EXPOSING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('It looks like you are exposing an operator, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the closing parenthesis immediately'),
										$author$project$Compiler$Reporting$Doc$reflow('after the operator. Try adding a'),
										$author$project$Compiler$Reporting$Doc$greenS(')'),
										$author$project$Compiler$Reporting$Doc$reflow('right here?')
									])))));
			case 'ExposingEnd':
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED EXPOSING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing exposed values, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$reflow('Maybe there is a comma missing before this?'))));
			case 'ExposingTypePrivacy':
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PROBLEM EXPOSING CUSTOM TYPE VARIANTS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('It looks like you are trying to expose the variants of a custom type:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('You need to write something like'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Status(..)'),
												$author$project$Compiler$Reporting$Doc$fromChars('or'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('Entity(..)'),
												$author$project$Compiler$Reporting$Doc$reflow('though. It is all or nothing, otherwise `case`'),
												$author$project$Compiler$Reporting$Doc$reflow('expressions could miss a variant and crash!')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('It is often best to keep the variants hidden! If someone pattern matches on' + (' the variants, it is a MAJOR change if any new variants are added. Suddenly' + (' their `case` expressions do not cover all variants! So if you do not need' + (' people to pattern match, keep the variants hidden and expose functions to' + ' construct values of this type. This way you can add new variants as a MINOR change!'))))
									])))));
			case 'ExposingIndentEnd':
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED EXPOSING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing exposed values, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I was expecting a closing parenthesis.'),
												$author$project$Compiler$Reporting$Doc$reflow('Try adding a'),
												$author$project$Compiler$Reporting$Doc$greenS(')'),
												$author$project$Compiler$Reporting$Doc$reflow('right here?')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I can get confused when there is not enough indentation, so if you already' + ' have a closing parenthesis, it probably just needs some spaces in front of it.')
									])))));
			default:
				var row = exposing_.a;
				var col = exposing_.b;
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2($author$project$Compiler$Reporting$Annotation$Position, startRow, startCol),
					A2($author$project$Compiler$Reporting$Annotation$Position, row, col));
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED EXPOSING',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was partway through parsing exposed values, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$reflow('I was expecting another value to expose.'))));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toImportReport = F3(
	function (source, row, col) {
		var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'UNFINISHED IMPORT',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				region,
				$elm$core$Maybe$Nothing,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I am partway through parsing an import, but I got stuck here:'),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('Here are some examples of valid `import` declarations:'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$vcat(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$cyanS('import'),
													$author$project$Compiler$Reporting$Doc$fromChars('Html')
												])),
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$cyanS('import'),
													$author$project$Compiler$Reporting$Doc$fromChars('Html'),
													$author$project$Compiler$Reporting$Doc$cyanS('as'),
													$author$project$Compiler$Reporting$Doc$fromChars('H')
												])),
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$cyanS('import'),
													$author$project$Compiler$Reporting$Doc$fromChars('Html'),
													$author$project$Compiler$Reporting$Doc$cyanS('as'),
													$author$project$Compiler$Reporting$Doc$fromChars('H'),
													$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
													$author$project$Compiler$Reporting$Doc$fromChars('(..)')
												])),
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$cyanS('import'),
													$author$project$Compiler$Reporting$Doc$fromChars('Html'),
													$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
													$author$project$Compiler$Reporting$Doc$fromChars('(Html, div, text)')
												]))
										]))),
								$author$project$Compiler$Reporting$Doc$reflow('You are probably trying to import a different module, but try to make it look like one of these examples!'),
								A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'imports', 'to learn more.')
							])))));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toWeirdEndReportOther = F2(
	function (source, region) {
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'SYNTAX PROBLEM',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				region,
				$elm$core$Maybe$Nothing,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I got stuck here:'),
					$author$project$Compiler$Reporting$Doc$reflow('Whatever I am running into is confusing me a lot! Normally I can give fairly' + ' specific hints, but something is really tripping me up this time.'))));
	});
var $author$project$Compiler$Reporting$Error$Syntax$toWeirdEndReport = F3(
	function (source, row, col) {
		var _v0 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
		switch (_v0.$) {
			case 'Keyword':
				var keyword = _v0.a;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, keyword);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'RESERVED WORD',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this reserved word:'),
							$author$project$Compiler$Reporting$Doc$reflow('The name `' + (keyword + '` is reserved, so try using a different name?')))));
			case 'Operator':
				var op = _v0.a;
				var region = A3($author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion, row, col, op);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED SYMBOL',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I ran into an unexpected symbol:'),
							$author$project$Compiler$Reporting$Doc$reflow('I was not expecting to see a ' + (op + (' here. Try deleting it? Maybe' + ' I can give a better hint from there?'))))));
			case 'Close':
				var term = _v0.a;
				var bracket = _v0.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED ' + A2($elm$core$String$map, $elm$core$Char$toUpper, term),
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I ran into an unexpected ' + (term + ':')),
							$author$project$Compiler$Reporting$Doc$reflow(
								'This ' + (A2($elm$core$String$cons, bracket, ' does not match up with an earlier open ') + (term + '. Try deleting it?'))))));
			case 'Lower':
				var c = _v0.a;
				var cs = _v0.b;
				var region = A3(
					$author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion,
					row,
					col,
					A2($elm$core$String$cons, c, cs));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this name:'),
							$author$project$Compiler$Reporting$Doc$reflow('It is confusing me a lot! Normally I can give fairly specific hints, but' + ' something is really tripping me up this time.'))));
			case 'Upper':
				var c = _v0.a;
				var cs = _v0.b;
				var region = A3(
					$author$project$Compiler$Reporting$Error$Syntax$toKeywordRegion,
					row,
					col,
					A2($elm$core$String$cons, c, cs));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this name:'),
							$author$project$Compiler$Reporting$Doc$reflow('It is confusing me a lot! Normally I can give fairly specific hints, but' + ' something is really tripping me up this time.'))));
			default:
				var maybeChar = _v0.a;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				if (maybeChar.$ === 'Just') {
					switch (maybeChar.a.valueOf()) {
						case ';':
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED SEMICOLON',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this semicolon:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Try removing it?'),
													$author$project$Compiler$Reporting$Doc$toSimpleNote('Some languages require semicolons at the end of each statement. These are' + (' often called C-like languages, and they usually share a lot of language design' + (' choices. (E.g. side-effects, for loops, etc.) Elm manages effects with commands' + (' and subscriptions instead, so there is no special syntax for \"statements\" and' + (' therefore no need to use semicolons to separate them. I think this will make' + ' more sense as you work through <https://guide.elm-lang.org> though!')))))
												])))));
						case ',':
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED COMMA',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this comma:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('I do not think I am parsing a list or tuple right now. Try deleting the comma?'),
													$author$project$Compiler$Reporting$Doc$toSimpleNote('If this is supposed to be part of a list, the problem may be a bit earlier.' + (' Perhaps the opening [ is missing? Or perhaps some value in the list has an extra' + (' closing ] that is making me think the list ended earlier? The same kinds of' + ' things could be going wrong if this is supposed to be a tuple.')))
												])))));
						case '`':
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED CHARACTER',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this character:'),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('It is not used for anything in Elm syntax. It is used for multi-line strings in' + (' some languages though, so if you want a string that spans multiple lines, you' + ' can use Elm\'s multi-line string syntax like this:')),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"\"\"'),
																$author$project$Compiler$Reporting$Doc$dullyellowS('# Multi-line Strings'),
																$author$project$Compiler$Reporting$Doc$dullyellowS(''),
																$author$project$Compiler$Reporting$Doc$dullyellowS('- start with triple double quotes'),
																$author$project$Compiler$Reporting$Doc$dullyellowS('- write whatever you want'),
																$author$project$Compiler$Reporting$Doc$dullyellowS('- no need to escape newlines or double quotes'),
																$author$project$Compiler$Reporting$Doc$dullyellowS('- end with triple double quotes'),
																$author$project$Compiler$Reporting$Doc$dullyellowS('\"\"\"')
															]))),
													$author$project$Compiler$Reporting$Doc$reflow('Otherwise I do not know what is going on! Try removing the character?')
												])))));
						case '$':
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED SYMBOL',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this dollar sign:'),
										$author$project$Compiler$Reporting$Doc$reflow('It is not used for anything in Elm syntax. Are you coming from a language where' + (' dollar signs can be used in variable names? If so, try a name that (1) starts' + ' with a letter and (2) only contains letters, numbers, and underscores.')))));
						default:
							var c = maybeChar.a;
							return A2(
								$author$project$Extra$Type$List$elem,
								c,
								_List_fromArray(
									[
										_Utils_chr('#'),
										_Utils_chr('@'),
										_Utils_chr('!'),
										_Utils_chr('%'),
										_Utils_chr('~')
									])) ? A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNEXPECTED SYMBOL',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I got stuck on this symbol:'),
										$author$project$Compiler$Reporting$Doc$reflow('It is not used for anything in Elm syntax. Try removing it?')))) : A2($author$project$Compiler$Reporting$Error$Syntax$toWeirdEndReportOther, source, region);
					}
				} else {
					return A2($author$project$Compiler$Reporting$Error$Syntax$toWeirdEndReportOther, source, region);
				}
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toParseErrorReport = F2(
	function (source, modul) {
		switch (modul.$) {
			case 'ModuleSpace':
				var space = modul.a;
				var row = modul.b;
				var col = modul.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toSpaceReport, source, space, row, col);
			case 'ModuleBadEnd':
				var row = modul.a;
				var col = modul.b;
				return (col === 1) ? A3($author$project$Compiler$Reporting$Error$Syntax$toDeclStartReport, source, row, col) : A3($author$project$Compiler$Reporting$Error$Syntax$toWeirdEndReport, source, row, col);
			case 'ModuleProblem':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED MODULE DECLARATION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am parsing an `module` declaration, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Here are some examples of valid `module` declarations:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Main'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Dict'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(Dict, empty, get)')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('I generally recommend using an explicit exposing list. I can skip compiling a bunch' + (' of files when the public interface of a module stays the same, so exposing fewer' + ' values can help improve compile times!'))
									])))));
			case 'ModuleName':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING MODULE NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was parsing an `module` declaration until I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the module name next, like in these examples:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Dict'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Maybe'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html.Attributes'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Json.Decode'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that the module names all start with capital letters. That is required!')
									])))));
			case 'ModuleExposing':
				var exposing_ = modul.a;
				var row = modul.b;
				var col = modul.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toExposingReport, source, exposing_, row, col);
			case 'PortModuleProblem':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED PORT MODULE DECLARATION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am parsing an `port module` declaration, but I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Here are some examples of valid `port module` declarations:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('port'),
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('WebSockets'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(send, listen, keepAlive)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('port'),
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Maps'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(Location, goto)')
														]))
												]))),
										A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Read', 'ports', 'for more help.')
									])))));
			case 'PortModuleName':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING MODULE NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was parsing an `module` declaration until I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the module name next, like in these examples:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('port'),
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('WebSockets'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(send, listen, keepAlive)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('port'),
															$author$project$Compiler$Reporting$Doc$cyanS('module'),
															$author$project$Compiler$Reporting$Doc$fromChars('Maps'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(Location, goto)')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that the module names start with capital letters. That is required!')
									])))));
			case 'PortModuleExposing':
				var exposing_ = modul.a;
				var row = modul.b;
				var col = modul.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toExposingReport, source, exposing_, row, col);
			case 'Effect':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD MODULE DECLARATION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I cannot parse this module declaration:'),
							$author$project$Compiler$Reporting$Doc$reflow('This type of module is reserved for the @elm organization. It is used to' + ' define certain effects, avoiding building them into the compiler.'))));
			case 'FreshLine':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				var toBadFirstLineReport = function (keyword) {
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'TOO MUCH INDENTATION',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('This `' + (keyword + '` should not have any spaces before it:')),
								$author$project$Compiler$Reporting$Doc$reflow('Delete the spaces before `' + (keyword + '` until there are none left!')))));
				};
				var _v1 = A3($author$project$Compiler$Reporting$Render$Code$whatIsNext, source, row, col);
				_v1$4:
				while (true) {
					if (_v1.$ === 'Keyword') {
						switch (_v1.a) {
							case 'module':
								return toBadFirstLineReport('module');
							case 'import':
								return toBadFirstLineReport('import');
							case 'type':
								return toBadFirstLineReport('type');
							case 'port':
								return toBadFirstLineReport('port');
							default:
								break _v1$4;
						}
					} else {
						break _v1$4;
					}
				}
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'SYNTAX PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I am not sure what is going on, but I recommend starting an Elm' + ' file with the following lines:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html')
														])),
													$author$project$Compiler$Reporting$Doc$fromChars(''),
													$author$project$Compiler$Reporting$Doc$fromChars('main ='),
													$author$project$Compiler$Reporting$Doc$hcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('  Html.text '),
															$author$project$Compiler$Reporting$Doc$dullyellowS('\"Hello!\"')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('You should be able to copy those lines directly into your file. Check out the' + ' examples at <https://elm-lang.org/examples> for more help getting started!'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('This can also happen when something is indented too much!')
									])))));
			case 'ImportStart':
				var row = modul.a;
				var col = modul.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toImportReport, source, row, col);
			case 'ImportName':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING IMPORT NAME',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was parsing an `import` until I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a module name next, like in these examples:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Dict')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Maybe')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html.Attributes'),
															$author$project$Compiler$Reporting$Doc$cyanS('as'),
															$author$project$Compiler$Reporting$Doc$fromChars('A')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Json.Decode'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that the module names all start with capital letters. That is required!'),
										A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'imports', 'to learn more.')
									])))));
			case 'ImportAs':
				var row = modul.a;
				var col = modul.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toImportReport, source, row, col);
			case 'ImportAlias':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EXPECTING IMPORT ALIAS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was parsing an `import` until I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see an alias next, like in these examples:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html.Attributes'),
															$author$project$Compiler$Reporting$Doc$cyanS('as'),
															$author$project$Compiler$Reporting$Doc$fromChars('Attr')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('WebGL.Texture'),
															$author$project$Compiler$Reporting$Doc$cyanS('as'),
															$author$project$Compiler$Reporting$Doc$fromChars('Texture')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Json.Decode'),
															$author$project$Compiler$Reporting$Doc$cyanS('as'),
															$author$project$Compiler$Reporting$Doc$fromChars('D')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('Notice that the alias always starts with a capital letter. That is required!'),
										A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'imports', 'to learn more.')
									])))));
			case 'ImportExposing':
				var row = modul.a;
				var col = modul.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toImportReport, source, row, col);
			case 'ImportExposingList':
				var exposing_ = modul.a;
				var row = modul.b;
				var col = modul.c;
				return A4($author$project$Compiler$Reporting$Error$Syntax$toExposingReport, source, exposing_, row, col);
			case 'ImportEnd':
				var row = modul.a;
				var col = modul.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toImportReport, source, row, col);
			case 'ImportIndentName':
				var row = modul.a;
				var col = modul.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toImportReport, source, row, col);
			case 'ImportIndentAlias':
				var row = modul.a;
				var col = modul.b;
				return A3($author$project$Compiler$Reporting$Error$Syntax$toImportReport, source, row, col);
			case 'ImportIndentExposingList':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNFINISHED IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I was parsing an `import` until I got stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see the list of exposed values next. For example, here' + ' are two ways to expose values from the `Html` module:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(..)')
														])),
													$author$project$Compiler$Reporting$Doc$fillSep(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$cyanS('import'),
															$author$project$Compiler$Reporting$Doc$fromChars('Html'),
															$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
															$author$project$Compiler$Reporting$Doc$fromChars('(Html, div, text)')
														]))
												]))),
										$author$project$Compiler$Reporting$Doc$reflow('I generally recommend the second style. It is more explicit, making it' + ' much easier to figure out where values are coming from in large projects!')
									])))));
			case 'Infix':
				var row = modul.a;
				var col = modul.b;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, row, col);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD INFIX',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Something went wrong in this infix operator declaration:'),
							$author$project$Compiler$Reporting$Doc$reflow('This feature is used by the @elm organization to define the' + ' languages built-in operators.'))));
			default:
				var decl = modul.a;
				return A2($author$project$Compiler$Reporting$Error$Syntax$toDeclarationsReport, source, decl);
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$toReport = F2(
	function (source, err) {
		switch (err.$) {
			case 'ModuleNameUnspecified':
				var name = err.a;
				var region = A2($author$project$Compiler$Reporting$Error$Syntax$toRegion, 1, 1);
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MODULE NAME MISSING',
					region,
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('I need the module name to be declared at the top of this file, like this:'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$cyanS('module'),
											$author$project$Compiler$Reporting$Doc$fromName(name),
											$author$project$Compiler$Reporting$Doc$cyanS('exposing'),
											$author$project$Compiler$Reporting$Doc$d('(..)')
										]))),
								$author$project$Compiler$Reporting$Doc$reflow('Try adding that as the first line of your file!'),
								$author$project$Compiler$Reporting$Doc$toSimpleNote('It is best to replace (..) with an explicit list of types and' + (' functions you want to expose. When you know a value is only used' + (' within this module, you can refactor without worrying about uses' + (' elsewhere. Limiting exposed values can also speed up compilation' + (' because I can skip a bunch of work if I see that the exposed API' + ' has not changed.')))))
							])));
			case 'ModuleNameMismatch':
				var expectedName = err.a;
				var _v1 = err.b;
				var region = _v1.a;
				var actualName = _v1.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MODULE NAME MISMATCH',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$d('It looks like this module name is out of sync:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow(
										'I need it to match the file path, so I was expecting to see `' + ($author$project$Compiler$Elm$ModuleName$toChars(expectedName) + '` here. Make the following change, and you should be all set!')),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$da(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellow(
													$author$project$Compiler$Reporting$Doc$fromName(actualName)),
													$author$project$Compiler$Reporting$Doc$d(' -> '),
													$author$project$Compiler$Reporting$Doc$green(
													$author$project$Compiler$Reporting$Doc$fromName(expectedName))
												]))),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('I require that module names correspond to file paths. This makes it much' + (' easier to explore unfamiliar codebases! So if you want to keep the current' + ' module name, try renaming the file instead.'))
									])))));
			case 'UnexpectedPort':
				var region = err.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNEXPECTED PORTS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('You are declaring ports in a normal module.'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Switch this to say'),
												$author$project$Compiler$Reporting$Doc$cyanS('port module'),
												$author$project$Compiler$Reporting$Doc$reflow('instead, marking that this module contains port declarations.')
											])),
										A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Ports are not a traditional FFI for calling JS functions directly. They need a different mindset! Read', 'ports', 'to learn the syntax and how to use it effectively.')
									])))));
			case 'NoPorts':
				var region = err.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'NO PORTS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('This module does not declare any ports, but it says it will:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Switch this to'),
										$author$project$Compiler$Reporting$Doc$cyanS('module'),
										$author$project$Compiler$Reporting$Doc$reflow('and you should be all set!')
									])))));
			case 'NoPortsInPackage':
				var _v2 = err.a;
				var region = _v2.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PACKAGES CANNOT HAVE PORTS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Packages cannot declare any ports, so I am getting stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Remove this port declaration.'),
										$author$project$Compiler$Reporting$Error$Syntax$noteForPortsInPackage
									])))));
			case 'NoPortModulesInPackage':
				var region = err.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'PACKAGES CANNOT HAVE PORTS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Packages cannot declare any ports, so I am getting stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Remove the'),
												$author$project$Compiler$Reporting$Doc$cyanS('port'),
												$author$project$Compiler$Reporting$Doc$reflow('keyword and I'),
												$author$project$Compiler$Reporting$Doc$reflow('should be able to continue.')
											])),
										$author$project$Compiler$Reporting$Error$Syntax$noteForPortsInPackage
									])))));
			case 'NoEffectsOutsideKernel':
				var region = err.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'INVALID EFFECT MODULE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('It is not possible to declare an `effect module` outside the @elm organization,' + ' so I am getting stuck here:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Switch to a normal module declaration.'),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('Effect modules are designed to allow certain core functionality to be' + (' defined separately from the compiler. So the @elm organization has access to' + (' this so that certain changes, extensions, and fixes can be introduced without' + (' needing to release new Elm binaries. For example, we want to make it possible' + (' to test effects, but this may require changes to the design of effect modules.' + (' By only having them defined in the @elm organization, that kind of design work' + ' can proceed much more smoothly.'))))))
									])))));
			default:
				var modul = err.a;
				return A2($author$project$Compiler$Reporting$Error$Syntax$toParseErrorReport, source, modul);
		}
	});
var $author$project$Compiler$Reporting$Render$Code$Source = function (a) {
	return {$: 'Source', a: a};
};
var $author$project$Extra$Type$List$indexedFrom = F2(
	function (n, l) {
		return A2(
			$elm$core$List$indexedMap,
			F2(
				function (i, a) {
					return _Utils_Tuple2(i + n, a);
				}),
			l);
	});
var $elm$core$String$lines = _String_lines;
var $author$project$Compiler$Reporting$Render$Code$toSource = function (source) {
	return $author$project$Compiler$Reporting$Render$Code$Source(
		A2(
			$author$project$Extra$Type$List$indexedFrom,
			1,
			$elm$core$String$lines(source)));
};
var $author$project$Terminal$Repl$toDeclPosition = F2(
	function (src, decl) {
		var err = $author$project$Compiler$Reporting$Error$Syntax$ParseError(
			$author$project$Compiler$Reporting$Error$Syntax$Declarations(decl));
		var report = A2(
			$author$project$Compiler$Reporting$Error$Syntax$toReport,
			$author$project$Compiler$Reporting$Render$Code$toSource(src),
			err);
		var _v0 = report;
		var _v1 = _v0.b;
		var _v2 = _v1.a;
		var row = _v2.a;
		var col = _v2.b;
		return _Utils_Tuple2(row, col);
	});
var $author$project$Compiler$Data$Name$replValueToPrint = 'repl_input_value_';
var $author$project$Terminal$Repl$toExprPosition = F4(
	function (src, expr, row, col) {
		var decl = A4(
			$author$project$Compiler$Reporting$Error$Syntax$DeclDef,
			$author$project$Compiler$Data$Name$replValueToPrint,
			A3($author$project$Compiler$Reporting$Error$Syntax$DeclDefBody, expr, row, col),
			row,
			col);
		return A2($author$project$Terminal$Repl$toDeclPosition, src, decl);
	});
var $author$project$Terminal$Repl$attemptDeclOrExpr = function (lines) {
	var src = $author$project$Terminal$Repl$linesToByteString(lines);
	var exprParser = A2(
		$author$project$Compiler$Parse$Primitives$specialize,
		$author$project$Terminal$Repl$toExprPosition(src),
		$author$project$Compiler$Parse$Expression$expression);
	var declParser = A2(
		$author$project$Compiler$Parse$Primitives$specialize,
		F3(
			function (decl, _v16, _v17) {
				return A2($author$project$Terminal$Repl$toDeclPosition, src, decl);
			}),
		$author$project$Compiler$Parse$Declaration$declaration);
	var _v0 = A3($author$project$Compiler$Parse$Primitives$fromByteString, declParser, $elm$core$Tuple$pair, src);
	if (_v0.$ === 'Right') {
		var _v1 = _v0.a;
		var decl = _v1.a;
		switch (decl.$) {
			case 'Value':
				var _v3 = decl.a;
				var _v4 = _v3.b;
				var _v5 = _v4.a;
				var name = _v5.b;
				return A2(
					$author$project$Terminal$Repl$ifDone,
					lines,
					A2($author$project$Terminal$Repl$Decl, name, src));
			case 'Union':
				var _v6 = decl.a;
				var _v7 = _v6.b;
				var _v8 = _v7.a;
				var name = _v8.b;
				return A2(
					$author$project$Terminal$Repl$ifDone,
					lines,
					A2($author$project$Terminal$Repl$Type, name, src));
			case 'Alias':
				var _v9 = decl.a;
				var _v10 = _v9.b;
				var _v11 = _v10.a;
				var name = _v11.b;
				return A2(
					$author$project$Terminal$Repl$ifDone,
					lines,
					A2($author$project$Terminal$Repl$Type, name, src));
			default:
				return $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Port);
		}
	} else {
		var declPosition = _v0.a;
		if (A2($author$project$Terminal$Repl$startsWithKeyword, 'type', lines)) {
			return A2(
				$author$project$Terminal$Repl$ifFail,
				lines,
				A2($author$project$Terminal$Repl$Type, 'ERR', src));
		} else {
			if (A2($author$project$Terminal$Repl$startsWithKeyword, 'port', lines)) {
				return $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Port);
			} else {
				var _v12 = A3($author$project$Compiler$Parse$Primitives$fromByteString, exprParser, $elm$core$Tuple$pair, src);
				if (_v12.$ === 'Right') {
					return A2(
						$author$project$Terminal$Repl$ifDone,
						lines,
						$author$project$Terminal$Repl$Expr(src));
				} else {
					var exprPosition = _v12.a;
					if (_Utils_cmp(exprPosition, declPosition) > -1) {
						return A2(
							$author$project$Terminal$Repl$ifFail,
							lines,
							$author$project$Terminal$Repl$Expr(src));
					} else {
						var _v13 = A3(
							$author$project$Compiler$Parse$Primitives$fromByteString,
							$author$project$Terminal$Repl$annotation,
							F2(
								function (_v14, _v15) {
									return _Utils_Tuple0;
								}),
							src);
						if (_v13.$ === 'Right') {
							var name = _v13.a;
							return $author$project$Terminal$Repl$Continue(
								$author$project$Terminal$Repl$DefStart(name));
						} else {
							return A2(
								$author$project$Terminal$Repl$ifFail,
								lines,
								A2($author$project$Terminal$Repl$Decl, 'ERR', src));
						}
					}
				}
			}
		}
	}
};
var $author$project$Terminal$Repl$Import = F2(
	function (a, b) {
		return {$: 'Import', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Explicit = function (a) {
	return {$: 'Explicit', a: a};
};
var $author$project$Compiler$AST$Source$Import = F3(
	function (a, b, c) {
		return {$: 'Import', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportAs = F2(
	function (a, b) {
		return {$: 'ImportAs', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportEnd = F2(
	function (a, b) {
		return {$: 'ImportEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportIndentName = F2(
	function (a, b) {
		return {$: 'ImportIndentName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportName = F2(
	function (a, b) {
		return {$: 'ImportName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportStart = F2(
	function (a, b) {
		return {$: 'ImportStart', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace = F3(
	function (a, b, c) {
		return {$: 'ModuleSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportAlias = F2(
	function (a, b) {
		return {$: 'ImportAlias', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportIndentAlias = F2(
	function (a, b) {
		return {$: 'ImportIndentAlias', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportExposing = F2(
	function (a, b) {
		return {$: 'ImportExposing', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportExposingList = F3(
	function (a, b, c) {
		return {$: 'ImportExposingList', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ImportIndentExposingList = F2(
	function (a, b) {
		return {$: 'ImportIndentExposingList', a: a, b: b};
	});
var $author$project$Compiler$Parse$Keyword$k8 = F9(
	function (w1, w2, w3, w4, w5, w6, w7, w8, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos8 = pos + 8;
				if ((_Utils_cmp(pos8, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2),
					w3) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3),
					w4) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4),
					w5) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 5),
					w6) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 6),
					w7) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 7),
					w8) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos8, end))))))))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos8, end, indent, row, col + 8);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$exposing_ = function (tx) {
	return A9($author$project$Compiler$Parse$Keyword$k8, 101, 120, 112, 111, 115, 105, 110, 103, tx);
};
var $author$project$Compiler$Reporting$Error$Syntax$ExposingEnd = F2(
	function (a, b) {
		return {$: 'ExposingEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentEnd = F2(
	function (a, b) {
		return {$: 'ExposingIndentEnd', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentValue = F2(
	function (a, b) {
		return {$: 'ExposingIndentValue', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace = F3(
	function (a, b, c) {
		return {$: 'ExposingSpace', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingStart = F2(
	function (a, b) {
		return {$: 'ExposingStart', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingValue = F2(
	function (a, b) {
		return {$: 'ExposingValue', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Open = {$: 'Open'};
var $author$project$Compiler$Reporting$Error$Syntax$ExposingOperator = F2(
	function (a, b) {
		return {$: 'ExposingOperator', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingOperatorReserved = F3(
	function (a, b, c) {
		return {$: 'ExposingOperatorReserved', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingOperatorRightParen = F2(
	function (a, b) {
		return {$: 'ExposingOperatorRightParen', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Lower = function (a) {
	return {$: 'Lower', a: a};
};
var $author$project$Compiler$AST$Source$Operator = F2(
	function (a, b) {
		return {$: 'Operator', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Upper = F2(
	function (a, b) {
		return {$: 'Upper', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ExposingTypePrivacy = F2(
	function (a, b) {
		return {$: 'ExposingTypePrivacy', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Private = {$: 'Private'};
var $author$project$Compiler$AST$Source$Public = function (a) {
	return {$: 'Public', a: a};
};
var $author$project$Compiler$Parse$Module$privacy = A2(
	$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
	_List_fromArray(
		[
			A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Primitives$word1, 40, $author$project$Compiler$Reporting$Error$Syntax$ExposingTypePrivacy),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingTypePrivacy),
					function (_v1) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$getPosition,
							function (start) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A3($author$project$Compiler$Parse$Primitives$word2, 46, 46, $author$project$Compiler$Reporting$Error$Syntax$ExposingTypePrivacy),
									function (_v2) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Primitives$getPosition,
											function (end) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingTypePrivacy),
													function (_v3) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$ExposingTypePrivacy),
															function (_v4) {
																return $author$project$Compiler$Parse$Primitives$return(
																	$author$project$Compiler$AST$Source$Public(
																		A2($author$project$Compiler$Reporting$Annotation$Region, start, end)));
															});
													});
											});
									});
							});
					});
			})
		]),
	$author$project$Compiler$AST$Source$Private);
var $author$project$Compiler$Parse$Module$chompExposed = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Primitives$getPosition,
	function (start) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Reporting$Error$Syntax$ExposingValue,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Variable$lower($author$project$Compiler$Reporting$Error$Syntax$ExposingValue),
					function (name) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$getPosition,
							function (end) {
								return $author$project$Compiler$Parse$Primitives$return(
									$author$project$Compiler$AST$Source$Lower(
										A3($author$project$Compiler$Reporting$Annotation$at, start, end, name)));
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 40, $author$project$Compiler$Reporting$Error$Syntax$ExposingValue),
					function (_v0) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Symbol$operator, $author$project$Compiler$Reporting$Error$Syntax$ExposingOperator, $author$project$Compiler$Reporting$Error$Syntax$ExposingOperatorReserved),
							function (op) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$ExposingOperatorRightParen),
									function (_v1) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Primitives$getPosition,
											function (end) {
												return $author$project$Compiler$Parse$Primitives$return(
													A2(
														$author$project$Compiler$AST$Source$Operator,
														A2($author$project$Compiler$Reporting$Annotation$Region, start, end),
														op));
											});
									});
							});
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$ExposingValue),
					function (name) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Primitives$getPosition,
							function (end) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentEnd),
									function (_v2) {
										return A2(
											$author$project$Compiler$Parse$Primitives$fmap,
											$author$project$Compiler$AST$Source$Upper(
												A3($author$project$Compiler$Reporting$Annotation$at, start, end, name)),
											$author$project$Compiler$Parse$Module$privacy);
									});
							});
					})
				]));
	});
var $author$project$Compiler$Parse$Module$exposingHelp = function (revExposed) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Reporting$Error$Syntax$ExposingEnd,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$ExposingEnd),
				function (_v0) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentValue),
						function (_v1) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Module$chompExposed,
								function (exposed) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentEnd),
										function (_v2) {
											return $author$project$Compiler$Parse$Primitives$return(
												$author$project$Compiler$Parse$Primitives$Loop(
													A2($elm$core$List$cons, exposed, revExposed)));
										});
								});
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$ExposingEnd),
				function (_v3) {
					return $author$project$Compiler$Parse$Primitives$return(
						$author$project$Compiler$Parse$Primitives$Done(
							$author$project$Compiler$AST$Source$Explicit(
								$author$project$Extra$Type$List$reverse(revExposed))));
				})
			]));
};
var $author$project$Compiler$Parse$Module$exposing_ = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	A2($author$project$Compiler$Parse$Primitives$word1, 40, $author$project$Compiler$Reporting$Error$Syntax$ExposingStart),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentValue),
			function (_v1) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$ExposingValue,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A3($author$project$Compiler$Parse$Primitives$word2, 46, 46, $author$project$Compiler$Reporting$Error$Syntax$ExposingValue),
							function (_v2) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentEnd),
									function (_v3) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Primitives$word1, 41, $author$project$Compiler$Reporting$Error$Syntax$ExposingEnd),
											function (_v4) {
												return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$AST$Source$Open);
											});
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Module$chompExposed,
							function (exposed) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ExposingSpace, $author$project$Compiler$Reporting$Error$Syntax$ExposingIndentEnd),
									function (_v5) {
										return A2(
											$author$project$Compiler$Parse$Primitives$loop,
											$author$project$Compiler$Parse$Module$exposingHelp,
											_List_fromArray(
												[exposed]));
									});
							})
						]));
			});
	});
var $author$project$Compiler$Parse$Module$freshLine = function (toFreshLineError) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$ModuleSpace),
		function (_v0) {
			return $author$project$Compiler$Parse$Space$checkFreshLine(toFreshLineError);
		});
};
var $author$project$Compiler$Parse$Module$chompExposing = F2(
	function (name, maybeAlias) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Keyword$exposing_($author$project$Compiler$Reporting$Error$Syntax$ImportExposing),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$ImportIndentExposingList),
					function (_v1) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$ImportExposingList, $author$project$Compiler$Parse$Module$exposing_),
							function (exposed) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Module$freshLine($author$project$Compiler$Reporting$Error$Syntax$ImportEnd),
									function (_v2) {
										return $author$project$Compiler$Parse$Primitives$return(
											A3($author$project$Compiler$AST$Source$Import, name, maybeAlias, exposed));
									});
							});
					});
			});
	});
var $author$project$Compiler$Parse$Module$chompAs = function (name) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Keyword$as_($author$project$Compiler$Reporting$Error$Syntax$ImportAs),
		function (_v0) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$ImportIndentAlias),
				function (_v1) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$ImportAlias),
						function (alias_) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Parse$Primitives$getPosition,
								function (end) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$ModuleSpace),
										function (_v2) {
											return A2(
												$author$project$Compiler$Parse$Primitives$oneOf,
												$author$project$Compiler$Reporting$Error$Syntax$ImportEnd,
												_List_fromArray(
													[
														A2(
														$author$project$Compiler$Parse$Primitives$bind,
														$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Reporting$Error$Syntax$ImportEnd),
														function (_v3) {
															return $author$project$Compiler$Parse$Primitives$return(
																A3(
																	$author$project$Compiler$AST$Source$Import,
																	name,
																	$elm$core$Maybe$Just(alias_),
																	$author$project$Compiler$AST$Source$Explicit(_List_Nil)));
														}),
														A2(
														$author$project$Compiler$Parse$Primitives$bind,
														A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$ImportEnd),
														function (_v4) {
															return A2(
																$author$project$Compiler$Parse$Module$chompExposing,
																name,
																$elm$core$Maybe$Just(alias_));
														})
													]));
										});
								});
						});
				});
		});
};
var $author$project$Compiler$Parse$Keyword$k6 = F7(
	function (w1, w2, w3, w4, w5, w6, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos6 = pos + 6;
				if ((_Utils_cmp(pos6, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2),
					w3) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3),
					w4) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4),
					w5) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 5),
					w6) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos6, end))))))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos6, end, indent, row, col + 6);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$import_ = function (tx) {
	return A7($author$project$Compiler$Parse$Keyword$k6, 105, 109, 112, 111, 114, 116, tx);
};
var $author$project$Compiler$Parse$Variable$Bad = {$: 'Bad'};
var $author$project$Compiler$Parse$Variable$Good = {$: 'Good'};
var $author$project$Compiler$Parse$Variable$moduleNameHelp = F4(
	function (src, pos, end, col) {
		moduleNameHelp:
		while (true) {
			if (A3($author$project$Compiler$Parse$Variable$isDot, src, pos, end)) {
				var pos1 = pos + 1;
				var _v0 = A4($author$project$Compiler$Parse$Variable$chompUpper, src, pos1, end, col + 1);
				var newPos = _v0.a;
				var newCol = _v0.b;
				if (_Utils_eq(pos1, newPos)) {
					return _Utils_Tuple3($author$project$Compiler$Parse$Variable$Bad, newPos, newCol);
				} else {
					var $temp$src = src,
						$temp$pos = newPos,
						$temp$end = end,
						$temp$col = newCol;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					col = $temp$col;
					continue moduleNameHelp;
				}
			} else {
				return _Utils_Tuple3($author$project$Compiler$Parse$Variable$Good, pos, col);
			}
		}
	});
var $author$project$Compiler$Parse$Variable$moduleName = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var _v1 = A4($author$project$Compiler$Parse$Variable$chompUpper, src, pos, end, col);
			var pos1 = _v1.a;
			var col1 = _v1.b;
			if (_Utils_eq(pos, pos1)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
			} else {
				var _v2 = A4($author$project$Compiler$Parse$Variable$moduleNameHelp, src, pos1, end, col1);
				var status = _v2.a;
				var newPos = _v2.b;
				var newCol = _v2.c;
				if (status.$ === 'Good') {
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
					var name = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, newPos);
					return A2($author$project$Compiler$Parse$Primitives$Cok, name, newState);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Cerr, row, newCol, toError);
				}
			}
		});
};
var $author$project$Compiler$Parse$Module$chompImport = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Keyword$import_($author$project$Compiler$Reporting$Error$Syntax$ImportStart),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$ImportIndentName),
			function (_v1) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Primitives$addLocation(
						$author$project$Compiler$Parse$Variable$moduleName($author$project$Compiler$Reporting$Error$Syntax$ImportName)),
					function (name) {
						var _v2 = name.a;
						var end = _v2.b;
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$ModuleSpace),
							function (_v3) {
								return A2(
									$author$project$Compiler$Parse$Primitives$oneOf,
									$author$project$Compiler$Reporting$Error$Syntax$ImportEnd,
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Reporting$Error$Syntax$ImportEnd),
											function (_v4) {
												return $author$project$Compiler$Parse$Primitives$return(
													A3(
														$author$project$Compiler$AST$Source$Import,
														name,
														$elm$core$Maybe$Nothing,
														$author$project$Compiler$AST$Source$Explicit(_List_Nil)));
											}),
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$checkIndent, end, $author$project$Compiler$Reporting$Error$Syntax$ImportEnd),
											function (_v5) {
												return A2(
													$author$project$Compiler$Parse$Primitives$oneOf,
													$author$project$Compiler$Reporting$Error$Syntax$ImportAs,
													_List_fromArray(
														[
															$author$project$Compiler$Parse$Module$chompAs(name),
															A2($author$project$Compiler$Parse$Module$chompExposing, name, $elm$core$Maybe$Nothing)
														]));
											})
										]));
							});
					});
			});
	});
var $author$project$Terminal$Repl$attemptImport = function (lines) {
	var src = $author$project$Terminal$Repl$linesToByteString(lines);
	var parser = A2(
		$author$project$Compiler$Parse$Primitives$specialize,
		F3(
			function (_v5, _v6, _v7) {
				return _Utils_Tuple0;
			}),
		$author$project$Compiler$Parse$Module$chompImport);
	var _v0 = A3(
		$author$project$Compiler$Parse$Primitives$fromByteString,
		parser,
		F2(
			function (_v1, _v2) {
				return _Utils_Tuple0;
			}),
		src);
	if (_v0.$ === 'Right') {
		var _v3 = _v0.a;
		var _v4 = _v3.a;
		var name = _v4.b;
		return $author$project$Terminal$Repl$Done(
			A2($author$project$Terminal$Repl$Import, name, src));
	} else {
		return A2(
			$author$project$Terminal$Repl$ifFail,
			lines,
			A2($author$project$Terminal$Repl$Import, 'ERR', src));
	}
};
var $elm$core$List$head = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(x);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Terminal$Repl$isBlank = function (_v0) {
	var prev = _v0.a;
	var rev = _v0.b;
	return $author$project$Extra$Type$List$null(rev) && A2(
		$elm$core$String$all,
		$elm$core$Basics$eq(
			_Utils_chr(' ')),
		prev);
};
var $author$project$Terminal$Repl$isBreakpoint = function (mode) {
	if (mode.$ === 'Breakpoint') {
		return true;
	} else {
		return false;
	}
};
var $elm$core$String$trimLeft = _String_trimLeft;
var $author$project$Terminal$Repl$startsWithColon = function (lines) {
	var _v0 = $elm$core$String$uncons(
		$elm$core$String$trimLeft(
			$author$project$Terminal$Repl$getFirstLine(lines)));
	if (_v0.$ === 'Nothing') {
		return false;
	} else {
		var _v1 = _v0.a;
		var c = _v1.a;
		return _Utils_eq(
			c,
			_Utils_chr(':'));
	}
};
var $author$project$Terminal$Repl$categorize = F2(
	function (mode, lines) {
		return $author$project$Terminal$Repl$isBlank(lines) ? $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Skip) : ($author$project$Terminal$Repl$startsWithColon(lines) ? A2($author$project$Terminal$Repl$toCommand, mode, lines) : (A2($author$project$Terminal$Repl$startsWithKeyword, 'import', lines) ? $author$project$Terminal$Repl$attemptImport(lines) : $author$project$Terminal$Repl$attemptDeclOrExpr(lines)));
	});
var $author$project$Terminal$Repl$toCommand = F2(
	function (mode, lines) {
		toCommand:
		while (true) {
			var _v0 = A2(
				$elm$core$String$dropLeft,
				1,
				$elm$core$String$trimLeft(
					$author$project$Terminal$Repl$getFirstLine(lines)));
			switch (_v0) {
				case 'reset':
					return $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Reset);
				case 'exit':
					return $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Exit);
				case 'quit':
					if ($author$project$Terminal$Repl$isBreakpoint(mode)) {
						var $temp$mode = mode,
							$temp$lines = A2($author$project$Terminal$Repl$Lines, ':resume', _List_Nil);
						mode = $temp$mode;
						lines = $temp$lines;
						continue toCommand;
					} else {
						return $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Exit);
					}
				case 'force_quit_':
					return $author$project$Terminal$Repl$Done($author$project$Terminal$Repl$Exit);
				case 'help':
					return $author$project$Terminal$Repl$Done(
						$author$project$Terminal$Repl$Help($elm$core$Maybe$Nothing));
				case 'resume':
					return $author$project$Terminal$Repl$isBreakpoint(mode) ? A2(
						$author$project$Terminal$Repl$categorize,
						mode,
						A2($author$project$Terminal$Repl$Lines, 'Breakpoint.resume bp', _List_Nil)) : $author$project$Terminal$Repl$Done(
						$author$project$Terminal$Repl$Help(
							$elm$core$Maybe$Just('resume')));
				default:
					var rest = _v0;
					return ($author$project$Terminal$Repl$isBreakpoint(mode) && (A2($elm$core$String$startsWith, 'resume ', rest) && ($elm$core$String$trimLeft(
						A2($elm$core$String$dropLeft, 7, rest)) !== ''))) ? A2(
						$author$project$Terminal$Repl$categorize,
						mode,
						A2(
							$author$project$Terminal$Repl$Lines,
							'Breakpoint.resumeWith bp <|' + A2($elm$core$String$dropLeft, 6, rest),
							_List_Nil)) : $author$project$Terminal$Repl$Done(
						$author$project$Terminal$Repl$Help(
							$elm$core$List$head(
								$elm$core$String$words(rest))));
			}
		}
	});
var $author$project$Terminal$Repl$End = {$: 'End'};
var $author$project$Terminal$Repl$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $author$project$Terminal$Repl$OutputDecl = function (a) {
	return {$: 'OutputDecl', a: a};
};
var $author$project$Terminal$Repl$OutputExpr = function (a) {
	return {$: 'OutputExpr', a: a};
};
var $author$project$Terminal$Repl$OutputNothing = {$: 'OutputNothing'};
var $author$project$Builder$Reporting$Exit$ReplBadDetails = function (a) {
	return {$: 'ReplBadDetails', a: a};
};
var $author$project$Builder$Reporting$Exit$ReplBadGenerate = function (a) {
	return {$: 'ReplBadGenerate', a: a};
};
var $author$project$Terminal$Repl$ShowError = function (a) {
	return {$: 'ShowError', a: a};
};
var $author$project$Builder$Reporting$Task$Task = function (a) {
	return {$: 'Task', a: a};
};
var $author$project$Builder$Reporting$Task$bind = F2(
	function (_v0, callback) {
		var taskA = _v0.a;
		return $author$project$Builder$Reporting$Task$Task(
			F2(
				function (ok, err) {
					var okA = function (a) {
						var _v1 = callback(a);
						var taskB = _v1.a;
						return A2(taskB, ok, err);
					};
					return A2(taskA, okA, err);
				}));
	});
var $elm$core$Basics$composeL = F3(
	function (g, f, x) {
		return g(
			f(x));
	});
var $author$project$Builder$Reporting$Task$eio = F2(
	function (func, work) {
		return $author$project$Builder$Reporting$Task$Task(
			F2(
				function (ok, err) {
					return A2(
						$author$project$Extra$System$IO$bind,
						work,
						function (result) {
							if (result.$ === 'Right') {
								var a = result.a;
								return ok(a);
							} else {
								var x = result.a;
								return err(
									func(x));
							}
						});
				}));
	});
var $author$project$Builder$Reporting$Task$fmap = F2(
	function (func, _v0) {
		var taskA = _v0.a;
		return $author$project$Builder$Reporting$Task$Task(
			F2(
				function (ok, err) {
					var okA = function (arg) {
						return ok(
							func(arg));
					};
					return A2(taskA, okA, err);
				}));
	});
var $author$project$Compiler$Reporting$Error$BadSyntax = function (a) {
	return {$: 'BadSyntax', a: a};
};
var $author$project$Builder$Reporting$Exit$ReplBadInput = F2(
	function (a, b) {
		return {$: 'ReplBadInput', a: a, b: b};
	});
var $author$project$Builder$Reporting$Exit$ReplProjectProblem = function (a) {
	return {$: 'ReplProjectProblem', a: a};
};
var $author$project$Extra$System$IO$andThen = F2(
	function (f, ma) {
		return A2($author$project$Extra$System$IO$bind, ma, f);
	});
var $author$project$Compiler$Data$NonEmptyList$CList = F2(
	function (a, b) {
		return {$: 'CList', a: a, b: b};
	});
var $author$project$Builder$Build$DepsBlock = {$: 'DepsBlock'};
var $author$project$Builder$Build$DepsChange = function (a) {
	return {$: 'DepsChange', a: a};
};
var $author$project$Builder$Build$DepsNotFound = function (a) {
	return {$: 'DepsNotFound', a: a};
};
var $author$project$Builder$Build$DepsSame = F2(
	function (a, b) {
		return {$: 'DepsSame', a: a, b: b};
	});
var $elm$core$Debug$toString = _Debug_toString;
var $author$project$Extra$Type$Map$ex = F2(
	function (m, k) {
		var _v0 = A2($author$project$Extra$Type$Map$lookup, k, m);
		if (_v0.$ === 'Just') {
			var a = _v0.a;
			return a;
		} else {
			return _Debug_todo(
				'Extra.Type.Map',
				{
					start: {line: 121, column: 13},
					end: {line: 121, column: 23}
				})(
				'Map.ex: key ' + ($elm$core$Debug$toString(k) + ' not found'));
		}
	});
var $author$project$Extra$Type$Map$fromList = $elm$core$Dict$fromList;
var $author$project$Builder$Build$lensMVResult = {
	getter: function (_v0) {
		var _v1 = _v0.d;
		var x = _v1.e;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var _v3 = _v2.d;
			var bi = _v3.a;
			var ci = _v3.b;
			var di = _v3.c;
			var ei = _v3.d;
			var fi = _v3.f;
			var gi = _v3.g;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				A7($author$project$Builder$Build$LocalState, bi, ci, di, ei, x, fi, gi),
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Build$Corrupted = {$: 'Corrupted'};
var $author$project$Builder$Build$Loaded = function (a) {
	return {$: 'Loaded', a: a};
};
var $author$project$Compiler$Elm$Interface$Interface = F5(
	function (a, b, c, d, e) {
		return {$: 'Interface', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Extra$Data$Binary$T5 = F5(
	function (a, b, c, d, e) {
		return {$: 'T5', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Elm$Interface$PrivateAlias = function (a) {
	return {$: 'PrivateAlias', a: a};
};
var $author$project$Compiler$Elm$Interface$PublicAlias = function (a) {
	return {$: 'PublicAlias', a: a};
};
var $author$project$Compiler$AST$Canonical$Alias = F2(
	function (a, b) {
		return {$: 'Alias', a: a, b: b};
	});
var $author$project$Extra$Data$Binary$T2 = F2(
	function (a, b) {
		return {$: 'T2', a: a, b: b};
	});
var $elm$bytes$Bytes$Decode$succeed = function (a) {
	return $elm$bytes$Bytes$Decode$Decoder(
		F2(
			function (_v0, offset) {
				return _Utils_Tuple2(offset, a);
			}));
};
var $author$project$Extra$Data$Binary$Get$bind = F3(
	function (ga, f, remaining1) {
		return A2(
			$elm$bytes$Bytes$Decode$andThen,
			function (ra) {
				if (ra.$ === 'Left') {
					var _v1 = ra.a;
					var remaining2 = _v1.a;
					var err = _v1.b;
					return $elm$bytes$Bytes$Decode$succeed(
						$author$project$Extra$Type$Either$Left(
							_Utils_Tuple2(remaining2, err)));
				} else {
					var _v2 = ra.a;
					var remaining2 = _v2.a;
					var a = _v2.b;
					return A2(f, a, remaining2);
				}
			},
			ga(remaining1));
	});
var $author$project$Extra$Data$Binary$Get$checkedOffset = F4(
	function (context, remaining, needed, decoder) {
		return (_Utils_cmp(needed, remaining) > 0) ? $elm$bytes$Bytes$Decode$succeed(
			$author$project$Extra$Type$Either$Left(
				_Utils_Tuple2(remaining, 'not enough bytes for ' + context))) : A2(
			$elm$bytes$Bytes$Decode$map,
			function (n) {
				return $author$project$Extra$Type$Either$Right(
					_Utils_Tuple2(remaining - needed, n));
			},
			decoder);
	});
var $author$project$Extra$Data$Binary$Get$getString = F2(
	function (width, remaining) {
		return A4(
			$author$project$Extra$Data$Binary$Get$checkedOffset,
			'string',
			remaining,
			width,
			$elm$bytes$Bytes$Decode$string(width));
	});
var $elm$bytes$Bytes$Encode$getStringWidth = _Bytes_getStringWidth;
var $elm$bytes$Bytes$Encode$Seq = F2(
	function (a, b) {
		return {$: 'Seq', a: a, b: b};
	});
var $elm$bytes$Bytes$Encode$getWidths = F2(
	function (width, builders) {
		getWidths:
		while (true) {
			if (!builders.b) {
				return width;
			} else {
				var b = builders.a;
				var bs = builders.b;
				var $temp$width = width + $elm$bytes$Bytes$Encode$getWidth(b),
					$temp$builders = bs;
				width = $temp$width;
				builders = $temp$builders;
				continue getWidths;
			}
		}
	});
var $elm$bytes$Bytes$Encode$sequence = function (builders) {
	return A2(
		$elm$bytes$Bytes$Encode$Seq,
		A2($elm$bytes$Bytes$Encode$getWidths, 0, builders),
		builders);
};
var $author$project$Extra$Data$Binary$Put$join = $elm$bytes$Bytes$Encode$sequence;
var $author$project$Extra$Data$Binary$Put$mappend = F2(
	function (p1, p2) {
		return $author$project$Extra$Data$Binary$Put$join(
			_List_fromArray(
				[p1, p2]));
	});
var $elm$bytes$Bytes$Encode$Utf8 = F2(
	function (a, b) {
		return {$: 'Utf8', a: a, b: b};
	});
var $elm$bytes$Bytes$Encode$string = function (str) {
	return A2(
		$elm$bytes$Bytes$Encode$Utf8,
		_Bytes_getStringWidth(str),
		str);
};
var $author$project$Extra$Data$Binary$Put$putString = $elm$bytes$Bytes$Encode$string;
var $author$project$Extra$Data$Binary$bStringWith = function (bWidth) {
	return {
		get: A2($author$project$Extra$Data$Binary$Get$bind, bWidth.get, $author$project$Extra$Data$Binary$Get$getString),
		put: function (string) {
			return A2(
				$author$project$Extra$Data$Binary$Put$mappend,
				bWidth.put(
					$elm$bytes$Bytes$Encode$getStringWidth(string)),
				$author$project$Extra$Data$Binary$Put$putString(string));
		}
	};
};
var $elm$bytes$Bytes$Decode$unsignedInt8 = $elm$bytes$Bytes$Decode$Decoder(_Bytes_read_u8);
var $author$project$Extra$Data$Binary$Get$getWord8 = function (remaining) {
	return A4($author$project$Extra$Data$Binary$Get$checkedOffset, 'word8', remaining, 1, $elm$bytes$Bytes$Decode$unsignedInt8);
};
var $elm$bytes$Bytes$Encode$U8 = function (a) {
	return {$: 'U8', a: a};
};
var $elm$bytes$Bytes$Encode$unsignedInt8 = $elm$bytes$Bytes$Encode$U8;
var $author$project$Extra$Data$Binary$Put$putWord8 = $elm$bytes$Bytes$Encode$unsignedInt8;
var $author$project$Extra$Data$Binary$bWord8 = {get: $author$project$Extra$Data$Binary$Get$getWord8, put: $author$project$Extra$Data$Binary$Put$putWord8};
var $author$project$Compiler$Data$Utf8$bUnder256 = $author$project$Extra$Data$Binary$bStringWith($author$project$Extra$Data$Binary$bWord8);
var $author$project$Compiler$Data$Name$bName = $author$project$Compiler$Data$Utf8$bUnder256;
var $author$project$Extra$Data$Binary$Get$getWord32 = function (remaining) {
	return A4(
		$author$project$Extra$Data$Binary$Get$checkedOffset,
		'word32',
		remaining,
		4,
		$elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$BE));
};
var $elm$bytes$Bytes$Encode$U32 = F2(
	function (a, b) {
		return {$: 'U32', a: a, b: b};
	});
var $elm$bytes$Bytes$Encode$unsignedInt32 = $elm$bytes$Bytes$Encode$U32;
var $author$project$Extra$Data$Binary$Put$putWord32 = function (word) {
	return A2($elm$bytes$Bytes$Encode$unsignedInt32, $elm$bytes$Bytes$BE, word);
};
var $author$project$Extra$Data$Binary$bWord32 = {get: $author$project$Extra$Data$Binary$Get$getWord32, put: $author$project$Extra$Data$Binary$Put$putWord32};
var $author$project$Extra$Data$Binary$Get$pure = F2(
	function (a, remaining) {
		return $elm$bytes$Bytes$Decode$succeed(
			$author$project$Extra$Type$Either$Right(
				_Utils_Tuple2(remaining, a)));
	});
var $author$project$Extra$Data$Binary$Get$liftM2 = F3(
	function (fun, ga, gb) {
		return A2(
			$author$project$Extra$Data$Binary$Get$bind,
			ga,
			function (a) {
				return A2(
					$author$project$Extra$Data$Binary$Get$bind,
					gb,
					function (b) {
						return $author$project$Extra$Data$Binary$Get$pure(
							A2(fun, a, b));
					});
			});
	});
var $author$project$Extra$Data$Binary$Put$put2 = F4(
	function (fa, fb, a, b) {
		return $author$project$Extra$Data$Binary$Put$join(
			_List_fromArray(
				[
					fa(a),
					fb(b)
				]));
	});
var $author$project$Extra$Data$Binary$bin2 = F4(
	function (ctor, dtor, binA, binB) {
		return {
			get: A3($author$project$Extra$Data$Binary$Get$liftM2, ctor, binA.get, binB.get),
			put: function (c) {
				var _v0 = dtor(c);
				var a = _v0.a;
				var b = _v0.b;
				return A4($author$project$Extra$Data$Binary$Put$put2, binA.put, binB.put, a, b);
			}
		};
	});
var $author$project$Extra$Data$Binary$bWord64 = A4(
	$author$project$Extra$Data$Binary$bin2,
	F2(
		function (hi, lo) {
			return (hi * 4294967296) + lo;
		}),
	function (word) {
		return A2(
			$author$project$Extra$Data$Binary$T2,
			(word / 4294967296) | 0,
			A2($elm$core$Basics$modBy, 4294967296, word));
	},
	$author$project$Extra$Data$Binary$bWord32,
	$author$project$Extra$Data$Binary$bWord32);
var $elm$bytes$Bytes$Decode$Done = function (a) {
	return {$: 'Done', a: a};
};
var $elm$bytes$Bytes$Decode$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $author$project$Extra$Data$Binary$Get$getSequenceStep = F2(
	function (ga, _v0) {
		var length = _v0.a;
		var remaining1 = _v0.b;
		var result = _v0.c;
		return (length <= 0) ? $elm$bytes$Bytes$Decode$succeed(
			$elm$bytes$Bytes$Decode$Done(
				$author$project$Extra$Type$Either$Right(
					_Utils_Tuple2(
						remaining1,
						$elm$core$List$reverse(result))))) : A2(
			$elm$bytes$Bytes$Decode$map,
			function (ra) {
				if (ra.$ === 'Left') {
					var _v2 = ra.a;
					var remaining2 = _v2.a;
					var err = _v2.b;
					return $elm$bytes$Bytes$Decode$Done(
						$author$project$Extra$Type$Either$Left(
							_Utils_Tuple2(remaining2, err)));
				} else {
					var _v3 = ra.a;
					var remaining2 = _v3.a;
					var a = _v3.b;
					return $elm$bytes$Bytes$Decode$Loop(
						_Utils_Tuple3(
							length - 1,
							remaining2,
							A2($elm$core$List$cons, a, result)));
				}
			},
			ga(remaining1));
	});
var $elm$bytes$Bytes$Decode$loopHelp = F4(
	function (state, callback, bites, offset) {
		loopHelp:
		while (true) {
			var _v0 = callback(state);
			var decoder = _v0.a;
			var _v1 = A2(decoder, bites, offset);
			var newOffset = _v1.a;
			var step = _v1.b;
			if (step.$ === 'Loop') {
				var newState = step.a;
				var $temp$state = newState,
					$temp$callback = callback,
					$temp$bites = bites,
					$temp$offset = newOffset;
				state = $temp$state;
				callback = $temp$callback;
				bites = $temp$bites;
				offset = $temp$offset;
				continue loopHelp;
			} else {
				var result = step.a;
				return _Utils_Tuple2(newOffset, result);
			}
		}
	});
var $elm$bytes$Bytes$Decode$loop = F2(
	function (state, callback) {
		return $elm$bytes$Bytes$Decode$Decoder(
			A2($elm$bytes$Bytes$Decode$loopHelp, state, callback));
	});
var $author$project$Extra$Data$Binary$Get$getSequence = F3(
	function (ga, length, remaining) {
		return A2(
			$elm$bytes$Bytes$Decode$loop,
			_Utils_Tuple3(length, remaining, _List_Nil),
			$author$project$Extra$Data$Binary$Get$getSequenceStep(ga));
	});
var $author$project$Extra$Type$List$length = $elm$core$List$length;
var $author$project$Extra$Data$Binary$Put$putSequence = F2(
	function (fa, list) {
		return $author$project$Extra$Data$Binary$Put$join(
			A2($author$project$Extra$Type$List$map, fa, list));
	});
var $author$project$Extra$Data$Binary$bTList = function (binA) {
	return {
		get: A2(
			$author$project$Extra$Data$Binary$Get$bind,
			$author$project$Extra$Data$Binary$bWord64.get,
			$author$project$Extra$Data$Binary$Get$getSequence(binA.get)),
		put: function (list) {
			return A2(
				$author$project$Extra$Data$Binary$Put$mappend,
				$author$project$Extra$Data$Binary$bWord64.put(
					$author$project$Extra$Type$List$length(list)),
				A2($author$project$Extra$Data$Binary$Put$putSequence, binA.put, list));
		}
	};
};
var $author$project$Compiler$AST$Canonical$FieldType = F2(
	function (a, b) {
		return {$: 'FieldType', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Filled = function (a) {
	return {$: 'Filled', a: a};
};
var $author$project$Compiler$AST$Canonical$Holey = function (a) {
	return {$: 'Holey', a: a};
};
var $author$project$Compiler$AST$Canonical$TAlias = F4(
	function (a, b, c, d) {
		return {$: 'TAlias', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Canonical$TLambda = F2(
	function (a, b) {
		return {$: 'TLambda', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$TRecord = F2(
	function (a, b) {
		return {$: 'TRecord', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$TTuple = F3(
	function (a, b, c) {
		return {$: 'TTuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$TType = F3(
	function (a, b, c) {
		return {$: 'TType', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$TUnit = {$: 'TUnit'};
var $author$project$Compiler$AST$Canonical$TVar = function (a) {
	return {$: 'TVar', a: a};
};
var $author$project$Compiler$Elm$ModuleName$Canonical = F2(
	function (a, b) {
		return {$: 'Canonical', a: a, b: b};
	});
var $author$project$Compiler$Elm$Package$Name = F2(
	function (a, b) {
		return {$: 'Name', a: a, b: b};
	});
var $author$project$Compiler$Elm$Package$bName = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$Elm$Package$Name,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Data$Utf8$bUnder256,
	$author$project$Compiler$Data$Utf8$bUnder256);
var $author$project$Compiler$Elm$ModuleName$bCanonical = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$Elm$ModuleName$Canonical,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Elm$Package$bName,
	$author$project$Compiler$Data$Name$bName);
var $author$project$Extra$Data$Binary$bTuple = F2(
	function (binA, binB) {
		return A4(
			$author$project$Extra$Data$Binary$bin2,
			$elm$core$Tuple$pair,
			function (_v0) {
				var a = _v0.a;
				var b = _v0.b;
				return A2($author$project$Extra$Data$Binary$T2, a, b);
			},
			binA,
			binB);
	});
var $author$project$Extra$Type$Either$fmap = F2(
	function (f, ea) {
		if (ea.$ === 'Left') {
			var x = ea.a;
			return $author$project$Extra$Type$Either$Left(x);
		} else {
			var a = ea.a;
			return $author$project$Extra$Type$Either$Right(
				f(a));
		}
	});
var $author$project$Extra$Data$Binary$Get$fmap = F3(
	function (f, g, remaining) {
		return A2(
			$elm$bytes$Bytes$Decode$map,
			$author$project$Extra$Type$Either$fmap(
				$elm$core$Tuple$mapSecond(f)),
			g(remaining));
	});
var $author$project$Extra$Data$Binary$bin1 = F3(
	function (ctor, dtor, binA) {
		return {
			get: A2($author$project$Extra$Data$Binary$Get$fmap, ctor, binA.get),
			put: function (b) {
				return binA.put(
					dtor(b));
			}
		};
	});
var $author$project$Extra$Type$Map$toList = $elm$core$Dict$toList;
var $author$project$Extra$Data$Binary$bMap = F2(
	function (binK, binA) {
		return A3(
			$author$project$Extra$Data$Binary$bin1,
			$author$project$Extra$Type$Map$fromList,
			$author$project$Extra$Type$Map$toList,
			$author$project$Extra$Data$Binary$bTList(
				A2($author$project$Extra$Data$Binary$bTuple, binK, binA)));
	});
var $author$project$Extra$Data$Binary$Get$fail = F2(
	function (err, remaining) {
		return $elm$bytes$Bytes$Decode$succeed(
			$author$project$Extra$Type$Either$Left(
				_Utils_Tuple2(remaining, err)));
	});
var $author$project$Extra$Data$Binary$custom = F2(
	function (error, toPut) {
		return {
			toGet: function (_v0) {
				return $author$project$Extra$Data$Binary$Get$fail(error);
			},
			toPut: toPut
		};
	});
var $author$project$Extra$Data$Binary$customVariant = F4(
	function (pred, putN, get, prev) {
		return {
			toGet: function (tag) {
				return pred(tag) ? get(tag) : prev.toGet(tag);
			},
			toPut: prev.toPut(putN)
		};
	});
var $author$project$Extra$Data$Binary$customVar1 = F3(
	function (pred, ctor, m1) {
		return A3(
			$author$project$Extra$Data$Binary$customVariant,
			pred,
			F2(
				function (id, a) {
					return $author$project$Extra$Data$Binary$Put$join(
						_List_fromArray(
							[
								$author$project$Extra$Data$Binary$Put$putWord8(id),
								m1(id).put(a)
							]));
				}),
			function (id) {
				return A2(
					$author$project$Extra$Data$Binary$Get$fmap,
					ctor,
					m1(id).get);
			});
	});
var $author$project$Extra$Data$Binary$finish = function (customType) {
	return {
		get: A2($author$project$Extra$Data$Binary$Get$bind, $author$project$Extra$Data$Binary$Get$getWord8, customType.toGet),
		put: customType.toPut
	};
};
var $author$project$Extra$Data$Binary$Get$return = $author$project$Extra$Data$Binary$Get$pure;
var $author$project$Extra$Data$Binary$variant = F4(
	function (pred, putN, get, prev) {
		return A4(
			$author$project$Extra$Data$Binary$customVariant,
			pred,
			putN,
			function (_v0) {
				return get;
			},
			prev);
	});
var $author$project$Extra$Data$Binary$var0 = F2(
	function (id, v) {
		return A3(
			$author$project$Extra$Data$Binary$variant,
			$elm$core$Basics$eq(id),
			$author$project$Extra$Data$Binary$Put$putWord8(id),
			$author$project$Extra$Data$Binary$Get$return(v));
	});
var $author$project$Extra$Data$Binary$bMaybe = function (binA) {
	return $author$project$Extra$Data$Binary$finish(
		A4(
			$author$project$Extra$Data$Binary$customVar1,
			function (id) {
				return id > 0;
			},
			$elm$core$Maybe$Just,
			function (_v1) {
				return binA;
			},
			A3(
				$author$project$Extra$Data$Binary$var0,
				0,
				$elm$core$Maybe$Nothing,
				A2(
					$author$project$Extra$Data$Binary$custom,
					'can\'t happen',
					F3(
						function (p0, p1, maybe) {
							if (maybe.$ === 'Nothing') {
								return p0;
							} else {
								var a = maybe.a;
								return A2(p1, 1, a);
							}
						})))));
};
var $author$project$Extra$Data$Binary$bSequence = F2(
	function (binA, n) {
		return {
			get: A2($author$project$Extra$Data$Binary$Get$getSequence, binA.get, n),
			put: $author$project$Extra$Data$Binary$Put$putSequence(binA.put)
		};
	});
var $elm$bytes$Bytes$Decode$unsignedInt16 = function (endianness) {
	return $elm$bytes$Bytes$Decode$Decoder(
		_Bytes_read_u16(
			_Utils_eq(endianness, $elm$bytes$Bytes$LE)));
};
var $author$project$Extra$Data$Binary$Get$getWord16 = function (remaining) {
	return A4(
		$author$project$Extra$Data$Binary$Get$checkedOffset,
		'word16',
		remaining,
		2,
		$elm$bytes$Bytes$Decode$unsignedInt16($elm$bytes$Bytes$BE));
};
var $elm$bytes$Bytes$Encode$U16 = F2(
	function (a, b) {
		return {$: 'U16', a: a, b: b};
	});
var $elm$bytes$Bytes$Encode$unsignedInt16 = $elm$bytes$Bytes$Encode$U16;
var $author$project$Extra$Data$Binary$Put$putWord16 = function (word) {
	return A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$BE, word);
};
var $author$project$Extra$Data$Binary$bWord16 = {get: $author$project$Extra$Data$Binary$Get$getWord16, put: $author$project$Extra$Data$Binary$Put$putWord16};
var $author$project$Extra$Data$Binary$Get$liftM3 = F4(
	function (fun, ga, gb, gc) {
		return A2(
			$author$project$Extra$Data$Binary$Get$bind,
			ga,
			function (a) {
				return A2(
					$author$project$Extra$Data$Binary$Get$bind,
					gb,
					function (b) {
						return A2(
							$author$project$Extra$Data$Binary$Get$bind,
							gc,
							function (c) {
								return $author$project$Extra$Data$Binary$Get$pure(
									A3(fun, a, b, c));
							});
					});
			});
	});
var $author$project$Extra$Data$Binary$customVar3 = F5(
	function (pred, ctor, m1, m2, m3) {
		return A3(
			$author$project$Extra$Data$Binary$customVariant,
			pred,
			F4(
				function (id, a, b, c) {
					return $author$project$Extra$Data$Binary$Put$join(
						_List_fromArray(
							[
								$author$project$Extra$Data$Binary$Put$putWord8(id),
								m1(id).put(a),
								m2(id).put(b),
								m3(id).put(c)
							]));
				}),
			function (id) {
				return A4(
					$author$project$Extra$Data$Binary$Get$liftM3,
					ctor,
					m1(id).get,
					m2(id).get,
					m3(id).get);
			});
	});
var $author$project$Extra$Data$Binary$lazy = function (thunk) {
	return {
		get: function (o) {
			return thunk(_Utils_Tuple0).get(o);
		},
		put: function (a) {
			return thunk(_Utils_Tuple0).put(a);
		}
	};
};
var $author$project$Extra$Data$Binary$var1 = F3(
	function (id, ctor, m1) {
		return A3(
			$author$project$Extra$Data$Binary$variant,
			$elm$core$Basics$eq(id),
			function (a) {
				return $author$project$Extra$Data$Binary$Put$join(
					_List_fromArray(
						[
							$author$project$Extra$Data$Binary$Put$putWord8(id),
							m1.put(a)
						]));
			},
			A2($author$project$Extra$Data$Binary$Get$fmap, ctor, m1.get));
	});
var $author$project$Extra$Data$Binary$var2 = F4(
	function (id, ctor, m1, m2) {
		return A3(
			$author$project$Extra$Data$Binary$variant,
			$elm$core$Basics$eq(id),
			F2(
				function (a, b) {
					return $author$project$Extra$Data$Binary$Put$join(
						_List_fromArray(
							[
								$author$project$Extra$Data$Binary$Put$putWord8(id),
								m1.put(a),
								m2.put(b)
							]));
				}),
			A3($author$project$Extra$Data$Binary$Get$liftM2, ctor, m1.get, m2.get));
	});
var $author$project$Extra$Data$Binary$var3 = F5(
	function (id, ctor, m1, m2, m3) {
		return A3(
			$author$project$Extra$Data$Binary$variant,
			$elm$core$Basics$eq(id),
			F3(
				function (a, b, c) {
					return $author$project$Extra$Data$Binary$Put$join(
						_List_fromArray(
							[
								$author$project$Extra$Data$Binary$Put$putWord8(id),
								m1.put(a),
								m2.put(b),
								m3.put(c)
							]));
				}),
			A4($author$project$Extra$Data$Binary$Get$liftM3, ctor, m1.get, m2.get, m3.get));
	});
var $author$project$Extra$Data$Binary$Get$liftM4 = F5(
	function (fun, ga, gb, gc, gd) {
		return A2(
			$author$project$Extra$Data$Binary$Get$bind,
			ga,
			function (a) {
				return A2(
					$author$project$Extra$Data$Binary$Get$bind,
					gb,
					function (b) {
						return A2(
							$author$project$Extra$Data$Binary$Get$bind,
							gc,
							function (c) {
								return A2(
									$author$project$Extra$Data$Binary$Get$bind,
									gd,
									function (d) {
										return $author$project$Extra$Data$Binary$Get$pure(
											A4(fun, a, b, c, d));
									});
							});
					});
			});
	});
var $author$project$Extra$Data$Binary$var4 = F6(
	function (id, ctor, m1, m2, m3, m4) {
		return A3(
			$author$project$Extra$Data$Binary$variant,
			$elm$core$Basics$eq(id),
			F4(
				function (a, b, c, d) {
					return $author$project$Extra$Data$Binary$Put$join(
						_List_fromArray(
							[
								$author$project$Extra$Data$Binary$Put$putWord8(id),
								m1.put(a),
								m2.put(b),
								m3.put(c),
								m4.put(d)
							]));
				}),
			A5($author$project$Extra$Data$Binary$Get$liftM4, ctor, m1.get, m2.get, m3.get, m4.get));
	});
function $author$project$Compiler$AST$Canonical$cyclic$bType() {
	return $author$project$Extra$Data$Binary$finish(
		A6(
			$author$project$Extra$Data$Binary$customVar3,
			function (id) {
				return id > 6;
			},
			$author$project$Compiler$AST$Canonical$TType,
			function (_v13) {
				return $author$project$Compiler$Elm$ModuleName$bCanonical;
			},
			function (_v14) {
				return $author$project$Compiler$Data$Name$bName;
			},
			function (id) {
				return A2(
					$author$project$Extra$Data$Binary$bSequence,
					$author$project$Extra$Data$Binary$lazy(
						function (_v15) {
							return $author$project$Compiler$AST$Canonical$cyclic$bType();
						}),
					id - 7);
			},
			A6(
				$author$project$Extra$Data$Binary$var3,
				6,
				$author$project$Compiler$AST$Canonical$TType,
				$author$project$Compiler$Elm$ModuleName$bCanonical,
				$author$project$Compiler$Data$Name$bName,
				$author$project$Extra$Data$Binary$bTList(
					$author$project$Extra$Data$Binary$lazy(
						function (_v12) {
							return $author$project$Compiler$AST$Canonical$cyclic$bType();
						})),
				A7(
					$author$project$Extra$Data$Binary$var4,
					5,
					$author$project$Compiler$AST$Canonical$TAlias,
					$author$project$Compiler$Elm$ModuleName$bCanonical,
					$author$project$Compiler$Data$Name$bName,
					$author$project$Extra$Data$Binary$bTList(
						A2(
							$author$project$Extra$Data$Binary$bTuple,
							$author$project$Compiler$Data$Name$bName,
							$author$project$Extra$Data$Binary$lazy(
								function (_v11) {
									return $author$project$Compiler$AST$Canonical$cyclic$bType();
								}))),
					$author$project$Compiler$AST$Canonical$cyclic$bAliasType(),
					A6(
						$author$project$Extra$Data$Binary$var3,
						4,
						$author$project$Compiler$AST$Canonical$TTuple,
						$author$project$Extra$Data$Binary$lazy(
							function (_v8) {
								return $author$project$Compiler$AST$Canonical$cyclic$bType();
							}),
						$author$project$Extra$Data$Binary$lazy(
							function (_v9) {
								return $author$project$Compiler$AST$Canonical$cyclic$bType();
							}),
						$author$project$Extra$Data$Binary$bMaybe(
							$author$project$Extra$Data$Binary$lazy(
								function (_v10) {
									return $author$project$Compiler$AST$Canonical$cyclic$bType();
								})),
						A3(
							$author$project$Extra$Data$Binary$var0,
							3,
							$author$project$Compiler$AST$Canonical$TUnit,
							A5(
								$author$project$Extra$Data$Binary$var2,
								2,
								$author$project$Compiler$AST$Canonical$TRecord,
								A2(
									$author$project$Extra$Data$Binary$bMap,
									$author$project$Compiler$Data$Name$bName,
									$author$project$Compiler$AST$Canonical$cyclic$bFieldType()),
								$author$project$Extra$Data$Binary$bMaybe($author$project$Compiler$Data$Name$bName),
								A4(
									$author$project$Extra$Data$Binary$var1,
									1,
									$author$project$Compiler$AST$Canonical$TVar,
									$author$project$Compiler$Data$Name$bName,
									A5(
										$author$project$Extra$Data$Binary$var2,
										0,
										$author$project$Compiler$AST$Canonical$TLambda,
										$author$project$Extra$Data$Binary$lazy(
											function (_v6) {
												return $author$project$Compiler$AST$Canonical$cyclic$bType();
											}),
										$author$project$Extra$Data$Binary$lazy(
											function (_v7) {
												return $author$project$Compiler$AST$Canonical$cyclic$bType();
											}),
										A2(
											$author$project$Extra$Data$Binary$custom,
											'can\'t happen',
											F9(
												function (p0, p1, p2, p3, p4, p5, p6, p7, tipe) {
													switch (tipe.$) {
														case 'TLambda':
															var a = tipe.a;
															var b = tipe.b;
															return A2(p0, a, b);
														case 'TVar':
															var a = tipe.a;
															return p1(a);
														case 'TRecord':
															var a = tipe.a;
															var b = tipe.b;
															return A2(p2, a, b);
														case 'TUnit':
															return p3;
														case 'TTuple':
															var a = tipe.a;
															var b = tipe.b;
															var c = tipe.c;
															return A3(p4, a, b, c);
														case 'TAlias':
															var a = tipe.a;
															var b = tipe.b;
															var c = tipe.c;
															var d = tipe.d;
															return A4(p5, a, b, c, d);
														default:
															var home = tipe.a;
															var name = tipe.b;
															var ts = tipe.c;
															var potentialWord = $author$project$Extra$Type$List$length(ts) + 7;
															return (potentialWord <= 255) ? A4(p7, potentialWord, home, name, ts) : A3(p6, home, name, ts);
													}
												})))))))))));
}
function $author$project$Compiler$AST$Canonical$cyclic$bAliasType() {
	return $author$project$Extra$Data$Binary$finish(
		A4(
			$author$project$Extra$Data$Binary$var1,
			1,
			$author$project$Compiler$AST$Canonical$Filled,
			$author$project$Extra$Data$Binary$lazy(
				function (_v4) {
					return $author$project$Compiler$AST$Canonical$cyclic$bType();
				}),
			A4(
				$author$project$Extra$Data$Binary$var1,
				0,
				$author$project$Compiler$AST$Canonical$Holey,
				$author$project$Extra$Data$Binary$lazy(
					function (_v3) {
						return $author$project$Compiler$AST$Canonical$cyclic$bType();
					}),
				A2(
					$author$project$Extra$Data$Binary$custom,
					'binary encoding of AliasType was corrupted',
					F3(
						function (p0, p1, aliasType) {
							if (aliasType.$ === 'Holey') {
								var tipe = aliasType.a;
								return p0(tipe);
							} else {
								var tipe = aliasType.a;
								return p1(tipe);
							}
						})))));
}
function $author$project$Compiler$AST$Canonical$cyclic$bFieldType() {
	return A4(
		$author$project$Extra$Data$Binary$bin2,
		$author$project$Compiler$AST$Canonical$FieldType,
		function (_v0) {
			var a = _v0.a;
			var b = _v0.b;
			return A2($author$project$Extra$Data$Binary$T2, a, b);
		},
		$author$project$Extra$Data$Binary$bWord16,
		$author$project$Extra$Data$Binary$lazy(
			function (_v1) {
				return $author$project$Compiler$AST$Canonical$cyclic$bType();
			}));
}
try {
	var $author$project$Compiler$AST$Canonical$bType = $author$project$Compiler$AST$Canonical$cyclic$bType();
	$author$project$Compiler$AST$Canonical$cyclic$bType = function () {
		return $author$project$Compiler$AST$Canonical$bType;
	};
	var $author$project$Compiler$AST$Canonical$bAliasType = $author$project$Compiler$AST$Canonical$cyclic$bAliasType();
	$author$project$Compiler$AST$Canonical$cyclic$bAliasType = function () {
		return $author$project$Compiler$AST$Canonical$bAliasType;
	};
	var $author$project$Compiler$AST$Canonical$bFieldType = $author$project$Compiler$AST$Canonical$cyclic$bFieldType();
	$author$project$Compiler$AST$Canonical$cyclic$bFieldType = function () {
		return $author$project$Compiler$AST$Canonical$bFieldType;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.AST.Canonical` are causing infinite recursion:\n\n  \n      bType\n       \n      bAliasType\n       \n      bFieldType\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$AST$Canonical$bAlias = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$AST$Canonical$Alias,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Data$Name$bName),
	$author$project$Compiler$AST$Canonical$bType);
var $author$project$Compiler$Elm$Interface$bAlias = $author$project$Extra$Data$Binary$finish(
	A4(
		$author$project$Extra$Data$Binary$var1,
		1,
		$author$project$Compiler$Elm$Interface$PrivateAlias,
		$author$project$Compiler$AST$Canonical$bAlias,
		A4(
			$author$project$Extra$Data$Binary$var1,
			0,
			$author$project$Compiler$Elm$Interface$PublicAlias,
			$author$project$Compiler$AST$Canonical$bAlias,
			A2(
				$author$project$Extra$Data$Binary$custom,
				'binary encoding of Alias was corrupted',
				F3(
					function (p0, p1, alias_) {
						if (alias_.$ === 'PublicAlias') {
							var a = alias_.a;
							return p0(a);
						} else {
							var a = alias_.a;
							return p1(a);
						}
					})))));
var $author$project$Compiler$AST$Canonical$Forall = F2(
	function (a, b) {
		return {$: 'Forall', a: a, b: b};
	});
var $author$project$Extra$Data$Binary$Put$mempty = $author$project$Extra$Data$Binary$Put$join(_List_Nil);
var $author$project$Extra$Data$Binary$bUnit = {
	get: $author$project$Extra$Data$Binary$Get$return(_Utils_Tuple0),
	put: function (_v0) {
		return $author$project$Extra$Data$Binary$Put$mempty;
	}
};
var $author$project$Compiler$AST$Canonical$bAnnotation = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$AST$Canonical$Forall,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Extra$Data$Binary$bUnit),
	$author$project$Compiler$AST$Canonical$bType);
var $author$project$Compiler$Elm$Interface$Binop = F4(
	function (a, b, c, d) {
		return {$: 'Binop', a: a, b: b, c: c, d: d};
	});
var $author$project$Extra$Data$Binary$T4 = F4(
	function (a, b, c, d) {
		return {$: 'T4', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Utils$Binop$Left = {$: 'Left'};
var $author$project$Compiler$AST$Utils$Binop$Non = {$: 'Non'};
var $author$project$Compiler$AST$Utils$Binop$Right = {$: 'Right'};
var $author$project$Extra$Data$Binary$enum = F2(
	function (error, items) {
		return function (_v3) {
			var put = _v3.b;
			var get = _v3.c;
			return {
				get: A2($author$project$Extra$Data$Binary$Get$bind, $author$project$Extra$Data$Binary$Get$getWord8, get),
				put: put
			};
		}(
			A3(
				$author$project$Extra$Type$List$foldl,
				F2(
					function (_v0, item) {
						var id = _v0.a;
						var put = _v0.b;
						var get = _v0.c;
						return _Utils_Tuple3(
							id + 1,
							function (value) {
								return _Utils_eq(value, item) ? $author$project$Extra$Data$Binary$Put$putWord8(id) : put(value);
							},
							function (tag) {
								return _Utils_eq(tag, id) ? $author$project$Extra$Data$Binary$Get$return(item) : get(tag);
							});
					}),
				_Utils_Tuple3(
					0,
					function (_v1) {
						return $author$project$Extra$Data$Binary$Put$mempty;
					},
					function (_v2) {
						return $author$project$Extra$Data$Binary$Get$fail(error);
					}),
				items));
	});
var $author$project$Compiler$AST$Utils$Binop$bAssociativity = A2(
	$author$project$Extra$Data$Binary$enum,
	'Error reading valid associativity from serialized string',
	_List_fromArray(
		[$author$project$Compiler$AST$Utils$Binop$Left, $author$project$Compiler$AST$Utils$Binop$Non, $author$project$Compiler$AST$Utils$Binop$Right]));
var $author$project$Compiler$AST$Utils$Binop$Precedence = function (a) {
	return {$: 'Precedence', a: a};
};
var $author$project$Compiler$AST$Utils$Binop$bPrecedence = A3(
	$author$project$Extra$Data$Binary$bin1,
	$author$project$Compiler$AST$Utils$Binop$Precedence,
	function (_v0) {
		var n = _v0.a;
		return n;
	},
	$author$project$Extra$Data$Binary$bWord64);
var $author$project$Extra$Data$Binary$Put$put4 = F8(
	function (fa, fb, fc, fd, a, b, c, d) {
		return $author$project$Extra$Data$Binary$Put$join(
			_List_fromArray(
				[
					fa(a),
					fb(b),
					fc(c),
					fd(d)
				]));
	});
var $author$project$Extra$Data$Binary$bin4 = F6(
	function (ctor, dtor, binA, binB, binC, binD) {
		return {
			get: A5($author$project$Extra$Data$Binary$Get$liftM4, ctor, binA.get, binB.get, binC.get, binD.get),
			put: function (e) {
				var _v0 = dtor(e);
				var a = _v0.a;
				var b = _v0.b;
				var c = _v0.c;
				var d = _v0.d;
				return A8($author$project$Extra$Data$Binary$Put$put4, binA.put, binB.put, binC.put, binD.put, a, b, c, d);
			}
		};
	});
var $author$project$Compiler$Elm$Interface$bBinop = A6(
	$author$project$Extra$Data$Binary$bin4,
	$author$project$Compiler$Elm$Interface$Binop,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		return A4($author$project$Extra$Data$Binary$T4, a, b, c, d);
	},
	$author$project$Compiler$Data$Name$bName,
	$author$project$Compiler$AST$Canonical$bAnnotation,
	$author$project$Compiler$AST$Utils$Binop$bAssociativity,
	$author$project$Compiler$AST$Utils$Binop$bPrecedence);
var $author$project$Compiler$Elm$Interface$ClosedUnion = function (a) {
	return {$: 'ClosedUnion', a: a};
};
var $author$project$Compiler$Elm$Interface$OpenUnion = function (a) {
	return {$: 'OpenUnion', a: a};
};
var $author$project$Compiler$Elm$Interface$PrivateUnion = function (a) {
	return {$: 'PrivateUnion', a: a};
};
var $author$project$Compiler$AST$Canonical$Union = F4(
	function (a, b, c, d) {
		return {$: 'Union', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Canonical$Ctor = F4(
	function (a, b, c, d) {
		return {$: 'Ctor', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Data$Index$ZeroBased = function (a) {
	return {$: 'ZeroBased', a: a};
};
var $author$project$Compiler$Data$Index$bZeroBased = A3(
	$author$project$Extra$Data$Binary$bin1,
	$author$project$Compiler$Data$Index$ZeroBased,
	function (_v0) {
		var n = _v0.a;
		return n;
	},
	$author$project$Extra$Data$Binary$bWord64);
var $author$project$Compiler$AST$Canonical$bCtor = A6(
	$author$project$Extra$Data$Binary$bin4,
	$author$project$Compiler$AST$Canonical$Ctor,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		return A4($author$project$Extra$Data$Binary$T4, a, b, c, d);
	},
	$author$project$Compiler$Data$Name$bName,
	$author$project$Compiler$Data$Index$bZeroBased,
	$author$project$Extra$Data$Binary$bWord64,
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$AST$Canonical$bType));
var $author$project$Compiler$AST$Canonical$Enum = {$: 'Enum'};
var $author$project$Compiler$AST$Canonical$Normal = {$: 'Normal'};
var $author$project$Compiler$AST$Canonical$Unbox = {$: 'Unbox'};
var $author$project$Compiler$AST$Canonical$bCtorOpts = A2(
	$author$project$Extra$Data$Binary$enum,
	'binary encoding of CtorOpts was corrupted',
	_List_fromArray(
		[$author$project$Compiler$AST$Canonical$Normal, $author$project$Compiler$AST$Canonical$Enum, $author$project$Compiler$AST$Canonical$Unbox]));
var $author$project$Compiler$AST$Canonical$bUnion = A6(
	$author$project$Extra$Data$Binary$bin4,
	$author$project$Compiler$AST$Canonical$Union,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		return A4($author$project$Extra$Data$Binary$T4, a, b, c, d);
	},
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Data$Name$bName),
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$AST$Canonical$bCtor),
	$author$project$Extra$Data$Binary$bWord64,
	$author$project$Compiler$AST$Canonical$bCtorOpts);
var $author$project$Compiler$Elm$Interface$bUnion = $author$project$Extra$Data$Binary$finish(
	A4(
		$author$project$Extra$Data$Binary$var1,
		2,
		$author$project$Compiler$Elm$Interface$PrivateUnion,
		$author$project$Compiler$AST$Canonical$bUnion,
		A4(
			$author$project$Extra$Data$Binary$var1,
			1,
			$author$project$Compiler$Elm$Interface$ClosedUnion,
			$author$project$Compiler$AST$Canonical$bUnion,
			A4(
				$author$project$Extra$Data$Binary$var1,
				0,
				$author$project$Compiler$Elm$Interface$OpenUnion,
				$author$project$Compiler$AST$Canonical$bUnion,
				A2(
					$author$project$Extra$Data$Binary$custom,
					'binary encoding of Union was corrupted',
					F4(
						function (p0, p1, p2, union) {
							switch (union.$) {
								case 'OpenUnion':
									var u = union.a;
									return p0(u);
								case 'ClosedUnion':
									var u = union.a;
									return p1(u);
								default:
									var u = union.a;
									return p2(u);
							}
						}))))));
var $author$project$Extra$Data$Binary$Get$liftM5 = F6(
	function (fun, ga, gb, gc, gd, ge) {
		return A2(
			$author$project$Extra$Data$Binary$Get$bind,
			ga,
			function (a) {
				return A2(
					$author$project$Extra$Data$Binary$Get$bind,
					gb,
					function (b) {
						return A2(
							$author$project$Extra$Data$Binary$Get$bind,
							gc,
							function (c) {
								return A2(
									$author$project$Extra$Data$Binary$Get$bind,
									gd,
									function (d) {
										return A2(
											$author$project$Extra$Data$Binary$Get$bind,
											ge,
											function (e) {
												return $author$project$Extra$Data$Binary$Get$pure(
													A5(fun, a, b, c, d, e));
											});
									});
							});
					});
			});
	});
var $author$project$Extra$Data$Binary$Put$put5 = function (fa) {
	return function (fb) {
		return function (fc) {
			return function (fd) {
				return function (fe) {
					return function (a) {
						return function (b) {
							return function (c) {
								return function (d) {
									return function (e) {
										return $author$project$Extra$Data$Binary$Put$join(
											_List_fromArray(
												[
													fa(a),
													fb(b),
													fc(c),
													fd(d),
													fe(e)
												]));
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var $author$project$Extra$Data$Binary$bin5 = F7(
	function (ctor, dtor, binA, binB, binC, binD, binE) {
		return {
			get: A6($author$project$Extra$Data$Binary$Get$liftM5, ctor, binA.get, binB.get, binC.get, binD.get, binE.get),
			put: function (f) {
				var _v0 = dtor(f);
				var a = _v0.a;
				var b = _v0.b;
				var c = _v0.c;
				var d = _v0.d;
				var e = _v0.e;
				return $author$project$Extra$Data$Binary$Put$put5(binA.put)(binB.put)(binC.put)(binD.put)(binE.put)(a)(b)(c)(d)(e);
			}
		};
	});
var $author$project$Compiler$Elm$Interface$bInterface = A7(
	$author$project$Extra$Data$Binary$bin5,
	$author$project$Compiler$Elm$Interface$Interface,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		var e = _v0.e;
		return A5($author$project$Extra$Data$Binary$T5, a, b, c, d, e);
	},
	$author$project$Compiler$Elm$Package$bName,
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$AST$Canonical$bAnnotation),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$Elm$Interface$bUnion),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$Elm$Interface$bAlias),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$Elm$Interface$bBinop));
var $author$project$Extra$System$File$addName = F2(
	function (path, name) {
		return A2(
			$author$project$Extra$System$File$modifyNames,
			path,
			function (names) {
				return A2($elm$core$List$cons, name, names);
			});
	});
var $author$project$Extra$System$File$addNames = F2(
	function (path, names) {
		return A3($author$project$Extra$Type$List$foldl, $author$project$Extra$System$File$addName, path, names);
	});
var $author$project$Builder$Stuff$compilerVersion = $author$project$Compiler$Elm$Version$toChars($author$project$Compiler$Elm$Version$compiler);
var $author$project$Builder$Stuff$stuff = function (root) {
	return A2(
		$author$project$Extra$System$File$addNames,
		root,
		_List_fromArray(
			['elm-stuff', $author$project$Builder$Stuff$compilerVersion]));
};
var $author$project$Compiler$Elm$ModuleName$toHyphenName = function (name) {
	return A2(
		$elm$core$String$map,
		function (c) {
			return _Utils_eq(
				c,
				_Utils_chr('.')) ? _Utils_chr('-') : c;
		},
		name);
};
var $author$project$Builder$Stuff$toArtifactPath = F3(
	function (root, name, ext) {
		return A2(
			$author$project$Extra$System$File$addName,
			$author$project$Builder$Stuff$stuff(root),
			$author$project$Compiler$Elm$ModuleName$toHyphenName(name) + ('.' + ext));
	});
var $author$project$Builder$Stuff$elmi = F2(
	function (root, name) {
		return A3($author$project$Builder$Stuff$toArtifactPath, root, name, 'elmi');
	});
var $author$project$Builder$Build$lensMVCachedInterface = {
	getter: function (_v0) {
		var _v1 = _v0.d;
		var x = _v1.g;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var _v3 = _v2.d;
			var bi = _v3.a;
			var ci = _v3.b;
			var di = _v3.c;
			var ei = _v3.d;
			var fi = _v3.e;
			var gi = _v3.f;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				A7($author$project$Builder$Build$LocalState, bi, ci, di, ei, fi, gi, x),
				e,
				f,
				g,
				h);
		})
};
var $author$project$Extra$System$MVar$getEntry = F2(
	function (_v0, _v1) {
		var id = _v0.a;
		var map = _v1.b;
		return A2($author$project$Extra$Type$Map$ex, map, id);
	});
var $author$project$Extra$System$MVar$Done = function (a) {
	return {$: 'Done', a: a};
};
var $author$project$Extra$System$MVar$modify = F2(
	function (_v0, f) {
		var getter = _v0.getter;
		var setter = _v0.setter;
		return $author$project$Extra$System$IO$modify(
			function (gs) {
				return A2(
					setter,
					f(
						getter(gs)),
					gs);
			});
	});
var $author$project$Extra$System$MVar$setEntry = F3(
	function (_v0, entry, _v1) {
		var id = _v0.a;
		var nextId = _v1.a;
		var map = _v1.b;
		var name = _v1.c;
		return _Utils_Tuple3(
			nextId,
			A3($author$project$Extra$Type$Map$insert, id, entry, map),
			name);
	});
var $author$project$Extra$System$MVar$write = F3(
	function (lens, mvar, a) {
		return A2(
			$author$project$Extra$System$MVar$modify,
			lens,
			A2(
				$author$project$Extra$System$MVar$setEntry,
				mvar,
				$author$project$Extra$System$MVar$Done(a)));
	});
var $author$project$Extra$System$MVar$read = F2(
	function (lens, mvar) {
		var getter = lens.getter;
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$IO$get,
			function (gs0) {
				var _v0 = A2(
					$author$project$Extra$System$MVar$getEntry,
					mvar,
					getter(gs0));
				if (_v0.$ === 'Waiting') {
					var f = _v0.a;
					return A2(
						$author$project$Extra$System$IO$bind,
						f(_Utils_Tuple0),
						function (a) {
							return A2(
								$author$project$Extra$System$IO$fmap,
								function (_v1) {
									return a;
								},
								A3($author$project$Extra$System$MVar$write, lens, mvar, a));
						});
				} else {
					var a = _v0.a;
					return $author$project$Extra$System$IO$return(a);
				}
			});
	});
var $author$project$Extra$System$File$BytesContent = function (a) {
	return {$: 'BytesContent', a: a};
};
var $author$project$Extra$System$File$MountedContent = function (a) {
	return {$: 'MountedContent', a: a};
};
var $author$project$Extra$System$File$getFileContent = function (maybeContent) {
	if (maybeContent.$ === 'Just') {
		if (maybeContent.a.$ === 'BytesContent') {
			var bytes = maybeContent.a.a;
			return $author$project$Extra$System$IO$return(
				$elm$core$Maybe$Just(bytes));
		} else {
			var io = maybeContent.a.a;
			return io;
		}
	} else {
		return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
	}
};
var $author$project$Extra$System$File$readFile = function (filePath) {
	return A2(
		$author$project$Extra$System$IO$andThen,
		$author$project$Extra$System$File$getFileContent,
		A3(
			$author$project$Extra$System$File$walkFileSystem,
			false,
			filePath,
			F2(
				function (maybeNode, _v0) {
					return _Utils_Tuple2(
						$elm$core$Maybe$Nothing,
						function () {
							_v1$2:
							while (true) {
								if ((maybeNode.$ === 'Just') && (maybeNode.a.c.$ === 'Just')) {
									switch (maybeNode.a.c.a.b.$) {
										case 'FileEntry':
											var _v2 = maybeNode.a;
											var _v3 = _v2.c.a;
											var contents = _v3.b.a;
											return $elm$core$Maybe$Just(
												$author$project$Extra$System$File$BytesContent(contents));
										case 'MountedFileEntry':
											var _v4 = maybeNode.a;
											var _v5 = _v4.c.a;
											var _v6 = _v5.b;
											var io = _v6.b;
											return $elm$core$Maybe$Just(
												$author$project$Extra$System$File$MountedContent(io));
										default:
											break _v1$2;
									}
								} else {
									break _v1$2;
								}
							}
							return $elm$core$Maybe$Nothing;
						}());
				})));
};
var $elm$bytes$Bytes$width = _Bytes_width;
var $author$project$Extra$Data$Binary$Get$runGetOrFail = F2(
	function (get, bytes) {
		var _v0 = A2(
			$elm$bytes$Bytes$Decode$decode,
			get(
				$elm$bytes$Bytes$width(bytes)),
			bytes);
		if (_v0.$ === 'Just') {
			if (_v0.a.$ === 'Right') {
				var _v1 = _v0.a.a;
				var a = _v1.b;
				return $author$project$Extra$Type$Either$Right(a);
			} else {
				var _v2 = _v0.a.a;
				var remaining = _v2.a;
				var err = _v2.b;
				return $author$project$Extra$Type$Either$Left(
					_Utils_Tuple2(
						$elm$bytes$Bytes$width(bytes) - remaining,
						err));
			}
		} else {
			return $author$project$Extra$Type$Either$Left(
				_Utils_Tuple2(
					$elm$bytes$Bytes$width(bytes),
					'binary encoding was corrupted'));
		}
	});
var $author$project$Extra$System$File$toString = function (path) {
	if (path.$ === 'Absolute') {
		var names = path.a;
		return '/' + A2(
			$elm$core$String$join,
			'/',
			$author$project$Extra$Type$List$reverse(names));
	} else {
		if (!path.a.b) {
			return '.';
		} else {
			var names = path.a;
			return A2(
				$elm$core$String$join,
				'/',
				$author$project$Extra$Type$List$reverse(names));
		}
	}
};
var $author$project$Extra$Data$Binary$decodeFileOrFail = F2(
	function (binV, path) {
		return A2(
			$author$project$Extra$System$IO$fmap,
			function (maybeBytes) {
				if (maybeBytes.$ === 'Just') {
					var bytes = maybeBytes.a;
					return A2($author$project$Extra$Data$Binary$Get$runGetOrFail, binV.get, bytes);
				} else {
					return $author$project$Extra$Type$Either$Left(
						_Utils_Tuple2(
							0,
							'File not found: ' + $author$project$Extra$System$File$toString(path)));
				}
			},
			$author$project$Extra$System$File$readFile(path));
	});
var $author$project$Extra$System$File$doesFileExist = function (filePath) {
	return A3(
		$author$project$Extra$System$File$walkFileSystem,
		false,
		filePath,
		F2(
			function (maybeNode, _v0) {
				return _Utils_Tuple2(
					$elm$core$Maybe$Nothing,
					function () {
						_v1$2:
						while (true) {
							if ((maybeNode.$ === 'Just') && (maybeNode.a.c.$ === 'Just')) {
								switch (maybeNode.a.c.a.b.$) {
									case 'FileEntry':
										var _v2 = maybeNode.a;
										var _v3 = _v2.c.a;
										return true;
									case 'MountedFileEntry':
										var _v4 = maybeNode.a;
										var _v5 = _v4.c.a;
										var _v6 = _v5.b;
										return true;
									default:
										break _v1$2;
								}
							} else {
								break _v1$2;
							}
						}
						return false;
					}());
			}));
};
var $elm$core$Debug$log = _Debug_log;
var $author$project$Extra$System$IO$log = F3(
	function (msg, a, s) {
		return _Utils_Tuple2(
			function (_v0) {
				return $author$project$Extra$System$IO$Pure(_Utils_Tuple0);
			}(
				A2($elm$core$Debug$log, msg, a)),
			s);
	});
var $author$project$Builder$File$readBinary = F2(
	function (binA, path) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$File$doesFileExist(path),
			function (pathExists) {
				return pathExists ? A2(
					$author$project$Extra$System$IO$bind,
					A2($author$project$Extra$Data$Binary$decodeFileOrFail, binA, path),
					function (result) {
						if (result.$ === 'Right') {
							var a = result.a;
							return $author$project$Extra$System$IO$return(
								$elm$core$Maybe$Just(a));
						} else {
							var _v1 = result.a;
							var offset = _v1.a;
							var message = _v1.b;
							return A2(
								$author$project$Extra$System$IO$bind,
								A2(
									$author$project$Extra$System$IO$log,
									'readBinary',
									_List_fromArray(
										[
											'+-------------------------------------------------------------------------------',
											'|  Corrupt File: ' + $author$project$Extra$System$File$toString(path),
											'|   Byte Offset: ' + $elm$core$String$fromInt(offset),
											'|       Message: ' + message,
											'|',
											'| Please report this to https://github.com/elm/compiler/issues',
											'| Trying to continue anyway.',
											'+-------------------------------------------------------------------------------'
										])),
								function (_v2) {
									return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
								});
						}
					}) : $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
			});
	});
var $author$project$Builder$Build$loadInterface = F2(
	function (root, _v0) {
		var name = _v0.a;
		var ciMvar = _v0.b;
		return A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Extra$System$MVar$read, $author$project$Builder$Build$lensMVCachedInterface, ciMvar),
			function (cachedInterface) {
				switch (cachedInterface.$) {
					case 'Corrupted':
						return A2(
							$author$project$Extra$System$IO$bind,
							A3($author$project$Extra$System$MVar$write, $author$project$Builder$Build$lensMVCachedInterface, ciMvar, cachedInterface),
							function (_v2) {
								return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
							});
					case 'Loaded':
						var iface = cachedInterface.a;
						return A2(
							$author$project$Extra$System$IO$bind,
							A3($author$project$Extra$System$MVar$write, $author$project$Builder$Build$lensMVCachedInterface, ciMvar, cachedInterface),
							function (_v3) {
								return $author$project$Extra$System$IO$return(
									$elm$core$Maybe$Just(
										_Utils_Tuple2(name, iface)));
							});
					default:
						return A2(
							$author$project$Extra$System$IO$bind,
							A2(
								$author$project$Builder$File$readBinary,
								$author$project$Compiler$Elm$Interface$bInterface,
								A2($author$project$Builder$Stuff$elmi, root, name)),
							function (maybeIface) {
								if (maybeIface.$ === 'Nothing') {
									return A2(
										$author$project$Extra$System$IO$bind,
										A3($author$project$Extra$System$MVar$write, $author$project$Builder$Build$lensMVCachedInterface, ciMvar, $author$project$Builder$Build$Corrupted),
										function (_v5) {
											return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
										});
								} else {
									var iface = maybeIface.a;
									return A2(
										$author$project$Extra$System$IO$bind,
										A3(
											$author$project$Extra$System$MVar$write,
											$author$project$Builder$Build$lensMVCachedInterface,
											ciMvar,
											$author$project$Builder$Build$Loaded(iface)),
										function (_v6) {
											return $author$project$Extra$System$IO$return(
												$elm$core$Maybe$Just(
													_Utils_Tuple2(name, iface)));
										});
								}
							});
				}
			});
	});
var $elm$core$Maybe$map2 = F3(
	function (func, ma, mb) {
		if (ma.$ === 'Nothing') {
			return $elm$core$Maybe$Nothing;
		} else {
			var a = ma.a;
			if (mb.$ === 'Nothing') {
				return $elm$core$Maybe$Nothing;
			} else {
				var b = mb.a;
				return $elm$core$Maybe$Just(
					A2(func, a, b));
			}
		}
	});
var $author$project$Extra$System$IO$pure = $author$project$Extra$System$IO$return;
var $author$project$Extra$Class$Traversable$sequenceA = function (pTraverse) {
	return pTraverse($elm$core$Basics$identity);
};
var $author$project$Extra$Type$List$traverse = F4(
	function (pPure, pLiftA2, f, l) {
		return A3(
			$author$project$Extra$Type$List$foldr,
			F2(
				function (a, flb) {
					return A3(
						pLiftA2,
						$elm$core$List$cons,
						f(a),
						flb);
				}),
			pPure(_List_Nil),
			l);
	});
var $author$project$Extra$Type$List$sequenceA = F3(
	function (pPure, pListA2, l) {
		return A2(
			$author$project$Extra$Class$Traversable$sequenceA,
			A2($author$project$Extra$Type$List$traverse, pPure, pListA2),
			l);
	});
var $elm$core$Dict$union = F2(
	function (t1, t2) {
		return A3($elm$core$Dict$foldl, $elm$core$Dict$insert, t2, t1);
	});
var $author$project$Extra$Type$Map$union = $elm$core$Dict$union;
var $author$project$Builder$Build$loadInterfaces = F3(
	function (root, same, cached) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A4(
				$author$project$Extra$Type$List$traverse,
				$author$project$Extra$System$IO$pure,
				$author$project$Extra$System$IO$liftA2,
				$author$project$Builder$Build$loadInterface(root),
				cached),
			function (maybeLoaded) {
				var _v0 = A3($author$project$Extra$Type$List$sequenceA, $elm$core$Maybe$Just, $elm$core$Maybe$map2, maybeLoaded);
				if (_v0.$ === 'Nothing') {
					return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
				} else {
					var loaded = _v0.a;
					return $author$project$Extra$System$IO$return(
						$elm$core$Maybe$Just(
							A2(
								$author$project$Extra$Type$Map$union,
								$author$project$Extra$Type$Map$fromList(loaded),
								$author$project$Extra$Type$Map$fromList(same))));
				}
			});
	});
var $author$project$Builder$Build$checkDepsHelp = function (root) {
	return function (results) {
		return function (deps) {
			return function (_new) {
				return function (same) {
					return function (cached) {
						return function (importProblems) {
							return function (isBlocked) {
								return function (lastDepChange) {
									return function (lastCompile) {
										if (deps.b) {
											var dep = deps.a;
											var otherDeps = deps.b;
											return A2(
												$author$project$Extra$System$IO$bind,
												A2(
													$author$project$Extra$System$MVar$read,
													$author$project$Builder$Build$lensMVResult,
													A2($author$project$Extra$Type$Map$ex, results, dep)),
												function (result) {
													switch (result.$) {
														case 'RNew':
															var _v2 = result.a;
															var lastChange = _v2.e;
															var iface = result.b;
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(
																A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(dep, iface),
																	_new))(same)(cached)(importProblems)(isBlocked)(
																A2($elm$core$Basics$max, lastChange, lastDepChange))(lastCompile);
														case 'RSame':
															var _v3 = result.a;
															var lastChange = _v3.e;
															var iface = result.b;
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(
																A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(dep, iface),
																	same))(cached)(importProblems)(isBlocked)(
																A2($elm$core$Basics$max, lastChange, lastDepChange))(lastCompile);
														case 'RCached':
															var lastChange = result.b;
															var mvar = result.c;
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(same)(
																A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(dep, mvar),
																	cached))(importProblems)(isBlocked)(
																A2($elm$core$Basics$max, lastChange, lastDepChange))(lastCompile);
														case 'RNotFound':
															var prob = result.a;
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(same)(cached)(
																A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(dep, prob),
																	importProblems))(true)(lastDepChange)(lastCompile);
														case 'RProblem':
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(same)(cached)(importProblems)(true)(lastDepChange)(lastCompile);
														case 'RBlocked':
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(same)(cached)(importProblems)(true)(lastDepChange)(lastCompile);
														case 'RForeign':
															var iface = result.a;
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(
																A2(
																	$elm$core$List$cons,
																	_Utils_Tuple2(dep, iface),
																	same))(cached)(importProblems)(isBlocked)(lastDepChange)(lastCompile);
														default:
															return $author$project$Builder$Build$checkDepsHelp(root)(results)(otherDeps)(_new)(same)(cached)(importProblems)(isBlocked)(lastDepChange)(lastCompile);
													}
												});
										} else {
											var _v4 = $author$project$Extra$Type$List$reverse(importProblems);
											if (_v4.b) {
												var p = _v4.a;
												var ps = _v4.b;
												return $author$project$Extra$System$IO$return(
													$author$project$Builder$Build$DepsNotFound(
														A2($author$project$Compiler$Data$NonEmptyList$CList, p, ps)));
											} else {
												return isBlocked ? $author$project$Extra$System$IO$return($author$project$Builder$Build$DepsBlock) : (($author$project$Extra$Type$List$null(_new) && (_Utils_cmp(lastDepChange, lastCompile) < 1)) ? $author$project$Extra$System$IO$return(
													A2($author$project$Builder$Build$DepsSame, same, cached)) : A2(
													$author$project$Extra$System$IO$bind,
													A3($author$project$Builder$Build$loadInterfaces, root, same, cached),
													function (maybeLoaded) {
														if (maybeLoaded.$ === 'Nothing') {
															return $author$project$Extra$System$IO$return($author$project$Builder$Build$DepsBlock);
														} else {
															var ifaces = maybeLoaded.a;
															return $author$project$Extra$System$IO$return(
																$author$project$Builder$Build$DepsChange(
																	A2(
																		$author$project$Extra$Type$Map$union,
																		$author$project$Extra$Type$Map$fromList(_new),
																		ifaces)));
														}
													}));
											}
										}
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var $author$project$Builder$Build$checkDeps = F4(
	function (root, results, deps, lastCompile) {
		return $author$project$Builder$Build$checkDepsHelp(root)(results)(deps)(_List_Nil)(_List_Nil)(_List_Nil)(_List_Nil)(false)(0)(lastCompile);
	});
var $author$project$Builder$Reporting$Exit$BP_CannotLoadDependencies = {$: 'BP_CannotLoadDependencies'};
var $author$project$Builder$Reporting$Exit$BP_Cycle = F2(
	function (a, b) {
		return {$: 'BP_Cycle', a: a, b: b};
	});
var $author$project$Builder$Build$addToGraph = F3(
	function (name, status, graph) {
		var dependencies = function () {
			switch (status.$) {
				case 'SCached':
					var _v1 = status.a;
					var deps = _v1.c;
					return deps;
				case 'SChanged':
					var _v2 = status.a;
					var deps = _v2.c;
					return deps;
				case 'SBadImport':
					return _List_Nil;
				case 'SBadSyntax':
					return _List_Nil;
				case 'SForeign':
					return _List_Nil;
				default:
					return _List_Nil;
			}
		}();
		return A2(
			$elm$core$List$cons,
			_Utils_Tuple3(name, name, dependencies),
			graph);
	});
var $author$project$Builder$Build$checkForCyclesHelp = function (sccs) {
	checkForCyclesHelp:
	while (true) {
		if (!sccs.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			var scc = sccs.a;
			var otherSccs = sccs.b;
			if (scc.$ === 'AcyclicSCC') {
				var $temp$sccs = otherSccs;
				sccs = $temp$sccs;
				continue checkForCyclesHelp;
			} else {
				if (!scc.a.b) {
					var $temp$sccs = otherSccs;
					sccs = $temp$sccs;
					continue checkForCyclesHelp;
				} else {
					var _v2 = scc.a;
					var m = _v2.a;
					var ms = _v2.b;
					return $elm$core$Maybe$Just(
						A2($author$project$Compiler$Data$NonEmptyList$CList, m, ms));
				}
			}
		}
	}
};
var $author$project$Extra$Type$Map$foldrWithKey = $elm$core$Dict$foldr;
var $author$project$Extra$Data$Graph$AcyclicSCC = function (a) {
	return {$: 'AcyclicSCC', a: a};
};
var $author$project$Extra$Data$Graph$CyclicSCC = function (a) {
	return {$: 'CyclicSCC', a: a};
};
var $author$project$Extra$Type$Set$insert = $elm$core$Set$insert;
var $author$project$Extra$Type$List$mapMaybe = $elm$core$List$filterMap;
var $author$project$Extra$Data$Graph$CheckAssigned = function (a) {
	return {$: 'CheckAssigned', a: a};
};
var $author$project$Extra$Data$Graph$FinishComponent = {$: 'FinishComponent'};
var $author$project$Extra$Data$Graph$assign = F2(
	function (graph, orderedVertices) {
		var check = function (vertices) {
			return A2($author$project$Extra$Type$List$map, $author$project$Extra$Data$Graph$CheckAssigned, vertices);
		};
		var go = F4(
			function (tasks, assigned, scc, output) {
				go:
				while (true) {
					if (!tasks.b) {
						return _Utils_Tuple3(assigned, scc, output);
					} else {
						if (tasks.a.$ === 'CheckAssigned') {
							var vertex = tasks.a.a;
							var rest = tasks.b;
							if (A2($author$project$Extra$Type$Set$member, vertex, assigned)) {
								var $temp$tasks = rest,
									$temp$assigned = assigned,
									$temp$scc = scc,
									$temp$output = output;
								tasks = $temp$tasks;
								assigned = $temp$assigned;
								scc = $temp$scc;
								output = $temp$output;
								continue go;
							} else {
								var newScc = A2($elm$core$List$cons, vertex, scc);
								var newAssigned = A2($author$project$Extra$Type$Set$insert, vertex, assigned);
								var neighborTasks = check(
									A2(
										$elm$core$Maybe$withDefault,
										_List_Nil,
										A2($author$project$Extra$Type$Map$lookup, vertex, graph)));
								var finishTasks = function () {
									if (!scc.b) {
										return _List_fromArray(
											[$author$project$Extra$Data$Graph$FinishComponent]);
									} else {
										return _List_Nil;
									}
								}();
								var newTasks = _Utils_ap(
									neighborTasks,
									_Utils_ap(finishTasks, rest));
								var $temp$tasks = newTasks,
									$temp$assigned = newAssigned,
									$temp$scc = newScc,
									$temp$output = output;
								tasks = $temp$tasks;
								assigned = $temp$assigned;
								scc = $temp$scc;
								output = $temp$output;
								continue go;
							}
						} else {
							var _v2 = tasks.a;
							var rest = tasks.b;
							var $temp$tasks = rest,
								$temp$assigned = assigned,
								$temp$scc = _List_Nil,
								$temp$output = A2($elm$core$List$cons, scc, output);
							tasks = $temp$tasks;
							assigned = $temp$assigned;
							scc = $temp$scc;
							output = $temp$output;
							continue go;
						}
					}
				}
			});
		return function (_v3) {
			var output = _v3.c;
			return output;
		}(
			A4(
				go,
				check(orderedVertices),
				$author$project$Extra$Type$Set$empty,
				_List_Nil,
				_List_Nil));
	});
var $author$project$Extra$Type$Map$alter = F3(
	function (f, k, m) {
		return A3($elm$core$Dict$update, k, f, m);
	});
var $author$project$Extra$Data$Graph$reverse = function (originalGraph) {
	var addReversedEdge = F3(
		function (from, to, graph) {
			return A3(
				$author$project$Extra$Type$Map$alter,
				function (neighbors) {
					return $elm$core$Maybe$Just(
						A2(
							$elm$core$List$cons,
							from,
							A2($elm$core$Maybe$withDefault, _List_Nil, neighbors)));
				},
				to,
				graph);
		});
	var addReversedEdges = F3(
		function (graph, from, tos) {
			return A3(
				$author$project$Extra$Type$List$foldl,
				F2(
					function (acc, to) {
						return A3(addReversedEdge, from, to, acc);
					}),
				graph,
				tos);
		});
	var addAllReversedEdges = function (graph) {
		return A3($author$project$Extra$Type$Map$foldlWithKey, addReversedEdges, $author$project$Extra$Type$Map$empty, graph);
	};
	return addAllReversedEdges(originalGraph);
};
var $author$project$Extra$Data$Graph$CheckVisited = function (a) {
	return {$: 'CheckVisited', a: a};
};
var $author$project$Extra$Data$Graph$Output = function (a) {
	return {$: 'Output', a: a};
};
var $author$project$Extra$Type$Map$keys = $elm$core$Dict$keys;
var $author$project$Extra$Data$Graph$visit = function (graph) {
	var check = function (vertices) {
		return A2($author$project$Extra$Type$List$map, $author$project$Extra$Data$Graph$CheckVisited, vertices);
	};
	var go = F3(
		function (tasks, visited, output) {
			go:
			while (true) {
				if (!tasks.b) {
					return _Utils_Tuple2(visited, output);
				} else {
					if (tasks.a.$ === 'CheckVisited') {
						var vertex = tasks.a.a;
						var rest = tasks.b;
						if (A2($author$project$Extra$Type$Set$member, vertex, visited)) {
							var $temp$tasks = rest,
								$temp$visited = visited,
								$temp$output = output;
							tasks = $temp$tasks;
							visited = $temp$visited;
							output = $temp$output;
							continue go;
						} else {
							var newVisited = A2($author$project$Extra$Type$Set$insert, vertex, visited);
							var neighbors = A2(
								$elm$core$Maybe$withDefault,
								_List_Nil,
								A2($author$project$Extra$Type$Map$lookup, vertex, graph));
							var newTasks = _Utils_ap(
								check(neighbors),
								A2(
									$elm$core$List$cons,
									$author$project$Extra$Data$Graph$Output(vertex),
									rest));
							var $temp$tasks = newTasks,
								$temp$visited = newVisited,
								$temp$output = output;
							tasks = $temp$tasks;
							visited = $temp$visited;
							output = $temp$output;
							continue go;
						}
					} else {
						var vertex = tasks.a.a;
						var rest = tasks.b;
						var $temp$tasks = rest,
							$temp$visited = visited,
							$temp$output = A2($elm$core$List$cons, vertex, output);
						tasks = $temp$tasks;
						visited = $temp$visited;
						output = $temp$output;
						continue go;
					}
				}
			}
		});
	return A3(
		go,
		check(
			$author$project$Extra$Type$Map$keys(graph)),
		$author$project$Extra$Type$Set$empty,
		_List_Nil).b;
};
var $author$project$Extra$Data$Graph$sccs = function (graph) {
	return A2(
		$author$project$Extra$Data$Graph$assign,
		$author$project$Extra$Data$Graph$reverse(graph),
		$author$project$Extra$Data$Graph$visit(graph));
};
var $elm$core$List$sortWith = _List_sortWith;
var $author$project$Extra$Type$List$sortBy = $elm$core$List$sortWith;
var $author$project$Extra$Data$Graph$stronglyConnCompR = function (edges0) {
	var lt = F2(
		function (_v5, _v6) {
			var v = _v5.b;
			var w = _v6.b;
			return A2($elm$core$Basics$compare, v, w);
		});
	var sorted = A2(
		$author$project$Extra$Type$List$indexedFrom,
		0,
		A2($author$project$Extra$Type$List$sortBy, lt, edges0));
	var nodeMap = $author$project$Extra$Type$Map$fromList(sorted);
	var keyMap = A3(
		$author$project$Extra$Type$List$foldl,
		F2(
			function (acc, _v3) {
				var i = _v3.a;
				var _v4 = _v3.b;
				var k = _v4.b;
				return A3($author$project$Extra$Type$Map$insert, k, i, acc);
			}),
		$author$project$Extra$Type$Map$empty,
		sorted);
	var getNode = function (vertex) {
		return A2($author$project$Extra$Type$Map$ex, nodeMap, vertex);
	};
	var edges = A2(
		$author$project$Extra$Type$List$mapMaybe,
		function (_v2) {
			var from = _v2.b;
			var neighbors = _v2.c;
			return A2(
				$elm$core$Maybe$map,
				function (vertex) {
					return _Utils_Tuple2(
						vertex,
						A2(
							$author$project$Extra$Type$List$mapMaybe,
							function (to) {
								return A2($author$project$Extra$Type$Map$lookup, to, keyMap);
							},
							neighbors));
				},
				A2($author$project$Extra$Type$Map$lookup, from, keyMap));
		},
		edges0);
	var graph = $author$project$Extra$Type$Map$fromList(edges);
	var selfRefs = A3(
		$author$project$Extra$Type$List$foldl,
		F2(
			function (acc, _v1) {
				var from = _v1.a;
				var neighbors = _v1.b;
				return A2($author$project$Extra$Type$List$elem, from, neighbors) ? A2($author$project$Extra$Type$Set$insert, from, acc) : acc;
			}),
		$author$project$Extra$Type$Set$empty,
		edges);
	var toSCC = function (component) {
		if (component.b && (!component.b.b)) {
			var vertex = component.a;
			return A2($author$project$Extra$Type$Set$member, vertex, selfRefs) ? $author$project$Extra$Data$Graph$CyclicSCC(
				_List_fromArray(
					[
						getNode(vertex)
					])) : $author$project$Extra$Data$Graph$AcyclicSCC(
				getNode(vertex));
		} else {
			return $author$project$Extra$Data$Graph$CyclicSCC(
				A2($author$project$Extra$Type$List$map, getNode, component));
		}
	};
	var components = $author$project$Extra$Data$Graph$sccs(graph);
	return A2($author$project$Extra$Type$List$map, toSCC, components);
};
var $author$project$Extra$Data$Graph$stronglyConnComp = function (edges0) {
	var get_node = function (scc) {
		if (scc.$ === 'AcyclicSCC') {
			var _v1 = scc.a;
			var n = _v1.a;
			return $author$project$Extra$Data$Graph$AcyclicSCC(n);
		} else {
			var triples = scc.a;
			return $author$project$Extra$Data$Graph$CyclicSCC(
				A2(
					$author$project$Extra$Type$List$map,
					function (_v2) {
						var n = _v2.a;
						return n;
					},
					triples));
		}
	};
	return A2(
		$author$project$Extra$Type$List$map,
		get_node,
		$author$project$Extra$Data$Graph$stronglyConnCompR(edges0));
};
var $author$project$Builder$Build$checkForCycles = function (modules) {
	var graph = A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Builder$Build$addToGraph, _List_Nil, modules);
	var sccs = $author$project$Extra$Data$Graph$stronglyConnComp(graph);
	return $author$project$Builder$Build$checkForCyclesHelp(sccs);
};
var $author$project$Builder$Elm$Details$lensMVInterfaces = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.g;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, bi, ci, di, ei, fi, x, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Build$checkMidpoint = F2(
	function (dmvar, statuses) {
		var _v0 = $author$project$Builder$Build$checkForCycles(statuses);
		if (_v0.$ === 'Nothing') {
			return A2(
				$author$project$Extra$System$IO$bind,
				A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVInterfaces, dmvar),
				function (maybeForeigns) {
					if (maybeForeigns.$ === 'Nothing') {
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$BP_CannotLoadDependencies));
					} else {
						var fs = maybeForeigns.a;
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Right(fs));
					}
				});
		} else {
			var _v2 = _v0.a;
			var name = _v2.a;
			var names = _v2.b;
			return A2(
				$author$project$Extra$System$IO$bind,
				A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVInterfaces, dmvar),
				function (_v3) {
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(
							A2($author$project$Builder$Reporting$Exit$BP_Cycle, name, names)));
				});
		}
	});
var $author$project$Compiler$Reporting$Error$BadImports = function (a) {
	return {$: 'BadImports', a: a};
};
var $author$project$Compiler$Reporting$Error$Module = F5(
	function (a, b, c, d, e) {
		return {$: 'Module', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Builder$Build$RBlocked = {$: 'RBlocked'};
var $author$project$Builder$Build$RCached = F3(
	function (a, b, c) {
		return {$: 'RCached', a: a, b: b, c: c};
	});
var $author$project$Builder$Build$RForeign = function (a) {
	return {$: 'RForeign', a: a};
};
var $author$project$Builder$Build$RKernel = {$: 'RKernel'};
var $author$project$Builder$Build$RNotFound = function (a) {
	return {$: 'RNotFound', a: a};
};
var $author$project$Builder$Build$RProblem = function (a) {
	return {$: 'RProblem', a: a};
};
var $author$project$Builder$Build$Unneeded = {$: 'Unneeded'};
var $author$project$Builder$Elm$Details$Local = F6(
	function (a, b, c, d, e, f) {
		return {$: 'Local', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Builder$Build$RNew = F3(
	function (a, b, c) {
		return {$: 'RNew', a: a, b: b, c: c};
	});
var $author$project$Builder$Build$RSame = F3(
	function (a, b, c) {
		return {$: 'RSame', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$LocalGraph = F3(
	function (a, b, c) {
		return {$: 'LocalGraph', a: a, b: b, c: c};
	});
var $author$project$Extra$Data$Binary$T3 = F3(
	function (a, b, c) {
		return {$: 'T3', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Package$fromComparable = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return A2($author$project$Compiler$Elm$Package$Name, author, project);
};
var $author$project$Compiler$Elm$ModuleName$fromComparable = function (_v0) {
	var name = _v0.a;
	var pkg = _v0.b;
	return A2(
		$author$project$Compiler$Elm$ModuleName$Canonical,
		$author$project$Compiler$Elm$Package$fromComparable(pkg),
		name);
};
var $author$project$Extra$Data$Binary$iso = F3(
	function (to, from, binA) {
		return {
			get: A2($author$project$Extra$Data$Binary$Get$fmap, to, binA.get),
			put: A2($elm$core$Basics$composeL, binA.put, from)
		};
	});
var $author$project$Compiler$Elm$Package$toComparable = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return _Utils_Tuple2(author, project);
};
var $author$project$Compiler$Elm$ModuleName$toComparable = function (_v0) {
	var pkg = _v0.a;
	var name = _v0.b;
	return _Utils_Tuple2(
		name,
		$author$project$Compiler$Elm$Package$toComparable(pkg));
};
var $author$project$Compiler$Elm$ModuleName$bComparable = A3($author$project$Extra$Data$Binary$iso, $author$project$Compiler$Elm$ModuleName$toComparable, $author$project$Compiler$Elm$ModuleName$fromComparable, $author$project$Compiler$Elm$ModuleName$bCanonical);
var $author$project$Compiler$AST$Optimized$bGlobalComparable = A2($author$project$Extra$Data$Binary$bTuple, $author$project$Compiler$Elm$ModuleName$bComparable, $author$project$Compiler$Data$Name$bName);
var $author$project$Compiler$AST$Optimized$Dynamic = F2(
	function (a, b) {
		return {$: 'Dynamic', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Static = {$: 'Static'};
var $author$project$Compiler$AST$Optimized$Access = F2(
	function (a, b) {
		return {$: 'Access', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Accessor = function (a) {
	return {$: 'Accessor', a: a};
};
var $author$project$Compiler$AST$Optimized$CBool = function (a) {
	return {$: 'CBool', a: a};
};
var $author$project$Compiler$AST$Optimized$CFloat = function (a) {
	return {$: 'CFloat', a: a};
};
var $author$project$Compiler$AST$Optimized$CInt = function (a) {
	return {$: 'CInt', a: a};
};
var $author$project$Compiler$AST$Optimized$CList = function (a) {
	return {$: 'CList', a: a};
};
var $author$project$Compiler$AST$Optimized$Call = F2(
	function (a, b) {
		return {$: 'Call', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Case = F4(
	function (a, b, c, d) {
		return {$: 'Case', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Optimized$Chr = function (a) {
	return {$: 'Chr', a: a};
};
var $author$project$Compiler$AST$Optimized$Def = F2(
	function (a, b) {
		return {$: 'Def', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Destruct = F2(
	function (a, b) {
		return {$: 'Destruct', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Function = F2(
	function (a, b) {
		return {$: 'Function', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$If = F2(
	function (a, b) {
		return {$: 'If', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Inline = function (a) {
	return {$: 'Inline', a: a};
};
var $author$project$Compiler$AST$Optimized$Jump = function (a) {
	return {$: 'Jump', a: a};
};
var $author$project$Compiler$AST$Optimized$Let = F2(
	function (a, b) {
		return {$: 'Let', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Record = function (a) {
	return {$: 'Record', a: a};
};
var $author$project$Compiler$AST$Optimized$Shader = F3(
	function (a, b, c) {
		return {$: 'Shader', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$Str = function (a) {
	return {$: 'Str', a: a};
};
var $author$project$Compiler$AST$Optimized$TailCall = F2(
	function (a, b) {
		return {$: 'TailCall', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$TailDef = F3(
	function (a, b, c) {
		return {$: 'TailDef', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$Tuple = F3(
	function (a, b, c) {
		return {$: 'Tuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$Unit = {$: 'Unit'};
var $author$project$Compiler$AST$Optimized$Update = F2(
	function (a, b) {
		return {$: 'Update', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$VarBox = function (a) {
	return {$: 'VarBox', a: a};
};
var $author$project$Compiler$AST$Optimized$VarCycle = F2(
	function (a, b) {
		return {$: 'VarCycle', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$VarDebug = F4(
	function (a, b, c, d) {
		return {$: 'VarDebug', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Optimized$VarEnum = F2(
	function (a, b) {
		return {$: 'VarEnum', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$VarGlobal = function (a) {
	return {$: 'VarGlobal', a: a};
};
var $author$project$Compiler$AST$Optimized$VarKernel = F2(
	function (a, b) {
		return {$: 'VarKernel', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$VarLocal = function (a) {
	return {$: 'VarLocal', a: a};
};
var $author$project$Extra$Data$Binary$bBool = A2(
	$author$project$Extra$Data$Binary$enum,
	'Could not map value to Bool',
	_List_fromArray(
		[false, true]));
var $author$project$Compiler$AST$Optimized$Chain = F3(
	function (a, b, c) {
		return {$: 'Chain', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$FanOut = F3(
	function (a, b, c) {
		return {$: 'FanOut', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$Leaf = function (a) {
	return {$: 'Leaf', a: a};
};
var $author$project$Compiler$Optimize$DecisionTree$Empty = {$: 'Empty'};
var $author$project$Compiler$Optimize$DecisionTree$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $author$project$Compiler$Optimize$DecisionTree$Unbox = function (a) {
	return {$: 'Unbox', a: a};
};
function $author$project$Compiler$Optimize$DecisionTree$cyclic$bPath() {
	return $author$project$Extra$Data$Binary$finish(
		A3(
			$author$project$Extra$Data$Binary$var0,
			2,
			$author$project$Compiler$Optimize$DecisionTree$Empty,
			A4(
				$author$project$Extra$Data$Binary$var1,
				1,
				$author$project$Compiler$Optimize$DecisionTree$Unbox,
				$author$project$Extra$Data$Binary$lazy(
					function (_v2) {
						return $author$project$Compiler$Optimize$DecisionTree$cyclic$bPath();
					}),
				A5(
					$author$project$Extra$Data$Binary$var2,
					0,
					$author$project$Compiler$Optimize$DecisionTree$Index,
					$author$project$Compiler$Data$Index$bZeroBased,
					$author$project$Extra$Data$Binary$lazy(
						function (_v1) {
							return $author$project$Compiler$Optimize$DecisionTree$cyclic$bPath();
						}),
					A2(
						$author$project$Extra$Data$Binary$custom,
						'problem getting DecisionTree.Path binary',
						F4(
							function (p0, p1, p2, path) {
								switch (path.$) {
									case 'Index':
										var a = path.a;
										var b = path.b;
										return A2(p0, a, b);
									case 'Unbox':
										var a = path.a;
										return p1(a);
									default:
										return p2;
								}
							}))))));
}
try {
	var $author$project$Compiler$Optimize$DecisionTree$bPath = $author$project$Compiler$Optimize$DecisionTree$cyclic$bPath();
	$author$project$Compiler$Optimize$DecisionTree$cyclic$bPath = function () {
		return $author$project$Compiler$Optimize$DecisionTree$bPath;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Optimize.DecisionTree` are causing infinite recursion:\n\n  \n      bPath\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$Optimize$DecisionTree$IsBool = function (a) {
	return {$: 'IsBool', a: a};
};
var $author$project$Compiler$Optimize$DecisionTree$IsChr = function (a) {
	return {$: 'IsChr', a: a};
};
var $author$project$Compiler$Optimize$DecisionTree$IsCons = {$: 'IsCons'};
var $author$project$Compiler$Optimize$DecisionTree$IsCtor = F5(
	function (a, b, c, d, e) {
		return {$: 'IsCtor', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Optimize$DecisionTree$IsInt = function (a) {
	return {$: 'IsInt', a: a};
};
var $author$project$Compiler$Optimize$DecisionTree$IsNil = {$: 'IsNil'};
var $author$project$Compiler$Optimize$DecisionTree$IsStr = function (a) {
	return {$: 'IsStr', a: a};
};
var $author$project$Compiler$Optimize$DecisionTree$IsTuple = {$: 'IsTuple'};
var $author$project$Extra$Data$Binary$bString = $author$project$Extra$Data$Binary$bStringWith($author$project$Extra$Data$Binary$bWord64);
var $author$project$Compiler$Data$Utf8$bVeryLong = $author$project$Extra$Data$Binary$bString;
var $author$project$Compiler$Elm$String$bTString = $author$project$Compiler$Data$Utf8$bVeryLong;
var $author$project$Extra$Data$Binary$var5 = F7(
	function (id, ctor, m1, m2, m3, m4, m5) {
		return A3(
			$author$project$Extra$Data$Binary$variant,
			$elm$core$Basics$eq(id),
			F5(
				function (a, b, c, d, e) {
					return $author$project$Extra$Data$Binary$Put$join(
						_List_fromArray(
							[
								$author$project$Extra$Data$Binary$Put$putWord8(id),
								m1.put(a),
								m2.put(b),
								m3.put(c),
								m4.put(d),
								m5.put(e)
							]));
				}),
			A6($author$project$Extra$Data$Binary$Get$liftM5, ctor, m1.get, m2.get, m3.get, m4.get, m5.get));
	});
var $author$project$Compiler$Optimize$DecisionTree$bTest = $author$project$Extra$Data$Binary$finish(
	A4(
		$author$project$Extra$Data$Binary$var1,
		7,
		$author$project$Compiler$Optimize$DecisionTree$IsBool,
		$author$project$Extra$Data$Binary$bBool,
		A4(
			$author$project$Extra$Data$Binary$var1,
			6,
			$author$project$Compiler$Optimize$DecisionTree$IsInt,
			$author$project$Extra$Data$Binary$bWord64,
			A4(
				$author$project$Extra$Data$Binary$var1,
				5,
				$author$project$Compiler$Optimize$DecisionTree$IsStr,
				$author$project$Compiler$Elm$String$bTString,
				A4(
					$author$project$Extra$Data$Binary$var1,
					4,
					$author$project$Compiler$Optimize$DecisionTree$IsChr,
					$author$project$Compiler$Elm$String$bTString,
					A3(
						$author$project$Extra$Data$Binary$var0,
						3,
						$author$project$Compiler$Optimize$DecisionTree$IsTuple,
						A3(
							$author$project$Extra$Data$Binary$var0,
							2,
							$author$project$Compiler$Optimize$DecisionTree$IsNil,
							A3(
								$author$project$Extra$Data$Binary$var0,
								1,
								$author$project$Compiler$Optimize$DecisionTree$IsCons,
								A8(
									$author$project$Extra$Data$Binary$var5,
									0,
									$author$project$Compiler$Optimize$DecisionTree$IsCtor,
									$author$project$Compiler$Elm$ModuleName$bCanonical,
									$author$project$Compiler$Data$Name$bName,
									$author$project$Compiler$Data$Index$bZeroBased,
									$author$project$Extra$Data$Binary$bWord64,
									$author$project$Compiler$AST$Canonical$bCtorOpts,
									A2(
										$author$project$Extra$Data$Binary$custom,
										'problem getting DecisionTree.Test binary',
										F9(
											function (p0, p1, p2, p3, p4, p5, p6, p7, test) {
												switch (test.$) {
													case 'IsCtor':
														var a = test.a;
														var b = test.b;
														var c = test.c;
														var d = test.d;
														var e = test.e;
														return A5(p0, a, b, c, d, e);
													case 'IsCons':
														return p1;
													case 'IsNil':
														return p2;
													case 'IsTuple':
														return p3;
													case 'IsChr':
														var a = test.a;
														return p4(a);
													case 'IsStr':
														var a = test.a;
														return p5(a);
													case 'IsInt':
														var a = test.a;
														return p6(a);
													default:
														var a = test.a;
														return p7(a);
												}
											})))))))))));
var $author$project$Compiler$AST$Optimized$bDecider = function (binA) {
	return $author$project$Extra$Data$Binary$finish(
		A6(
			$author$project$Extra$Data$Binary$var3,
			2,
			$author$project$Compiler$AST$Optimized$FanOut,
			$author$project$Compiler$Optimize$DecisionTree$bPath,
			$author$project$Extra$Data$Binary$bTList(
				A2(
					$author$project$Extra$Data$Binary$bTuple,
					$author$project$Compiler$Optimize$DecisionTree$bTest,
					$author$project$Extra$Data$Binary$lazy(
						function (_v3) {
							return $author$project$Compiler$AST$Optimized$bDecider(binA);
						}))),
			$author$project$Extra$Data$Binary$lazy(
				function (_v4) {
					return $author$project$Compiler$AST$Optimized$bDecider(binA);
				}),
			A6(
				$author$project$Extra$Data$Binary$var3,
				1,
				$author$project$Compiler$AST$Optimized$Chain,
				$author$project$Extra$Data$Binary$bTList(
					A2($author$project$Extra$Data$Binary$bTuple, $author$project$Compiler$Optimize$DecisionTree$bPath, $author$project$Compiler$Optimize$DecisionTree$bTest)),
				$author$project$Extra$Data$Binary$lazy(
					function (_v1) {
						return $author$project$Compiler$AST$Optimized$bDecider(binA);
					}),
				$author$project$Extra$Data$Binary$lazy(
					function (_v2) {
						return $author$project$Compiler$AST$Optimized$bDecider(binA);
					}),
				A4(
					$author$project$Extra$Data$Binary$var1,
					0,
					$author$project$Compiler$AST$Optimized$Leaf,
					binA,
					A2(
						$author$project$Extra$Data$Binary$custom,
						'problem getting Opt.Decider binary',
						F4(
							function (p0, p1, p2, decider) {
								switch (decider.$) {
									case 'Leaf':
										var a = decider.a;
										return p0(a);
									case 'Chain':
										var a = decider.a;
										var b = decider.b;
										var c = decider.c;
										return A3(p1, a, b, c);
									default:
										var a = decider.a;
										var b = decider.b;
										var c = decider.c;
										return A3(p2, a, b, c);
								}
							}))))));
};
var $author$project$Compiler$AST$Optimized$Destructor = F2(
	function (a, b) {
		return {$: 'Destructor', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Field = F2(
	function (a, b) {
		return {$: 'Field', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Root = function (a) {
	return {$: 'Root', a: a};
};
var $author$project$Compiler$AST$Optimized$Unbox = function (a) {
	return {$: 'Unbox', a: a};
};
function $author$project$Compiler$AST$Optimized$cyclic$bPath() {
	return $author$project$Extra$Data$Binary$finish(
		A4(
			$author$project$Extra$Data$Binary$var1,
			3,
			$author$project$Compiler$AST$Optimized$Root,
			$author$project$Compiler$Data$Name$bName,
			A4(
				$author$project$Extra$Data$Binary$var1,
				2,
				$author$project$Compiler$AST$Optimized$Unbox,
				$author$project$Extra$Data$Binary$lazy(
					function (_v3) {
						return $author$project$Compiler$AST$Optimized$cyclic$bPath();
					}),
				A5(
					$author$project$Extra$Data$Binary$var2,
					1,
					$author$project$Compiler$AST$Optimized$Field,
					$author$project$Compiler$Data$Name$bName,
					$author$project$Extra$Data$Binary$lazy(
						function (_v2) {
							return $author$project$Compiler$AST$Optimized$cyclic$bPath();
						}),
					A5(
						$author$project$Extra$Data$Binary$var2,
						0,
						$author$project$Compiler$AST$Optimized$Index,
						$author$project$Compiler$Data$Index$bZeroBased,
						$author$project$Extra$Data$Binary$lazy(
							function (_v1) {
								return $author$project$Compiler$AST$Optimized$cyclic$bPath();
							}),
						A2(
							$author$project$Extra$Data$Binary$custom,
							'problem getting Opt.Path binary',
							F5(
								function (p0, p1, p2, p3, path) {
									switch (path.$) {
										case 'Index':
											var a = path.a;
											var b = path.b;
											return A2(p0, a, b);
										case 'Field':
											var a = path.a;
											var b = path.b;
											return A2(p1, a, b);
										case 'Unbox':
											var a = path.a;
											return p2(a);
										default:
											var a = path.a;
											return p3(a);
									}
								})))))));
}
try {
	var $author$project$Compiler$AST$Optimized$bPath = $author$project$Compiler$AST$Optimized$cyclic$bPath();
	$author$project$Compiler$AST$Optimized$cyclic$bPath = function () {
		return $author$project$Compiler$AST$Optimized$bPath;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.AST.Optimized` are causing infinite recursion:\n\n  \n      bPath\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$AST$Optimized$bDestructor = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$AST$Optimized$Destructor,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Data$Name$bName,
	$author$project$Compiler$AST$Optimized$bPath);
var $author$project$Compiler$AST$Optimized$Global = F2(
	function (a, b) {
		return {$: 'Global', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$bGlobal = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$AST$Optimized$Global,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Elm$ModuleName$bCanonical,
	$author$project$Compiler$Data$Name$bName);
var $author$project$Compiler$Reporting$Annotation$bPosition = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$Reporting$Annotation$Position,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Extra$Data$Binary$bWord16,
	$author$project$Extra$Data$Binary$bWord16);
var $author$project$Compiler$Reporting$Annotation$bRegion = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$Reporting$Annotation$Region,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Reporting$Annotation$bPosition,
	$author$project$Compiler$Reporting$Annotation$bPosition);
var $author$project$Extra$Type$Set$toList = $elm$core$Set$toList;
var $author$project$Extra$Data$Binary$bSet = function (binC) {
	return A3(
		$author$project$Extra$Data$Binary$bin1,
		$author$project$Extra$Type$Set$fromList,
		$author$project$Extra$Type$Set$toList,
		$author$project$Extra$Data$Binary$bTList(binC));
};
var $author$project$Compiler$AST$Utils$Shader$bSource = A3(
	$author$project$Extra$Data$Binary$bin1,
	$author$project$Compiler$AST$Utils$Shader$Source,
	function (_v0) {
		var a = _v0.a;
		return a;
	},
	$author$project$Extra$Data$Binary$bString);
var $author$project$Compiler$Elm$Float$bTFloat = $author$project$Compiler$Data$Utf8$bUnder256;
function $author$project$Compiler$AST$Optimized$cyclic$bExpr() {
	return $author$project$Extra$Data$Binary$finish(
		A6(
			$author$project$Extra$Data$Binary$var3,
			26,
			$author$project$Compiler$AST$Optimized$Shader,
			$author$project$Compiler$AST$Utils$Shader$bSource,
			$author$project$Extra$Data$Binary$bSet($author$project$Compiler$Data$Name$bName),
			$author$project$Extra$Data$Binary$bSet($author$project$Compiler$Data$Name$bName),
			A6(
				$author$project$Extra$Data$Binary$var3,
				25,
				$author$project$Compiler$AST$Optimized$Tuple,
				$author$project$Extra$Data$Binary$lazy(
					function (_v21) {
						return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
					}),
				$author$project$Extra$Data$Binary$lazy(
					function (_v22) {
						return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
					}),
				$author$project$Extra$Data$Binary$bMaybe(
					$author$project$Extra$Data$Binary$lazy(
						function (_v23) {
							return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
						})),
				A3(
					$author$project$Extra$Data$Binary$var0,
					24,
					$author$project$Compiler$AST$Optimized$Unit,
					A4(
						$author$project$Extra$Data$Binary$var1,
						23,
						$author$project$Compiler$AST$Optimized$Record,
						A2(
							$author$project$Extra$Data$Binary$bMap,
							$author$project$Compiler$Data$Name$bName,
							$author$project$Extra$Data$Binary$lazy(
								function (_v20) {
									return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
								})),
						A5(
							$author$project$Extra$Data$Binary$var2,
							22,
							$author$project$Compiler$AST$Optimized$Update,
							$author$project$Extra$Data$Binary$lazy(
								function (_v18) {
									return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
								}),
							A2(
								$author$project$Extra$Data$Binary$bMap,
								$author$project$Compiler$Data$Name$bName,
								$author$project$Extra$Data$Binary$lazy(
									function (_v19) {
										return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
									})),
							A5(
								$author$project$Extra$Data$Binary$var2,
								21,
								$author$project$Compiler$AST$Optimized$Access,
								$author$project$Extra$Data$Binary$lazy(
									function (_v17) {
										return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
									}),
								$author$project$Compiler$Data$Name$bName,
								A4(
									$author$project$Extra$Data$Binary$var1,
									20,
									$author$project$Compiler$AST$Optimized$Accessor,
									$author$project$Compiler$Data$Name$bName,
									A7(
										$author$project$Extra$Data$Binary$var4,
										19,
										$author$project$Compiler$AST$Optimized$Case,
										$author$project$Compiler$Data$Name$bName,
										$author$project$Compiler$Data$Name$bName,
										$author$project$Compiler$AST$Optimized$bDecider(
											$author$project$Compiler$AST$Optimized$cyclic$bChoice()),
										$author$project$Extra$Data$Binary$bTList(
											A2(
												$author$project$Extra$Data$Binary$bTuple,
												$author$project$Extra$Data$Binary$bWord64,
												$author$project$Extra$Data$Binary$lazy(
													function (_v16) {
														return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
													}))),
										A5(
											$author$project$Extra$Data$Binary$var2,
											18,
											$author$project$Compiler$AST$Optimized$Destruct,
											$author$project$Compiler$AST$Optimized$bDestructor,
											$author$project$Extra$Data$Binary$lazy(
												function (_v15) {
													return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
												}),
											A5(
												$author$project$Extra$Data$Binary$var2,
												17,
												$author$project$Compiler$AST$Optimized$Let,
												$author$project$Compiler$AST$Optimized$cyclic$bDef(),
												$author$project$Extra$Data$Binary$lazy(
													function (_v14) {
														return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
													}),
												A5(
													$author$project$Extra$Data$Binary$var2,
													16,
													$author$project$Compiler$AST$Optimized$If,
													$author$project$Extra$Data$Binary$bTList(
														A2(
															$author$project$Extra$Data$Binary$bTuple,
															$author$project$Extra$Data$Binary$lazy(
																function (_v11) {
																	return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																}),
															$author$project$Extra$Data$Binary$lazy(
																function (_v12) {
																	return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																}))),
													$author$project$Extra$Data$Binary$lazy(
														function (_v13) {
															return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
														}),
													A5(
														$author$project$Extra$Data$Binary$var2,
														15,
														$author$project$Compiler$AST$Optimized$TailCall,
														$author$project$Compiler$Data$Name$bName,
														$author$project$Extra$Data$Binary$bTList(
															A2(
																$author$project$Extra$Data$Binary$bTuple,
																$author$project$Compiler$Data$Name$bName,
																$author$project$Extra$Data$Binary$lazy(
																	function (_v10) {
																		return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																	}))),
														A5(
															$author$project$Extra$Data$Binary$var2,
															14,
															$author$project$Compiler$AST$Optimized$Call,
															$author$project$Extra$Data$Binary$lazy(
																function (_v8) {
																	return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																}),
															$author$project$Extra$Data$Binary$bTList(
																$author$project$Extra$Data$Binary$lazy(
																	function (_v9) {
																		return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																	})),
															A5(
																$author$project$Extra$Data$Binary$var2,
																13,
																$author$project$Compiler$AST$Optimized$Function,
																$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Data$Name$bName),
																$author$project$Extra$Data$Binary$lazy(
																	function (_v7) {
																		return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																	}),
																A4(
																	$author$project$Extra$Data$Binary$var1,
																	12,
																	$author$project$Compiler$AST$Optimized$CList,
																	$author$project$Extra$Data$Binary$bTList(
																		$author$project$Extra$Data$Binary$lazy(
																			function (_v6) {
																				return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
																			})),
																	A5(
																		$author$project$Extra$Data$Binary$var2,
																		11,
																		$author$project$Compiler$AST$Optimized$VarKernel,
																		$author$project$Compiler$Data$Name$bName,
																		$author$project$Compiler$Data$Name$bName,
																		A7(
																			$author$project$Extra$Data$Binary$var4,
																			10,
																			$author$project$Compiler$AST$Optimized$VarDebug,
																			$author$project$Compiler$Data$Name$bName,
																			$author$project$Compiler$Elm$ModuleName$bCanonical,
																			$author$project$Compiler$Reporting$Annotation$bRegion,
																			$author$project$Extra$Data$Binary$bMaybe($author$project$Compiler$Data$Name$bName),
																			A5(
																				$author$project$Extra$Data$Binary$var2,
																				9,
																				$author$project$Compiler$AST$Optimized$VarCycle,
																				$author$project$Compiler$Elm$ModuleName$bCanonical,
																				$author$project$Compiler$Data$Name$bName,
																				A4(
																					$author$project$Extra$Data$Binary$var1,
																					8,
																					$author$project$Compiler$AST$Optimized$VarBox,
																					$author$project$Compiler$AST$Optimized$bGlobal,
																					A5(
																						$author$project$Extra$Data$Binary$var2,
																						7,
																						$author$project$Compiler$AST$Optimized$VarEnum,
																						$author$project$Compiler$AST$Optimized$bGlobal,
																						$author$project$Compiler$Data$Index$bZeroBased,
																						A4(
																							$author$project$Extra$Data$Binary$var1,
																							6,
																							$author$project$Compiler$AST$Optimized$VarGlobal,
																							$author$project$Compiler$AST$Optimized$bGlobal,
																							A4(
																								$author$project$Extra$Data$Binary$var1,
																								5,
																								$author$project$Compiler$AST$Optimized$VarLocal,
																								$author$project$Compiler$Data$Name$bName,
																								A4(
																									$author$project$Extra$Data$Binary$var1,
																									4,
																									$author$project$Compiler$AST$Optimized$CFloat,
																									$author$project$Compiler$Elm$Float$bTFloat,
																									A4(
																										$author$project$Extra$Data$Binary$var1,
																										3,
																										$author$project$Compiler$AST$Optimized$CInt,
																										$author$project$Extra$Data$Binary$bWord64,
																										A4(
																											$author$project$Extra$Data$Binary$var1,
																											2,
																											$author$project$Compiler$AST$Optimized$Str,
																											$author$project$Compiler$Elm$String$bTString,
																											A4(
																												$author$project$Extra$Data$Binary$var1,
																												1,
																												$author$project$Compiler$AST$Optimized$Chr,
																												$author$project$Compiler$Elm$String$bTString,
																												A4(
																													$author$project$Extra$Data$Binary$var1,
																													0,
																													$author$project$Compiler$AST$Optimized$CBool,
																													$author$project$Extra$Data$Binary$bBool,
																													A2(
																														$author$project$Extra$Data$Binary$custom,
																														'problem getting Opt.Expr binary',
																														function (p0) {
																															return function (p1) {
																																return function (p2) {
																																	return function (p3) {
																																		return function (p4) {
																																			return function (p5) {
																																				return function (p6) {
																																					return function (p7) {
																																						return function (p8) {
																																							return function (p9) {
																																								return function (p10) {
																																									return function (p11) {
																																										return function (p12) {
																																											return function (p13) {
																																												return function (p14) {
																																													return function (p15) {
																																														return function (p16) {
																																															return function (p17) {
																																																return function (p18) {
																																																	return function (p19) {
																																																		return function (p20) {
																																																			return function (p21) {
																																																				return function (p22) {
																																																					return function (p23) {
																																																						return function (p24) {
																																																							return function (p25) {
																																																								return function (p26) {
																																																									return function (expr) {
																																																										switch (expr.$) {
																																																											case 'CBool':
																																																												var a = expr.a;
																																																												return p0(a);
																																																											case 'Chr':
																																																												var a = expr.a;
																																																												return p1(a);
																																																											case 'Str':
																																																												var a = expr.a;
																																																												return p2(a);
																																																											case 'CInt':
																																																												var a = expr.a;
																																																												return p3(a);
																																																											case 'CFloat':
																																																												var a = expr.a;
																																																												return p4(a);
																																																											case 'VarLocal':
																																																												var a = expr.a;
																																																												return p5(a);
																																																											case 'VarGlobal':
																																																												var a = expr.a;
																																																												return p6(a);
																																																											case 'VarEnum':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p7, a, b);
																																																											case 'VarBox':
																																																												var a = expr.a;
																																																												return p8(a);
																																																											case 'VarCycle':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p9, a, b);
																																																											case 'VarDebug':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												var c = expr.c;
																																																												var d = expr.d;
																																																												return A4(p10, a, b, c, d);
																																																											case 'VarKernel':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p11, a, b);
																																																											case 'CList':
																																																												var a = expr.a;
																																																												return p12(a);
																																																											case 'Function':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p13, a, b);
																																																											case 'Call':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p14, a, b);
																																																											case 'TailCall':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p15, a, b);
																																																											case 'If':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p16, a, b);
																																																											case 'Let':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p17, a, b);
																																																											case 'Destruct':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p18, a, b);
																																																											case 'Case':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												var c = expr.c;
																																																												var d = expr.d;
																																																												return A4(p19, a, b, c, d);
																																																											case 'Accessor':
																																																												var a = expr.a;
																																																												return p20(a);
																																																											case 'Access':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p21, a, b);
																																																											case 'Update':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												return A2(p22, a, b);
																																																											case 'Record':
																																																												var a = expr.a;
																																																												return p23(a);
																																																											case 'Unit':
																																																												return p24;
																																																											case 'Tuple':
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												var c = expr.c;
																																																												return A3(p25, a, b, c);
																																																											default:
																																																												var a = expr.a;
																																																												var b = expr.b;
																																																												var c = expr.c;
																																																												return A3(p26, a, b, c);
																																																										}
																																																									};
																																																								};
																																																							};
																																																						};
																																																					};
																																																				};
																																																			};
																																																		};
																																																	};
																																																};
																																															};
																																														};
																																													};
																																												};
																																											};
																																										};
																																									};
																																								};
																																							};
																																						};
																																					};
																																				};
																																			};
																																		};
																																	};
																																};
																															};
																														})))))))))))))))))))))))))))));
}
function $author$project$Compiler$AST$Optimized$cyclic$bChoice() {
	return $author$project$Extra$Data$Binary$finish(
		A4(
			$author$project$Extra$Data$Binary$var1,
			1,
			$author$project$Compiler$AST$Optimized$Jump,
			$author$project$Extra$Data$Binary$bWord64,
			A4(
				$author$project$Extra$Data$Binary$var1,
				0,
				$author$project$Compiler$AST$Optimized$Inline,
				$author$project$Extra$Data$Binary$lazy(
					function (_v4) {
						return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
					}),
				A2(
					$author$project$Extra$Data$Binary$custom,
					'problem getting Opt.Choice binary',
					F3(
						function (p0, p1, choice) {
							if (choice.$ === 'Inline') {
								var a = choice.a;
								return p0(a);
							} else {
								var a = choice.a;
								return p1(a);
							}
						})))));
}
function $author$project$Compiler$AST$Optimized$cyclic$bDef() {
	return $author$project$Extra$Data$Binary$finish(
		A6(
			$author$project$Extra$Data$Binary$var3,
			1,
			$author$project$Compiler$AST$Optimized$TailDef,
			$author$project$Compiler$Data$Name$bName,
			$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Data$Name$bName),
			$author$project$Extra$Data$Binary$lazy(
				function (_v2) {
					return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
				}),
			A5(
				$author$project$Extra$Data$Binary$var2,
				0,
				$author$project$Compiler$AST$Optimized$Def,
				$author$project$Compiler$Data$Name$bName,
				$author$project$Extra$Data$Binary$lazy(
					function (_v1) {
						return $author$project$Compiler$AST$Optimized$cyclic$bExpr();
					}),
				A2(
					$author$project$Extra$Data$Binary$custom,
					'problem getting Opt.Def binary',
					F3(
						function (p0, p1, def) {
							if (def.$ === 'Def') {
								var a = def.a;
								var b = def.b;
								return A2(p0, a, b);
							} else {
								var a = def.a;
								var b = def.b;
								var c = def.c;
								return A3(p1, a, b, c);
							}
						})))));
}
try {
	var $author$project$Compiler$AST$Optimized$bExpr = $author$project$Compiler$AST$Optimized$cyclic$bExpr();
	$author$project$Compiler$AST$Optimized$cyclic$bExpr = function () {
		return $author$project$Compiler$AST$Optimized$bExpr;
	};
	var $author$project$Compiler$AST$Optimized$bChoice = $author$project$Compiler$AST$Optimized$cyclic$bChoice();
	$author$project$Compiler$AST$Optimized$cyclic$bChoice = function () {
		return $author$project$Compiler$AST$Optimized$bChoice;
	};
	var $author$project$Compiler$AST$Optimized$bDef = $author$project$Compiler$AST$Optimized$cyclic$bDef();
	$author$project$Compiler$AST$Optimized$cyclic$bDef = function () {
		return $author$project$Compiler$AST$Optimized$bDef;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.AST.Optimized` are causing infinite recursion:\n\n  \n      bExpr\n       \n      bChoice\n       \n      bDef\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$AST$Optimized$bMain = $author$project$Extra$Data$Binary$finish(
	A5(
		$author$project$Extra$Data$Binary$var2,
		1,
		$author$project$Compiler$AST$Optimized$Dynamic,
		$author$project$Compiler$AST$Canonical$bType,
		$author$project$Compiler$AST$Optimized$bExpr,
		A3(
			$author$project$Extra$Data$Binary$var0,
			0,
			$author$project$Compiler$AST$Optimized$Static,
			A2(
				$author$project$Extra$Data$Binary$custom,
				'problem getting Opt.Main binary',
				F3(
					function (p0, p1, main) {
						if (main.$ === 'Static') {
							return p0;
						} else {
							var a = main.a;
							var b = main.b;
							return A2(p1, a, b);
						}
					})))));
var $author$project$Compiler$AST$Optimized$Box = {$: 'Box'};
var $author$project$Compiler$AST$Optimized$Ctor = F2(
	function (a, b) {
		return {$: 'Ctor', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Cycle = F4(
	function (a, b, c, d) {
		return {$: 'Cycle', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Optimized$Define = F2(
	function (a, b) {
		return {$: 'Define', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$DefineTailFunc = F3(
	function (a, b, c) {
		return {$: 'DefineTailFunc', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Optimized$Enum = function (a) {
	return {$: 'Enum', a: a};
};
var $author$project$Compiler$AST$Optimized$Kernel = F2(
	function (a, b) {
		return {$: 'Kernel', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$Link = function (a) {
	return {$: 'Link', a: a};
};
var $author$project$Compiler$AST$Optimized$Manager = function (a) {
	return {$: 'Manager', a: a};
};
var $author$project$Compiler$AST$Optimized$PortIncoming = F2(
	function (a, b) {
		return {$: 'PortIncoming', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$PortOutgoing = F2(
	function (a, b) {
		return {$: 'PortOutgoing', a: a, b: b};
	});
var $author$project$Compiler$Elm$Kernel$Async = {$: 'Async'};
var $author$project$Compiler$Elm$Kernel$Debug = {$: 'Debug'};
var $author$project$Compiler$Elm$Kernel$ElmField = function (a) {
	return {$: 'ElmField', a: a};
};
var $author$project$Compiler$Elm$Kernel$ElmVar = F2(
	function (a, b) {
		return {$: 'ElmVar', a: a, b: b};
	});
var $author$project$Compiler$Elm$Kernel$JS = function (a) {
	return {$: 'JS', a: a};
};
var $author$project$Compiler$Elm$Kernel$JsEnum = function (a) {
	return {$: 'JsEnum', a: a};
};
var $author$project$Compiler$Elm$Kernel$JsField = function (a) {
	return {$: 'JsField', a: a};
};
var $author$project$Compiler$Elm$Kernel$JsVar = F2(
	function (a, b) {
		return {$: 'JsVar', a: a, b: b};
	});
var $author$project$Compiler$Elm$Kernel$Prod = {$: 'Prod'};
var $author$project$Compiler$Elm$Kernel$bChunk = $author$project$Extra$Data$Binary$finish(
	A3(
		$author$project$Extra$Data$Binary$var0,
		8,
		$author$project$Compiler$Elm$Kernel$Async,
		A3(
			$author$project$Extra$Data$Binary$var0,
			7,
			$author$project$Compiler$Elm$Kernel$Prod,
			A3(
				$author$project$Extra$Data$Binary$var0,
				6,
				$author$project$Compiler$Elm$Kernel$Debug,
				A4(
					$author$project$Extra$Data$Binary$var1,
					5,
					$author$project$Compiler$Elm$Kernel$JsEnum,
					$author$project$Extra$Data$Binary$bWord64,
					A4(
						$author$project$Extra$Data$Binary$var1,
						4,
						$author$project$Compiler$Elm$Kernel$JsField,
						$author$project$Extra$Data$Binary$bWord64,
						A4(
							$author$project$Extra$Data$Binary$var1,
							3,
							$author$project$Compiler$Elm$Kernel$ElmField,
							$author$project$Compiler$Data$Name$bName,
							A5(
								$author$project$Extra$Data$Binary$var2,
								2,
								$author$project$Compiler$Elm$Kernel$JsVar,
								$author$project$Compiler$Data$Name$bName,
								$author$project$Compiler$Data$Name$bName,
								A5(
									$author$project$Extra$Data$Binary$var2,
									1,
									$author$project$Compiler$Elm$Kernel$ElmVar,
									$author$project$Compiler$Elm$ModuleName$bCanonical,
									$author$project$Compiler$Data$Name$bName,
									A4(
										$author$project$Extra$Data$Binary$var1,
										0,
										$author$project$Compiler$Elm$Kernel$JS,
										$author$project$Extra$Data$Binary$bString,
										A2(
											$author$project$Extra$Data$Binary$custom,
											'problem deserializing Elm.Kernel.Chunk',
											function (p0) {
												return function (p1) {
													return function (p2) {
														return function (p3) {
															return function (p4) {
																return function (p5) {
																	return function (p6) {
																		return function (p7) {
																			return function (p8) {
																				return function (chunk) {
																					switch (chunk.$) {
																						case 'JS':
																							var a = chunk.a;
																							return p0(a);
																						case 'ElmVar':
																							var a = chunk.a;
																							var b = chunk.b;
																							return A2(p1, a, b);
																						case 'JsVar':
																							var a = chunk.a;
																							var b = chunk.b;
																							return A2(p2, a, b);
																						case 'ElmField':
																							var a = chunk.a;
																							return p3(a);
																						case 'JsField':
																							var a = chunk.a;
																							return p4(a);
																						case 'JsEnum':
																							var a = chunk.a;
																							return p5(a);
																						case 'Debug':
																							return p6;
																						case 'Prod':
																							return p7;
																						default:
																							return p8;
																					}
																				};
																			};
																		};
																	};
																};
															};
														};
													};
												};
											})))))))))));
var $author$project$Compiler$AST$Optimized$CCmd = {$: 'CCmd'};
var $author$project$Compiler$AST$Optimized$CSub = {$: 'CSub'};
var $author$project$Compiler$AST$Optimized$Fx = {$: 'Fx'};
var $author$project$Compiler$AST$Optimized$bEffectsType = A2(
	$author$project$Extra$Data$Binary$enum,
	'problem getting Opt.EffectsType binary',
	_List_fromArray(
		[$author$project$Compiler$AST$Optimized$CCmd, $author$project$Compiler$AST$Optimized$CSub, $author$project$Compiler$AST$Optimized$Fx]));
var $author$project$Compiler$AST$Optimized$bNode = $author$project$Extra$Data$Binary$finish(
	A5(
		$author$project$Extra$Data$Binary$var2,
		10,
		$author$project$Compiler$AST$Optimized$PortOutgoing,
		$author$project$Compiler$AST$Optimized$bExpr,
		$author$project$Extra$Data$Binary$bSet($author$project$Compiler$AST$Optimized$bGlobalComparable),
		A5(
			$author$project$Extra$Data$Binary$var2,
			9,
			$author$project$Compiler$AST$Optimized$PortIncoming,
			$author$project$Compiler$AST$Optimized$bExpr,
			$author$project$Extra$Data$Binary$bSet($author$project$Compiler$AST$Optimized$bGlobalComparable),
			A5(
				$author$project$Extra$Data$Binary$var2,
				8,
				$author$project$Compiler$AST$Optimized$Kernel,
				$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Elm$Kernel$bChunk),
				$author$project$Extra$Data$Binary$bSet($author$project$Compiler$AST$Optimized$bGlobalComparable),
				A4(
					$author$project$Extra$Data$Binary$var1,
					7,
					$author$project$Compiler$AST$Optimized$Manager,
					$author$project$Compiler$AST$Optimized$bEffectsType,
					A7(
						$author$project$Extra$Data$Binary$var4,
						6,
						$author$project$Compiler$AST$Optimized$Cycle,
						$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Data$Name$bName),
						$author$project$Extra$Data$Binary$bTList(
							A2($author$project$Extra$Data$Binary$bTuple, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$AST$Optimized$bExpr)),
						$author$project$Extra$Data$Binary$bTList($author$project$Compiler$AST$Optimized$bDef),
						$author$project$Extra$Data$Binary$bSet($author$project$Compiler$AST$Optimized$bGlobalComparable),
						A4(
							$author$project$Extra$Data$Binary$var1,
							5,
							$author$project$Compiler$AST$Optimized$Link,
							$author$project$Compiler$AST$Optimized$bGlobal,
							A3(
								$author$project$Extra$Data$Binary$var0,
								4,
								$author$project$Compiler$AST$Optimized$Box,
								A4(
									$author$project$Extra$Data$Binary$var1,
									3,
									$author$project$Compiler$AST$Optimized$Enum,
									$author$project$Compiler$Data$Index$bZeroBased,
									A5(
										$author$project$Extra$Data$Binary$var2,
										2,
										$author$project$Compiler$AST$Optimized$Ctor,
										$author$project$Compiler$Data$Index$bZeroBased,
										$author$project$Extra$Data$Binary$bWord64,
										A6(
											$author$project$Extra$Data$Binary$var3,
											1,
											$author$project$Compiler$AST$Optimized$DefineTailFunc,
											$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Data$Name$bName),
											$author$project$Compiler$AST$Optimized$bExpr,
											$author$project$Extra$Data$Binary$bSet($author$project$Compiler$AST$Optimized$bGlobalComparable),
											A5(
												$author$project$Extra$Data$Binary$var2,
												0,
												$author$project$Compiler$AST$Optimized$Define,
												$author$project$Compiler$AST$Optimized$bExpr,
												$author$project$Extra$Data$Binary$bSet($author$project$Compiler$AST$Optimized$bGlobalComparable),
												A2(
													$author$project$Extra$Data$Binary$custom,
													'problem getting Opt.Node binary',
													function (p0) {
														return function (p1) {
															return function (p2) {
																return function (p3) {
																	return function (p4) {
																		return function (p5) {
																			return function (p6) {
																				return function (p7) {
																					return function (p8) {
																						return function (p9) {
																							return function (p10) {
																								return function (node) {
																									switch (node.$) {
																										case 'Define':
																											var a = node.a;
																											var b = node.b;
																											return A2(p0, a, b);
																										case 'DefineTailFunc':
																											var a = node.a;
																											var b = node.b;
																											var c = node.c;
																											return A3(p1, a, b, c);
																										case 'Ctor':
																											var a = node.a;
																											var b = node.b;
																											return A2(p2, a, b);
																										case 'Enum':
																											var a = node.a;
																											return p3(a);
																										case 'Box':
																											return p4;
																										case 'Link':
																											var a = node.a;
																											return p5(a);
																										case 'Cycle':
																											var a = node.a;
																											var b = node.b;
																											var c = node.c;
																											var d = node.d;
																											return A4(p6, a, b, c, d);
																										case 'Manager':
																											var a = node.a;
																											return p7(a);
																										case 'Kernel':
																											var a = node.a;
																											var b = node.b;
																											return A2(p8, a, b);
																										case 'PortIncoming':
																											var a = node.a;
																											var b = node.b;
																											return A2(p9, a, b);
																										default:
																											var a = node.a;
																											var b = node.b;
																											return A2(p10, a, b);
																									}
																								};
																							};
																						};
																					};
																				};
																			};
																		};
																	};
																};
															};
														};
													})))))))))))));
var $author$project$Extra$Data$Binary$Put$put3 = F6(
	function (fa, fb, fc, a, b, c) {
		return $author$project$Extra$Data$Binary$Put$join(
			_List_fromArray(
				[
					fa(a),
					fb(b),
					fc(c)
				]));
	});
var $author$project$Extra$Data$Binary$bin3 = F5(
	function (ctor, dtor, binA, binB, binC) {
		return {
			get: A4($author$project$Extra$Data$Binary$Get$liftM3, ctor, binA.get, binB.get, binC.get),
			put: function (d) {
				var _v0 = dtor(d);
				var a = _v0.a;
				var b = _v0.b;
				var c = _v0.c;
				return A6($author$project$Extra$Data$Binary$Put$put3, binA.put, binB.put, binC.put, a, b, c);
			}
		};
	});
var $author$project$Compiler$AST$Optimized$bLocalGraph = A5(
	$author$project$Extra$Data$Binary$bin3,
	$author$project$Compiler$AST$Optimized$LocalGraph,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		return A3($author$project$Extra$Data$Binary$T3, a, b, c);
	},
	$author$project$Extra$Data$Binary$bMaybe($author$project$Compiler$AST$Optimized$bMain),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$AST$Optimized$bGlobalComparable, $author$project$Compiler$AST$Optimized$bNode),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Extra$Data$Binary$bWord64));
var $author$project$Compiler$Compile$Artifacts = F3(
	function (a, b, c) {
		return {$: 'Artifacts', a: a, b: b, c: c};
	});
var $author$project$Extra$Type$Either$bind = F2(
	function (ea, callback) {
		if (ea.$ === 'Left') {
			var x = ea.a;
			return $author$project$Extra$Type$Either$Left(x);
		} else {
			var a = ea.a;
			return callback(a);
		}
	});
var $author$project$Compiler$Reporting$Error$BadNames = function (a) {
	return {$: 'BadNames', a: a};
};
var $author$project$Compiler$AST$Canonical$Module = F7(
	function (a, b, c, d, e, f, g) {
		return {$: 'Module', a: a, b: b, c: c, d: d, e: e, f: f, g: g};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateCtor = F3(
	function (a, b, c) {
		return {$: 'DuplicateCtor', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Environment$Env = F8(
	function (a, b, c, d, e, f, g, h) {
		return {$: 'Env', a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h};
	});
var $author$project$Compiler$Reporting$Result$CResult = function (a) {
	return {$: 'CResult', a: a};
};
var $author$project$Compiler$Reporting$Result$Rbad = F3(
	function (a, b, c) {
		return {$: 'Rbad', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Result$bind = F2(
	function (_v0, callback) {
		var ka = _v0.a;
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (i, w) {
					var _v1 = A2(ka, i, w);
					if (_v1.$ === 'Rbad') {
						var i1 = _v1.a;
						var w1 = _v1.b;
						var e = _v1.c;
						return A3($author$project$Compiler$Reporting$Result$Rbad, i1, w1, e);
					} else {
						var i1 = _v1.a;
						var w1 = _v1.b;
						var a = _v1.c;
						var _v2 = callback(a);
						var kb = _v2.a;
						return A2(kb, i1, w1);
					}
				}));
	});
var $author$project$Compiler$Canonicalize$Environment$Specific = F2(
	function (a, b) {
		return {$: 'Specific', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$TupleLargerThanThree = function (a) {
	return {$: 'TupleLargerThanThree', a: a};
};
var $author$project$Compiler$Reporting$Result$Rgood = F3(
	function (a, b, c) {
		return {$: 'Rgood', a: a, b: b, c: c};
	});
var $author$project$Compiler$Data$OneOrMore$More = F2(
	function (a, b) {
		return {$: 'More', a: a, b: b};
	});
var $author$project$Compiler$Data$OneOrMore$more = $author$project$Compiler$Data$OneOrMore$More;
var $author$project$Compiler$Reporting$Result$andMap = F2(
	function (_v0, _v1) {
		var kv = _v0.a;
		var kf = _v1.a;
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (i, w) {
					var _v2 = A2(kf, i, w);
					if (_v2.$ === 'Rbad') {
						var i1 = _v2.a;
						var w1 = _v2.b;
						var e1 = _v2.c;
						var _v3 = A2(kv, i1, w1);
						if (_v3.$ === 'Rbad') {
							var i2 = _v3.a;
							var w2 = _v3.b;
							var e2 = _v3.c;
							return A3(
								$author$project$Compiler$Reporting$Result$Rbad,
								i2,
								w2,
								A2($author$project$Compiler$Data$OneOrMore$more, e1, e2));
						} else {
							var i2 = _v3.a;
							var w2 = _v3.b;
							return A3($author$project$Compiler$Reporting$Result$Rbad, i2, w2, e1);
						}
					} else {
						var i1 = _v2.a;
						var w1 = _v2.b;
						var func = _v2.c;
						var _v4 = A2(kv, i1, w1);
						if (_v4.$ === 'Rbad') {
							var i2 = _v4.a;
							var w2 = _v4.b;
							var e2 = _v4.c;
							return A3($author$project$Compiler$Reporting$Result$Rbad, i2, w2, e2);
						} else {
							var i2 = _v4.a;
							var w2 = _v4.b;
							var value = _v4.c;
							return A3(
								$author$project$Compiler$Reporting$Result$Rgood,
								i2,
								w2,
								func(value));
						}
					}
				}));
	});
var $author$project$Extra$Class$Monad$andThen = F3(
	function (pBind, f, ma) {
		return A2(pBind, ma, f);
	});
var $author$project$Compiler$Reporting$Result$andThen = $author$project$Extra$Class$Monad$andThen($author$project$Compiler$Reporting$Result$bind);
var $author$project$Compiler$Reporting$Error$Canonicalize$BadArity = F5(
	function (a, b, c, d, e) {
		return {$: 'BadArity', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$TypeArity = {$: 'TypeArity'};
var $author$project$Compiler$Reporting$Result$ok = function (a) {
	return $author$project$Compiler$Reporting$Result$CResult(
		F2(
			function (i, w) {
				return A3($author$project$Compiler$Reporting$Result$Rgood, i, w, a);
			}));
};
var $author$project$Compiler$Data$OneOrMore$One = function (a) {
	return {$: 'One', a: a};
};
var $author$project$Compiler$Data$OneOrMore$one = $author$project$Compiler$Data$OneOrMore$One;
var $author$project$Compiler$Reporting$Result$throw = function (e) {
	return $author$project$Compiler$Reporting$Result$CResult(
		F2(
			function (i, w) {
				return A3(
					$author$project$Compiler$Reporting$Result$Rbad,
					i,
					w,
					$author$project$Compiler$Data$OneOrMore$one(e));
			}));
};
var $author$project$Compiler$Canonicalize$Type$checkArity = F5(
	function (expected, region, name, args, answer) {
		var actual = $author$project$Extra$Type$List$length(args);
		return _Utils_eq(expected, actual) ? $author$project$Compiler$Reporting$Result$ok(answer) : $author$project$Compiler$Reporting$Result$throw(
			A5($author$project$Compiler$Reporting$Error$Canonicalize$BadArity, region, $author$project$Compiler$Reporting$Error$Canonicalize$TypeArity, name, expected, actual));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateField = F3(
	function (a, b, c) {
		return {$: 'DuplicateField', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$Info = F2(
	function (a, b) {
		return {$: 'Info', a: a, b: b};
	});
var $author$project$Extra$Type$Map$insertWith = F4(
	function (f, k, _new, m) {
		return A3(
			$elm$core$Dict$update,
			k,
			function (ma) {
				return $elm$core$Maybe$Just(
					function () {
						if (ma.$ === 'Just') {
							var old = ma.a;
							return A2(f, _new, old);
						} else {
							return _new;
						}
					}());
			},
			m);
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$addField = F2(
	function (_v0, dups) {
		var _v1 = _v0.a;
		var region = _v1.a;
		var name = _v1.b;
		var value = _v0.b;
		return A4(
			$author$project$Extra$Type$Map$insertWith,
			$author$project$Compiler$Data$OneOrMore$more,
			name,
			$author$project$Compiler$Data$OneOrMore$one(
				A2($author$project$Compiler$Canonicalize$Environment$Dups$Info, region, value)),
			dups);
	});
var $author$project$Compiler$Data$OneOrMore$getFirstOne = function (oneOrMore) {
	getFirstOne:
	while (true) {
		if (oneOrMore.$ === 'One') {
			var x = oneOrMore.a;
			return x;
		} else {
			var left = oneOrMore.a;
			var $temp$oneOrMore = left;
			oneOrMore = $temp$oneOrMore;
			continue getFirstOne;
		}
	}
};
var $author$project$Compiler$Data$OneOrMore$getFirstTwo = F2(
	function (left, right) {
		getFirstTwo:
		while (true) {
			if (left.$ === 'One') {
				var x = left.a;
				return _Utils_Tuple2(
					x,
					$author$project$Compiler$Data$OneOrMore$getFirstOne(right));
			} else {
				var lleft = left.a;
				var lright = left.b;
				var $temp$left = lleft,
					$temp$right = lright;
				left = $temp$left;
				right = $temp$right;
				continue getFirstTwo;
			}
		}
	});
var $author$project$Compiler$Reporting$Result$return = $author$project$Compiler$Reporting$Result$ok;
var $author$project$Compiler$Canonicalize$Environment$Dups$detectHelp = F3(
	function (toError, name, values) {
		if (values.$ === 'One') {
			var _v1 = values.a;
			var value = _v1.b;
			return $author$project$Compiler$Reporting$Result$return(value);
		} else {
			var left = values.a;
			var right = values.b;
			var _v2 = A2($author$project$Compiler$Data$OneOrMore$getFirstTwo, left, right);
			var _v3 = _v2.a;
			var r1 = _v3.a;
			var _v4 = _v2.b;
			var r2 = _v4.a;
			return $author$project$Compiler$Reporting$Result$throw(
				A3(toError, name, r1, r2));
		}
	});
var $author$project$Compiler$Reporting$Result$loopHelp = F4(
	function (callback, i, w, state) {
		loopHelp:
		while (true) {
			var _v0 = callback(state);
			var k = _v0.a;
			var _v1 = A2(k, i, w);
			if (_v1.$ === 'Rbad') {
				var i1 = _v1.a;
				var w1 = _v1.b;
				var e = _v1.c;
				return A3($author$project$Compiler$Reporting$Result$Rbad, i1, w1, e);
			} else {
				if (_v1.c.$ === 'Loop') {
					var i1 = _v1.a;
					var w1 = _v1.b;
					var newState = _v1.c.a;
					var $temp$callback = callback,
						$temp$i = i1,
						$temp$w = w1,
						$temp$state = newState;
					callback = $temp$callback;
					i = $temp$i;
					w = $temp$w;
					state = $temp$state;
					continue loopHelp;
				} else {
					var i1 = _v1.a;
					var w1 = _v1.b;
					var a = _v1.c.a;
					return A3($author$project$Compiler$Reporting$Result$Rgood, i1, w1, a);
				}
			}
		}
	});
var $author$project$Compiler$Reporting$Result$loop = F2(
	function (callback, state) {
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (i, w) {
					return A4($author$project$Compiler$Reporting$Result$loopHelp, callback, i, w, state);
				}));
	});
var $author$project$Compiler$Reporting$Result$Done = function (a) {
	return {$: 'Done', a: a};
};
var $author$project$Compiler$Reporting$Result$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $author$project$Compiler$Reporting$Result$fmap = F2(
	function (func, _v0) {
		var k = _v0.a;
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (i, w) {
					var _v1 = A2(k, i, w);
					if (_v1.$ === 'Rbad') {
						var i1 = _v1.a;
						var w1 = _v1.b;
						var e = _v1.c;
						return A3($author$project$Compiler$Reporting$Result$Rbad, i1, w1, e);
					} else {
						var i1 = _v1.a;
						var w1 = _v1.b;
						var value = _v1.c;
						return A3(
							$author$project$Compiler$Reporting$Result$Rgood,
							i1,
							w1,
							func(value));
					}
				}));
	});
var $author$project$Compiler$Reporting$Result$traverseWithKeyHelp = F2(
	function (callback, _v0) {
		var pairs = _v0.a;
		var result = _v0.b;
		if (!pairs.b) {
			return $author$project$Compiler$Reporting$Result$return(
				$author$project$Compiler$Reporting$Result$Done(result));
		} else {
			var _v2 = pairs.a;
			var k = _v2.a;
			var a = _v2.b;
			var rest = pairs.b;
			return A2(
				$author$project$Compiler$Reporting$Result$fmap,
				function (b) {
					return $author$project$Compiler$Reporting$Result$Loop(
						_Utils_Tuple2(
							rest,
							A3($author$project$Extra$Type$Map$insert, k, b, result)));
				},
				A2(callback, k, a));
		}
	});
var $author$project$Compiler$Reporting$Result$traverseWithKey = F2(
	function (callback, map) {
		return A2(
			$author$project$Compiler$Reporting$Result$loop,
			$author$project$Compiler$Reporting$Result$traverseWithKeyHelp(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$Map$toList(map),
				$author$project$Extra$Type$Map$empty));
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$detect = F2(
	function (toError, dict) {
		return A2(
			$author$project$Compiler$Reporting$Result$traverseWithKey,
			$author$project$Compiler$Canonicalize$Environment$Dups$detectHelp(toError),
			dict);
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$none = $author$project$Extra$Type$Map$empty;
var $author$project$Compiler$Canonicalize$Environment$Dups$checkFields = function (fields) {
	return A2(
		$author$project$Compiler$Canonicalize$Environment$Dups$detect,
		$author$project$Compiler$Reporting$Error$Canonicalize$DuplicateField,
		A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Canonicalize$Environment$Dups$addField, $author$project$Compiler$Canonicalize$Environment$Dups$none, fields));
};
var $author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousType = F5(
	function (a, b, c, d, e) {
		return {$: 'AmbiguousType', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$NotFoundType = F4(
	function (a, b, c, d) {
		return {$: 'NotFoundType', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$PossibleNames = F2(
	function (a, b) {
		return {$: 'PossibleNames', a: a, b: b};
	});
var $author$project$Extra$Type$Map$keysSet = function (m) {
	return A3(
		$author$project$Extra$Type$Map$foldrWithKey,
		F3(
			function (k, _v0, s) {
				return A2($author$project$Extra$Type$Set$insert, k, s);
			}),
		$author$project$Extra$Type$Set$empty,
		m);
};
var $author$project$Compiler$Canonicalize$Environment$toPossibleNames = F2(
	function (exposed, qualified) {
		return A2(
			$author$project$Compiler$Reporting$Error$Canonicalize$PossibleNames,
			$author$project$Extra$Type$Map$keysSet(exposed),
			A2($author$project$Extra$Type$Map$map, $author$project$Extra$Type$Map$keysSet, qualified));
	});
var $author$project$Compiler$Canonicalize$Environment$findType = F3(
	function (region, _v0, name) {
		var ts = _v0.c;
		var qts = _v0.g;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, name, ts);
		if (_v1.$ === 'Just') {
			if (_v1.a.$ === 'Specific') {
				var _v2 = _v1.a;
				var tipe = _v2.b;
				return $author$project$Compiler$Reporting$Result$ok(tipe);
			} else {
				var _v3 = _v1.a;
				var h = _v3.a;
				var hs = _v3.b;
				return $author$project$Compiler$Reporting$Result$throw(
					A5($author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousType, region, $elm$core$Maybe$Nothing, name, h, hs));
			}
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundType,
					region,
					$elm$core$Maybe$Nothing,
					name,
					A2($author$project$Compiler$Canonicalize$Environment$toPossibleNames, ts, qts)));
		}
	});
var $author$project$Compiler$Canonicalize$Environment$findTypeQual = F4(
	function (region, _v0, prefix, name) {
		var ts = _v0.c;
		var qts = _v0.g;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, prefix, qts);
		if (_v1.$ === 'Just') {
			var qualified = _v1.a;
			var _v2 = A2($author$project$Extra$Type$Map$lookup, name, qualified);
			if (_v2.$ === 'Just') {
				if (_v2.a.$ === 'Specific') {
					var _v3 = _v2.a;
					var tipe = _v3.b;
					return $author$project$Compiler$Reporting$Result$ok(tipe);
				} else {
					var _v4 = _v2.a;
					var h = _v4.a;
					var hs = _v4.b;
					return $author$project$Compiler$Reporting$Result$throw(
						A5(
							$author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousType,
							region,
							$elm$core$Maybe$Just(prefix),
							name,
							h,
							hs));
				}
			} else {
				return $author$project$Compiler$Reporting$Result$throw(
					A4(
						$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundType,
						region,
						$elm$core$Maybe$Just(prefix),
						name,
						A2($author$project$Compiler$Canonicalize$Environment$toPossibleNames, ts, qts)));
			}
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundType,
					region,
					$elm$core$Maybe$Just(prefix),
					name,
					A2($author$project$Compiler$Canonicalize$Environment$toPossibleNames, ts, qts)));
		}
	});
var $author$project$Compiler$Reporting$Result$pure = $author$project$Compiler$Reporting$Result$ok;
var $author$project$Extra$Type$List$range = $elm$core$List$range;
var $author$project$Compiler$Reporting$Result$sequenceAMapHelp = function (_v0) {
	var pairs = _v0.a;
	var result = _v0.b;
	if (!pairs.b) {
		return $author$project$Compiler$Reporting$Result$return(
			$author$project$Compiler$Reporting$Result$Done(result));
	} else {
		var _v2 = pairs.a;
		var k = _v2.a;
		var r = _v2.b;
		var rest = pairs.b;
		return A2(
			$author$project$Compiler$Reporting$Result$fmap,
			function (a) {
				return $author$project$Compiler$Reporting$Result$Loop(
					_Utils_Tuple2(
						rest,
						A3($author$project$Extra$Type$Map$insert, k, a, result)));
			},
			r);
	}
};
var $author$project$Compiler$Reporting$Result$sequenceAMap = function (map) {
	return A2(
		$author$project$Compiler$Reporting$Result$loop,
		$author$project$Compiler$Reporting$Result$sequenceAMapHelp,
		_Utils_Tuple2(
			$author$project$Extra$Type$Map$toList(map),
			$author$project$Extra$Type$Map$empty));
};
var $author$project$Compiler$Reporting$Annotation$toValue = function (_v0) {
	var value = _v0.b;
	return value;
};
var $author$project$Compiler$Reporting$Result$traverseListHelp = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return $author$project$Compiler$Reporting$Result$return(
				$author$project$Compiler$Reporting$Result$Done(
					$author$project$Extra$Type$List$reverse(result)));
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Compiler$Reporting$Result$fmap,
				function (b) {
					return $author$project$Compiler$Reporting$Result$Loop(
						_Utils_Tuple2(
							rest,
							A2($elm$core$List$cons, b, result)));
				},
				callback(a));
		}
	});
var $author$project$Compiler$Reporting$Result$traverseList = F2(
	function (callback, list) {
		return A2(
			$author$project$Compiler$Reporting$Result$loop,
			$author$project$Compiler$Reporting$Result$traverseListHelp(callback),
			_Utils_Tuple2(list, _List_Nil));
	});
var $author$project$Extra$Type$List$zipWith = $elm$core$List$map2;
var $author$project$Extra$Type$List$zip = F2(
	function (la, lb) {
		return A3($author$project$Extra$Type$List$zipWith, $elm$core$Tuple$pair, la, lb);
	});
var $author$project$Compiler$Canonicalize$Type$canonicalize = F2(
	function (env, _v2) {
		var typeRegion = _v2.a;
		var tipe = _v2.b;
		switch (tipe.$) {
			case 'TVar':
				var x = tipe.a;
				return $author$project$Compiler$Reporting$Result$ok(
					$author$project$Compiler$AST$Canonical$TVar(x));
			case 'TType':
				var region = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A2(
					$author$project$Compiler$Reporting$Result$andThen,
					A4($author$project$Compiler$Canonicalize$Type$canonicalizeType, env, typeRegion, name, args),
					A3($author$project$Compiler$Canonicalize$Environment$findType, region, env, name));
			case 'TTypeQual':
				var region = tipe.a;
				var home = tipe.b;
				var name = tipe.c;
				var args = tipe.d;
				return A2(
					$author$project$Compiler$Reporting$Result$andThen,
					A4($author$project$Compiler$Canonicalize$Type$canonicalizeType, env, typeRegion, name, args),
					A4($author$project$Compiler$Canonicalize$Environment$findTypeQual, region, env, home, name));
			case 'TLambda':
				var a = tipe.a;
				var b = tipe.b;
				return A2(
					$author$project$Compiler$Reporting$Result$andMap,
					A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, b),
					A2(
						$author$project$Compiler$Reporting$Result$andMap,
						A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, a),
						$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$TLambda)));
			case 'TRecord':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2(
						$author$project$Compiler$Reporting$Result$andThen,
						$author$project$Compiler$Reporting$Result$sequenceAMap,
						$author$project$Compiler$Canonicalize$Environment$Dups$checkFields(
							A2($author$project$Compiler$Canonicalize$Type$canonicalizeFields, env, fields))),
					function (cfields) {
						return $author$project$Compiler$Reporting$Result$return(
							A2(
								$author$project$Compiler$AST$Canonical$TRecord,
								cfields,
								A2($elm$core$Maybe$map, $author$project$Compiler$Reporting$Annotation$toValue, ext)));
					});
			case 'TUnit':
				return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$TUnit);
			default:
				var a = tipe.a;
				var b = tipe.b;
				var cs = tipe.c;
				return A2(
					$author$project$Compiler$Reporting$Result$andMap,
					function () {
						if (!cs.b) {
							return $author$project$Compiler$Reporting$Result$ok($elm$core$Maybe$Nothing);
						} else {
							if (!cs.b.b) {
								var c = cs.a;
								return A2(
									$author$project$Compiler$Reporting$Result$fmap,
									$elm$core$Maybe$Just,
									A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, c));
							} else {
								return $author$project$Compiler$Reporting$Result$throw(
									$author$project$Compiler$Reporting$Error$Canonicalize$TupleLargerThanThree(typeRegion));
							}
						}
					}(),
					A2(
						$author$project$Compiler$Reporting$Result$andMap,
						A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, b),
						A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, a),
							$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$TTuple))));
		}
	});
var $author$project$Compiler$Canonicalize$Type$canonicalizeFields = F2(
	function (env, fields) {
		var len = $author$project$Extra$Type$List$length(fields);
		var canonicalizeField = F2(
			function (index, _v1) {
				var name = _v1.a;
				var srcType = _v1.b;
				return _Utils_Tuple2(
					name,
					A2(
						$author$project$Compiler$Reporting$Result$fmap,
						$author$project$Compiler$AST$Canonical$FieldType(index),
						A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, srcType)));
			});
		return A3(
			$author$project$Extra$Type$List$zipWith,
			canonicalizeField,
			A2($author$project$Extra$Type$List$range, 0, len),
			fields);
	});
var $author$project$Compiler$Canonicalize$Type$canonicalizeType = F5(
	function (env, region, name, args, info) {
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2(
				$author$project$Compiler$Reporting$Result$traverseList,
				$author$project$Compiler$Canonicalize$Type$canonicalize(env),
				args),
			function (cargs) {
				if (info.$ === 'Alias') {
					var arity = info.a;
					var home = info.b;
					var argNames = info.c;
					var aliasedType = info.d;
					return A5(
						$author$project$Compiler$Canonicalize$Type$checkArity,
						arity,
						region,
						name,
						args,
						A4(
							$author$project$Compiler$AST$Canonical$TAlias,
							home,
							name,
							A2($author$project$Extra$Type$List$zip, argNames, cargs),
							$author$project$Compiler$AST$Canonical$Holey(aliasedType)));
				} else {
					var arity = info.a;
					var home = info.b;
					return A5(
						$author$project$Compiler$Canonicalize$Type$checkArity,
						arity,
						region,
						name,
						args,
						A3($author$project$Compiler$AST$Canonical$TType, home, name, cargs));
				}
			});
	});
var $elm$core$Dict$singleton = F2(
	function (key, value) {
		return A5($elm$core$Dict$RBNode_elm_builtin, $elm$core$Dict$Black, key, value, $elm$core$Dict$RBEmpty_elm_builtin, $elm$core$Dict$RBEmpty_elm_builtin);
	});
var $author$project$Extra$Type$Map$singleton = $elm$core$Dict$singleton;
var $author$project$Compiler$Canonicalize$Environment$Dups$one = F3(
	function (name, region, value) {
		return A2(
			$author$project$Extra$Type$Map$singleton,
			name,
			$author$project$Compiler$Data$OneOrMore$one(
				A2($author$project$Compiler$Canonicalize$Environment$Dups$Info, region, value)));
	});
var $author$project$Compiler$Canonicalize$Environment$RecordCtor = F3(
	function (a, b, c) {
		return {$: 'RecordCtor', a: a, b: b, c: c};
	});
var $elm$core$List$sortBy = _List_sortBy;
var $author$project$Extra$Type$List$sortOn = $elm$core$List$sortBy;
var $author$project$Compiler$AST$Canonical$fieldsToList = function (fields) {
	var getIndex = function (_v2) {
		var _v3 = _v2.b;
		var index = _v3.a;
		return index;
	};
	var dropIndex = function (_v0) {
		var name = _v0.a;
		var _v1 = _v0.b;
		var tipe = _v1.b;
		return _Utils_Tuple2(name, tipe);
	};
	return A2(
		$author$project$Extra$Type$List$map,
		dropIndex,
		A2(
			$author$project$Extra$Type$List$sortOn,
			getIndex,
			$author$project$Extra$Type$Map$toList(fields)));
};
var $author$project$Compiler$Canonicalize$Environment$Local$toRecordCtor = F4(
	function (home, name, vars, fields) {
		var avars = A2(
			$author$project$Extra$Type$List$map,
			function (_var) {
				return _Utils_Tuple2(
					_var,
					$author$project$Compiler$AST$Canonical$TVar(_var));
			},
			vars);
		var alias_ = A3(
			$author$project$Extra$Type$List$foldr,
			F2(
				function (_v0, t2) {
					var t1 = _v0.b;
					return A2($author$project$Compiler$AST$Canonical$TLambda, t1, t2);
				}),
			A4(
				$author$project$Compiler$AST$Canonical$TAlias,
				home,
				name,
				avars,
				$author$project$Compiler$AST$Canonical$Filled(
					A2($author$project$Compiler$AST$Canonical$TRecord, fields, $elm$core$Maybe$Nothing))),
			$author$project$Compiler$AST$Canonical$fieldsToList(fields));
		return A3($author$project$Compiler$Canonicalize$Environment$RecordCtor, home, vars, alias_);
	});
var $author$project$Compiler$Canonicalize$Environment$Local$canonicalizeAlias = F2(
	function (env, _v0) {
		var home = env.a;
		var _v1 = _v0.b;
		var _v2 = _v1.a;
		var region = _v2.a;
		var name = _v2.b;
		var args = _v1.b;
		var tipe = _v1.c;
		var vars = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, args);
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, tipe),
			function (ctipe) {
				return $author$project$Compiler$Reporting$Result$ok(
					_Utils_Tuple2(
						_Utils_Tuple2(
							name,
							A2($author$project$Compiler$AST$Canonical$Alias, vars, ctipe)),
						function () {
							if ((ctipe.$ === 'TRecord') && (ctipe.b.$ === 'Nothing')) {
								var fields = ctipe.a;
								var _v4 = ctipe.b;
								return A3(
									$author$project$Compiler$Canonicalize$Environment$Dups$one,
									name,
									region,
									A2(
										$author$project$Compiler$Canonicalize$Environment$Specific,
										home,
										A4($author$project$Compiler$Canonicalize$Environment$Local$toRecordCtor, home, name, vars, fields)));
							} else {
								return $author$project$Compiler$Canonicalize$Environment$Dups$none;
							}
						}()));
			});
	});
var $author$project$Compiler$Canonicalize$Environment$Local$canonicalizeCtor = F3(
	function (env, index, _v0) {
		var _v1 = _v0.a;
		var region = _v1.a;
		var ctor = _v1.b;
		var tipes = _v0.b;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2(
				$author$project$Compiler$Reporting$Result$traverseList,
				$author$project$Compiler$Canonicalize$Type$canonicalize(env),
				tipes),
			function (ctipes) {
				return $author$project$Compiler$Reporting$Result$ok(
					A2(
						$author$project$Compiler$Reporting$Annotation$At,
						region,
						A4(
							$author$project$Compiler$AST$Canonical$Ctor,
							ctor,
							index,
							$author$project$Extra$Type$List$length(ctipes),
							ctipes)));
			});
	});
var $author$project$Compiler$Data$Index$indexedMap = F2(
	function (func, xs) {
		return A3(
			$author$project$Extra$Type$List$zipWith,
			func,
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Data$Index$ZeroBased,
				A2(
					$author$project$Extra$Type$List$range,
					0,
					$author$project$Extra$Type$List$length(xs))),
			xs);
	});
var $author$project$Compiler$Data$Index$indexedTraverse = F4(
	function (pPure, pLiftA2, func, xs) {
		return A3(
			$author$project$Extra$Type$List$sequenceA,
			pPure,
			pLiftA2,
			A2($author$project$Compiler$Data$Index$indexedMap, func, xs));
	});
var $author$project$Extra$Class$Applicative$liftA2 = F5(
	function (pFmap, pAndMap, func, fa, fb) {
		return A2(
			pAndMap,
			fb,
			A2(pFmap, func, fa));
	});
var $author$project$Compiler$Reporting$Result$liftA2 = A2($author$project$Extra$Class$Applicative$liftA2, $author$project$Compiler$Reporting$Result$fmap, $author$project$Compiler$Reporting$Result$andMap);
var $author$project$Compiler$Canonicalize$Environment$Ctor = F5(
	function (a, b, c, d, e) {
		return {$: 'Ctor', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Canonicalize$Environment$Local$toCtor = F4(
	function (home, typeName, union, _v0) {
		var region = _v0.a;
		var _v1 = _v0.b;
		var name = _v1.a;
		var index = _v1.b;
		var args = _v1.d;
		return A3(
			$author$project$Compiler$Canonicalize$Environment$Dups$one,
			name,
			region,
			A2(
				$author$project$Compiler$Canonicalize$Environment$Specific,
				home,
				A5($author$project$Compiler$Canonicalize$Environment$Ctor, home, typeName, union, index, args)));
	});
var $elm$core$List$all = F2(
	function (isOkay, list) {
		return !A2(
			$elm$core$List$any,
			A2($elm$core$Basics$composeL, $elm$core$Basics$not, isOkay),
			list);
	});
var $author$project$Extra$Type$List$all = $elm$core$List$all;
var $author$project$Compiler$Canonicalize$Environment$Local$toOpts = function (ctors) {
	if (((ctors.b && ctors.a.b.b) && (!ctors.a.b.b.b)) && (!ctors.b.b)) {
		var _v1 = ctors.a;
		var _v2 = _v1.b;
		return $author$project$Compiler$AST$Canonical$Unbox;
	} else {
		return A2(
			$author$project$Extra$Type$List$all,
			A2($elm$core$Basics$composeL, $author$project$Extra$Type$List$null, $elm$core$Tuple$second),
			ctors) ? $author$project$Compiler$AST$Canonical$Enum : $author$project$Compiler$AST$Canonical$Normal;
	}
};
var $elm$core$Dict$merge = F6(
	function (leftStep, bothStep, rightStep, leftDict, rightDict, initialResult) {
		var stepState = F3(
			function (rKey, rValue, _v0) {
				stepState:
				while (true) {
					var list = _v0.a;
					var result = _v0.b;
					if (!list.b) {
						return _Utils_Tuple2(
							list,
							A3(rightStep, rKey, rValue, result));
					} else {
						var _v2 = list.a;
						var lKey = _v2.a;
						var lValue = _v2.b;
						var rest = list.b;
						if (_Utils_cmp(lKey, rKey) < 0) {
							var $temp$rKey = rKey,
								$temp$rValue = rValue,
								$temp$_v0 = _Utils_Tuple2(
								rest,
								A3(leftStep, lKey, lValue, result));
							rKey = $temp$rKey;
							rValue = $temp$rValue;
							_v0 = $temp$_v0;
							continue stepState;
						} else {
							if (_Utils_cmp(lKey, rKey) > 0) {
								return _Utils_Tuple2(
									list,
									A3(rightStep, rKey, rValue, result));
							} else {
								return _Utils_Tuple2(
									rest,
									A4(bothStep, lKey, lValue, rValue, result));
							}
						}
					}
				}
			});
		var _v3 = A3(
			$elm$core$Dict$foldl,
			stepState,
			_Utils_Tuple2(
				$elm$core$Dict$toList(leftDict),
				initialResult),
			rightDict);
		var leftovers = _v3.a;
		var intermediateResult = _v3.b;
		return A3(
			$elm$core$List$foldl,
			F2(
				function (_v4, result) {
					var k = _v4.a;
					var v = _v4.b;
					return A3(leftStep, k, v, result);
				}),
			intermediateResult,
			leftovers);
	});
var $author$project$Extra$Type$Map$unionWith = F3(
	function (f, m1, m2) {
		return A6(
			$elm$core$Dict$merge,
			F2(
				function (k, a1) {
					return A2($author$project$Extra$Type$Map$insert, k, a1);
				}),
			F3(
				function (key, a1, a2) {
					return A2(
						$author$project$Extra$Type$Map$insert,
						key,
						A2(f, a1, a2));
				}),
			F2(
				function (key, a2) {
					return A2($author$project$Extra$Type$Map$insert, key, a2);
				}),
			m1,
			m2,
			$author$project$Extra$Type$Map$empty);
	});
var $author$project$Extra$Type$Map$unionsWith = F3(
	function (pFoldl, f, t) {
		return A3(
			pFoldl,
			$author$project$Extra$Type$Map$unionWith(f),
			$author$project$Extra$Type$Map$empty,
			t);
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$unions = function (dicts) {
	return A3($author$project$Extra$Type$Map$unionsWith, $author$project$Extra$Type$List$foldl, $author$project$Compiler$Data$OneOrMore$more, dicts);
};
var $author$project$Compiler$Canonicalize$Environment$Local$canonicalizeUnion = F2(
	function (env, _v0) {
		var home = env.a;
		var _v1 = _v0.b;
		var _v2 = _v1.a;
		var name = _v2.b;
		var avars = _v1.b;
		var ctors = _v1.c;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A4(
				$author$project$Compiler$Data$Index$indexedTraverse,
				$author$project$Compiler$Reporting$Result$pure,
				$author$project$Compiler$Reporting$Result$liftA2,
				$author$project$Compiler$Canonicalize$Environment$Local$canonicalizeCtor(env),
				ctors),
			function (cctors) {
				var vars = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, avars);
				var alts = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, cctors);
				var union = A4(
					$author$project$Compiler$AST$Canonical$Union,
					vars,
					alts,
					$author$project$Extra$Type$List$length(alts),
					$author$project$Compiler$Canonicalize$Environment$Local$toOpts(ctors));
				return $author$project$Compiler$Reporting$Result$ok(
					_Utils_Tuple2(
						_Utils_Tuple2(name, union),
						$author$project$Compiler$Canonicalize$Environment$Dups$unions(
							A2(
								$author$project$Extra$Type$List$map,
								A3($author$project$Compiler$Canonicalize$Environment$Local$toCtor, home, name, union),
								cctors))));
			});
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$union = F2(
	function (a, b) {
		return A3($author$project$Extra$Type$Map$unionWith, $author$project$Compiler$Data$OneOrMore$more, a, b);
	});
var $author$project$Compiler$Canonicalize$Environment$Local$addCtors = F2(
	function (_v0, env) {
		var unions = _v0.e;
		var aliases = _v0.f;
		var home = env.a;
		var vs = env.b;
		var ts = env.c;
		var cs = env.d;
		var bs = env.e;
		var qvs = env.f;
		var qts = env.g;
		var qcs = env.h;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2(
				$author$project$Compiler$Reporting$Result$traverseList,
				$author$project$Compiler$Canonicalize$Environment$Local$canonicalizeUnion(env),
				unions),
			function (unionInfo) {
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2(
						$author$project$Compiler$Reporting$Result$traverseList,
						$author$project$Compiler$Canonicalize$Environment$Local$canonicalizeAlias(env),
						aliases),
					function (aliasInfo) {
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							A2(
								$author$project$Compiler$Canonicalize$Environment$Dups$detect,
								$author$project$Compiler$Reporting$Error$Canonicalize$DuplicateCtor,
								A2(
									$author$project$Compiler$Canonicalize$Environment$Dups$union,
									$author$project$Compiler$Canonicalize$Environment$Dups$unions(
										A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, unionInfo)),
									$author$project$Compiler$Canonicalize$Environment$Dups$unions(
										A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, aliasInfo)))),
							function (ctors) {
								var cs2 = A2($author$project$Extra$Type$Map$union, ctors, cs);
								return $author$project$Compiler$Reporting$Result$ok(
									_Utils_Tuple3(
										A8($author$project$Compiler$Canonicalize$Environment$Env, home, vs, ts, cs2, bs, qvs, qts, qcs),
										$author$project$Extra$Type$Map$fromList(
											A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, unionInfo)),
										$author$project$Extra$Type$Map$fromList(
											A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, aliasInfo))));
							});
					});
			});
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateType = F3(
	function (a, b, c) {
		return {$: 'DuplicateType', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Environment$Alias = F4(
	function (a, b, c, d) {
		return {$: 'Alias', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$RecursiveAlias = F5(
	function (a, b, c, d, e) {
		return {$: 'RecursiveAlias', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateAliasArg = F4(
	function (a, b, c, d) {
		return {$: 'DuplicateAliasArg', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$TypeVarsMessedUpInAlias = F5(
	function (a, b, c, d, e) {
		return {$: 'TypeVarsMessedUpInAlias', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Canonicalize$Environment$Local$addFreeVars = F2(
	function (freeVars, _v0) {
		addFreeVars:
		while (true) {
			var region = _v0.a;
			var tipe = _v0.b;
			switch (tipe.$) {
				case 'TLambda':
					var arg = tipe.a;
					var result = tipe.b;
					var $temp$freeVars = A2($author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, freeVars, arg),
						$temp$_v0 = result;
					freeVars = $temp$freeVars;
					_v0 = $temp$_v0;
					continue addFreeVars;
				case 'TVar':
					var name = tipe.a;
					return A3($author$project$Extra$Type$Map$insert, name, region, freeVars);
				case 'TType':
					var args = tipe.c;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, freeVars, args);
				case 'TTypeQual':
					var args = tipe.d;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, freeVars, args);
				case 'TRecord':
					var fields = tipe.a;
					var maybeExt = tipe.b;
					var extFreeVars = function () {
						if (maybeExt.$ === 'Nothing') {
							return freeVars;
						} else {
							var _v4 = maybeExt.a;
							var extRegion = _v4.a;
							var ext = _v4.b;
							return A3($author$project$Extra$Type$Map$insert, ext, extRegion, freeVars);
						}
					}();
					return A3(
						$author$project$Extra$Type$List$foldl,
						F2(
							function (fvs, _v2) {
								var t = _v2.b;
								return A2($author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, fvs, t);
							}),
						extFreeVars,
						fields);
				case 'TUnit':
					return freeVars;
				default:
					var a = tipe.a;
					var b = tipe.b;
					var cs = tipe.c;
					return A3(
						$author$project$Extra$Type$List$foldl,
						$author$project$Compiler$Canonicalize$Environment$Local$addFreeVars,
						A2(
							$author$project$Compiler$Canonicalize$Environment$Local$addFreeVars,
							A2($author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, freeVars, a),
							b),
						cs);
			}
		}
	});
var $elm$core$Dict$diff = F2(
	function (t1, t2) {
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (k, v, t) {
					return A2($elm$core$Dict$remove, k, t);
				}),
			t1,
			t2);
	});
var $author$project$Extra$Type$Map$difference = $elm$core$Dict$diff;
var $author$project$Compiler$Canonicalize$Environment$Dups$insert = F4(
	function (name, region, value, dict) {
		return A4(
			$author$project$Extra$Type$Map$insertWith,
			F2(
				function (_new, old) {
					return A2($author$project$Compiler$Data$OneOrMore$more, old, _new);
				}),
			name,
			$author$project$Compiler$Data$OneOrMore$one(
				A2($author$project$Compiler$Canonicalize$Environment$Dups$Info, region, value)),
			dict);
	});
var $author$project$Extra$Type$Map$intersectionWithKey = F3(
	function (f, m1, m2) {
		return A6(
			$elm$core$Dict$merge,
			F3(
				function (_v0, _v1, m) {
					return m;
				}),
			F3(
				function (k, a1, a2) {
					return A2(
						$author$project$Extra$Type$Map$insert,
						k,
						A3(f, k, a1, a2));
				}),
			F3(
				function (_v2, _v3, m) {
					return m;
				}),
			m1,
			m2,
			$author$project$Extra$Type$Map$empty);
	});
var $author$project$Extra$Type$Map$intersectionWith = F3(
	function (f, m1, m2) {
		return A3(
			$author$project$Extra$Type$Map$intersectionWithKey,
			function (_v0) {
				return f;
			},
			m1,
			m2);
	});
var $author$project$Extra$Type$Map$intersection = $author$project$Extra$Type$Map$intersectionWith(
	F2(
		function (a, _v0) {
			return a;
		}));
var $elm$core$Dict$sizeHelp = F2(
	function (n, dict) {
		sizeHelp:
		while (true) {
			if (dict.$ === 'RBEmpty_elm_builtin') {
				return n;
			} else {
				var left = dict.d;
				var right = dict.e;
				var $temp$n = A2($elm$core$Dict$sizeHelp, n + 1, right),
					$temp$dict = left;
				n = $temp$n;
				dict = $temp$dict;
				continue sizeHelp;
			}
		}
	});
var $elm$core$Dict$size = function (dict) {
	return A2($elm$core$Dict$sizeHelp, 0, dict);
};
var $author$project$Extra$Type$Map$size = $elm$core$Dict$size;
var $author$project$Compiler$Canonicalize$Environment$Local$checkAliasFreeVars = function (_v0) {
	var aliasRegion = _v0.a;
	var _v1 = _v0.b;
	var _v2 = _v1.a;
	var name = _v2.b;
	var args = _v1.b;
	var tipe = _v1.c;
	var addArg = F2(
		function (_v3, dict) {
			var region = _v3.a;
			var arg = _v3.b;
			return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, arg, region, region, dict);
		});
	return A2(
		$author$project$Compiler$Reporting$Result$bind,
		A2(
			$author$project$Compiler$Canonicalize$Environment$Dups$detect,
			$author$project$Compiler$Reporting$Error$Canonicalize$DuplicateAliasArg(name),
			A3($author$project$Extra$Type$List$foldr, addArg, $author$project$Compiler$Canonicalize$Environment$Dups$none, args)),
		function (boundVars) {
			var freeVars = A2($author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, $author$project$Extra$Type$Map$empty, tipe);
			var overlap = $author$project$Extra$Type$Map$size(
				A2($author$project$Extra$Type$Map$intersection, boundVars, freeVars));
			return (_Utils_eq(
				$author$project$Extra$Type$Map$size(boundVars),
				overlap) && _Utils_eq(
				$author$project$Extra$Type$Map$size(freeVars),
				overlap)) ? $author$project$Compiler$Reporting$Result$ok(
				A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, args)) : $author$project$Compiler$Reporting$Result$throw(
				A5(
					$author$project$Compiler$Reporting$Error$Canonicalize$TypeVarsMessedUpInAlias,
					aliasRegion,
					name,
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, args),
					$author$project$Extra$Type$Map$toList(
						A2($author$project$Extra$Type$Map$difference, boundVars, freeVars)),
					$author$project$Extra$Type$Map$toList(
						A2($author$project$Extra$Type$Map$difference, freeVars, boundVars))));
		});
};
var $author$project$Compiler$Canonicalize$Environment$Local$addAlias = F2(
	function (env, scc) {
		var home = env.a;
		var vs = env.b;
		var ts = env.c;
		var cs = env.d;
		var bs = env.e;
		var qvs = env.f;
		var qts = env.g;
		var qcs = env.h;
		if (scc.$ === 'AcyclicSCC') {
			var alias = scc.a;
			var _v1 = alias.b;
			var _v2 = _v1.a;
			var name = _v2.b;
			var tipe = _v1.c;
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				$author$project$Compiler$Canonicalize$Environment$Local$checkAliasFreeVars(alias),
				function (args) {
					return A2(
						$author$project$Compiler$Reporting$Result$bind,
						A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, tipe),
						function (ctype) {
							var one = A2(
								$author$project$Compiler$Canonicalize$Environment$Specific,
								home,
								A4(
									$author$project$Compiler$Canonicalize$Environment$Alias,
									$author$project$Extra$Type$List$length(args),
									home,
									args,
									ctype));
							var ts1 = A3($author$project$Extra$Type$Map$insert, name, one, ts);
							return $author$project$Compiler$Reporting$Result$ok(
								A8($author$project$Compiler$Canonicalize$Environment$Env, home, vs, ts1, cs, bs, qvs, qts, qcs));
						});
				});
		} else {
			if (!scc.a.b) {
				return $author$project$Compiler$Reporting$Result$ok(env);
			} else {
				var _v3 = scc.a;
				var alias = _v3.a;
				var _v4 = alias.b;
				var _v5 = _v4.a;
				var region = _v5.a;
				var name1 = _v5.b;
				var tipe = _v4.c;
				var others = _v3.b;
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					$author$project$Compiler$Canonicalize$Environment$Local$checkAliasFreeVars(alias),
					function (args) {
						var toName = function (_v6) {
							var _v7 = _v6.b;
							var _v8 = _v7.a;
							var name = _v8.b;
							return name;
						};
						return $author$project$Compiler$Reporting$Result$throw(
							A5(
								$author$project$Compiler$Reporting$Error$Canonicalize$RecursiveAlias,
								region,
								name1,
								args,
								tipe,
								A2($author$project$Extra$Type$List$map, toName, others)));
					});
			}
		}
	});
var $author$project$Compiler$Reporting$Result$foldMHelp = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return $author$project$Compiler$Reporting$Result$return(
				$author$project$Compiler$Reporting$Result$Done(result));
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Compiler$Reporting$Result$fmap,
				function (b) {
					return $author$project$Compiler$Reporting$Result$Loop(
						_Utils_Tuple2(rest, b));
				},
				A2(callback, result, a));
		}
	});
var $author$project$Compiler$Reporting$Result$foldM = F3(
	function (callback, zero, list) {
		return A2(
			$author$project$Compiler$Reporting$Result$loop,
			$author$project$Compiler$Reporting$Result$foldMHelp(callback),
			_Utils_Tuple2(list, zero));
	});
var $author$project$Compiler$Canonicalize$Environment$Local$getEdges = F2(
	function (edges, _v0) {
		getEdges:
		while (true) {
			var tipe = _v0.b;
			switch (tipe.$) {
				case 'TLambda':
					var arg = tipe.a;
					var result = tipe.b;
					var $temp$edges = A2($author$project$Compiler$Canonicalize$Environment$Local$getEdges, edges, arg),
						$temp$_v0 = result;
					edges = $temp$edges;
					_v0 = $temp$_v0;
					continue getEdges;
				case 'TVar':
					return edges;
				case 'TType':
					var name = tipe.b;
					var args = tipe.c;
					return A3(
						$author$project$Extra$Type$List$foldl,
						$author$project$Compiler$Canonicalize$Environment$Local$getEdges,
						A2($elm$core$List$cons, name, edges),
						args);
				case 'TTypeQual':
					var args = tipe.d;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Environment$Local$getEdges, edges, args);
				case 'TRecord':
					var fields = tipe.a;
					return A3(
						$author$project$Extra$Type$List$foldl,
						F2(
							function (es, _v2) {
								var t = _v2.b;
								return A2($author$project$Compiler$Canonicalize$Environment$Local$getEdges, es, t);
							}),
						edges,
						fields);
				case 'TUnit':
					return edges;
				default:
					var a = tipe.a;
					var b = tipe.b;
					var cs = tipe.c;
					return A3(
						$author$project$Extra$Type$List$foldl,
						$author$project$Compiler$Canonicalize$Environment$Local$getEdges,
						A2(
							$author$project$Compiler$Canonicalize$Environment$Local$getEdges,
							A2($author$project$Compiler$Canonicalize$Environment$Local$getEdges, edges, a),
							b),
						cs);
			}
		}
	});
var $author$project$Compiler$Canonicalize$Environment$Local$toNode = function (alias) {
	var _v0 = alias.b;
	var _v1 = _v0.a;
	var name = _v1.b;
	var tipe = _v0.c;
	return _Utils_Tuple3(
		alias,
		name,
		A2($author$project$Compiler$Canonicalize$Environment$Local$getEdges, _List_Nil, tipe));
};
var $author$project$Compiler$Canonicalize$Environment$Local$addAliases = F2(
	function (aliases, env) {
		var nodes = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Canonicalize$Environment$Local$toNode, aliases);
		var sccs = $author$project$Extra$Data$Graph$stronglyConnComp(nodes);
		return A3($author$project$Compiler$Reporting$Result$foldM, $author$project$Compiler$Canonicalize$Environment$Local$addAlias, env, sccs);
	});
var $author$project$Compiler$Canonicalize$Environment$Union = F2(
	function (a, b) {
		return {$: 'Union', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateUnionArg = F4(
	function (a, b, c, d) {
		return {$: 'DuplicateUnionArg', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$TypeVarsUnboundInUnion = F5(
	function (a, b, c, d, e) {
		return {$: 'TypeVarsUnboundInUnion', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Canonicalize$Environment$Local$checkUnionFreeVars = function (_v0) {
	var unionRegion = _v0.a;
	var _v1 = _v0.b;
	var _v2 = _v1.a;
	var name = _v2.b;
	var args = _v1.b;
	var ctors = _v1.c;
	var addCtorFreeVars = F2(
		function (_v5, freeVars) {
			var tipes = _v5.b;
			return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Environment$Local$addFreeVars, freeVars, tipes);
		});
	var addArg = F2(
		function (_v4, dict) {
			var region = _v4.a;
			var arg = _v4.b;
			return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, arg, region, region, dict);
		});
	return A2(
		$author$project$Compiler$Reporting$Result$bind,
		A2(
			$author$project$Compiler$Canonicalize$Environment$Dups$detect,
			$author$project$Compiler$Reporting$Error$Canonicalize$DuplicateUnionArg(name),
			A3($author$project$Extra$Type$List$foldr, addArg, $author$project$Compiler$Canonicalize$Environment$Dups$none, args)),
		function (boundVars) {
			var freeVars = A3($author$project$Extra$Type$List$foldr, addCtorFreeVars, $author$project$Extra$Type$Map$empty, ctors);
			var _v3 = $author$project$Extra$Type$Map$toList(
				A2($author$project$Extra$Type$Map$difference, freeVars, boundVars));
			if (!_v3.b) {
				return $author$project$Compiler$Reporting$Result$ok(
					$author$project$Extra$Type$List$length(args));
			} else {
				var unbound = _v3.a;
				var unbounds = _v3.b;
				return $author$project$Compiler$Reporting$Result$throw(
					A5(
						$author$project$Compiler$Reporting$Error$Canonicalize$TypeVarsUnboundInUnion,
						unionRegion,
						name,
						A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, args),
						unbound,
						unbounds));
			}
		});
};
var $author$project$Compiler$Canonicalize$Environment$Local$addUnion = F3(
	function (home, types, union) {
		var _v0 = union.b;
		var _v1 = _v0.a;
		var name = _v1.b;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			$author$project$Compiler$Canonicalize$Environment$Local$checkUnionFreeVars(union),
			function (arity) {
				var one = A2(
					$author$project$Compiler$Canonicalize$Environment$Specific,
					home,
					A2($author$project$Compiler$Canonicalize$Environment$Union, arity, home));
				return $author$project$Compiler$Reporting$Result$ok(
					A3($author$project$Extra$Type$Map$insert, name, one, types));
			});
	});
var $author$project$Compiler$Canonicalize$Environment$Local$addTypes = F2(
	function (_v0, _v1) {
		var unions = _v0.e;
		var aliases = _v0.f;
		var home = _v1.a;
		var vs = _v1.b;
		var ts = _v1.c;
		var cs = _v1.d;
		var bs = _v1.e;
		var qvs = _v1.f;
		var qts = _v1.g;
		var qcs = _v1.h;
		var addUnionDups = F2(
			function (dups, _v6) {
				var _v7 = _v6.b;
				var _v8 = _v7.a;
				var region = _v8.a;
				var name = _v8.b;
				return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, region, _Utils_Tuple0, dups);
			});
		var addAliasDups = F2(
			function (dups, _v3) {
				var _v4 = _v3.b;
				var _v5 = _v4.a;
				var region = _v5.a;
				var name = _v5.b;
				return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, region, _Utils_Tuple0, dups);
			});
		var typeNameDups = A3(
			$author$project$Extra$Type$List$foldl,
			addUnionDups,
			A3($author$project$Extra$Type$List$foldl, addAliasDups, $author$project$Compiler$Canonicalize$Environment$Dups$none, aliases),
			unions);
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2($author$project$Compiler$Canonicalize$Environment$Dups$detect, $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateType, typeNameDups),
			function (_v2) {
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A3(
						$author$project$Compiler$Reporting$Result$foldM,
						$author$project$Compiler$Canonicalize$Environment$Local$addUnion(home),
						ts,
						unions),
					function (ts1) {
						return A2(
							$author$project$Compiler$Canonicalize$Environment$Local$addAliases,
							aliases,
							A8($author$project$Compiler$Canonicalize$Environment$Env, home, vs, ts1, cs, bs, qvs, qts, qcs));
					});
			});
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicateDecl = F3(
	function (a, b, c) {
		return {$: 'DuplicateDecl', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Environment$TopLevel = function (a) {
	return {$: 'TopLevel', a: a};
};
var $author$project$Compiler$Canonicalize$Environment$Local$toEffectDups = function (effects) {
	switch (effects.$) {
		case 'NoEffects':
			return $author$project$Compiler$Canonicalize$Environment$Dups$none;
		case 'Ports':
			var ports = effects.a;
			var addPort = F2(
				function (dict, _v1) {
					var _v2 = _v1.a;
					var region = _v2.a;
					var name = _v2.b;
					return A4(
						$author$project$Compiler$Canonicalize$Environment$Dups$insert,
						name,
						region,
						$author$project$Compiler$Canonicalize$Environment$TopLevel(region),
						dict);
				});
			return A3($author$project$Extra$Type$List$foldl, addPort, $author$project$Compiler$Canonicalize$Environment$Dups$none, ports);
		default:
			var manager = effects.b;
			switch (manager.$) {
				case 'CCmd':
					var _v4 = manager.a;
					var region = _v4.a;
					return A3(
						$author$project$Compiler$Canonicalize$Environment$Dups$one,
						'command',
						region,
						$author$project$Compiler$Canonicalize$Environment$TopLevel(region));
				case 'CSub':
					var _v5 = manager.a;
					var region = _v5.a;
					return A3(
						$author$project$Compiler$Canonicalize$Environment$Dups$one,
						'subscription',
						region,
						$author$project$Compiler$Canonicalize$Environment$TopLevel(region));
				default:
					var _v6 = manager.a;
					var regionCmd = _v6.a;
					var _v7 = manager.b;
					var regionSub = _v7.a;
					return A2(
						$author$project$Compiler$Canonicalize$Environment$Dups$union,
						A3(
							$author$project$Compiler$Canonicalize$Environment$Dups$one,
							'command',
							regionCmd,
							$author$project$Compiler$Canonicalize$Environment$TopLevel(regionCmd)),
						A3(
							$author$project$Compiler$Canonicalize$Environment$Dups$one,
							'subscription',
							regionSub,
							$author$project$Compiler$Canonicalize$Environment$TopLevel(regionSub)));
			}
	}
};
var $author$project$Compiler$Canonicalize$Environment$Local$collectVars = function (_v0) {
	var values = _v0.d;
	var effects = _v0.h;
	var addDecl = F2(
		function (dict, _v1) {
			var _v2 = _v1.b;
			var _v3 = _v2.a;
			var region = _v3.a;
			var name = _v3.b;
			return A4(
				$author$project$Compiler$Canonicalize$Environment$Dups$insert,
				name,
				region,
				$author$project$Compiler$Canonicalize$Environment$TopLevel(region),
				dict);
		});
	return A2(
		$author$project$Compiler$Canonicalize$Environment$Dups$detect,
		$author$project$Compiler$Reporting$Error$Canonicalize$DuplicateDecl,
		A3(
			$author$project$Extra$Type$List$foldl,
			addDecl,
			$author$project$Compiler$Canonicalize$Environment$Local$toEffectDups(effects),
			values));
};
var $author$project$Compiler$Canonicalize$Environment$Local$addVars = F2(
	function (module_, _v0) {
		var home = _v0.a;
		var vs = _v0.b;
		var ts = _v0.c;
		var cs = _v0.d;
		var bs = _v0.e;
		var qvs = _v0.f;
		var qts = _v0.g;
		var qcs = _v0.h;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			$author$project$Compiler$Canonicalize$Environment$Local$collectVars(module_),
			function (topLevelVars) {
				var vs2 = A2($author$project$Extra$Type$Map$union, topLevelVars, vs);
				return $author$project$Compiler$Reporting$Result$ok(
					A8($author$project$Compiler$Canonicalize$Environment$Env, home, vs2, ts, cs, bs, qvs, qts, qcs));
			});
	});
var $author$project$Compiler$Canonicalize$Environment$Local$add = F2(
	function (module_, env) {
		return A2(
			$author$project$Compiler$Reporting$Result$andThen,
			$author$project$Compiler$Canonicalize$Environment$Local$addCtors(module_),
			A2(
				$author$project$Compiler$Reporting$Result$andThen,
				$author$project$Compiler$Canonicalize$Environment$Local$addVars(module_),
				A2($author$project$Compiler$Canonicalize$Environment$Local$addTypes, module_, env)));
	});
var $author$project$Compiler$AST$Canonical$CCmd = function (a) {
	return {$: 'CCmd', a: a};
};
var $author$project$Compiler$AST$Canonical$CSub = function (a) {
	return {$: 'CSub', a: a};
};
var $author$project$Compiler$AST$Canonical$Fx = F2(
	function (a, b) {
		return {$: 'Fx', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Manager = F4(
	function (a, b, c, d) {
		return {$: 'Manager', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Canonical$NoEffects = {$: 'NoEffects'};
var $author$project$Compiler$AST$Canonical$Ports = function (a) {
	return {$: 'Ports', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$CmdBadMsg = {$: 'CmdBadMsg'};
var $author$project$Compiler$Reporting$Error$Canonicalize$CmdExtraArgs = function (a) {
	return {$: 'CmdExtraArgs', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$CmdNoArg = {$: 'CmdNoArg'};
var $author$project$Compiler$AST$Canonical$Incoming = F3(
	function (a, b, c) {
		return {$: 'Incoming', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$NotCmdOrSub = {$: 'NotCmdOrSub'};
var $author$project$Compiler$AST$Canonical$Outgoing = F3(
	function (a, b, c) {
		return {$: 'Outgoing', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$PortPayloadInvalid = F3(
	function (a, b, c) {
		return {$: 'PortPayloadInvalid', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid = F3(
	function (a, b, c) {
		return {$: 'PortTypeInvalid', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$SubBad = {$: 'SubBad'};
var $author$project$Compiler$Reporting$Error$Canonicalize$ExtendedRecord = {$: 'ExtendedRecord'};
var $author$project$Compiler$Reporting$Error$Canonicalize$Function = {$: 'Function'};
var $author$project$Compiler$Reporting$Error$Canonicalize$TypeVariable = function (a) {
	return {$: 'TypeVariable', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$UnsupportedType = function (a) {
	return {$: 'UnsupportedType', a: a};
};
var $author$project$Extra$Type$Map$findWithDefault = F3(
	function (def, k, m) {
		return A2(
			$elm$core$Maybe$withDefault,
			def,
			A2($author$project$Extra$Type$Map$lookup, k, m));
	});
var $author$project$Compiler$AST$Utils$Type$dealiasField = F2(
	function (typeTable, _v1) {
		var index = _v1.a;
		var tipe = _v1.b;
		return A2(
			$author$project$Compiler$AST$Canonical$FieldType,
			index,
			A2($author$project$Compiler$AST$Utils$Type$dealiasHelp, typeTable, tipe));
	});
var $author$project$Compiler$AST$Utils$Type$dealiasHelp = F2(
	function (typeTable, tipe) {
		switch (tipe.$) {
			case 'TLambda':
				var a = tipe.a;
				var b = tipe.b;
				return A2(
					$author$project$Compiler$AST$Canonical$TLambda,
					A2($author$project$Compiler$AST$Utils$Type$dealiasHelp, typeTable, a),
					A2($author$project$Compiler$AST$Utils$Type$dealiasHelp, typeTable, b));
			case 'TVar':
				var x = tipe.a;
				return A3($author$project$Extra$Type$Map$findWithDefault, tipe, x, typeTable);
			case 'TRecord':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$AST$Canonical$TRecord,
					A2(
						$author$project$Extra$Type$Map$map,
						$author$project$Compiler$AST$Utils$Type$dealiasField(typeTable),
						fields),
					ext);
			case 'TAlias':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				var t = tipe.d;
				return A4(
					$author$project$Compiler$AST$Canonical$TAlias,
					home,
					name,
					A2(
						$author$project$Extra$Type$List$map,
						$elm$core$Tuple$mapSecond(
							$author$project$Compiler$AST$Utils$Type$dealiasHelp(typeTable)),
						args),
					t);
			case 'TType':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A3(
					$author$project$Compiler$AST$Canonical$TType,
					home,
					name,
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$AST$Utils$Type$dealiasHelp(typeTable),
						args));
			case 'TUnit':
				return $author$project$Compiler$AST$Canonical$TUnit;
			default:
				var a = tipe.a;
				var b = tipe.b;
				var maybeC = tipe.c;
				return A3(
					$author$project$Compiler$AST$Canonical$TTuple,
					A2($author$project$Compiler$AST$Utils$Type$dealiasHelp, typeTable, a),
					A2($author$project$Compiler$AST$Utils$Type$dealiasHelp, typeTable, b),
					A2(
						$elm$core$Maybe$map,
						$author$project$Compiler$AST$Utils$Type$dealiasHelp(typeTable),
						maybeC));
		}
	});
var $author$project$Compiler$AST$Utils$Type$dealias = F2(
	function (args, aliasType) {
		if (aliasType.$ === 'Holey') {
			var tipe = aliasType.a;
			return A2(
				$author$project$Compiler$AST$Utils$Type$dealiasHelp,
				$author$project$Extra$Type$Map$fromList(args),
				tipe);
		} else {
			var tipe = aliasType.a;
			return tipe;
		}
	});
var $author$project$Compiler$Data$Name$array = 'Array';
var $author$project$Compiler$Elm$Package$elm = 'elm';
var $author$project$Compiler$Elm$Package$toName = F2(
	function (author, project) {
		return A2($author$project$Compiler$Elm$Package$Name, author, project);
	});
var $author$project$Compiler$Elm$Package$core = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'core');
var $author$project$Compiler$Elm$ModuleName$array = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$array);
var $author$project$Compiler$Canonicalize$Effects$isArray = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$array) && _Utils_eq(name, $author$project$Compiler$Data$Name$array);
	});
var $author$project$Compiler$Data$Name$basics = 'Basics';
var $author$project$Compiler$Elm$ModuleName$basics = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$basics);
var $author$project$Compiler$Data$Name$bool = 'Bool';
var $author$project$Compiler$Data$Name$float = 'Float';
var $author$project$Compiler$Data$Name$int = 'Int';
var $author$project$Compiler$Canonicalize$Effects$isIntFloatBool = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) && (_Utils_eq(name, $author$project$Compiler$Data$Name$int) || (_Utils_eq(name, $author$project$Compiler$Data$Name$float) || _Utils_eq(name, $author$project$Compiler$Data$Name$bool)));
	});
var $author$project$Compiler$Elm$Package$json = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'json');
var $author$project$Compiler$Elm$ModuleName$jsonEncode = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$json, 'Json.Encode');
var $author$project$Compiler$Data$Name$value = 'Value';
var $author$project$Compiler$Canonicalize$Effects$isJson = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$jsonEncode) && _Utils_eq(name, $author$project$Compiler$Data$Name$value);
	});
var $author$project$Compiler$Data$Name$list = 'List';
var $author$project$Compiler$Elm$ModuleName$list = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$list);
var $author$project$Compiler$Canonicalize$Effects$isList = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$list) && _Utils_eq(name, $author$project$Compiler$Data$Name$list);
	});
var $author$project$Compiler$Data$Name$maybe = 'Maybe';
var $author$project$Compiler$Elm$ModuleName$maybe = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$maybe);
var $author$project$Compiler$Canonicalize$Effects$isMaybe = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$maybe) && _Utils_eq(name, $author$project$Compiler$Data$Name$maybe);
	});
var $author$project$Compiler$Data$Name$string = 'String';
var $author$project$Compiler$Elm$ModuleName$string = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$string);
var $author$project$Compiler$Canonicalize$Effects$isString = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$string) && _Utils_eq(name, $author$project$Compiler$Data$Name$string);
	});
var $author$project$Extra$Type$Either$liftA2 = F3(
	function (f, ea, eb) {
		if (ea.$ === 'Left') {
			var x = ea.a;
			return $author$project$Extra$Type$Either$Left(x);
		} else {
			var a = ea.a;
			if (eb.$ === 'Left') {
				var x = eb.a;
				return $author$project$Extra$Type$Either$Left(x);
			} else {
				var b = eb.a;
				return $author$project$Extra$Type$Either$Right(
					A2(f, a, b));
			}
		}
	});
var $author$project$Extra$Type$Either$pure = $author$project$Extra$Type$Either$Right;
var $author$project$Extra$Type$Map$foldr = F3(
	function (f, z, m) {
		return A3(
			$author$project$Extra$Type$Map$foldrWithKey,
			function (_v0) {
				return f;
			},
			z,
			m);
	});
var $author$project$Extra$Class$Foldable$traverse_ = F5(
	function (pPure, pLiftA2, pFoldr, f, t) {
		return A3(
			pFoldr,
			A2(
				$elm$core$Basics$composeL,
				pLiftA2(
					F2(
						function (_v0, _v1) {
							return _Utils_Tuple0;
						})),
				f),
			pPure(_Utils_Tuple0),
			t);
	});
var $author$project$Extra$Type$Map$traverse_ = F4(
	function (pPure, pLiftA2, f, t) {
		return A5($author$project$Extra$Class$Foldable$traverse_, pPure, pLiftA2, $author$project$Extra$Type$Map$foldr, f, t);
	});
var $author$project$Compiler$Canonicalize$Effects$checkFieldPayload = function (_v6) {
	var tipe = _v6.b;
	return $author$project$Compiler$Canonicalize$Effects$checkPayload(tipe);
};
var $author$project$Compiler$Canonicalize$Effects$checkPayload = function (tipe) {
	checkPayload:
	while (true) {
		switch (tipe.$) {
			case 'TAlias':
				var args = tipe.c;
				var aliasedType = tipe.d;
				var $temp$tipe = A2($author$project$Compiler$AST$Utils$Type$dealias, args, aliasedType);
				tipe = $temp$tipe;
				continue checkPayload;
			case 'TType':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				if (!args.b) {
					return A2($author$project$Compiler$Canonicalize$Effects$isJson, home, name) ? $author$project$Extra$Type$Either$Right(_Utils_Tuple0) : (A2($author$project$Compiler$Canonicalize$Effects$isString, home, name) ? $author$project$Extra$Type$Either$Right(_Utils_Tuple0) : (A2($author$project$Compiler$Canonicalize$Effects$isIntFloatBool, home, name) ? $author$project$Extra$Type$Either$Right(_Utils_Tuple0) : $author$project$Extra$Type$Either$Left(
						_Utils_Tuple2(
							tipe,
							$author$project$Compiler$Reporting$Error$Canonicalize$UnsupportedType(name)))));
				} else {
					if (!args.b.b) {
						var arg = args.a;
						if (A2($author$project$Compiler$Canonicalize$Effects$isList, home, name)) {
							var $temp$tipe = arg;
							tipe = $temp$tipe;
							continue checkPayload;
						} else {
							if (A2($author$project$Compiler$Canonicalize$Effects$isMaybe, home, name)) {
								var $temp$tipe = arg;
								tipe = $temp$tipe;
								continue checkPayload;
							} else {
								if (A2($author$project$Compiler$Canonicalize$Effects$isArray, home, name)) {
									var $temp$tipe = arg;
									tipe = $temp$tipe;
									continue checkPayload;
								} else {
									return $author$project$Extra$Type$Either$Left(
										_Utils_Tuple2(
											tipe,
											$author$project$Compiler$Reporting$Error$Canonicalize$UnsupportedType(name)));
								}
							}
						}
					} else {
						return $author$project$Extra$Type$Either$Left(
							_Utils_Tuple2(
								tipe,
								$author$project$Compiler$Reporting$Error$Canonicalize$UnsupportedType(name)));
					}
				}
			case 'TUnit':
				return $author$project$Extra$Type$Either$Right(_Utils_Tuple0);
			case 'TTuple':
				var a = tipe.a;
				var b = tipe.b;
				var maybeC = tipe.c;
				return A2(
					$author$project$Extra$Type$Either$bind,
					$author$project$Compiler$Canonicalize$Effects$checkPayload(a),
					function (_v2) {
						return A2(
							$author$project$Extra$Type$Either$bind,
							$author$project$Compiler$Canonicalize$Effects$checkPayload(b),
							function (_v3) {
								if (maybeC.$ === 'Nothing') {
									return $author$project$Extra$Type$Either$Right(_Utils_Tuple0);
								} else {
									var c = maybeC.a;
									return $author$project$Compiler$Canonicalize$Effects$checkPayload(c);
								}
							});
					});
			case 'TVar':
				var name = tipe.a;
				return $author$project$Extra$Type$Either$Left(
					_Utils_Tuple2(
						tipe,
						$author$project$Compiler$Reporting$Error$Canonicalize$TypeVariable(name)));
			case 'TLambda':
				return $author$project$Extra$Type$Either$Left(
					_Utils_Tuple2(tipe, $author$project$Compiler$Reporting$Error$Canonicalize$Function));
			default:
				if (tipe.b.$ === 'Just') {
					return $author$project$Extra$Type$Either$Left(
						_Utils_Tuple2(tipe, $author$project$Compiler$Reporting$Error$Canonicalize$ExtendedRecord));
				} else {
					var fields = tipe.a;
					var _v5 = tipe.b;
					return A4($author$project$Extra$Type$Map$traverse_, $author$project$Extra$Type$Either$pure, $author$project$Extra$Type$Either$liftA2, $author$project$Compiler$Canonicalize$Effects$checkFieldPayload, fields);
				}
		}
	}
};
var $author$project$Compiler$Data$Name$cmd = 'Cmd';
var $author$project$Compiler$Elm$ModuleName$cmd = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, 'Platform.Cmd');
var $author$project$Compiler$AST$Utils$Type$deepDealias = function (tipe) {
	deepDealias:
	while (true) {
		switch (tipe.$) {
			case 'TLambda':
				var a = tipe.a;
				var b = tipe.b;
				return A2(
					$author$project$Compiler$AST$Canonical$TLambda,
					$author$project$Compiler$AST$Utils$Type$deepDealias(a),
					$author$project$Compiler$AST$Utils$Type$deepDealias(b));
			case 'TVar':
				return tipe;
			case 'TRecord':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$AST$Canonical$TRecord,
					A2($author$project$Extra$Type$Map$map, $author$project$Compiler$AST$Utils$Type$deepDealiasField, fields),
					ext);
			case 'TAlias':
				var args = tipe.c;
				var tipe_ = tipe.d;
				var $temp$tipe = A2($author$project$Compiler$AST$Utils$Type$dealias, args, tipe_);
				tipe = $temp$tipe;
				continue deepDealias;
			case 'TType':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A3(
					$author$project$Compiler$AST$Canonical$TType,
					home,
					name,
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$AST$Utils$Type$deepDealias, args));
			case 'TUnit':
				return $author$project$Compiler$AST$Canonical$TUnit;
			default:
				var a = tipe.a;
				var b = tipe.b;
				var c = tipe.c;
				return A3(
					$author$project$Compiler$AST$Canonical$TTuple,
					$author$project$Compiler$AST$Utils$Type$deepDealias(a),
					$author$project$Compiler$AST$Utils$Type$deepDealias(b),
					A2($elm$core$Maybe$map, $author$project$Compiler$AST$Utils$Type$deepDealias, c));
		}
	}
};
var $author$project$Compiler$AST$Utils$Type$deepDealiasField = function (_v0) {
	var index = _v0.a;
	var tipe = _v0.b;
	return A2(
		$author$project$Compiler$AST$Canonical$FieldType,
		index,
		$author$project$Compiler$AST$Utils$Type$deepDealias(tipe));
};
var $author$project$Compiler$AST$Utils$Type$delambda = function (tipe) {
	if (tipe.$ === 'TLambda') {
		var arg = tipe.a;
		var result = tipe.b;
		return A2(
			$elm$core$List$cons,
			arg,
			$author$project$Compiler$AST$Utils$Type$delambda(result));
	} else {
		return _List_fromArray(
			[tipe]);
	}
};
var $author$project$Compiler$Data$Name$sub = 'Sub';
var $author$project$Compiler$Elm$ModuleName$sub = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, 'Platform.Sub');
var $author$project$Extra$Type$Map$foldl = F3(
	function (f, z, m) {
		return A3(
			$author$project$Extra$Type$Map$foldlWithKey,
			F3(
				function (a, _v0, b) {
					return A2(f, a, b);
				}),
			z,
			m);
	});
var $author$project$Compiler$Canonicalize$Type$addFieldFreeVars = F2(
	function (freeVars, _v4) {
		var tipe = _v4.b;
		return A2($author$project$Compiler$Canonicalize$Type$addFreeVars, freeVars, tipe);
	});
var $author$project$Compiler$Canonicalize$Type$addFreeVars = F2(
	function (freeVars, tipe) {
		addFreeVars:
		while (true) {
			switch (tipe.$) {
				case 'TLambda':
					var arg = tipe.a;
					var result = tipe.b;
					var $temp$freeVars = A2($author$project$Compiler$Canonicalize$Type$addFreeVars, freeVars, result),
						$temp$tipe = arg;
					freeVars = $temp$freeVars;
					tipe = $temp$tipe;
					continue addFreeVars;
				case 'TVar':
					var _var = tipe.a;
					return A3($author$project$Extra$Type$Map$insert, _var, _Utils_Tuple0, freeVars);
				case 'TType':
					var args = tipe.c;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Type$addFreeVars, freeVars, args);
				case 'TRecord':
					if (tipe.b.$ === 'Nothing') {
						var fields = tipe.a;
						var _v1 = tipe.b;
						return A3($author$project$Extra$Type$Map$foldl, $author$project$Compiler$Canonicalize$Type$addFieldFreeVars, freeVars, fields);
					} else {
						var fields = tipe.a;
						var ext = tipe.b.a;
						return A3(
							$author$project$Extra$Type$Map$foldl,
							$author$project$Compiler$Canonicalize$Type$addFieldFreeVars,
							A3($author$project$Extra$Type$Map$insert, ext, _Utils_Tuple0, freeVars),
							fields);
					}
				case 'TUnit':
					return freeVars;
				case 'TTuple':
					var a = tipe.a;
					var b = tipe.b;
					var maybeC = tipe.c;
					if (maybeC.$ === 'Nothing') {
						var $temp$freeVars = A2($author$project$Compiler$Canonicalize$Type$addFreeVars, freeVars, a),
							$temp$tipe = b;
						freeVars = $temp$freeVars;
						tipe = $temp$tipe;
						continue addFreeVars;
					} else {
						var c = maybeC.a;
						var $temp$freeVars = A2(
							$author$project$Compiler$Canonicalize$Type$addFreeVars,
							A2($author$project$Compiler$Canonicalize$Type$addFreeVars, freeVars, a),
							b),
							$temp$tipe = c;
						freeVars = $temp$freeVars;
						tipe = $temp$tipe;
						continue addFreeVars;
					}
				default:
					var args = tipe.c;
					return A3(
						$author$project$Extra$Type$List$foldl,
						F2(
							function (fvs, _v3) {
								var arg = _v3.b;
								return A2($author$project$Compiler$Canonicalize$Type$addFreeVars, fvs, arg);
							}),
						freeVars,
						args);
			}
		}
	});
var $author$project$Compiler$Canonicalize$Type$toAnnotation = F2(
	function (env, srcType) {
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2($author$project$Compiler$Canonicalize$Type$canonicalize, env, srcType),
			function (tipe) {
				return $author$project$Compiler$Reporting$Result$ok(
					A2(
						$author$project$Compiler$AST$Canonical$Forall,
						A2($author$project$Compiler$Canonicalize$Type$addFreeVars, $author$project$Extra$Type$Map$empty, tipe),
						tipe));
			});
	});
var $author$project$Compiler$Canonicalize$Effects$canonicalizePort = F2(
	function (env, _v0) {
		var _v1 = _v0.a;
		var region = _v1.a;
		var portName = _v1.b;
		var tipe = _v0.b;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2($author$project$Compiler$Canonicalize$Type$toAnnotation, env, tipe),
			function (_v2) {
				var freeVars = _v2.a;
				var ctipe = _v2.b;
				var _v3 = $author$project$Extra$Type$List$reverse(
					$author$project$Compiler$AST$Utils$Type$delambda(
						$author$project$Compiler$AST$Utils$Type$deepDealias(ctipe)));
				if (((_v3.b && (_v3.a.$ === 'TType')) && _v3.a.c.b) && (!_v3.a.c.b.b)) {
					var _v4 = _v3.a;
					var home = _v4.a;
					var name = _v4.b;
					var _v5 = _v4.c;
					var msg = _v5.a;
					var revArgs = _v3.b;
					if (_Utils_eq(home, $author$project$Compiler$Elm$ModuleName$cmd) && _Utils_eq(name, $author$project$Compiler$Data$Name$cmd)) {
						if (!revArgs.b) {
							return $author$project$Compiler$Reporting$Result$throw(
								A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$CmdNoArg));
						} else {
							if (!revArgs.b.b) {
								var outgoingType = revArgs.a;
								if (msg.$ === 'TVar') {
									var _v8 = $author$project$Compiler$Canonicalize$Effects$checkPayload(outgoingType);
									if (_v8.$ === 'Right') {
										return $author$project$Compiler$Reporting$Result$ok(
											_Utils_Tuple2(
												portName,
												A3($author$project$Compiler$AST$Canonical$Outgoing, freeVars, outgoingType, ctipe)));
									} else {
										var _v9 = _v8.a;
										var err = _v9.b;
										return $author$project$Compiler$Reporting$Result$throw(
											A3($author$project$Compiler$Reporting$Error$Canonicalize$PortPayloadInvalid, region, portName, err));
									}
								} else {
									return $author$project$Compiler$Reporting$Result$throw(
										A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$CmdBadMsg));
								}
							} else {
								return $author$project$Compiler$Reporting$Result$throw(
									A3(
										$author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid,
										region,
										portName,
										$author$project$Compiler$Reporting$Error$Canonicalize$CmdExtraArgs(
											$author$project$Extra$Type$List$length(revArgs))));
							}
						}
					} else {
						if (_Utils_eq(home, $author$project$Compiler$Elm$ModuleName$sub) && _Utils_eq(name, $author$project$Compiler$Data$Name$sub)) {
							if (((revArgs.b && (revArgs.a.$ === 'TLambda')) && (revArgs.a.b.$ === 'TVar')) && (!revArgs.b.b)) {
								var _v11 = revArgs.a;
								var incomingType = _v11.a;
								var msg1 = _v11.b.a;
								if (msg.$ === 'TVar') {
									var msg2 = msg.a;
									if (_Utils_eq(msg1, msg2)) {
										var _v13 = $author$project$Compiler$Canonicalize$Effects$checkPayload(incomingType);
										if (_v13.$ === 'Right') {
											return $author$project$Compiler$Reporting$Result$ok(
												_Utils_Tuple2(
													portName,
													A3($author$project$Compiler$AST$Canonical$Incoming, freeVars, incomingType, ctipe)));
										} else {
											var _v14 = _v13.a;
											var err = _v14.b;
											return $author$project$Compiler$Reporting$Result$throw(
												A3($author$project$Compiler$Reporting$Error$Canonicalize$PortPayloadInvalid, region, portName, err));
										}
									} else {
										return $author$project$Compiler$Reporting$Result$throw(
											A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$SubBad));
									}
								} else {
									return $author$project$Compiler$Reporting$Result$throw(
										A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$SubBad));
								}
							} else {
								return $author$project$Compiler$Reporting$Result$throw(
									A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$SubBad));
							}
						} else {
							return $author$project$Compiler$Reporting$Result$throw(
								A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$NotCmdOrSub));
						}
					}
				} else {
					return $author$project$Compiler$Reporting$Result$throw(
						A3($author$project$Compiler$Reporting$Error$Canonicalize$PortTypeInvalid, region, portName, $author$project$Compiler$Reporting$Error$Canonicalize$NotCmdOrSub));
				}
			});
	});
var $author$project$Extra$Class$Applicative$discardFirst = F3(
	function (pLiftA2, fa, fb) {
		return A3(
			pLiftA2,
			F2(
				function (_v0, b) {
					return b;
				}),
			fa,
			fb);
	});
var $author$project$Compiler$Reporting$Result$discardFirst = $author$project$Extra$Class$Applicative$discardFirst($author$project$Compiler$Reporting$Result$liftA2);
var $author$project$Compiler$Canonicalize$Effects$toNameRegion = function (_v0) {
	var _v1 = _v0.b;
	var _v2 = _v1.a;
	var region = _v2.a;
	var name = _v2.b;
	return _Utils_Tuple2(name, region);
};
var $author$project$Compiler$Reporting$Error$Canonicalize$EffectNotFound = F2(
	function (a, b) {
		return {$: 'EffectNotFound', a: a, b: b};
	});
var $author$project$Extra$Type$Map$member = $elm$core$Dict$member;
var $author$project$Compiler$Canonicalize$Effects$verifyEffectType = F2(
	function (_v0, unions) {
		var region = _v0.a;
		var name = _v0.b;
		return A2($author$project$Extra$Type$Map$member, name, unions) ? $author$project$Compiler$Reporting$Result$ok(name) : $author$project$Compiler$Reporting$Result$throw(
			A2($author$project$Compiler$Reporting$Error$Canonicalize$EffectNotFound, region, name));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$EffectFunctionNotFound = F2(
	function (a, b) {
		return {$: 'EffectFunctionNotFound', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Effects$verifyManager = F3(
	function (tagRegion, values, name) {
		var _v0 = A2($author$project$Extra$Type$Map$lookup, name, values);
		if (_v0.$ === 'Just') {
			var region = _v0.a;
			return $author$project$Compiler$Reporting$Result$ok(region);
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A2($author$project$Compiler$Reporting$Error$Canonicalize$EffectFunctionNotFound, tagRegion, name));
		}
	});
var $author$project$Compiler$Canonicalize$Effects$canonicalize = F4(
	function (env, values, unions, effects) {
		switch (effects.$) {
			case 'NoEffects':
				return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$NoEffects);
			case 'Ports':
				var ports = effects.a;
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2(
						$author$project$Compiler$Reporting$Result$traverseList,
						$author$project$Compiler$Canonicalize$Effects$canonicalizePort(env),
						ports),
					function (pairs) {
						return $author$project$Compiler$Reporting$Result$return(
							$author$project$Compiler$AST$Canonical$Ports(
								$author$project$Extra$Type$Map$fromList(pairs)));
					});
			default:
				var region = effects.a;
				var manager = effects.b;
				var dict = $author$project$Extra$Type$Map$fromList(
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Canonicalize$Effects$toNameRegion, values));
				return A2(
					$author$project$Compiler$Reporting$Result$andMap,
					function () {
						switch (manager.$) {
							case 'CCmd':
								var cmdType = manager.a;
								return A2(
									$author$project$Compiler$Reporting$Result$discardFirst,
									A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'cmdMap'),
									A2(
										$author$project$Compiler$Reporting$Result$andMap,
										A2($author$project$Compiler$Canonicalize$Effects$verifyEffectType, cmdType, unions),
										$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$CCmd)));
							case 'CSub':
								var subType = manager.a;
								return A2(
									$author$project$Compiler$Reporting$Result$discardFirst,
									A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'subMap'),
									A2(
										$author$project$Compiler$Reporting$Result$andMap,
										A2($author$project$Compiler$Canonicalize$Effects$verifyEffectType, subType, unions),
										$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$CSub)));
							default:
								var cmdType = manager.a;
								var subType = manager.b;
								return A2(
									$author$project$Compiler$Reporting$Result$discardFirst,
									A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'subMap'),
									A2(
										$author$project$Compiler$Reporting$Result$discardFirst,
										A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'cmdMap'),
										A2(
											$author$project$Compiler$Reporting$Result$andMap,
											A2($author$project$Compiler$Canonicalize$Effects$verifyEffectType, subType, unions),
											A2(
												$author$project$Compiler$Reporting$Result$andMap,
												A2($author$project$Compiler$Canonicalize$Effects$verifyEffectType, cmdType, unions),
												$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$Fx)))));
						}
					}(),
					A2(
						$author$project$Compiler$Reporting$Result$andMap,
						A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'onSelfMsg'),
						A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'onEffects'),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A3($author$project$Compiler$Canonicalize$Effects$verifyManager, region, dict, 'init'),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$Manager)))));
		}
	});
var $author$project$Compiler$AST$Canonical$Binop_ = F3(
	function (a, b, c) {
		return {$: 'Binop_', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Module$canonicalizeBinop = function (_v0) {
	var _v1 = _v0.b;
	var op = _v1.a;
	var associativity = _v1.b;
	var precedence = _v1.c;
	var func = _v1.d;
	return _Utils_Tuple2(
		op,
		A3($author$project$Compiler$AST$Canonical$Binop_, associativity, precedence, func));
};
var $author$project$Compiler$AST$Canonical$Export = function (a) {
	return {$: 'Export', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$ExportDuplicate = F3(
	function (a, b, c) {
		return {$: 'ExportDuplicate', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$ExportEverything = {$: 'ExportEverything'};
var $author$project$Compiler$Reporting$Error$Canonicalize$BadOp = {$: 'BadOp'};
var $author$project$Compiler$Reporting$Error$Canonicalize$BadType = {$: 'BadType'};
var $author$project$Compiler$Reporting$Error$Canonicalize$BadVar = {$: 'BadVar'};
var $author$project$Compiler$AST$Canonical$ExportAlias = {$: 'ExportAlias'};
var $author$project$Compiler$AST$Canonical$ExportBinop = {$: 'ExportBinop'};
var $author$project$Compiler$Reporting$Error$Canonicalize$ExportNotFound = F4(
	function (a, b, c, d) {
		return {$: 'ExportNotFound', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$ExportOpenAlias = F2(
	function (a, b) {
		return {$: 'ExportOpenAlias', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$ExportPort = {$: 'ExportPort'};
var $author$project$Compiler$AST$Canonical$ExportUnionClosed = {$: 'ExportUnionClosed'};
var $author$project$Compiler$AST$Canonical$ExportUnionOpen = {$: 'ExportUnionOpen'};
var $author$project$Compiler$AST$Canonical$ExportValue = {$: 'ExportValue'};
var $author$project$Compiler$Canonicalize$Module$checkPorts = F2(
	function (effects, name) {
		switch (effects.$) {
			case 'NoEffects':
				return $elm$core$Maybe$Just(_List_Nil);
			case 'Ports':
				var ports = effects.a;
				return A2($author$project$Extra$Type$Map$member, name, ports) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
					$author$project$Extra$Type$Map$keys(ports));
			default:
				return $elm$core$Maybe$Just(_List_Nil);
		}
	});
var $author$project$Compiler$Canonicalize$Module$ok = F3(
	function (name, region, _export) {
		return $author$project$Compiler$Reporting$Result$ok(
			A3(
				$author$project$Compiler$Canonicalize$Environment$Dups$one,
				name,
				region,
				A2($author$project$Compiler$Reporting$Annotation$At, region, _export)));
	});
var $author$project$Compiler$Canonicalize$Module$checkExposed = F6(
	function (values, unions, aliases, binops, effects, exposed) {
		switch (exposed.$) {
			case 'Lower':
				var _v1 = exposed.a;
				var region = _v1.a;
				var name = _v1.b;
				if (A2($author$project$Extra$Type$Map$member, name, values)) {
					return A3($author$project$Compiler$Canonicalize$Module$ok, name, region, $author$project$Compiler$AST$Canonical$ExportValue);
				} else {
					var _v2 = A2($author$project$Compiler$Canonicalize$Module$checkPorts, effects, name);
					if (_v2.$ === 'Nothing') {
						return A3($author$project$Compiler$Canonicalize$Module$ok, name, region, $author$project$Compiler$AST$Canonical$ExportPort);
					} else {
						var ports = _v2.a;
						return $author$project$Compiler$Reporting$Result$throw(
							A4(
								$author$project$Compiler$Reporting$Error$Canonicalize$ExportNotFound,
								region,
								$author$project$Compiler$Reporting$Error$Canonicalize$BadVar,
								name,
								_Utils_ap(
									ports,
									$author$project$Extra$Type$Map$keys(values))));
					}
				}
			case 'Operator':
				var region = exposed.a;
				var name = exposed.b;
				return A2($author$project$Extra$Type$Map$member, name, binops) ? A3($author$project$Compiler$Canonicalize$Module$ok, name, region, $author$project$Compiler$AST$Canonical$ExportBinop) : $author$project$Compiler$Reporting$Result$throw(
					A4(
						$author$project$Compiler$Reporting$Error$Canonicalize$ExportNotFound,
						region,
						$author$project$Compiler$Reporting$Error$Canonicalize$BadOp,
						name,
						$author$project$Extra$Type$Map$keys(binops)));
			default:
				if (exposed.b.$ === 'Public') {
					var _v3 = exposed.a;
					var region = _v3.a;
					var name = _v3.b;
					var dotDotRegion = exposed.b.a;
					return A2($author$project$Extra$Type$Map$member, name, unions) ? A3($author$project$Compiler$Canonicalize$Module$ok, name, region, $author$project$Compiler$AST$Canonical$ExportUnionOpen) : (A2($author$project$Extra$Type$Map$member, name, aliases) ? $author$project$Compiler$Reporting$Result$throw(
						A2($author$project$Compiler$Reporting$Error$Canonicalize$ExportOpenAlias, dotDotRegion, name)) : $author$project$Compiler$Reporting$Result$throw(
						A4(
							$author$project$Compiler$Reporting$Error$Canonicalize$ExportNotFound,
							region,
							$author$project$Compiler$Reporting$Error$Canonicalize$BadType,
							name,
							_Utils_ap(
								$author$project$Extra$Type$Map$keys(unions),
								$author$project$Extra$Type$Map$keys(aliases)))));
				} else {
					var _v4 = exposed.a;
					var region = _v4.a;
					var name = _v4.b;
					var _v5 = exposed.b;
					return A2($author$project$Extra$Type$Map$member, name, unions) ? A3($author$project$Compiler$Canonicalize$Module$ok, name, region, $author$project$Compiler$AST$Canonical$ExportUnionClosed) : (A2($author$project$Extra$Type$Map$member, name, aliases) ? A3($author$project$Compiler$Canonicalize$Module$ok, name, region, $author$project$Compiler$AST$Canonical$ExportAlias) : $author$project$Compiler$Reporting$Result$throw(
						A4(
							$author$project$Compiler$Reporting$Error$Canonicalize$ExportNotFound,
							region,
							$author$project$Compiler$Reporting$Error$Canonicalize$BadType,
							name,
							_Utils_ap(
								$author$project$Extra$Type$Map$keys(unions),
								$author$project$Extra$Type$Map$keys(aliases)))));
				}
		}
	});
var $author$project$Compiler$Canonicalize$Module$valueToName = function (_v0) {
	var _v1 = _v0.b;
	var _v2 = _v1.a;
	var name = _v2.b;
	return _Utils_Tuple2(name, _Utils_Tuple0);
};
var $author$project$Compiler$Canonicalize$Module$canonicalizeExports = F6(
	function (values, unions, aliases, binops, effects, _v0) {
		var exposing_ = _v0.b;
		if (exposing_.$ === 'Open') {
			return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$ExportEverything);
		} else {
			var exposeds = exposing_.a;
			var names = $author$project$Extra$Type$Map$fromList(
				A2($author$project$Extra$Type$List$map, $author$project$Compiler$Canonicalize$Module$valueToName, values));
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2(
					$author$project$Compiler$Reporting$Result$traverseList,
					A5($author$project$Compiler$Canonicalize$Module$checkExposed, names, unions, aliases, binops, effects),
					exposeds),
				function (infos) {
					return A2(
						$author$project$Compiler$Reporting$Result$fmap,
						$author$project$Compiler$AST$Canonical$Export,
						A2(
							$author$project$Compiler$Canonicalize$Environment$Dups$detect,
							$author$project$Compiler$Reporting$Error$Canonicalize$ExportDuplicate,
							$author$project$Compiler$Canonicalize$Environment$Dups$unions(infos)));
				});
		}
	});
var $author$project$Compiler$AST$Canonical$Declare = F2(
	function (a, b) {
		return {$: 'Declare', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$DeclareRec = F3(
	function (a, b, c) {
		return {$: 'DeclareRec', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$SaveTheEnvironment = {$: 'SaveTheEnvironment'};
var $author$project$Compiler$Reporting$Error$Canonicalize$RecursiveDecl = F3(
	function (a, b, c) {
		return {$: 'RecursiveDecl', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Module$extractDefName = function (def) {
	if (def.$ === 'Def') {
		var name = def.a;
		return name;
	} else {
		var name = def.a;
		return name;
	}
};
var $author$project$Compiler$Canonicalize$Module$detectBadCycles = function (scc) {
	if (scc.$ === 'AcyclicSCC') {
		var def = scc.a;
		return $author$project$Compiler$Reporting$Result$ok(def);
	} else {
		if (!scc.a.b) {
			return _Debug_todo(
				'Compiler.Canonicalize.Module',
				{
					start: {line: 109, column: 7},
					end: {line: 109, column: 17}
				})('The definition of Data.Graph.SCC should not allow empty CyclicSCC!');
		} else {
			var _v1 = scc.a;
			var def = _v1.a;
			var defs = _v1.b;
			var names = A2(
				$author$project$Extra$Type$List$map,
				A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Annotation$toValue, $author$project$Compiler$Canonicalize$Module$extractDefName),
				defs);
			var _v2 = $author$project$Compiler$Canonicalize$Module$extractDefName(def);
			var region = _v2.a;
			var name = _v2.b;
			return $author$project$Compiler$Reporting$Result$throw(
				A3($author$project$Compiler$Reporting$Error$Canonicalize$RecursiveDecl, region, name, names));
		}
	}
};
var $author$project$Compiler$Canonicalize$Module$detectCycles = function (sccs) {
	if (!sccs.b) {
		return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$SaveTheEnvironment);
	} else {
		var scc = sccs.a;
		var otherSccs = sccs.b;
		if (scc.$ === 'AcyclicSCC') {
			var _v2 = scc.a;
			var def = _v2.a;
			return A2(
				$author$project$Compiler$Reporting$Result$fmap,
				$author$project$Compiler$AST$Canonical$Declare(def),
				$author$project$Compiler$Canonicalize$Module$detectCycles(otherSccs));
		} else {
			var subNodes = scc.a;
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2(
					$author$project$Compiler$Reporting$Result$traverseList,
					$author$project$Compiler$Canonicalize$Module$detectBadCycles,
					$author$project$Extra$Data$Graph$stronglyConnComp(subNodes)),
				function (defs) {
					if (!defs.b) {
						return $author$project$Compiler$Canonicalize$Module$detectCycles(otherSccs);
					} else {
						var d = defs.a;
						var ds = defs.b;
						return A2(
							$author$project$Compiler$Reporting$Result$fmap,
							A2($author$project$Compiler$AST$Canonical$DeclareRec, d, ds),
							$author$project$Compiler$Canonicalize$Module$detectCycles(otherSccs));
					}
				});
		}
	}
};
var $author$project$Compiler$Reporting$Error$Canonicalize$DPFuncArgs = function (a) {
	return {$: 'DPFuncArgs', a: a};
};
var $author$project$Compiler$AST$Canonical$Def = F3(
	function (a, b, c) {
		return {$: 'Def', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Warning$Pattern = {$: 'Pattern'};
var $author$project$Compiler$AST$Canonical$TypedDef = F5(
	function (a, b, c, d, e) {
		return {$: 'TypedDef', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Canonicalize$Environment$Local = function (a) {
	return {$: 'Local', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$Shadowing = F3(
	function (a, b, c) {
		return {$: 'Shadowing', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Environment$addLocalBoth = F3(
	function (name, region, _var) {
		switch (_var.$) {
			case 'Foreign':
				return $author$project$Compiler$Reporting$Result$ok(
					$author$project$Compiler$Canonicalize$Environment$Local(region));
			case 'Foreigns':
				return $author$project$Compiler$Reporting$Result$ok(
					$author$project$Compiler$Canonicalize$Environment$Local(region));
			case 'Local':
				var parentRegion = _var.a;
				return $author$project$Compiler$Reporting$Result$throw(
					A3($author$project$Compiler$Reporting$Error$Canonicalize$Shadowing, name, parentRegion, region));
			default:
				var parentRegion = _var.a;
				return $author$project$Compiler$Reporting$Result$throw(
					A3($author$project$Compiler$Reporting$Error$Canonicalize$Shadowing, name, parentRegion, region));
		}
	});
var $author$project$Compiler$Canonicalize$Environment$addLocalLeft = F2(
	function (_v0, region) {
		return $author$project$Compiler$Canonicalize$Environment$Local(region);
	});
var $author$project$Compiler$Reporting$Result$mapMissing = F3(
	function (f, k, a) {
		return $author$project$Compiler$Reporting$Result$pure(
			$elm$core$Maybe$Just(
				A2(f, k, a)));
	});
var $author$project$Compiler$Reporting$Result$loop2 = F4(
	function (k, mc, pairsA, map) {
		return _Utils_Tuple2(
			pairsA,
			function () {
				if (mc.$ === 'Just') {
					var c = mc.a;
					return A3($author$project$Extra$Type$Map$insert, k, c, map);
				} else {
					return map;
				}
			}());
	});
var $author$project$Compiler$Reporting$Result$loop1 = F5(
	function (k, mc, pairsB, pairsA, map) {
		return _Utils_Tuple2(
			pairsB,
			A4($author$project$Compiler$Reporting$Result$loop2, k, mc, pairsA, map));
	});
var $author$project$Compiler$Reporting$Result$mergeAHelp1 = F4(
	function (missA, missB, zipAB, _v0) {
		var pairsB = _v0.a;
		var state = _v0.b;
		var pairsA = state.a;
		var map = state.b;
		if (!pairsB.b) {
			return $author$project$Compiler$Reporting$Result$return(
				$author$project$Compiler$Reporting$Result$Done(state));
		} else {
			var _v2 = pairsB.a;
			var kB = _v2.a;
			var b = _v2.b;
			var restB = pairsB.b;
			if (!pairsA.b) {
				return A2(
					$author$project$Compiler$Reporting$Result$fmap,
					function (mc) {
						return $author$project$Compiler$Reporting$Result$Loop(
							A5($author$project$Compiler$Reporting$Result$loop1, kB, mc, restB, pairsA, map));
					},
					A2(missB, kB, b));
			} else {
				var _v4 = pairsA.a;
				var kA = _v4.a;
				var a = _v4.b;
				var restA = pairsA.b;
				return (_Utils_cmp(kA, kB) < 0) ? A2(
					$author$project$Compiler$Reporting$Result$fmap,
					function (mc) {
						return $author$project$Compiler$Reporting$Result$Loop(
							A5($author$project$Compiler$Reporting$Result$loop1, kA, mc, pairsB, restA, map));
					},
					A2(missA, kA, a)) : ((_Utils_cmp(kA, kB) > 0) ? A2(
					$author$project$Compiler$Reporting$Result$fmap,
					function (mc) {
						return $author$project$Compiler$Reporting$Result$Loop(
							A5($author$project$Compiler$Reporting$Result$loop1, kB, mc, restB, pairsA, map));
					},
					A2(missB, kB, b)) : A2(
					$author$project$Compiler$Reporting$Result$fmap,
					function (mc) {
						return $author$project$Compiler$Reporting$Result$Loop(
							A5($author$project$Compiler$Reporting$Result$loop1, kA, mc, restB, restA, map));
					},
					A3(zipAB, kA, a, b)));
			}
		}
	});
var $author$project$Compiler$Reporting$Result$mergeAHelp2 = F2(
	function (missA, _v0) {
		var pairsA = _v0.a;
		var map = _v0.b;
		if (!pairsA.b) {
			return $author$project$Compiler$Reporting$Result$return(
				$author$project$Compiler$Reporting$Result$Done(map));
		} else {
			var _v2 = pairsA.a;
			var k = _v2.a;
			var a = _v2.b;
			var rest = pairsA.b;
			return A2(
				$author$project$Compiler$Reporting$Result$fmap,
				function (mc) {
					return $author$project$Compiler$Reporting$Result$Loop(
						A4($author$project$Compiler$Reporting$Result$loop2, k, mc, rest, map));
				},
				A2(missA, k, a));
		}
	});
var $author$project$Compiler$Reporting$Result$mergeA = F5(
	function (missA, missB, zipAB, ma, mb) {
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2(
				$author$project$Compiler$Reporting$Result$loop,
				A3($author$project$Compiler$Reporting$Result$mergeAHelp1, missA, missB, zipAB),
				_Utils_Tuple2(
					$author$project$Extra$Type$Map$toList(mb),
					_Utils_Tuple2(
						$author$project$Extra$Type$Map$toList(ma),
						$author$project$Extra$Type$Map$empty))),
			function (_v0) {
				var leftovers = _v0.a;
				var intermediateResult = _v0.b;
				return A2(
					$author$project$Compiler$Reporting$Result$loop,
					$author$project$Compiler$Reporting$Result$mergeAHelp2(missA),
					_Utils_Tuple2(leftovers, intermediateResult));
			});
	});
var $author$project$Compiler$Reporting$Result$zipWithAMatched = F4(
	function (f, k, a, b) {
		return A2(
			$author$project$Compiler$Reporting$Result$fmap,
			$elm$core$Maybe$Just,
			A3(f, k, a, b));
	});
var $author$project$Compiler$Canonicalize$Environment$addLocals = F2(
	function (names, _v0) {
		var home = _v0.a;
		var vars = _v0.b;
		var ts = _v0.c;
		var cs = _v0.d;
		var bs = _v0.e;
		var qvs = _v0.f;
		var qts = _v0.g;
		var qcs = _v0.h;
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A5(
				$author$project$Compiler$Reporting$Result$mergeA,
				$author$project$Compiler$Reporting$Result$mapMissing($author$project$Compiler$Canonicalize$Environment$addLocalLeft),
				$author$project$Compiler$Reporting$Result$mapMissing(
					F2(
						function (_v1, homes) {
							return homes;
						})),
				$author$project$Compiler$Reporting$Result$zipWithAMatched($author$project$Compiler$Canonicalize$Environment$addLocalBoth),
				names,
				vars),
			function (newVars) {
				return $author$project$Compiler$Reporting$Result$ok(
					A8($author$project$Compiler$Canonicalize$Environment$Env, home, newVars, ts, cs, bs, qvs, qts, qcs));
			});
	});
var $author$project$Compiler$AST$Canonical$Access = F2(
	function (a, b) {
		return {$: 'Access', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Accessor = function (a) {
	return {$: 'Accessor', a: a};
};
var $author$project$Compiler$AST$Canonical$CFloat = function (a) {
	return {$: 'CFloat', a: a};
};
var $author$project$Compiler$AST$Canonical$CInt = function (a) {
	return {$: 'CInt', a: a};
};
var $author$project$Compiler$AST$Canonical$CList = function (a) {
	return {$: 'CList', a: a};
};
var $author$project$Compiler$AST$Canonical$Call = F2(
	function (a, b) {
		return {$: 'Call', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Case = F2(
	function (a, b) {
		return {$: 'Case', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$CaseBranch = F2(
	function (a, b) {
		return {$: 'CaseBranch', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Chr = function (a) {
	return {$: 'Chr', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$DPCaseBranch = {$: 'DPCaseBranch'};
var $author$project$Compiler$Reporting$Error$Canonicalize$DPDestruct = {$: 'DPDestruct'};
var $author$project$Compiler$Reporting$Error$Canonicalize$DPLambdaArgs = {$: 'DPLambdaArgs'};
var $author$project$Compiler$Reporting$Error$Canonicalize$DPLetBinding = {$: 'DPLetBinding'};
var $author$project$Compiler$Reporting$Warning$Def = {$: 'Def'};
var $author$project$Compiler$Canonicalize$Expression$Define = function (a) {
	return {$: 'Define', a: a};
};
var $author$project$Compiler$Canonicalize$Expression$Destruct = F2(
	function (a, b) {
		return {$: 'Destruct', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$DuplicatePattern = F4(
	function (a, b, c, d) {
		return {$: 'DuplicatePattern', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Canonical$FieldUpdate = F2(
	function (a, b) {
		return {$: 'FieldUpdate', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$If = F2(
	function (a, b) {
		return {$: 'If', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Lambda = F2(
	function (a, b) {
		return {$: 'Lambda', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Expression$More = F2(
	function (a, b) {
		return {$: 'More', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Negate = function (a) {
	return {$: 'Negate', a: a};
};
var $author$project$Compiler$AST$Canonical$Record = function (a) {
	return {$: 'Record', a: a};
};
var $author$project$Compiler$AST$Canonical$Shader = F2(
	function (a, b) {
		return {$: 'Shader', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$Str = function (a) {
	return {$: 'Str', a: a};
};
var $author$project$Compiler$AST$Canonical$Tuple = F3(
	function (a, b, c) {
		return {$: 'Tuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$Unit = {$: 'Unit'};
var $author$project$Compiler$AST$Canonical$Update = F3(
	function (a, b, c) {
		return {$: 'Update', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$VarOperator = F4(
	function (a, b, c, d) {
		return {$: 'VarOperator', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Canonicalize$Expression$addBindingsHelp = F2(
	function (bindings, _v0) {
		addBindingsHelp:
		while (true) {
			var region = _v0.a;
			var pattern = _v0.b;
			switch (pattern.$) {
				case 'PAnything':
					return bindings;
				case 'PVar':
					var name = pattern.a;
					return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, region, region, bindings);
				case 'PRecord':
					var fields = pattern.a;
					var addField = F2(
						function (dict, _v2) {
							var fieldRegion = _v2.a;
							var name = _v2.b;
							return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, fieldRegion, fieldRegion, dict);
						});
					return A3($author$project$Extra$Type$List$foldl, addField, bindings, fields);
				case 'PUnit':
					return bindings;
				case 'PTuple':
					var a = pattern.a;
					var b = pattern.b;
					var cs = pattern.c;
					return A3(
						$author$project$Extra$Type$List$foldl,
						$author$project$Compiler$Canonicalize$Expression$addBindingsHelp,
						bindings,
						A2(
							$elm$core$List$cons,
							a,
							A2($elm$core$List$cons, b, cs)));
				case 'PCtor':
					var patterns = pattern.c;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$addBindingsHelp, bindings, patterns);
				case 'PCtorQual':
					var patterns = pattern.d;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$addBindingsHelp, bindings, patterns);
				case 'PList':
					var patterns = pattern.a;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$addBindingsHelp, bindings, patterns);
				case 'PCons':
					var hd = pattern.a;
					var tl = pattern.b;
					var $temp$bindings = A2($author$project$Compiler$Canonicalize$Expression$addBindingsHelp, bindings, hd),
						$temp$_v0 = tl;
					bindings = $temp$bindings;
					_v0 = $temp$_v0;
					continue addBindingsHelp;
				case 'PAlias':
					var aliasPattern = pattern.a;
					var _v3 = pattern.b;
					var nameRegion = _v3.a;
					var name = _v3.b;
					return A4(
						$author$project$Compiler$Canonicalize$Environment$Dups$insert,
						name,
						nameRegion,
						nameRegion,
						A2($author$project$Compiler$Canonicalize$Expression$addBindingsHelp, bindings, aliasPattern));
				case 'PChr':
					return bindings;
				case 'PStr':
					return bindings;
				default:
					return bindings;
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$addBindings = F2(
	function (bindings, _v0) {
		var def = _v0.b;
		if (def.$ === 'Define') {
			var _v2 = def.a;
			var region = _v2.a;
			var name = _v2.b;
			return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, region, region, bindings);
		} else {
			var pattern = def.a;
			return A2($author$project$Compiler$Canonicalize$Expression$addBindingsHelp, bindings, pattern);
		}
	});
var $author$project$Compiler$Canonicalize$Expression$Edge = function (a) {
	return {$: 'Edge', a: a};
};
var $author$project$Compiler$Canonicalize$Expression$addEdge = F3(
	function (edges, nodes, aname) {
		var name = aname.b;
		return A2(
			$elm$core$List$cons,
			_Utils_Tuple3(
				$author$project$Compiler$Canonicalize$Expression$Edge(aname),
				name,
				edges),
			nodes);
	});
var $author$project$Compiler$AST$Canonical$PAlias = F2(
	function (a, b) {
		return {$: 'PAlias', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$PAnything = {$: 'PAnything'};
var $author$project$Compiler$AST$Canonical$PBool = F2(
	function (a, b) {
		return {$: 'PBool', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$PChr = function (a) {
	return {$: 'PChr', a: a};
};
var $author$project$Compiler$AST$Canonical$PCons = F2(
	function (a, b) {
		return {$: 'PCons', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$PCtor = F6(
	function (a, b, c, d, e, f) {
		return {$: 'PCtor', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Compiler$AST$Canonical$PInt = function (a) {
	return {$: 'PInt', a: a};
};
var $author$project$Compiler$AST$Canonical$PList = function (a) {
	return {$: 'PList', a: a};
};
var $author$project$Compiler$AST$Canonical$PRecord = function (a) {
	return {$: 'PRecord', a: a};
};
var $author$project$Compiler$AST$Canonical$PStr = function (a) {
	return {$: 'PStr', a: a};
};
var $author$project$Compiler$AST$Canonical$PTuple = F3(
	function (a, b, c) {
		return {$: 'PTuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$PUnit = {$: 'PUnit'};
var $author$project$Compiler$AST$Canonical$PVar = function (a) {
	return {$: 'PVar', a: a};
};
var $author$project$Compiler$Reporting$Error$Canonicalize$PatternArity = {$: 'PatternArity'};
var $author$project$Compiler$AST$Canonical$PatternCtorArg = F3(
	function (a, b, c) {
		return {$: 'PatternCtorArg', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$PatternHasRecordCtor = F2(
	function (a, b) {
		return {$: 'PatternHasRecordCtor', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousVariant = F5(
	function (a, b, c, d, e) {
		return {$: 'AmbiguousVariant', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVariant = F4(
	function (a, b, c, d) {
		return {$: 'NotFoundVariant', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Canonicalize$Environment$findCtor = F3(
	function (region, _v0, name) {
		var cs = _v0.d;
		var qcs = _v0.h;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, name, cs);
		if (_v1.$ === 'Just') {
			if (_v1.a.$ === 'Specific') {
				var _v2 = _v1.a;
				var ctor = _v2.b;
				return $author$project$Compiler$Reporting$Result$ok(ctor);
			} else {
				var _v3 = _v1.a;
				var h = _v3.a;
				var hs = _v3.b;
				return $author$project$Compiler$Reporting$Result$throw(
					A5($author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousVariant, region, $elm$core$Maybe$Nothing, name, h, hs));
			}
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVariant,
					region,
					$elm$core$Maybe$Nothing,
					name,
					A2($author$project$Compiler$Canonicalize$Environment$toPossibleNames, cs, qcs)));
		}
	});
var $author$project$Compiler$Canonicalize$Environment$findCtorQual = F4(
	function (region, _v0, prefix, name) {
		var cs = _v0.d;
		var qcs = _v0.h;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, prefix, qcs);
		if (_v1.$ === 'Just') {
			var qualified = _v1.a;
			var _v2 = A2($author$project$Extra$Type$Map$lookup, name, qualified);
			if (_v2.$ === 'Just') {
				if (_v2.a.$ === 'Specific') {
					var _v3 = _v2.a;
					var pattern = _v3.b;
					return $author$project$Compiler$Reporting$Result$ok(pattern);
				} else {
					var _v4 = _v2.a;
					var h = _v4.a;
					var hs = _v4.b;
					return $author$project$Compiler$Reporting$Result$throw(
						A5(
							$author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousVariant,
							region,
							$elm$core$Maybe$Just(prefix),
							name,
							h,
							hs));
				}
			} else {
				return $author$project$Compiler$Reporting$Result$throw(
					A4(
						$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVariant,
						region,
						$elm$core$Maybe$Just(prefix),
						name,
						A2($author$project$Compiler$Canonicalize$Environment$toPossibleNames, cs, qcs)));
			}
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVariant,
					region,
					$elm$core$Maybe$Just(prefix),
					name,
					A2($author$project$Compiler$Canonicalize$Environment$toPossibleNames, cs, qcs)));
		}
	});
var $author$project$Compiler$Data$Index$LengthMatch = function (a) {
	return {$: 'LengthMatch', a: a};
};
var $author$project$Compiler$Data$Index$LengthMismatch = F2(
	function (a, b) {
		return {$: 'LengthMismatch', a: a, b: b};
	});
var $author$project$Compiler$Data$Index$indexedZipWithHelp = F5(
	function (func, index, listX, listY, revListZ) {
		var _v0 = _Utils_Tuple2(listX, listY);
		_v0$2:
		while (true) {
			if (!_v0.a.b) {
				if (!_v0.b.b) {
					return $author$project$Compiler$Data$Index$LengthMatch(
						$author$project$Extra$Type$List$reverse(revListZ));
				} else {
					break _v0$2;
				}
			} else {
				if (_v0.b.b) {
					var _v1 = _v0.a;
					var x = _v1.a;
					var xs = _v1.b;
					var _v2 = _v0.b;
					var y = _v2.a;
					var ys = _v2.b;
					return A5(
						$author$project$Compiler$Data$Index$indexedZipWithHelp,
						func,
						index + 1,
						xs,
						ys,
						A2(
							$elm$core$List$cons,
							A3(
								func,
								$author$project$Compiler$Data$Index$ZeroBased(index),
								x,
								y),
							revListZ));
				} else {
					break _v0$2;
				}
			}
		}
		return A2(
			$author$project$Compiler$Data$Index$LengthMismatch,
			index + $author$project$Extra$Type$List$length(listX),
			index + $author$project$Extra$Type$List$length(listY));
	});
var $author$project$Compiler$Data$Index$indexedZipWith = F3(
	function (func, listX, listY) {
		return A5($author$project$Compiler$Data$Index$indexedZipWithHelp, func, 0, listX, listY, _List_Nil);
	});
var $author$project$Compiler$Data$Index$indexedZipWithA = F7(
	function (pPure, pPure2, pMap, pLiftA2, func, listX, listY) {
		var _v0 = A3($author$project$Compiler$Data$Index$indexedZipWith, func, listX, listY);
		if (_v0.$ === 'LengthMatch') {
			var xs = _v0.a;
			return A2(
				pMap,
				$author$project$Compiler$Data$Index$LengthMatch,
				A3($author$project$Extra$Type$List$sequenceA, pPure, pLiftA2, xs));
		} else {
			var x = _v0.a;
			var y = _v0.b;
			return pPure2(
				A2($author$project$Compiler$Data$Index$LengthMismatch, x, y));
		}
	});
var $author$project$Compiler$Canonicalize$Pattern$logFields = F2(
	function (fields, value) {
		var addField = F2(
			function (dict, _v0) {
				var region = _v0.a;
				var name = _v0.b;
				return A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, region, region, dict);
			});
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (bindings, warnings) {
					return A3(
						$author$project$Compiler$Reporting$Result$Rgood,
						A3($author$project$Extra$Type$List$foldl, addField, bindings, fields),
						warnings,
						value);
				}));
	});
var $author$project$Compiler$Canonicalize$Pattern$logVar = F3(
	function (name, region, value) {
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (bindings, warnings) {
					return A3(
						$author$project$Compiler$Reporting$Result$Rgood,
						A4($author$project$Compiler$Canonicalize$Environment$Dups$insert, name, region, region, bindings),
						warnings,
						value);
				}));
	});
var $author$project$Compiler$Data$Name$true = 'True';
var $author$project$Compiler$Canonicalize$Pattern$canonicalize = F2(
	function (env, _v4) {
		var region = _v4.a;
		var pattern = _v4.b;
		return A2(
			$author$project$Compiler$Reporting$Result$fmap,
			$author$project$Compiler$Reporting$Annotation$At(region),
			function () {
				switch (pattern.$) {
					case 'PAnything':
						return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$PAnything);
					case 'PVar':
						var name = pattern.a;
						return A3(
							$author$project$Compiler$Canonicalize$Pattern$logVar,
							name,
							region,
							$author$project$Compiler$AST$Canonical$PVar(name));
					case 'PRecord':
						var fields = pattern.a;
						return A2(
							$author$project$Compiler$Canonicalize$Pattern$logFields,
							fields,
							$author$project$Compiler$AST$Canonical$PRecord(
								A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, fields)));
					case 'PUnit':
						return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$PUnit);
					case 'PTuple':
						var a = pattern.a;
						var b = pattern.b;
						var cs = pattern.c;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A3($author$project$Compiler$Canonicalize$Pattern$canonicalizeTuple, region, env, cs),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, b),
								A2(
									$author$project$Compiler$Reporting$Result$andMap,
									A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, a),
									$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$PTuple))));
					case 'PCtor':
						var nameRegion = pattern.a;
						var name = pattern.b;
						var patterns = pattern.c;
						return A2(
							$author$project$Compiler$Reporting$Result$andThen,
							A4($author$project$Compiler$Canonicalize$Pattern$canonicalizeCtor, env, region, name, patterns),
							A3($author$project$Compiler$Canonicalize$Environment$findCtor, nameRegion, env, name));
					case 'PCtorQual':
						var nameRegion = pattern.a;
						var home = pattern.b;
						var name = pattern.c;
						var patterns = pattern.d;
						return A2(
							$author$project$Compiler$Reporting$Result$andThen,
							A4($author$project$Compiler$Canonicalize$Pattern$canonicalizeCtor, env, region, name, patterns),
							A4($author$project$Compiler$Canonicalize$Environment$findCtorQual, nameRegion, env, home, name));
					case 'PList':
						var patterns = pattern.a;
						return A2(
							$author$project$Compiler$Reporting$Result$fmap,
							$author$project$Compiler$AST$Canonical$PList,
							A2($author$project$Compiler$Canonicalize$Pattern$canonicalizeList, env, patterns));
					case 'PCons':
						var first = pattern.a;
						var rest = pattern.b;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, rest),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, first),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$PCons)));
					case 'PAlias':
						var ptrn = pattern.a;
						var _v6 = pattern.b;
						var reg = _v6.a;
						var name = _v6.b;
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, ptrn),
							function (cpattern) {
								return A3(
									$author$project$Compiler$Canonicalize$Pattern$logVar,
									name,
									reg,
									A2($author$project$Compiler$AST$Canonical$PAlias, cpattern, name));
							});
					case 'PChr':
						var chr = pattern.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$PChr(chr));
					case 'PStr':
						var str = pattern.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$PStr(str));
					default:
						var _int = pattern.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$PInt(_int));
				}
			}());
	});
var $author$project$Compiler$Canonicalize$Pattern$canonicalizeCtor = F5(
	function (env, region, name, patterns, ctor) {
		if (ctor.$ === 'Ctor') {
			var home = ctor.a;
			var tipe = ctor.b;
			var union = ctor.c;
			var index = ctor.d;
			var args = ctor.e;
			var toCanonicalArg = F3(
				function (argIndex, argPattern, argTipe) {
					return A2(
						$author$project$Compiler$Reporting$Result$fmap,
						A2($author$project$Compiler$AST$Canonical$PatternCtorArg, argIndex, argTipe),
						A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, argPattern));
				});
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				A7($author$project$Compiler$Data$Index$indexedZipWithA, $author$project$Compiler$Reporting$Result$pure, $author$project$Compiler$Reporting$Result$pure, $author$project$Compiler$Reporting$Result$fmap, $author$project$Compiler$Reporting$Result$liftA2, toCanonicalArg, patterns, args),
				function (verifiedList) {
					if (verifiedList.$ === 'LengthMatch') {
						var cargs = verifiedList.a;
						return (_Utils_eq(tipe, $author$project$Compiler$Data$Name$bool) && _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics)) ? $author$project$Compiler$Reporting$Result$ok(
							A2(
								$author$project$Compiler$AST$Canonical$PBool,
								union,
								_Utils_eq(name, $author$project$Compiler$Data$Name$true))) : $author$project$Compiler$Reporting$Result$ok(
							A6($author$project$Compiler$AST$Canonical$PCtor, home, tipe, union, name, index, cargs));
					} else {
						var actualLength = verifiedList.a;
						var expectedLength = verifiedList.b;
						return $author$project$Compiler$Reporting$Result$throw(
							A5($author$project$Compiler$Reporting$Error$Canonicalize$BadArity, region, $author$project$Compiler$Reporting$Error$Canonicalize$PatternArity, name, expectedLength, actualLength));
					}
				});
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A2($author$project$Compiler$Reporting$Error$Canonicalize$PatternHasRecordCtor, region, name));
		}
	});
var $author$project$Compiler$Canonicalize$Pattern$canonicalizeList = F2(
	function (env, list) {
		if (!list.b) {
			return $author$project$Compiler$Reporting$Result$ok(_List_Nil);
		} else {
			var pattern = list.a;
			var otherPatterns = list.b;
			return A2(
				$author$project$Compiler$Reporting$Result$andMap,
				A2($author$project$Compiler$Canonicalize$Pattern$canonicalizeList, env, otherPatterns),
				A2(
					$author$project$Compiler$Reporting$Result$andMap,
					A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, pattern),
					$author$project$Compiler$Reporting$Result$pure($elm$core$List$cons)));
		}
	});
var $author$project$Compiler$Canonicalize$Pattern$canonicalizeTuple = F3(
	function (tupleRegion, env, extras) {
		if (!extras.b) {
			return $author$project$Compiler$Reporting$Result$ok($elm$core$Maybe$Nothing);
		} else {
			if (!extras.b.b) {
				var three = extras.a;
				return A2(
					$author$project$Compiler$Reporting$Result$fmap,
					$elm$core$Maybe$Just,
					A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, three));
			} else {
				return $author$project$Compiler$Reporting$Result$throw(
					$author$project$Compiler$Reporting$Error$Canonicalize$TupleLargerThanThree(tupleRegion));
			}
		}
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$addField_ = F3(
	function (toValue, _v0, dups) {
		var _v1 = _v0.a;
		var region = _v1.a;
		var name = _v1.b;
		var value = _v0.b;
		return A4(
			$author$project$Extra$Type$Map$insertWith,
			$author$project$Compiler$Data$OneOrMore$more,
			name,
			$author$project$Compiler$Data$OneOrMore$one(
				A2(
					$author$project$Compiler$Canonicalize$Environment$Dups$Info,
					region,
					A2(toValue, region, value))),
			dups);
	});
var $author$project$Compiler$Canonicalize$Environment$Dups$checkFields_ = F2(
	function (toValue, fields) {
		return A2(
			$author$project$Compiler$Canonicalize$Environment$Dups$detect,
			$author$project$Compiler$Reporting$Error$Canonicalize$DuplicateField,
			A3(
				$author$project$Extra$Type$List$foldr,
				$author$project$Compiler$Canonicalize$Environment$Dups$addField_(toValue),
				$author$project$Compiler$Canonicalize$Environment$Dups$none,
				fields));
	});
var $author$project$Compiler$Canonicalize$Expression$Uses = F2(
	function (a, b) {
		return {$: 'Uses', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Expression$combineUses = F2(
	function (_v0, _v1) {
		var a = _v0.a;
		var b = _v0.b;
		var x = _v1.a;
		var y = _v1.b;
		return A2($author$project$Compiler$Canonicalize$Expression$Uses, a + x, b + y);
	});
var $author$project$Compiler$Canonicalize$Expression$delayUse = function (_v0) {
	var direct = _v0.a;
	var delayed = _v0.b;
	return A2($author$project$Compiler$Canonicalize$Expression$Uses, 0, direct + delayed);
};
var $author$project$Compiler$Canonicalize$Expression$delayedUsage = function (_v0) {
	var k = _v0.a;
	return $author$project$Compiler$Reporting$Result$CResult(
		F2(
			function (freeLocals, warnings) {
				var _v1 = A2(k, _Utils_Tuple0, warnings);
				if (_v1.$ === 'Rbad') {
					var ws = _v1.b;
					var es = _v1.c;
					return A3($author$project$Compiler$Reporting$Result$Rbad, freeLocals, ws, es);
				} else {
					var ws = _v1.b;
					var _v2 = _v1.c;
					var value = _v2.a;
					var newFreeLocals = _v2.b;
					var delayedLocals = A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Canonicalize$Expression$delayUse, newFreeLocals);
					return A3(
						$author$project$Compiler$Reporting$Result$Rgood,
						A3($author$project$Extra$Type$Map$unionWith, $author$project$Compiler$Canonicalize$Expression$combineUses, freeLocals, delayedLocals),
						ws,
						value);
				}
			}));
};
var $author$project$Compiler$AST$Canonical$Let = F2(
	function (a, b) {
		return {$: 'Let', a: a, b: b};
	});
var $author$project$Compiler$AST$Canonical$LetDestruct = F3(
	function (a, b, c) {
		return {$: 'LetDestruct', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$LetRec = F2(
	function (a, b) {
		return {$: 'LetRec', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$RecursiveLet = F2(
	function (a, b) {
		return {$: 'RecursiveLet', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Expression$getDefName = function (def) {
	if (def.$ === 'Def') {
		var _v1 = def.a;
		var name = _v1.b;
		return name;
	} else {
		var _v2 = def.a;
		var name = _v2.b;
		return name;
	}
};
var $author$project$Compiler$Canonicalize$Expression$toNames = F2(
	function (bindings, revDefs) {
		toNames:
		while (true) {
			if (!bindings.b) {
				return $author$project$Extra$Type$List$reverse(
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Canonicalize$Expression$getDefName, revDefs));
			} else {
				var binding = bindings.a;
				var otherBindings = bindings.b;
				switch (binding.$) {
					case 'Define':
						var def = binding.a;
						return A2(
							$elm$core$List$cons,
							$author$project$Compiler$Canonicalize$Expression$getDefName(def),
							A2($author$project$Compiler$Canonicalize$Expression$toNames, otherBindings, revDefs));
					case 'Edge':
						var _v2 = binding.a;
						var name = _v2.b;
						return A2(
							$elm$core$List$cons,
							name,
							A2($author$project$Compiler$Canonicalize$Expression$toNames, otherBindings, revDefs));
					default:
						var $temp$bindings = otherBindings,
							$temp$revDefs = revDefs;
						bindings = $temp$bindings;
						revDefs = $temp$revDefs;
						continue toNames;
				}
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$checkCycle = F2(
	function (bindings, defs) {
		checkCycle:
		while (true) {
			if (!bindings.b) {
				return $author$project$Compiler$Reporting$Result$ok(defs);
			} else {
				var binding = bindings.a;
				var otherBindings = bindings.b;
				switch (binding.$) {
					case 'Define':
						if (binding.a.$ === 'Def') {
							var def = binding.a;
							var name = def.a;
							var args = def.b;
							if ($author$project$Extra$Type$List$null(args)) {
								return $author$project$Compiler$Reporting$Result$throw(
									A2(
										$author$project$Compiler$Reporting$Error$Canonicalize$RecursiveLet,
										name,
										A2($author$project$Compiler$Canonicalize$Expression$toNames, otherBindings, defs)));
							} else {
								var $temp$bindings = otherBindings,
									$temp$defs = A2($elm$core$List$cons, def, defs);
								bindings = $temp$bindings;
								defs = $temp$defs;
								continue checkCycle;
							}
						} else {
							var def = binding.a;
							var name = def.a;
							var args = def.c;
							if ($author$project$Extra$Type$List$null(args)) {
								return $author$project$Compiler$Reporting$Result$throw(
									A2(
										$author$project$Compiler$Reporting$Error$Canonicalize$RecursiveLet,
										name,
										A2($author$project$Compiler$Canonicalize$Expression$toNames, otherBindings, defs)));
							} else {
								var $temp$bindings = otherBindings,
									$temp$defs = A2($elm$core$List$cons, def, defs);
								bindings = $temp$bindings;
								defs = $temp$defs;
								continue checkCycle;
							}
						}
					case 'Edge':
						var name = binding.a;
						return $author$project$Compiler$Reporting$Result$throw(
							A2(
								$author$project$Compiler$Reporting$Error$Canonicalize$RecursiveLet,
								name,
								A2($author$project$Compiler$Canonicalize$Expression$toNames, otherBindings, defs)));
					default:
						var $temp$bindings = otherBindings,
							$temp$defs = defs;
						bindings = $temp$bindings;
						defs = $temp$defs;
						continue checkCycle;
				}
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$detectCycles = F3(
	function (letRegion, sccs, body) {
		detectCycles:
		while (true) {
			if (!sccs.b) {
				return $author$project$Compiler$Reporting$Result$ok(body);
			} else {
				var scc = sccs.a;
				var subSccs = sccs.b;
				if (scc.$ === 'AcyclicSCC') {
					var binding = scc.a;
					switch (binding.$) {
						case 'Define':
							var def = binding.a;
							return A2(
								$author$project$Compiler$Reporting$Result$fmap,
								A2(
									$elm$core$Basics$composeL,
									$author$project$Compiler$Reporting$Annotation$At(letRegion),
									$author$project$Compiler$AST$Canonical$Let(def)),
								A3($author$project$Compiler$Canonicalize$Expression$detectCycles, letRegion, subSccs, body));
						case 'Edge':
							var $temp$letRegion = letRegion,
								$temp$sccs = subSccs,
								$temp$body = body;
							letRegion = $temp$letRegion;
							sccs = $temp$sccs;
							body = $temp$body;
							continue detectCycles;
						default:
							var pattern = binding.a;
							var expr = binding.b;
							return A2(
								$author$project$Compiler$Reporting$Result$fmap,
								A2(
									$elm$core$Basics$composeL,
									$author$project$Compiler$Reporting$Annotation$At(letRegion),
									A2($author$project$Compiler$AST$Canonical$LetDestruct, pattern, expr)),
								A3($author$project$Compiler$Canonicalize$Expression$detectCycles, letRegion, subSccs, body));
					}
				} else {
					var bindings = scc.a;
					return A2(
						$author$project$Compiler$Reporting$Result$fmap,
						$author$project$Compiler$Reporting$Annotation$At(letRegion),
						A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A3($author$project$Compiler$Canonicalize$Expression$detectCycles, letRegion, subSccs, body),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Expression$checkCycle, bindings, _List_Nil),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$LetRec))));
				}
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$directUsage = function (_v0) {
	var k = _v0.a;
	return $author$project$Compiler$Reporting$Result$CResult(
		F2(
			function (freeLocals, warnings) {
				var _v1 = A2(k, _Utils_Tuple0, warnings);
				if (_v1.$ === 'Rbad') {
					var ws = _v1.b;
					var es = _v1.c;
					return A3($author$project$Compiler$Reporting$Result$Rbad, freeLocals, ws, es);
				} else {
					var ws = _v1.b;
					var _v2 = _v1.c;
					var value = _v2.a;
					var newFreeLocals = _v2.b;
					return A3(
						$author$project$Compiler$Reporting$Result$Rgood,
						A3($author$project$Extra$Type$Map$unionWith, $author$project$Compiler$Canonicalize$Expression$combineUses, freeLocals, newFreeLocals),
						ws,
						value);
				}
			}));
};
var $author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousBinop = F4(
	function (a, b, c, d) {
		return {$: 'AmbiguousBinop', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$NotFoundBinop = F3(
	function (a, b, c) {
		return {$: 'NotFoundBinop', a: a, b: b, c: c};
	});
var $author$project$Compiler$Canonicalize$Environment$findBinop = F3(
	function (region, _v0, name) {
		var binops = _v0.e;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, name, binops);
		if (_v1.$ === 'Just') {
			if (_v1.a.$ === 'Specific') {
				var _v2 = _v1.a;
				var binop = _v2.b;
				return $author$project$Compiler$Reporting$Result$ok(binop);
			} else {
				var _v3 = _v1.a;
				var h = _v3.a;
				var hs = _v3.b;
				return $author$project$Compiler$Reporting$Result$throw(
					A4($author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousBinop, region, name, h, hs));
			}
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A3(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundBinop,
					region,
					name,
					$author$project$Extra$Type$Map$keysSet(binops)));
		}
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousVar = F5(
	function (a, b, c, d, e) {
		return {$: 'AmbiguousVar', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVar = F4(
	function (a, b, c, d) {
		return {$: 'NotFoundVar', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Canonical$VarDebug = F3(
	function (a, b, c) {
		return {$: 'VarDebug', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$VarForeign = F3(
	function (a, b, c) {
		return {$: 'VarForeign', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$VarLocal = function (a) {
	return {$: 'VarLocal', a: a};
};
var $author$project$Compiler$AST$Canonical$VarTopLevel = F2(
	function (a, b) {
		return {$: 'VarTopLevel', a: a, b: b};
	});
var $author$project$Compiler$Data$Name$debug = 'Debug';
var $author$project$Compiler$Elm$ModuleName$debug = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$debug);
var $author$project$Compiler$Canonicalize$Expression$oneDirectUse = A2($author$project$Compiler$Canonicalize$Expression$Uses, 1, 0);
var $author$project$Compiler$Canonicalize$Expression$logVar = F2(
	function (name, value) {
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (freeLocals, warnings) {
					return A3(
						$author$project$Compiler$Reporting$Result$Rgood,
						A4($author$project$Extra$Type$Map$insertWith, $author$project$Compiler$Canonicalize$Expression$combineUses, name, $author$project$Compiler$Canonicalize$Expression$oneDirectUse, freeLocals),
						warnings,
						value);
				}));
	});
var $author$project$Compiler$Canonicalize$Expression$toPossibleNames = F2(
	function (exposed, qualified) {
		return A2(
			$author$project$Compiler$Reporting$Error$Canonicalize$PossibleNames,
			$author$project$Extra$Type$Map$keysSet(exposed),
			A2($author$project$Extra$Type$Map$map, $author$project$Extra$Type$Map$keysSet, qualified));
	});
var $author$project$Compiler$Canonicalize$Expression$findVar = F3(
	function (region, _v0, name) {
		var localHome = _v0.a;
		var vs = _v0.b;
		var qvs = _v0.f;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, name, vs);
		if (_v1.$ === 'Just') {
			var _var = _v1.a;
			switch (_var.$) {
				case 'Local':
					return A2(
						$author$project$Compiler$Canonicalize$Expression$logVar,
						name,
						$author$project$Compiler$AST$Canonical$VarLocal(name));
				case 'TopLevel':
					return A2(
						$author$project$Compiler$Canonicalize$Expression$logVar,
						name,
						A2($author$project$Compiler$AST$Canonical$VarTopLevel, localHome, name));
				case 'Foreign':
					var home = _var.a;
					var annotation = _var.b;
					return $author$project$Compiler$Reporting$Result$ok(
						_Utils_eq(home, $author$project$Compiler$Elm$ModuleName$debug) ? A3($author$project$Compiler$AST$Canonical$VarDebug, localHome, name, annotation) : A3($author$project$Compiler$AST$Canonical$VarForeign, home, name, annotation));
				default:
					var h = _var.a;
					var hs = _var.b;
					return $author$project$Compiler$Reporting$Result$throw(
						A5($author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousVar, region, $elm$core$Maybe$Nothing, name, h, hs));
			}
		} else {
			return $author$project$Compiler$Reporting$Result$throw(
				A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVar,
					region,
					$elm$core$Maybe$Nothing,
					name,
					A2($author$project$Compiler$Canonicalize$Expression$toPossibleNames, vs, qvs)));
		}
	});
var $author$project$Compiler$AST$Canonical$VarKernel = F2(
	function (a, b) {
		return {$: 'VarKernel', a: a, b: b};
	});
var $author$project$Compiler$Data$Name$prefix_kernel = 'Elm.Kernel.';
var $author$project$Compiler$Data$Utf8$startsWith = $elm$core$String$startsWith;
var $author$project$Compiler$Data$Name$isKernel = $author$project$Compiler$Data$Utf8$startsWith($author$project$Compiler$Data$Name$prefix_kernel);
var $author$project$Compiler$Data$Name$getKernel = function (name) {
	return $author$project$Compiler$Data$Name$isKernel(name) ? A2($elm$core$String$dropLeft, 11, name) : _Debug_todo(
		'Compiler.Data.Name',
		{
			start: {line: 120, column: 9},
			end: {line: 120, column: 19}
		})('getKernel: not a kernel name');
};
var $author$project$Compiler$Elm$ModuleName$getPackage = function (_v0) {
	var pkg = _v0.a;
	return pkg;
};
var $author$project$Compiler$Elm$Package$elm_explorations = 'elm-explorations';
var $author$project$Compiler$Elm$Package$isKernel = function (_v0) {
	var author = _v0.a;
	return _Utils_eq(author, $author$project$Compiler$Elm$Package$elm) || _Utils_eq(author, $author$project$Compiler$Elm$Package$elm_explorations);
};
var $author$project$Compiler$Canonicalize$Expression$findVarQual = F4(
	function (region, _v0, prefix, name) {
		var localHome = _v0.a;
		var vs = _v0.b;
		var qvs = _v0.f;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, prefix, qvs);
		if (_v1.$ === 'Just') {
			var qualified = _v1.a;
			var _v2 = A2($author$project$Extra$Type$Map$lookup, name, qualified);
			if (_v2.$ === 'Just') {
				if (_v2.a.$ === 'Specific') {
					var _v3 = _v2.a;
					var home = _v3.a;
					var annotation = _v3.b;
					return $author$project$Compiler$Reporting$Result$ok(
						_Utils_eq(home, $author$project$Compiler$Elm$ModuleName$debug) ? A3($author$project$Compiler$AST$Canonical$VarDebug, localHome, name, annotation) : A3($author$project$Compiler$AST$Canonical$VarForeign, home, name, annotation));
				} else {
					var _v4 = _v2.a;
					var h = _v4.a;
					var hs = _v4.b;
					return $author$project$Compiler$Reporting$Result$throw(
						A5(
							$author$project$Compiler$Reporting$Error$Canonicalize$AmbiguousVar,
							region,
							$elm$core$Maybe$Just(prefix),
							name,
							h,
							hs));
				}
			} else {
				return $author$project$Compiler$Reporting$Result$throw(
					A4(
						$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVar,
						region,
						$elm$core$Maybe$Just(prefix),
						name,
						A2($author$project$Compiler$Canonicalize$Expression$toPossibleNames, vs, qvs)));
			}
		} else {
			return ($author$project$Compiler$Data$Name$isKernel(prefix) && $author$project$Compiler$Elm$Package$isKernel(
				$author$project$Compiler$Elm$ModuleName$getPackage(localHome))) ? $author$project$Compiler$Reporting$Result$ok(
				A2(
					$author$project$Compiler$AST$Canonical$VarKernel,
					$author$project$Compiler$Data$Name$getKernel(prefix),
					name)) : $author$project$Compiler$Reporting$Result$throw(
				A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$NotFoundVar,
					region,
					$elm$core$Maybe$Just(prefix),
					name,
					A2($author$project$Compiler$Canonicalize$Expression$toPossibleNames, vs, qvs)));
		}
	});
var $author$project$Compiler$Data$Index$first = $author$project$Compiler$Data$Index$ZeroBased(0);
var $author$project$Compiler$Data$Name$blank = '_M$';
var $author$project$Compiler$Data$Name$fromManyNames = function (names) {
	if (!names.b) {
		return $author$project$Compiler$Data$Name$blank;
	} else {
		var name = names.a;
		return '_M$' + name;
	}
};
var $author$project$Compiler$Reporting$Error$Canonicalize$AnnotationTooShort = F4(
	function (a, b, c, d) {
		return {$: 'AnnotationTooShort', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$AST$Utils$Type$iteratedDealias = function (tipe) {
	iteratedDealias:
	while (true) {
		if (tipe.$ === 'TAlias') {
			var args = tipe.c;
			var realType = tipe.d;
			var $temp$tipe = A2($author$project$Compiler$AST$Utils$Type$dealias, args, realType);
			tipe = $temp$tipe;
			continue iteratedDealias;
		} else {
			return tipe;
		}
	}
};
var $author$project$Compiler$Data$Index$next = function (_v0) {
	var i = _v0.a;
	return $author$project$Compiler$Data$Index$ZeroBased(i + 1);
};
var $author$project$Compiler$Canonicalize$Expression$gatherTypedArgs = F6(
	function (env, name, srcArgs, tipe, index, revTypedArgs) {
		if (!srcArgs.b) {
			return $author$project$Compiler$Reporting$Result$return(
				_Utils_Tuple2(
					$author$project$Extra$Type$List$reverse(revTypedArgs),
					tipe));
		} else {
			var srcArg = srcArgs.a;
			var otherSrcArgs = srcArgs.b;
			var _v1 = $author$project$Compiler$AST$Utils$Type$iteratedDealias(tipe);
			if (_v1.$ === 'TLambda') {
				var argType = _v1.a;
				var resultType = _v1.b;
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, srcArg),
					function (arg) {
						return A6(
							$author$project$Compiler$Canonicalize$Expression$gatherTypedArgs,
							env,
							name,
							otherSrcArgs,
							resultType,
							$author$project$Compiler$Data$Index$next(index),
							A2(
								$elm$core$List$cons,
								_Utils_Tuple2(arg, argType),
								revTypedArgs));
					});
			} else {
				var _v2 = _Utils_Tuple2(
					$author$project$Extra$Type$List$head(srcArgs),
					$author$project$Extra$Type$List$last(srcArgs));
				var _v3 = _v2.a;
				var start = _v3.a;
				var _v4 = _v2.b;
				var end = _v4.a;
				return $author$project$Compiler$Reporting$Result$throw(
					A4(
						$author$project$Compiler$Reporting$Error$Canonicalize$AnnotationTooShort,
						A2($author$project$Compiler$Reporting$Annotation$mergeRegions, start, end),
						name,
						index,
						$author$project$Extra$Type$List$length(srcArgs)));
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$getPatternNames = F2(
	function (names, _v0) {
		getPatternNames:
		while (true) {
			var region = _v0.a;
			var pattern = _v0.b;
			switch (pattern.$) {
				case 'PAnything':
					return names;
				case 'PVar':
					var name = pattern.a;
					return A2(
						$elm$core$List$cons,
						A2($author$project$Compiler$Reporting$Annotation$At, region, name),
						names);
				case 'PRecord':
					var fields = pattern.a;
					return _Utils_ap(fields, names);
				case 'PAlias':
					var ptrn = pattern.a;
					var name = pattern.b;
					var $temp$names = A2($elm$core$List$cons, name, names),
						$temp$_v0 = ptrn;
					names = $temp$names;
					_v0 = $temp$_v0;
					continue getPatternNames;
				case 'PUnit':
					return names;
				case 'PTuple':
					var a = pattern.a;
					var b = pattern.b;
					var cs = pattern.c;
					return A3(
						$author$project$Extra$Type$List$foldl,
						$author$project$Compiler$Canonicalize$Expression$getPatternNames,
						A2(
							$author$project$Compiler$Canonicalize$Expression$getPatternNames,
							A2($author$project$Compiler$Canonicalize$Expression$getPatternNames, names, a),
							b),
						cs);
				case 'PCtor':
					var args = pattern.c;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$getPatternNames, names, args);
				case 'PCtorQual':
					var args = pattern.d;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$getPatternNames, names, args);
				case 'PList':
					var patterns = pattern.a;
					return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$getPatternNames, names, patterns);
				case 'PCons':
					var hd = pattern.a;
					var tl = pattern.b;
					var $temp$names = A2($author$project$Compiler$Canonicalize$Expression$getPatternNames, names, hd),
						$temp$_v0 = tl;
					names = $temp$names;
					_v0 = $temp$_v0;
					continue getPatternNames;
				case 'PChr':
					return names;
				case 'PStr':
					return names;
				default:
					return names;
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$logLetLocals = F3(
	function (args, letLocals, value) {
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (freeLocals, warnings) {
					return A3(
						$author$project$Compiler$Reporting$Result$Rgood,
						A3(
							$author$project$Extra$Type$Map$unionWith,
							$author$project$Compiler$Canonicalize$Expression$combineUses,
							freeLocals,
							function () {
								if (!args.b) {
									return letLocals;
								} else {
									return A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Canonicalize$Expression$delayUse, letLocals);
								}
							}()),
						warnings,
						value);
				}));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$Binop = F3(
	function (a, b, c) {
		return {$: 'Binop', a: a, b: b, c: c};
	});
var $author$project$Compiler$AST$Canonical$Binop = F6(
	function (a, b, c, d, e, f) {
		return {$: 'Binop', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Compiler$Canonicalize$Expression$toBinop = F3(
	function (_v0, left, right) {
		var op = _v0.a;
		var home = _v0.b;
		var name = _v0.c;
		var annotation = _v0.d;
		return A3(
			$author$project$Compiler$Reporting$Annotation$merge,
			left,
			right,
			A6($author$project$Compiler$AST$Canonical$Binop, op, home, name, annotation, left, right));
	});
var $author$project$Compiler$Canonicalize$Expression$Done = function (a) {
	return {$: 'Done', a: a};
};
var $author$project$Compiler$Canonicalize$Expression$Error = F2(
	function (a, b) {
		return {$: 'Error', a: a, b: b};
	});
var $author$project$Compiler$AST$Utils$Binop$toInt = function (_v0) {
	var n = _v0.a;
	return n;
};
var $author$project$Compiler$Canonicalize$Expression$toBinopStep = F4(
	function (makeBinop, rootOp, middle, _final) {
		toBinopStep:
		while (true) {
			var rootAssociativity = rootOp.e;
			var rootPrecedence = rootOp.f;
			if (!middle.b) {
				return $author$project$Compiler$Canonicalize$Expression$Done(
					makeBinop(_final));
			} else {
				var _v1 = middle.a;
				var expr = _v1.a;
				var op = _v1.b;
				var associativity = op.e;
				var precedence = op.f;
				var rest = middle.b;
				if (_Utils_cmp(
					$author$project$Compiler$AST$Utils$Binop$toInt(precedence),
					$author$project$Compiler$AST$Utils$Binop$toInt(rootPrecedence)) < 0) {
					return A2(
						$author$project$Compiler$Canonicalize$Expression$More,
						A2(
							$elm$core$List$cons,
							_Utils_Tuple2(
								makeBinop(expr),
								op),
							rest),
						_final);
				} else {
					if (_Utils_cmp(
						$author$project$Compiler$AST$Utils$Binop$toInt(precedence),
						$author$project$Compiler$AST$Utils$Binop$toInt(rootPrecedence)) > 0) {
						var _v2 = A4(
							$author$project$Compiler$Canonicalize$Expression$toBinopStep,
							A2($author$project$Compiler$Canonicalize$Expression$toBinop, op, expr),
							op,
							rest,
							_final);
						switch (_v2.$) {
							case 'Done':
								var newLast = _v2.a;
								return $author$project$Compiler$Canonicalize$Expression$Done(
									makeBinop(newLast));
							case 'More':
								var newMiddle = _v2.a;
								var newLast = _v2.b;
								var $temp$makeBinop = makeBinop,
									$temp$rootOp = rootOp,
									$temp$middle = newMiddle,
									$temp$final = newLast;
								makeBinop = $temp$makeBinop;
								rootOp = $temp$rootOp;
								middle = $temp$middle;
								_final = $temp$final;
								continue toBinopStep;
							default:
								var a = _v2.a;
								var b = _v2.b;
								return A2($author$project$Compiler$Canonicalize$Expression$Error, a, b);
						}
					} else {
						var _v3 = _Utils_Tuple2(rootAssociativity, associativity);
						_v3$2:
						while (true) {
							switch (_v3.a.$) {
								case 'Left':
									if (_v3.b.$ === 'Left') {
										var _v4 = _v3.a;
										var _v5 = _v3.b;
										return function (_v6) {
											return A4(
												$author$project$Compiler$Canonicalize$Expression$toBinopStep,
												function (right) {
													return A3(
														$author$project$Compiler$Canonicalize$Expression$toBinop,
														op,
														makeBinop(expr),
														right);
												},
												op,
												rest,
												_final);
										}(_Utils_Tuple0);
									} else {
										break _v3$2;
									}
								case 'Right':
									if (_v3.b.$ === 'Right') {
										var _v7 = _v3.a;
										var _v8 = _v3.b;
										return function (_v9) {
											return A4(
												$author$project$Compiler$Canonicalize$Expression$toBinopStep,
												function (right) {
													return makeBinop(
														A3($author$project$Compiler$Canonicalize$Expression$toBinop, op, expr, right));
												},
												op,
												rest,
												_final);
										}(_Utils_Tuple0);
									} else {
										break _v3$2;
									}
								default:
									break _v3$2;
							}
						}
						return A2($author$project$Compiler$Canonicalize$Expression$Error, rootOp, op);
					}
				}
			}
		}
	});
var $author$project$Compiler$Canonicalize$Expression$runBinopStepper = F2(
	function (overallRegion, step) {
		switch (step.$) {
			case 'Done':
				var expr = step.a;
				return $author$project$Compiler$Reporting$Result$ok(expr);
			case 'More':
				if (!step.a.b) {
					var expr = step.b;
					return $author$project$Compiler$Reporting$Result$ok(expr);
				} else {
					var _v1 = step.a;
					var _v2 = _v1.a;
					var expr = _v2.a;
					var op = _v2.b;
					var rest = _v1.b;
					var _final = step.b;
					return A2(
						$author$project$Compiler$Canonicalize$Expression$runBinopStepper,
						overallRegion,
						A4(
							$author$project$Compiler$Canonicalize$Expression$toBinopStep,
							A2($author$project$Compiler$Canonicalize$Expression$toBinop, op, expr),
							op,
							rest,
							_final));
				}
			default:
				var _v3 = step.a;
				var op1 = _v3.a;
				var _v4 = step.b;
				var op2 = _v4.a;
				return $author$project$Compiler$Reporting$Result$throw(
					A3($author$project$Compiler$Reporting$Error$Canonicalize$Binop, overallRegion, op1, op2));
		}
	});
var $author$project$Compiler$AST$Canonical$VarCtor = F5(
	function (a, b, c, d, e) {
		return {$: 'VarCtor', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Canonicalize$Expression$toVarCtor = F2(
	function (name, ctor) {
		if (ctor.$ === 'Ctor') {
			var home = ctor.a;
			var typeName = ctor.b;
			var _v1 = ctor.c;
			var vars = _v1.a;
			var opts = _v1.d;
			var index = ctor.d;
			var args = ctor.e;
			var result = A3(
				$author$project$Compiler$AST$Canonical$TType,
				home,
				typeName,
				A2($author$project$Extra$Type$List$map, $author$project$Compiler$AST$Canonical$TVar, vars));
			var tipe = A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Canonical$TLambda, result, args);
			var freeVars = $author$project$Extra$Type$Map$fromList(
				A2(
					$author$project$Extra$Type$List$map,
					function (v) {
						return _Utils_Tuple2(v, _Utils_Tuple0);
					},
					vars));
			return A5(
				$author$project$Compiler$AST$Canonical$VarCtor,
				opts,
				home,
				name,
				index,
				A2($author$project$Compiler$AST$Canonical$Forall, freeVars, tipe));
		} else {
			var home = ctor.a;
			var vars = ctor.b;
			var tipe = ctor.c;
			var freeVars = $author$project$Extra$Type$Map$fromList(
				A2(
					$author$project$Extra$Type$List$map,
					function (v) {
						return _Utils_Tuple2(v, _Utils_Tuple0);
					},
					vars));
			return A5(
				$author$project$Compiler$AST$Canonical$VarCtor,
				$author$project$Compiler$AST$Canonical$Normal,
				home,
				name,
				$author$project$Compiler$Data$Index$first,
				A2($author$project$Compiler$AST$Canonical$Forall, freeVars, tipe));
		}
	});
var $author$project$Compiler$Reporting$Result$traverseMapHelp = F2(
	function (callback, _v0) {
		var pairs = _v0.a;
		var result = _v0.b;
		if (!pairs.b) {
			return $author$project$Compiler$Reporting$Result$return(
				$author$project$Compiler$Reporting$Result$Done(result));
		} else {
			var _v2 = pairs.a;
			var k = _v2.a;
			var a = _v2.b;
			var rest = pairs.b;
			return A2(
				$author$project$Compiler$Reporting$Result$fmap,
				function (b) {
					return $author$project$Compiler$Reporting$Result$Loop(
						_Utils_Tuple2(
							rest,
							A3($author$project$Extra$Type$Map$insert, k, b, result)));
				},
				callback(a));
		}
	});
var $author$project$Compiler$Reporting$Result$traverseMap = F2(
	function (callback, map) {
		return A2(
			$author$project$Compiler$Reporting$Result$loop,
			$author$project$Compiler$Reporting$Result$traverseMapHelp(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$Map$toList(map),
				$author$project$Extra$Type$Map$empty));
	});
var $author$project$Compiler$Canonicalize$Pattern$verify = F2(
	function (context, _v0) {
		var k = _v0.a;
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (info, warnings) {
					var _v1 = A2(k, $author$project$Compiler$Canonicalize$Environment$Dups$none, warnings);
					if (_v1.$ === 'Rbad') {
						var warnings1 = _v1.b;
						var errors = _v1.c;
						return A3($author$project$Compiler$Reporting$Result$Rbad, info, warnings1, errors);
					} else {
						var bindings = _v1.a;
						var warnings1 = _v1.b;
						var value = _v1.c;
						var _v2 = A2(
							$author$project$Compiler$Canonicalize$Environment$Dups$detect,
							$author$project$Compiler$Reporting$Error$Canonicalize$DuplicatePattern(context),
							bindings);
						var k1 = _v2.a;
						var _v3 = A2(k1, _Utils_Tuple0, _Utils_Tuple0);
						if (_v3.$ === 'Rbad') {
							var errs = _v3.c;
							return A3($author$project$Compiler$Reporting$Result$Rbad, info, warnings1, errs);
						} else {
							var dict = _v3.c;
							return A3(
								$author$project$Compiler$Reporting$Result$Rgood,
								info,
								warnings1,
								_Utils_Tuple2(value, dict));
						}
					}
				}));
	});
var $author$project$Compiler$Reporting$Warning$UnusedVariable = {$: 'UnusedVariable'};
var $author$project$Compiler$Canonicalize$Expression$addUnusedWarning = F4(
	function (_v0, warnings, _v1, _v2) {
		return A2($elm$core$List$cons, $author$project$Compiler$Reporting$Warning$UnusedVariable, warnings);
	});
var $author$project$Compiler$Canonicalize$Expression$verifyBindings = F3(
	function (context, bindings, _v0) {
		var k = _v0.a;
		return $author$project$Compiler$Reporting$Result$CResult(
			F2(
				function (info, warnings) {
					var _v1 = A2(k, $author$project$Extra$Type$Map$empty, warnings);
					if (_v1.$ === 'Rbad') {
						var warnings1 = _v1.b;
						var err = _v1.c;
						return A3($author$project$Compiler$Reporting$Result$Rbad, info, warnings1, err);
					} else {
						var freeLocals = _v1.a;
						var warnings1 = _v1.b;
						var value = _v1.c;
						var outerFreeLocals = A2($author$project$Extra$Type$Map$difference, freeLocals, bindings);
						var warnings2 = _Utils_eq(
							$author$project$Extra$Type$Map$size(bindings) + $author$project$Extra$Type$Map$size(outerFreeLocals),
							$author$project$Extra$Type$Map$size(freeLocals)) ? warnings1 : A3(
							$author$project$Extra$Type$Map$foldlWithKey,
							$author$project$Compiler$Canonicalize$Expression$addUnusedWarning(context),
							warnings1,
							A2($author$project$Extra$Type$Map$difference, bindings, freeLocals));
						return A3(
							$author$project$Compiler$Reporting$Result$Rgood,
							info,
							warnings2,
							_Utils_Tuple2(value, outerFreeLocals));
					}
				}));
	});
var $author$project$Compiler$Canonicalize$Expression$addDefNodes = F3(
	function (env, nodes, _v15) {
		var def = _v15.b;
		if (def.$ === 'Define') {
			var aname = def.a;
			var name = aname.b;
			var srcArgs = def.b;
			var body = def.c;
			var maybeType = def.d;
			if (maybeType.$ === 'Nothing') {
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2(
						$author$project$Compiler$Canonicalize$Pattern$verify,
						$author$project$Compiler$Reporting$Error$Canonicalize$DPFuncArgs(name),
						A2(
							$author$project$Compiler$Reporting$Result$traverseList,
							$author$project$Compiler$Canonicalize$Pattern$canonicalize(env),
							srcArgs)),
					function (_v18) {
						var args = _v18.a;
						var argBindings = _v18.b;
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							A2($author$project$Compiler$Canonicalize$Environment$addLocals, argBindings, env),
							function (newEnv) {
								return A2(
									$author$project$Compiler$Reporting$Result$bind,
									A3(
										$author$project$Compiler$Canonicalize$Expression$verifyBindings,
										$author$project$Compiler$Reporting$Warning$Pattern,
										argBindings,
										A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, body)),
									function (_v19) {
										var cbody = _v19.a;
										var freeLocals = _v19.b;
										var cdef = A3($author$project$Compiler$AST$Canonical$Def, aname, args, cbody);
										var node = _Utils_Tuple3(
											$author$project$Compiler$Canonicalize$Expression$Define(cdef),
											name,
											$author$project$Extra$Type$Map$keys(freeLocals));
										return A3(
											$author$project$Compiler$Canonicalize$Expression$logLetLocals,
											args,
											freeLocals,
											A2($elm$core$List$cons, node, nodes));
									});
							});
					});
			} else {
				var tipe = maybeType.a;
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2($author$project$Compiler$Canonicalize$Type$toAnnotation, env, tipe),
					function (_v20) {
						var freeVars = _v20.a;
						var ctipe = _v20.b;
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							A2(
								$author$project$Compiler$Canonicalize$Pattern$verify,
								$author$project$Compiler$Reporting$Error$Canonicalize$DPFuncArgs(name),
								A6($author$project$Compiler$Canonicalize$Expression$gatherTypedArgs, env, name, srcArgs, ctipe, $author$project$Compiler$Data$Index$first, _List_Nil)),
							function (_v21) {
								var _v22 = _v21.a;
								var args = _v22.a;
								var resultType = _v22.b;
								var argBindings = _v21.b;
								return A2(
									$author$project$Compiler$Reporting$Result$bind,
									A2($author$project$Compiler$Canonicalize$Environment$addLocals, argBindings, env),
									function (newEnv) {
										return A2(
											$author$project$Compiler$Reporting$Result$bind,
											A3(
												$author$project$Compiler$Canonicalize$Expression$verifyBindings,
												$author$project$Compiler$Reporting$Warning$Pattern,
												argBindings,
												A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, body)),
											function (_v23) {
												var cbody = _v23.a;
												var freeLocals = _v23.b;
												var cdef = A5($author$project$Compiler$AST$Canonical$TypedDef, aname, freeVars, args, cbody, resultType);
												var node = _Utils_Tuple3(
													$author$project$Compiler$Canonicalize$Expression$Define(cdef),
													name,
													$author$project$Extra$Type$Map$keys(freeLocals));
												return A3(
													$author$project$Compiler$Canonicalize$Expression$logLetLocals,
													args,
													freeLocals,
													A2($elm$core$List$cons, node, nodes));
											});
									});
							});
					});
			}
		} else {
			var pattern = def.a;
			var body = def.b;
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2(
					$author$project$Compiler$Canonicalize$Pattern$verify,
					$author$project$Compiler$Reporting$Error$Canonicalize$DPDestruct,
					A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, pattern)),
				function (_v24) {
					var cpattern = _v24.a;
					return $author$project$Compiler$Reporting$Result$CResult(
						F2(
							function (fs, ws) {
								var _v25 = A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, body);
								var k = _v25.a;
								var _v26 = A2(k, $author$project$Extra$Type$Map$empty, ws);
								if (_v26.$ === 'Rbad') {
									var freeLocals = _v26.a;
									var warnings = _v26.b;
									var errors = _v26.c;
									return A3(
										$author$project$Compiler$Reporting$Result$Rbad,
										A3($author$project$Extra$Type$Map$unionWith, $author$project$Compiler$Canonicalize$Expression$combineUses, freeLocals, fs),
										warnings,
										errors);
								} else {
									var freeLocals = _v26.a;
									var warnings = _v26.b;
									var cbody = _v26.c;
									var names = A2($author$project$Compiler$Canonicalize$Expression$getPatternNames, _List_Nil, pattern);
									var name = $author$project$Compiler$Data$Name$fromManyNames(
										A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Annotation$toValue, names));
									var node = _Utils_Tuple3(
										A2($author$project$Compiler$Canonicalize$Expression$Destruct, cpattern, cbody),
										name,
										$author$project$Extra$Type$Map$keys(freeLocals));
									return A3(
										$author$project$Compiler$Reporting$Result$Rgood,
										A3($author$project$Extra$Type$Map$unionWith, $author$project$Compiler$Canonicalize$Expression$combineUses, fs, freeLocals),
										warnings,
										A3(
											$author$project$Extra$Type$List$foldl,
											$author$project$Compiler$Canonicalize$Expression$addEdge(
												_List_fromArray(
													[name])),
											A2($elm$core$List$cons, node, nodes),
											names));
								}
							}));
				});
		}
	});
var $author$project$Compiler$Canonicalize$Expression$canonicalize = F2(
	function (env, _v7) {
		var region = _v7.a;
		var expression = _v7.b;
		return A2(
			$author$project$Compiler$Reporting$Result$fmap,
			$author$project$Compiler$Reporting$Annotation$At(region),
			function () {
				switch (expression.$) {
					case 'Str':
						var string = expression.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$Str(string));
					case 'Chr':
						var _char = expression.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$Chr(_char));
					case 'CInt':
						var _int = expression.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$CInt(_int));
					case 'CFloat':
						var _float = expression.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$CFloat(_float));
					case 'Var':
						var varType = expression.a;
						var name = expression.b;
						if (varType.$ === 'LowVar') {
							return A3($author$project$Compiler$Canonicalize$Expression$findVar, region, env, name);
						} else {
							return A2(
								$author$project$Compiler$Reporting$Result$fmap,
								$author$project$Compiler$Canonicalize$Expression$toVarCtor(name),
								A3($author$project$Compiler$Canonicalize$Environment$findCtor, region, env, name));
						}
					case 'VarQual':
						var varType = expression.a;
						var prefix = expression.b;
						var name = expression.c;
						if (varType.$ === 'LowVar') {
							return A4($author$project$Compiler$Canonicalize$Expression$findVarQual, region, env, prefix, name);
						} else {
							return A2(
								$author$project$Compiler$Reporting$Result$fmap,
								$author$project$Compiler$Canonicalize$Expression$toVarCtor(name),
								A4($author$project$Compiler$Canonicalize$Environment$findCtorQual, region, env, prefix, name));
						}
					case 'CList':
						var exprs = expression.a;
						return A2(
							$author$project$Compiler$Reporting$Result$fmap,
							$author$project$Compiler$AST$Canonical$CList,
							A2(
								$author$project$Compiler$Reporting$Result$traverseList,
								$author$project$Compiler$Canonicalize$Expression$canonicalize(env),
								exprs));
					case 'Op':
						var op = expression.a;
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							A3($author$project$Compiler$Canonicalize$Environment$findBinop, region, env, op),
							function (_v11) {
								var home = _v11.b;
								var name = _v11.c;
								var annotation = _v11.d;
								return $author$project$Compiler$Reporting$Result$return(
									A4($author$project$Compiler$AST$Canonical$VarOperator, op, home, name, annotation));
							});
					case 'Negate':
						var expr = expression.a;
						return A2(
							$author$project$Compiler$Reporting$Result$fmap,
							$author$project$Compiler$AST$Canonical$Negate,
							A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, expr));
					case 'Binops':
						var ops = expression.a;
						var _final = expression.b;
						return A2(
							$author$project$Compiler$Reporting$Result$fmap,
							$author$project$Compiler$Reporting$Annotation$toValue,
							A4($author$project$Compiler$Canonicalize$Expression$canonicalizeBinops, region, env, ops, _final));
					case 'Lambda':
						var srcArgs = expression.a;
						var body = expression.b;
						return $author$project$Compiler$Canonicalize$Expression$delayedUsage(
							A2(
								$author$project$Compiler$Reporting$Result$bind,
								A2(
									$author$project$Compiler$Canonicalize$Pattern$verify,
									$author$project$Compiler$Reporting$Error$Canonicalize$DPLambdaArgs,
									A2(
										$author$project$Compiler$Reporting$Result$traverseList,
										$author$project$Compiler$Canonicalize$Pattern$canonicalize(env),
										srcArgs)),
								function (_v12) {
									var args = _v12.a;
									var bindings = _v12.b;
									return A2(
										$author$project$Compiler$Reporting$Result$bind,
										A2($author$project$Compiler$Canonicalize$Environment$addLocals, bindings, env),
										function (newEnv) {
											return A2(
												$author$project$Compiler$Reporting$Result$bind,
												A3(
													$author$project$Compiler$Canonicalize$Expression$verifyBindings,
													$author$project$Compiler$Reporting$Warning$Pattern,
													bindings,
													A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, body)),
												function (_v13) {
													var cbody = _v13.a;
													var freeLocals = _v13.b;
													return $author$project$Compiler$Reporting$Result$return(
														_Utils_Tuple2(
															A2($author$project$Compiler$AST$Canonical$Lambda, args, cbody),
															freeLocals));
												});
										});
								}));
					case 'Call':
						var func = expression.a;
						var args = expression.b;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A2(
								$author$project$Compiler$Reporting$Result$traverseList,
								$author$project$Compiler$Canonicalize$Expression$canonicalize(env),
								args),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, func),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$Call)));
					case 'If':
						var branches = expression.a;
						var _finally = expression.b;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, _finally),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2(
									$author$project$Compiler$Reporting$Result$traverseList,
									$author$project$Compiler$Canonicalize$Expression$canonicalizeIfBranch(env),
									branches),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$If)));
					case 'Let':
						var defs = expression.a;
						var expr = expression.b;
						return A2(
							$author$project$Compiler$Reporting$Result$fmap,
							$author$project$Compiler$Reporting$Annotation$toValue,
							A4($author$project$Compiler$Canonicalize$Expression$canonicalizeLet, region, env, defs, expr));
					case 'Case':
						var expr = expression.a;
						var branches = expression.b;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A2(
								$author$project$Compiler$Reporting$Result$traverseList,
								$author$project$Compiler$Canonicalize$Expression$canonicalizeCaseBranch(env),
								branches),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, expr),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$Case)));
					case 'Accessor':
						var field = expression.a;
						return $author$project$Compiler$Reporting$Result$ok(
							$author$project$Compiler$AST$Canonical$Accessor(field));
					case 'Access':
						var record = expression.a;
						var field = expression.b;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							$author$project$Compiler$Reporting$Result$ok(field),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, record),
								$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$Access)));
					case 'Update':
						var _v14 = expression.a;
						var reg = _v14.a;
						var name = _v14.b;
						var fields = expression.b;
						var makeCanFields = A2(
							$author$project$Compiler$Canonicalize$Environment$Dups$checkFields_,
							F2(
								function (r, t) {
									return A2(
										$author$project$Compiler$Reporting$Result$fmap,
										$author$project$Compiler$AST$Canonical$FieldUpdate(r),
										A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, t));
								}),
							fields);
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A2($author$project$Compiler$Reporting$Result$andThen, $author$project$Compiler$Reporting$Result$sequenceAMap, makeCanFields),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2(
									$author$project$Compiler$Reporting$Result$fmap,
									$author$project$Compiler$Reporting$Annotation$At(reg),
									A3($author$project$Compiler$Canonicalize$Expression$findVar, reg, env, name)),
								$author$project$Compiler$Reporting$Result$pure(
									$author$project$Compiler$AST$Canonical$Update(name))));
					case 'Record':
						var fields = expression.a;
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							$author$project$Compiler$Canonicalize$Environment$Dups$checkFields(fields),
							function (fieldDict) {
								return A2(
									$author$project$Compiler$Reporting$Result$fmap,
									$author$project$Compiler$AST$Canonical$Record,
									A2(
										$author$project$Compiler$Reporting$Result$traverseMap,
										$author$project$Compiler$Canonicalize$Expression$canonicalize(env),
										fieldDict));
							});
					case 'Unit':
						return $author$project$Compiler$Reporting$Result$ok($author$project$Compiler$AST$Canonical$Unit);
					case 'Tuple':
						var a = expression.a;
						var b = expression.b;
						var cs = expression.c;
						return A2(
							$author$project$Compiler$Reporting$Result$andMap,
							A3($author$project$Compiler$Canonicalize$Expression$canonicalizeTupleExtras, region, env, cs),
							A2(
								$author$project$Compiler$Reporting$Result$andMap,
								A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, b),
								A2(
									$author$project$Compiler$Reporting$Result$andMap,
									A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, a),
									$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$AST$Canonical$Tuple))));
					default:
						var src = expression.a;
						var tipe = expression.b;
						return $author$project$Compiler$Reporting$Result$ok(
							A2($author$project$Compiler$AST$Canonical$Shader, src, tipe));
				}
			}());
	});
var $author$project$Compiler$Canonicalize$Expression$canonicalizeBinops = F4(
	function (overallRegion, env, ops, _final) {
		var canonicalizeHelp = function (_v5) {
			var expr = _v5.a;
			var _v6 = _v5.b;
			var region = _v6.a;
			var op = _v6.b;
			return A2(
				$author$project$Compiler$Reporting$Result$andMap,
				A3($author$project$Compiler$Canonicalize$Environment$findBinop, region, env, op),
				A2(
					$author$project$Compiler$Reporting$Result$andMap,
					A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, expr),
					$author$project$Compiler$Reporting$Result$pure($elm$core$Tuple$pair)));
		};
		return A2(
			$author$project$Compiler$Reporting$Result$andThen,
			$author$project$Compiler$Canonicalize$Expression$runBinopStepper(overallRegion),
			A2(
				$author$project$Compiler$Reporting$Result$andMap,
				A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, _final),
				A2(
					$author$project$Compiler$Reporting$Result$andMap,
					A2($author$project$Compiler$Reporting$Result$traverseList, canonicalizeHelp, ops),
					$author$project$Compiler$Reporting$Result$pure($author$project$Compiler$Canonicalize$Expression$More))));
	});
var $author$project$Compiler$Canonicalize$Expression$canonicalizeCaseBranch = F2(
	function (env, _v2) {
		var pattern = _v2.a;
		var expr = _v2.b;
		return $author$project$Compiler$Canonicalize$Expression$directUsage(
			A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2(
					$author$project$Compiler$Canonicalize$Pattern$verify,
					$author$project$Compiler$Reporting$Error$Canonicalize$DPCaseBranch,
					A2($author$project$Compiler$Canonicalize$Pattern$canonicalize, env, pattern)),
				function (_v3) {
					var cpattern = _v3.a;
					var bindings = _v3.b;
					return A2(
						$author$project$Compiler$Reporting$Result$bind,
						A2($author$project$Compiler$Canonicalize$Environment$addLocals, bindings, env),
						function (newEnv) {
							return A2(
								$author$project$Compiler$Reporting$Result$bind,
								A3(
									$author$project$Compiler$Canonicalize$Expression$verifyBindings,
									$author$project$Compiler$Reporting$Warning$Pattern,
									bindings,
									A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, expr)),
								function (_v4) {
									var cexpr = _v4.a;
									var freeLocals = _v4.b;
									return $author$project$Compiler$Reporting$Result$return(
										_Utils_Tuple2(
											A2($author$project$Compiler$AST$Canonical$CaseBranch, cpattern, cexpr),
											freeLocals));
								});
						});
				}));
	});
var $author$project$Compiler$Canonicalize$Expression$canonicalizeIfBranch = F2(
	function (env, _v1) {
		var condition = _v1.a;
		var branch = _v1.b;
		return A2(
			$author$project$Compiler$Reporting$Result$andMap,
			A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, branch),
			A2(
				$author$project$Compiler$Reporting$Result$andMap,
				A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, condition),
				$author$project$Compiler$Reporting$Result$pure($elm$core$Tuple$pair)));
	});
var $author$project$Compiler$Canonicalize$Expression$canonicalizeLet = F4(
	function (letRegion, env, defs, body) {
		return $author$project$Compiler$Canonicalize$Expression$directUsage(
			A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2(
					$author$project$Compiler$Canonicalize$Environment$Dups$detect,
					$author$project$Compiler$Reporting$Error$Canonicalize$DuplicatePattern($author$project$Compiler$Reporting$Error$Canonicalize$DPLetBinding),
					A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Canonicalize$Expression$addBindings, $author$project$Compiler$Canonicalize$Environment$Dups$none, defs)),
				function (bindings) {
					return A2(
						$author$project$Compiler$Reporting$Result$bind,
						A2($author$project$Compiler$Canonicalize$Environment$addLocals, bindings, env),
						function (newEnv) {
							return A3(
								$author$project$Compiler$Canonicalize$Expression$verifyBindings,
								$author$project$Compiler$Reporting$Warning$Def,
								bindings,
								A2(
									$author$project$Compiler$Reporting$Result$bind,
									A3(
										$author$project$Compiler$Reporting$Result$foldM,
										$author$project$Compiler$Canonicalize$Expression$addDefNodes(newEnv),
										_List_Nil,
										defs),
									function (nodes) {
										return A2(
											$author$project$Compiler$Reporting$Result$bind,
											A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, body),
											function (cbody) {
												return A3(
													$author$project$Compiler$Canonicalize$Expression$detectCycles,
													letRegion,
													$author$project$Extra$Data$Graph$stronglyConnComp(nodes),
													cbody);
											});
									}));
						});
				}));
	});
var $author$project$Compiler$Canonicalize$Expression$canonicalizeTupleExtras = F3(
	function (region, env, extras) {
		if (!extras.b) {
			return $author$project$Compiler$Reporting$Result$ok($elm$core$Maybe$Nothing);
		} else {
			if (!extras.b.b) {
				var three = extras.a;
				return A2(
					$author$project$Compiler$Reporting$Result$fmap,
					$elm$core$Maybe$Just,
					A2($author$project$Compiler$Canonicalize$Expression$canonicalize, env, three));
			} else {
				return $author$project$Compiler$Reporting$Result$throw(
					$author$project$Compiler$Reporting$Error$Canonicalize$TupleLargerThanThree(region));
			}
		}
	});
var $author$project$Compiler$Canonicalize$Module$addDirects = F3(
	function (name, _v0, directDeps) {
		var directUses = _v0.a;
		return (directUses > 0) ? A2($elm$core$List$cons, name, directDeps) : directDeps;
	});
var $author$project$Compiler$Canonicalize$Module$toNodeTwo = F4(
	function (name, args, def, freeLocals) {
		if (!args.b) {
			return _Utils_Tuple3(
				def,
				name,
				A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Compiler$Canonicalize$Module$addDirects, _List_Nil, freeLocals));
		} else {
			return _Utils_Tuple3(def, name, _List_Nil);
		}
	});
var $author$project$Compiler$Canonicalize$Module$toNodeOne = F2(
	function (env, _v0) {
		var _v1 = _v0.b;
		var aname = _v1.a;
		var name = aname.b;
		var srcArgs = _v1.b;
		var body = _v1.c;
		var maybeType = _v1.d;
		if (maybeType.$ === 'Nothing') {
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2(
					$author$project$Compiler$Canonicalize$Pattern$verify,
					$author$project$Compiler$Reporting$Error$Canonicalize$DPFuncArgs(name),
					A2(
						$author$project$Compiler$Reporting$Result$traverseList,
						$author$project$Compiler$Canonicalize$Pattern$canonicalize(env),
						srcArgs)),
				function (_v3) {
					var args = _v3.a;
					var argBindings = _v3.b;
					return A2(
						$author$project$Compiler$Reporting$Result$bind,
						A2($author$project$Compiler$Canonicalize$Environment$addLocals, argBindings, env),
						function (newEnv) {
							return A2(
								$author$project$Compiler$Reporting$Result$bind,
								A3(
									$author$project$Compiler$Canonicalize$Expression$verifyBindings,
									$author$project$Compiler$Reporting$Warning$Pattern,
									argBindings,
									A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, body)),
								function (_v4) {
									var cbody = _v4.a;
									var freeLocals = _v4.b;
									var def = A3($author$project$Compiler$AST$Canonical$Def, aname, args, cbody);
									return $author$project$Compiler$Reporting$Result$return(
										_Utils_Tuple3(
											A4($author$project$Compiler$Canonicalize$Module$toNodeTwo, name, srcArgs, def, freeLocals),
											name,
											$author$project$Extra$Type$Map$keys(freeLocals)));
								});
						});
				});
		} else {
			var srcType = maybeType.a;
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				A2($author$project$Compiler$Canonicalize$Type$toAnnotation, env, srcType),
				function (_v5) {
					var freeVars = _v5.a;
					var tipe = _v5.b;
					return A2(
						$author$project$Compiler$Reporting$Result$bind,
						A2(
							$author$project$Compiler$Canonicalize$Pattern$verify,
							$author$project$Compiler$Reporting$Error$Canonicalize$DPFuncArgs(name),
							A6($author$project$Compiler$Canonicalize$Expression$gatherTypedArgs, env, name, srcArgs, tipe, $author$project$Compiler$Data$Index$first, _List_Nil)),
						function (_v6) {
							var _v7 = _v6.a;
							var args = _v7.a;
							var resultType = _v7.b;
							var argBindings = _v6.b;
							return A2(
								$author$project$Compiler$Reporting$Result$bind,
								A2($author$project$Compiler$Canonicalize$Environment$addLocals, argBindings, env),
								function (newEnv) {
									return A2(
										$author$project$Compiler$Reporting$Result$bind,
										A3(
											$author$project$Compiler$Canonicalize$Expression$verifyBindings,
											$author$project$Compiler$Reporting$Warning$Pattern,
											argBindings,
											A2($author$project$Compiler$Canonicalize$Expression$canonicalize, newEnv, body)),
										function (_v8) {
											var cbody = _v8.a;
											var freeLocals = _v8.b;
											var def = A5($author$project$Compiler$AST$Canonical$TypedDef, aname, freeVars, args, cbody, resultType);
											return $author$project$Compiler$Reporting$Result$return(
												_Utils_Tuple3(
													A4($author$project$Compiler$Canonicalize$Module$toNodeTwo, name, srcArgs, def, freeLocals),
													name,
													$author$project$Extra$Type$Map$keys(freeLocals)));
										});
								});
						});
				});
		}
	});
var $author$project$Compiler$Canonicalize$Module$canonicalizeValues = F2(
	function (env, values) {
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2(
				$author$project$Compiler$Reporting$Result$traverseList,
				$author$project$Compiler$Canonicalize$Module$toNodeOne(env),
				values),
			function (nodes) {
				return $author$project$Compiler$Canonicalize$Module$detectCycles(
					$author$project$Extra$Data$Graph$stronglyConnComp(nodes));
			});
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$State = F7(
	function (a, b, c, d, e, f, g) {
		return {$: 'State', a: a, b: b, c: c, d: d, e: e, f: f, g: g};
	});
var $author$project$Compiler$Canonicalize$Environment$Ambiguous = F2(
	function (a, b) {
		return {$: 'Ambiguous', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Environment$mergeInfo = F2(
	function (info1, info2) {
		if (info1.$ === 'Specific') {
			var h1 = info1.a;
			if (info2.$ === 'Specific') {
				var h2 = info2.a;
				return _Utils_eq(h1, h2) ? info1 : A2(
					$author$project$Compiler$Canonicalize$Environment$Ambiguous,
					h1,
					$author$project$Compiler$Data$OneOrMore$one(h2));
			} else {
				var h2 = info2.a;
				var hs2 = info2.b;
				return A2(
					$author$project$Compiler$Canonicalize$Environment$Ambiguous,
					h1,
					A2(
						$author$project$Compiler$Data$OneOrMore$more,
						$author$project$Compiler$Data$OneOrMore$one(h2),
						hs2));
			}
		} else {
			var h1 = info1.a;
			var hs1 = info1.b;
			if (info2.$ === 'Specific') {
				var h2 = info2.a;
				return A2(
					$author$project$Compiler$Canonicalize$Environment$Ambiguous,
					h1,
					A2(
						$author$project$Compiler$Data$OneOrMore$more,
						hs1,
						$author$project$Compiler$Data$OneOrMore$one(h2)));
			} else {
				var h2 = info2.a;
				var hs2 = info2.b;
				return A2(
					$author$project$Compiler$Canonicalize$Environment$Ambiguous,
					h1,
					A2(
						$author$project$Compiler$Data$OneOrMore$more,
						hs1,
						A2(
							$author$project$Compiler$Data$OneOrMore$more,
							$author$project$Compiler$Data$OneOrMore$one(h2),
							hs2)));
			}
		}
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$addExposed = $author$project$Extra$Type$Map$unionWith($author$project$Compiler$Canonicalize$Environment$mergeInfo);
var $author$project$Compiler$Reporting$Error$Canonicalize$ImportCtorByName = F3(
	function (a, b, c) {
		return {$: 'ImportCtorByName', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$ImportExposingNotFound = F4(
	function (a, b, c, d) {
		return {$: 'ImportExposingNotFound', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$ImportOpenAlias = F2(
	function (a, b) {
		return {$: 'ImportOpenAlias', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Environment$Binop = F6(
	function (a, b, c, d, e, f) {
		return {$: 'Binop', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$binopToBinop = F3(
	function (home, op, _v0) {
		var name = _v0.a;
		var annotation = _v0.b;
		var associativity = _v0.c;
		var precedence = _v0.d;
		return A2(
			$author$project$Compiler$Canonicalize$Environment$Specific,
			home,
			A6($author$project$Compiler$Canonicalize$Environment$Binop, op, home, name, annotation, associativity, precedence));
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$checkForCtorMistake = F2(
	function (givenName, types) {
		var addMatch = F3(
			function (ctorName, info, matches) {
				if (!_Utils_eq(ctorName, givenName)) {
					return matches;
				} else {
					if (info.$ === 'Specific') {
						if (info.b.$ === 'Ctor') {
							var _v2 = info.b;
							var tipeName = _v2.b;
							return A2($elm$core$List$cons, tipeName, matches);
						} else {
							var _v3 = info.b;
							return matches;
						}
					} else {
						return matches;
					}
				}
			});
		var addMatches = F2(
			function (_v0, matches) {
				var exposedCtors = _v0.b;
				return A3($author$project$Extra$Type$Map$foldrWithKey, addMatch, matches, exposedCtors);
			});
		return A3($author$project$Extra$Type$Map$foldr, addMatches, _List_Nil, types);
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$addExposedValue = F6(
	function (home, vars, types, binops, _v0, exposed) {
		var vs = _v0.a;
		var ts = _v0.b;
		var cs = _v0.c;
		var bs = _v0.d;
		var qvs = _v0.e;
		var qts = _v0.f;
		var qcs = _v0.g;
		switch (exposed.$) {
			case 'Lower':
				var _v2 = exposed.a;
				var region = _v2.a;
				var name = _v2.b;
				var _v3 = A2($author$project$Extra$Type$Map$lookup, name, vars);
				if (_v3.$ === 'Just') {
					var info = _v3.a;
					return $author$project$Compiler$Reporting$Result$ok(
						A7(
							$author$project$Compiler$Canonicalize$Environment$Foreign$State,
							A4($author$project$Extra$Type$Map$insertWith, $author$project$Compiler$Canonicalize$Environment$mergeInfo, name, info, vs),
							ts,
							cs,
							bs,
							qvs,
							qts,
							qcs));
				} else {
					return $author$project$Compiler$Reporting$Result$throw(
						A4(
							$author$project$Compiler$Reporting$Error$Canonicalize$ImportExposingNotFound,
							region,
							home,
							name,
							$author$project$Extra$Type$Map$keys(vars)));
				}
			case 'Upper':
				var _v4 = exposed.a;
				var region = _v4.a;
				var name = _v4.b;
				var privacy = exposed.b;
				if (privacy.$ === 'Private') {
					var _v6 = A2($author$project$Extra$Type$Map$lookup, name, types);
					if (_v6.$ === 'Just') {
						var _v7 = _v6.a;
						var tipe = _v7.a;
						var ctors = _v7.b;
						if (tipe.$ === 'Union') {
							var ts2 = A3(
								$author$project$Extra$Type$Map$insert,
								name,
								A2($author$project$Compiler$Canonicalize$Environment$Specific, home, tipe),
								ts);
							return $author$project$Compiler$Reporting$Result$ok(
								A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, vs, ts2, cs, bs, qvs, qts, qcs));
						} else {
							var ts2 = A3(
								$author$project$Extra$Type$Map$insert,
								name,
								A2($author$project$Compiler$Canonicalize$Environment$Specific, home, tipe),
								ts);
							var cs2 = A2($author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, cs, ctors);
							return $author$project$Compiler$Reporting$Result$ok(
								A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, vs, ts2, cs2, bs, qvs, qts, qcs));
						}
					} else {
						var _v9 = A2($author$project$Compiler$Canonicalize$Environment$Foreign$checkForCtorMistake, name, types);
						if (_v9.b) {
							var tipe = _v9.a;
							return $author$project$Compiler$Reporting$Result$throw(
								A3($author$project$Compiler$Reporting$Error$Canonicalize$ImportCtorByName, region, name, tipe));
						} else {
							return $author$project$Compiler$Reporting$Result$throw(
								A4(
									$author$project$Compiler$Reporting$Error$Canonicalize$ImportExposingNotFound,
									region,
									home,
									name,
									$author$project$Extra$Type$Map$keys(types)));
						}
					}
				} else {
					var dotDotRegion = privacy.a;
					var _v10 = A2($author$project$Extra$Type$Map$lookup, name, types);
					if (_v10.$ === 'Just') {
						var _v11 = _v10.a;
						var tipe = _v11.a;
						var ctors = _v11.b;
						if (tipe.$ === 'Union') {
							var ts2 = A3(
								$author$project$Extra$Type$Map$insert,
								name,
								A2($author$project$Compiler$Canonicalize$Environment$Specific, home, tipe),
								ts);
							var cs2 = A2($author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, cs, ctors);
							return $author$project$Compiler$Reporting$Result$ok(
								A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, vs, ts2, cs2, bs, qvs, qts, qcs));
						} else {
							return $author$project$Compiler$Reporting$Result$throw(
								A2($author$project$Compiler$Reporting$Error$Canonicalize$ImportOpenAlias, dotDotRegion, name));
						}
					} else {
						return $author$project$Compiler$Reporting$Result$throw(
							A4(
								$author$project$Compiler$Reporting$Error$Canonicalize$ImportExposingNotFound,
								region,
								home,
								name,
								$author$project$Extra$Type$Map$keys(types)));
					}
				}
			default:
				var region = exposed.a;
				var op = exposed.b;
				var _v13 = A2($author$project$Extra$Type$Map$lookup, op, binops);
				if (_v13.$ === 'Just') {
					var binop = _v13.a;
					var bs2 = A3(
						$author$project$Extra$Type$Map$insert,
						op,
						A3($author$project$Compiler$Canonicalize$Environment$Foreign$binopToBinop, home, op, binop),
						bs);
					return $author$project$Compiler$Reporting$Result$ok(
						A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, vs, ts, cs, bs2, qvs, qts, qcs));
				} else {
					return $author$project$Compiler$Reporting$Result$throw(
						A4(
							$author$project$Compiler$Reporting$Error$Canonicalize$ImportExposingNotFound,
							region,
							home,
							op,
							$author$project$Extra$Type$Map$keys(binops)));
				}
		}
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$addQualified = F3(
	function (prefix, exposed, qualified) {
		return A4($author$project$Extra$Type$Map$insertWith, $author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, prefix, exposed, qualified);
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$aliasToTypeHelp = F3(
	function (home, name, _v0) {
		var vars = _v0.a;
		var tipe = _v0.b;
		return _Utils_Tuple2(
			A4(
				$author$project$Compiler$Canonicalize$Environment$Alias,
				$author$project$Extra$Type$List$length(vars),
				home,
				vars,
				tipe),
			function () {
				if ((tipe.$ === 'TRecord') && (tipe.b.$ === 'Nothing')) {
					var fields = tipe.a;
					var _v2 = tipe.b;
					var avars = A2(
						$author$project$Extra$Type$List$map,
						function (_var) {
							return _Utils_Tuple2(
								_var,
								$author$project$Compiler$AST$Canonical$TVar(_var));
						},
						vars);
					var alias_ = A3(
						$author$project$Extra$Type$List$foldr,
						F2(
							function (_v3, t2) {
								var t1 = _v3.b;
								return A2($author$project$Compiler$AST$Canonical$TLambda, t1, t2);
							}),
						A4(
							$author$project$Compiler$AST$Canonical$TAlias,
							home,
							name,
							avars,
							$author$project$Compiler$AST$Canonical$Filled(tipe)),
						$author$project$Compiler$AST$Canonical$fieldsToList(fields));
					return A2(
						$author$project$Extra$Type$Map$singleton,
						name,
						A2(
							$author$project$Compiler$Canonicalize$Environment$Specific,
							home,
							A3($author$project$Compiler$Canonicalize$Environment$RecordCtor, home, vars, alias_)));
				} else {
					return $author$project$Extra$Type$Map$empty;
				}
			}());
	});
var $author$project$Compiler$Elm$Interface$toPublicAlias = function (iAlias) {
	if (iAlias.$ === 'PublicAlias') {
		var alias = iAlias.a;
		return $elm$core$Maybe$Just(alias);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Compiler$Canonicalize$Environment$Foreign$aliasToType = F3(
	function (home, name, alias) {
		return A2(
			$elm$core$Maybe$map,
			A2($author$project$Compiler$Canonicalize$Environment$Foreign$aliasToTypeHelp, home, name),
			$author$project$Compiler$Elm$Interface$toPublicAlias(alias));
	});
var $author$project$Extra$Type$Map$mapMaybeWithKey = F2(
	function (f, m) {
		return A3(
			$author$project$Extra$Type$Map$foldrWithKey,
			F3(
				function (k, a, _new) {
					var _v0 = A2(f, k, a);
					if (_v0.$ === 'Just') {
						var b = _v0.a;
						return A3($author$project$Extra$Type$Map$insert, k, b, _new);
					} else {
						return _new;
					}
				}),
			$author$project$Extra$Type$Map$empty,
			m);
	});
var $author$project$Extra$Type$Maybe$maybe = F3(
	function (b, f, ma) {
		if (ma.$ === 'Just') {
			var a = ma.a;
			return f(a);
		} else {
			return b;
		}
	});
var $author$project$Compiler$Elm$Interface$toPublicUnion = function (iUnion) {
	switch (iUnion.$) {
		case 'OpenUnion':
			var union = iUnion.a;
			return $elm$core$Maybe$Just(union);
		case 'ClosedUnion':
			var _v1 = iUnion.a;
			var vars = _v1.a;
			var opts = _v1.d;
			return $elm$core$Maybe$Just(
				A4($author$project$Compiler$AST$Canonical$Union, vars, _List_Nil, 0, opts));
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Compiler$Canonicalize$Environment$Foreign$unionToTypeHelp = F3(
	function (home, name, union) {
		var vars = union.a;
		var ctors = union.b;
		var addCtor = F2(
			function (dict, _v0) {
				var ctor = _v0.a;
				var index = _v0.b;
				var args = _v0.d;
				return A3(
					$author$project$Extra$Type$Map$insert,
					ctor,
					A2(
						$author$project$Compiler$Canonicalize$Environment$Specific,
						home,
						A5($author$project$Compiler$Canonicalize$Environment$Ctor, home, name, union, index, args)),
					dict);
			});
		return _Utils_Tuple2(
			A2(
				$author$project$Compiler$Canonicalize$Environment$Union,
				$author$project$Extra$Type$List$length(vars),
				home),
			A3($author$project$Extra$Type$List$foldl, addCtor, $author$project$Extra$Type$Map$empty, ctors));
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$unionToType = F3(
	function (home, name, union) {
		return A2(
			$elm$core$Maybe$map,
			A2($author$project$Compiler$Canonicalize$Environment$Foreign$unionToTypeHelp, home, name),
			$author$project$Compiler$Elm$Interface$toPublicUnion(union));
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$addImport = F3(
	function (ifaces, _v0, _v1) {
		var vs = _v0.a;
		var ts = _v0.b;
		var cs = _v0.c;
		var bs = _v0.d;
		var qvs = _v0.e;
		var qts = _v0.f;
		var qcs = _v0.g;
		var _v2 = _v1.a;
		var name = _v2.b;
		var maybeAlias = _v1.b;
		var exposing_ = _v1.c;
		var prefix = A3($author$project$Extra$Type$Maybe$maybe, name, $elm$core$Basics$identity, maybeAlias);
		var _v3 = A2($author$project$Extra$Type$Map$ex, ifaces, name);
		var pkg = _v3.a;
		var defs = _v3.b;
		var unions = _v3.c;
		var aliases = _v3.d;
		var binops = _v3.e;
		var home = A2($author$project$Compiler$Elm$ModuleName$Canonical, pkg, name);
		var vars = A2(
			$author$project$Extra$Type$Map$map,
			$author$project$Compiler$Canonicalize$Environment$Specific(home),
			defs);
		var qvs2 = A3($author$project$Compiler$Canonicalize$Environment$Foreign$addQualified, prefix, vars, qvs);
		var rawTypeInfo = A2(
			$author$project$Extra$Type$Map$union,
			A2(
				$author$project$Extra$Type$Map$mapMaybeWithKey,
				$author$project$Compiler$Canonicalize$Environment$Foreign$unionToType(home),
				unions),
			A2(
				$author$project$Extra$Type$Map$mapMaybeWithKey,
				$author$project$Compiler$Canonicalize$Environment$Foreign$aliasToType(home),
				aliases));
		var ctors = A3(
			$author$project$Extra$Type$Map$foldr,
			A2($elm$core$Basics$composeL, $author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, $elm$core$Tuple$second),
			$author$project$Extra$Type$Map$empty,
			rawTypeInfo);
		var qcs2 = A3($author$project$Compiler$Canonicalize$Environment$Foreign$addQualified, prefix, ctors, qcs);
		var types = A2(
			$author$project$Extra$Type$Map$map,
			A2(
				$elm$core$Basics$composeL,
				$author$project$Compiler$Canonicalize$Environment$Specific(home),
				$elm$core$Tuple$first),
			rawTypeInfo);
		var qts2 = A3($author$project$Compiler$Canonicalize$Environment$Foreign$addQualified, prefix, types, qts);
		if (exposing_.$ === 'Open') {
			var vs2 = A2($author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, vs, vars);
			var ts2 = A2($author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, ts, types);
			var cs2 = A2($author$project$Compiler$Canonicalize$Environment$Foreign$addExposed, cs, ctors);
			var bs2 = A2(
				$author$project$Compiler$Canonicalize$Environment$Foreign$addExposed,
				bs,
				A2(
					$author$project$Extra$Type$Map$mapWithKey,
					$author$project$Compiler$Canonicalize$Environment$Foreign$binopToBinop(home),
					binops));
			return $author$project$Compiler$Reporting$Result$ok(
				A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, vs2, ts2, cs2, bs2, qvs2, qts2, qcs2));
		} else {
			var exposedList = exposing_.a;
			return A3(
				$author$project$Compiler$Reporting$Result$foldM,
				A4($author$project$Compiler$Canonicalize$Environment$Foreign$addExposedValue, home, vars, rawTypeInfo, binops),
				A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, vs, ts, cs, bs, qvs2, qts2, qcs2),
				exposedList);
		}
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$emptyTypes = A2(
	$author$project$Extra$Type$Map$singleton,
	'List',
	A2(
		$author$project$Compiler$Canonicalize$Environment$Specific,
		$author$project$Compiler$Elm$ModuleName$list,
		A2($author$project$Compiler$Canonicalize$Environment$Union, 1, $author$project$Compiler$Elm$ModuleName$list)));
var $author$project$Compiler$Canonicalize$Environment$Foreign$emptyState = A7($author$project$Compiler$Canonicalize$Environment$Foreign$State, $author$project$Extra$Type$Map$empty, $author$project$Compiler$Canonicalize$Environment$Foreign$emptyTypes, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty);
var $author$project$Compiler$Canonicalize$Environment$Foreign = F2(
	function (a, b) {
		return {$: 'Foreign', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Environment$Foreigns = F2(
	function (a, b) {
		return {$: 'Foreigns', a: a, b: b};
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$infoToVar = function (info) {
	if (info.$ === 'Specific') {
		var home = info.a;
		var tipe = info.b;
		return A2($author$project$Compiler$Canonicalize$Environment$Foreign, home, tipe);
	} else {
		var h = info.a;
		var hs = info.b;
		return A2($author$project$Compiler$Canonicalize$Environment$Foreigns, h, hs);
	}
};
var $author$project$Compiler$Canonicalize$Environment$Foreign$isNormal = function (_v0) {
	var _v1 = _v0.a;
	var name = _v1.b;
	var maybeAlias = _v0.b;
	if ($author$project$Compiler$Data$Name$isKernel(name)) {
		if (maybeAlias.$ === 'Nothing') {
			return false;
		} else {
			return _Debug_todo(
				'Compiler.Canonicalize.Environment.Foreign',
				{
					start: {line: 85, column: 17},
					end: {line: 85, column: 27}
				})('kernel imports cannot use `as`');
		}
	} else {
		return true;
	}
};
var $author$project$Compiler$Canonicalize$Environment$Foreign$toSafeImports = F2(
	function (_v0, imports) {
		var pkg = _v0.a;
		return $author$project$Compiler$Elm$Package$isKernel(pkg) ? A2($author$project$Extra$Type$List$filter, $author$project$Compiler$Canonicalize$Environment$Foreign$isNormal, imports) : imports;
	});
var $author$project$Compiler$Canonicalize$Environment$Foreign$createInitialEnv = F3(
	function (home, ifaces, imports) {
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A3(
				$author$project$Compiler$Reporting$Result$foldM,
				$author$project$Compiler$Canonicalize$Environment$Foreign$addImport(ifaces),
				$author$project$Compiler$Canonicalize$Environment$Foreign$emptyState,
				A2($author$project$Compiler$Canonicalize$Environment$Foreign$toSafeImports, home, imports)),
			function (_v0) {
				var vs = _v0.a;
				var ts = _v0.b;
				var cs = _v0.c;
				var bs = _v0.d;
				var qvs = _v0.e;
				var qts = _v0.f;
				var qcs = _v0.g;
				return $author$project$Compiler$Reporting$Result$ok(
					A8(
						$author$project$Compiler$Canonicalize$Environment$Env,
						home,
						A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Canonicalize$Environment$Foreign$infoToVar, vs),
						ts,
						cs,
						bs,
						qvs,
						qts,
						qcs));
			});
	});
var $author$project$Compiler$Data$Name$u_Main = 'Main';
var $author$project$Compiler$AST$Source$getName = function (_v0) {
	var maybeName = _v0.a;
	if (maybeName.$ === 'Just') {
		var _v2 = maybeName.a;
		var name = _v2.b;
		return name;
	} else {
		return $author$project$Compiler$Data$Name$u_Main;
	}
};
var $author$project$Compiler$Canonicalize$Module$canonicalize = F3(
	function (pkg, ifaces, modul) {
		var exports = modul.b;
		var imports = modul.c;
		var values = modul.d;
		var binops = modul.g;
		var effects = modul.h;
		var home = A2(
			$author$project$Compiler$Elm$ModuleName$Canonical,
			pkg,
			$author$project$Compiler$AST$Source$getName(modul));
		var cbinops = $author$project$Extra$Type$Map$fromList(
			A2($author$project$Extra$Type$List$map, $author$project$Compiler$Canonicalize$Module$canonicalizeBinop, binops));
		return A2(
			$author$project$Compiler$Reporting$Result$bind,
			A2(
				$author$project$Compiler$Reporting$Result$andThen,
				$author$project$Compiler$Canonicalize$Environment$Local$add(modul),
				A3($author$project$Compiler$Canonicalize$Environment$Foreign$createInitialEnv, home, ifaces, imports)),
			function (_v0) {
				var env = _v0.a;
				var cunions = _v0.b;
				var caliases = _v0.c;
				return A2(
					$author$project$Compiler$Reporting$Result$bind,
					A2($author$project$Compiler$Canonicalize$Module$canonicalizeValues, env, values),
					function (cvalues) {
						return A2(
							$author$project$Compiler$Reporting$Result$bind,
							A4($author$project$Compiler$Canonicalize$Effects$canonicalize, env, values, cunions, effects),
							function (ceffects) {
								return A2(
									$author$project$Compiler$Reporting$Result$bind,
									A6($author$project$Compiler$Canonicalize$Module$canonicalizeExports, values, cunions, caliases, cbinops, ceffects, exports),
									function (cexports) {
										return $author$project$Compiler$Reporting$Result$return(
											A7($author$project$Compiler$AST$Canonical$Module, home, cexports, cvalues, cunions, caliases, cbinops, ceffects));
									});
							});
					});
			});
	});
var $author$project$Compiler$Reporting$Result$run = function (_v0) {
	var k = _v0.a;
	var _v1 = A2(k, _Utils_Tuple0, _List_Nil);
	if (_v1.$ === 'Rbad') {
		var w = _v1.b;
		var e = _v1.c;
		return _Utils_Tuple2(
			$author$project$Extra$Type$List$reverse(w),
			$author$project$Extra$Type$Either$Left(e));
	} else {
		var w = _v1.b;
		var a = _v1.c;
		return _Utils_Tuple2(
			$author$project$Extra$Type$List$reverse(w),
			$author$project$Extra$Type$Either$Right(a));
	}
};
var $author$project$Compiler$Compile$canonicalize = F3(
	function (pkg, ifaces, modul) {
		var _v0 = $author$project$Compiler$Reporting$Result$run(
			A3($author$project$Compiler$Canonicalize$Module$canonicalize, pkg, ifaces, modul)).b;
		if (_v0.$ === 'Right') {
			var canonical = _v0.a;
			return $author$project$Extra$Type$Either$Right(canonical);
		} else {
			var errors = _v0.a;
			return $author$project$Extra$Type$Either$Left(
				$author$project$Compiler$Reporting$Error$BadNames(errors));
		}
	});
var $author$project$Compiler$Reporting$Error$BadPatterns = function (a) {
	return {$: 'BadPatterns', a: a};
};
var $author$project$Compiler$Nitpick$PatternMatches$BadCase = {$: 'BadCase'};
var $author$project$Compiler$Nitpick$PatternMatches$BadDestruct = {$: 'BadDestruct'};
var $author$project$Compiler$Nitpick$PatternMatches$BadArg = {$: 'BadArg'};
var $author$project$Compiler$Nitpick$PatternMatches$Incomplete = F3(
	function (a, b, c) {
		return {$: 'Incomplete', a: a, b: b, c: c};
	});
var $author$project$Compiler$Nitpick$PatternMatches$Anything = {$: 'Anything'};
var $elm$core$List$append = F2(
	function (xs, ys) {
		if (!ys.b) {
			return xs;
		} else {
			return A3($elm$core$List$foldr, $elm$core$List$cons, ys, xs);
		}
	});
var $elm$core$List$concat = function (lists) {
	return A3($elm$core$List$foldr, $elm$core$List$append, _List_Nil, lists);
};
var $elm$core$List$concatMap = F2(
	function (f, list) {
		return $elm$core$List$concat(
			A2($elm$core$List$map, f, list));
	});
var $author$project$Extra$Type$List$concatMap = $elm$core$List$concatMap;
var $author$project$Extra$Type$List$andMap = F2(
	function (la, lf) {
		return A2(
			$author$project$Extra$Type$List$concatMap,
			function (f) {
				return A2($author$project$Extra$Type$List$map, f, la);
			},
			lf);
	});
var $author$project$Compiler$Nitpick$PatternMatches$collectCtorsHelp = F2(
	function (ctors, row) {
		if (row.b && (row.a.$ === 'Ctor')) {
			var _v1 = row.a;
			var union = _v1.a;
			var name = _v1.b;
			return A3($author$project$Extra$Type$Map$insert, name, union, ctors);
		} else {
			return ctors;
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$collectCtors = function (matrix) {
	return A3($author$project$Extra$Type$List$foldl, $author$project$Compiler$Nitpick$PatternMatches$collectCtorsHelp, $author$project$Extra$Type$Map$empty, matrix);
};
var $author$project$Extra$Type$Map$lookupMin = function (m) {
	return A3(
		$author$project$Extra$Type$Map$foldlWithKey,
		F3(
			function (mka, k, a) {
				if (mka.$ === 'Nothing') {
					return $elm$core$Maybe$Just(
						_Utils_Tuple2(k, a));
				} else {
					return mka;
				}
			}),
		$elm$core$Maybe$Nothing,
		m);
};
var $author$project$Extra$Type$Map$findMin = function (m) {
	var _v0 = $author$project$Extra$Type$Map$lookupMin(m);
	if (_v0.$ === 'Just') {
		var ka = _v0.a;
		return ka;
	} else {
		return _Debug_todo(
			'Extra.Type.Map',
			{
				start: {line: 136, column: 13},
				end: {line: 136, column: 23}
			})('Map.findMin: empty map has no minimal element');
	}
};
var $author$project$Compiler$Nitpick$PatternMatches$Ctor = F3(
	function (a, b, c) {
		return {$: 'Ctor', a: a, b: b, c: c};
	});
var $elm$core$List$repeatHelp = F3(
	function (result, n, value) {
		repeatHelp:
		while (true) {
			if (n <= 0) {
				return result;
			} else {
				var $temp$result = A2($elm$core$List$cons, value, result),
					$temp$n = n - 1,
					$temp$value = value;
				result = $temp$result;
				n = $temp$n;
				value = $temp$value;
				continue repeatHelp;
			}
		}
	});
var $elm$core$List$repeat = F2(
	function (n, value) {
		return A3($elm$core$List$repeatHelp, _List_Nil, n, value);
	});
var $author$project$Extra$Type$List$replicate = $elm$core$List$repeat;
var $author$project$Compiler$Nitpick$PatternMatches$isMissing = F3(
	function (union, ctors, _v0) {
		var name = _v0.a;
		var arity = _v0.c;
		return A2($author$project$Extra$Type$Map$member, name, ctors) ? $elm$core$Maybe$Nothing : $elm$core$Maybe$Just(
			A3(
				$author$project$Compiler$Nitpick$PatternMatches$Ctor,
				union,
				name,
				A2($author$project$Extra$Type$List$replicate, arity, $author$project$Compiler$Nitpick$PatternMatches$Anything)));
	});
var $author$project$Extra$Type$Maybe$mapMaybe = F2(
	function (f, l) {
		if (!l.b) {
			return _List_Nil;
		} else {
			var x = l.a;
			var xs = l.b;
			var rs = A2($author$project$Extra$Type$Maybe$mapMaybe, f, xs);
			var _v1 = f(x);
			if (_v1.$ === 'Nothing') {
				return rs;
			} else {
				var r = _v1.a;
				return A2($elm$core$List$cons, r, rs);
			}
		}
	});
var $elm$core$List$singleton = function (value) {
	return _List_fromArray(
		[value]);
};
var $author$project$Extra$Type$List$pure = $elm$core$List$singleton;
var $author$project$Extra$Type$List$splitAt = F2(
	function (n, l) {
		return _Utils_Tuple2(
			A2($author$project$Extra$Type$List$take, n, l),
			A2($author$project$Extra$Type$List$drop, n, l));
	});
var $author$project$Compiler$Nitpick$PatternMatches$recoverCtor = F4(
	function (union, name, arity, patterns) {
		var _v0 = A2($author$project$Extra$Type$List$splitAt, arity, patterns);
		var args = _v0.a;
		var rest = _v0.b;
		return A2(
			$elm$core$List$cons,
			A3($author$project$Compiler$Nitpick$PatternMatches$Ctor, union, name, args),
			rest);
	});
var $author$project$Compiler$Nitpick$PatternMatches$specializeRowByAnything = function (row) {
	if (!row.b) {
		return $elm$core$Maybe$Nothing;
	} else {
		switch (row.a.$) {
			case 'Ctor':
				var _v1 = row.a;
				return $elm$core$Maybe$Nothing;
			case 'Anything':
				var _v2 = row.a;
				var patterns = row.b;
				return $elm$core$Maybe$Just(patterns);
			default:
				return $elm$core$Maybe$Nothing;
		}
	}
};
var $author$project$Compiler$Nitpick$PatternMatches$specializeRowByCtor = F3(
	function (ctorName, arity, row) {
		if (row.b) {
			switch (row.a.$) {
				case 'Ctor':
					var _v1 = row.a;
					var name = _v1.b;
					var args = _v1.c;
					var patterns = row.b;
					return _Utils_eq(name, ctorName) ? $elm$core$Maybe$Just(
						_Utils_ap(args, patterns)) : $elm$core$Maybe$Nothing;
				case 'Anything':
					var _v2 = row.a;
					var patterns = row.b;
					return $elm$core$Maybe$Just(
						_Utils_ap(
							A2($author$project$Extra$Type$List$replicate, arity, $author$project$Compiler$Nitpick$PatternMatches$Anything),
							patterns));
				default:
					return _Debug_todo(
						'Compiler.Nitpick.PatternMatches',
						{
							start: {line: 555, column: 7},
							end: {line: 555, column: 17}
						})('Compiler bug! After type checking, constructors and literals' + ' should never align in pattern match exhaustiveness checks.');
			}
		} else {
			return _Debug_todo(
				'Compiler.Nitpick.PatternMatches',
				{
					start: {line: 560, column: 7},
					end: {line: 560, column: 17}
				})('Compiler error! Empty matrices should not get specialized.');
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$isExhaustive = F2(
	function (matrix, n) {
		if (!matrix.b) {
			return _List_fromArray(
				[
					A2($author$project$Extra$Type$List$replicate, n, $author$project$Compiler$Nitpick$PatternMatches$Anything)
				]);
		} else {
			if (!n) {
				return _List_Nil;
			} else {
				var ctors = $author$project$Compiler$Nitpick$PatternMatches$collectCtors(matrix);
				var numSeen = $author$project$Extra$Type$Map$size(ctors);
				if (!numSeen) {
					return A2(
						$author$project$Extra$Type$List$map,
						$elm$core$List$cons($author$project$Compiler$Nitpick$PatternMatches$Anything),
						A2(
							$author$project$Compiler$Nitpick$PatternMatches$isExhaustive,
							A2($author$project$Extra$Type$Maybe$mapMaybe, $author$project$Compiler$Nitpick$PatternMatches$specializeRowByAnything, matrix),
							n - 1));
				} else {
					var alts = $author$project$Extra$Type$Map$findMin(ctors).b;
					var altList = alts.b;
					var numAlts = alts.c;
					if (_Utils_cmp(numSeen, numAlts) < 0) {
						return A2(
							$author$project$Extra$Type$List$andMap,
							A2(
								$author$project$Compiler$Nitpick$PatternMatches$isExhaustive,
								A2($author$project$Extra$Type$Maybe$mapMaybe, $author$project$Compiler$Nitpick$PatternMatches$specializeRowByAnything, matrix),
								n - 1),
							A2(
								$author$project$Extra$Type$List$andMap,
								A2(
									$author$project$Extra$Type$Maybe$mapMaybe,
									A2($author$project$Compiler$Nitpick$PatternMatches$isMissing, alts, ctors),
									altList),
								$author$project$Extra$Type$List$pure($elm$core$List$cons)));
					} else {
						var isAltExhaustive = function (_v1) {
							var name = _v1.a;
							var arity = _v1.c;
							return A2(
								$author$project$Extra$Type$List$map,
								A3($author$project$Compiler$Nitpick$PatternMatches$recoverCtor, alts, name, arity),
								A2(
									$author$project$Compiler$Nitpick$PatternMatches$isExhaustive,
									A2(
										$author$project$Extra$Type$Maybe$mapMaybe,
										A2($author$project$Compiler$Nitpick$PatternMatches$specializeRowByCtor, name, arity),
										matrix),
									(arity + n) - 1));
						};
						return A2($author$project$Extra$Type$List$concatMap, isAltExhaustive, altList);
					}
				}
			}
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$Redundant = F3(
	function (a, b, c) {
		return {$: 'Redundant', a: a, b: b, c: c};
	});
var $author$project$Extra$Type$List$any = $elm$core$List$any;
var $author$project$Compiler$Nitpick$PatternMatches$No = {$: 'No'};
var $author$project$Compiler$Nitpick$PatternMatches$Yes = function (a) {
	return {$: 'Yes', a: a};
};
var $author$project$Compiler$Nitpick$PatternMatches$isComplete = function (matrix) {
	var ctors = $author$project$Compiler$Nitpick$PatternMatches$collectCtors(matrix);
	var numSeen = $author$project$Extra$Type$Map$size(ctors);
	if (!numSeen) {
		return $author$project$Compiler$Nitpick$PatternMatches$No;
	} else {
		var _v0 = $author$project$Extra$Type$Map$findMin(ctors).b;
		var alts = _v0.b;
		var numAlts = _v0.c;
		return _Utils_eq(numSeen, numAlts) ? $author$project$Compiler$Nitpick$PatternMatches$Yes(alts) : $author$project$Compiler$Nitpick$PatternMatches$No;
	}
};
var $author$project$Compiler$Nitpick$PatternMatches$specializeRowByLiteral = F2(
	function (literal, row) {
		if (row.b) {
			switch (row.a.$) {
				case 'Literal':
					var lit = row.a.a;
					var patterns = row.b;
					return _Utils_eq(lit, literal) ? $elm$core$Maybe$Just(patterns) : $elm$core$Maybe$Nothing;
				case 'Anything':
					var _v1 = row.a;
					var patterns = row.b;
					return $elm$core$Maybe$Just(patterns);
				default:
					var _v2 = row.a;
					return _Debug_todo(
						'Compiler.Nitpick.PatternMatches',
						{
							start: {line: 577, column: 7},
							end: {line: 577, column: 17}
						})('Compiler bug! After type checking, constructors and literals' + ' should never align in pattern match exhaustiveness checks.');
			}
		} else {
			return _Debug_todo(
				'Compiler.Nitpick.PatternMatches',
				{
					start: {line: 582, column: 7},
					end: {line: 582, column: 17}
				})('Compiler error! Empty matrices should not get specialized.');
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$isUseful = F2(
	function (matrix, vector) {
		isUseful:
		while (true) {
			if (!matrix.b) {
				return true;
			} else {
				if (!vector.b) {
					return false;
				} else {
					var firstPattern = vector.a;
					var patterns = vector.b;
					switch (firstPattern.$) {
						case 'Ctor':
							var name = firstPattern.b;
							var args = firstPattern.c;
							var $temp$matrix = A2(
								$author$project$Extra$Type$Maybe$mapMaybe,
								A2(
									$author$project$Compiler$Nitpick$PatternMatches$specializeRowByCtor,
									name,
									$author$project$Extra$Type$List$length(args)),
								matrix),
								$temp$vector = _Utils_ap(args, patterns);
							matrix = $temp$matrix;
							vector = $temp$vector;
							continue isUseful;
						case 'Anything':
							var _v3 = $author$project$Compiler$Nitpick$PatternMatches$isComplete(matrix);
							if (_v3.$ === 'No') {
								var $temp$matrix = A2($author$project$Extra$Type$Maybe$mapMaybe, $author$project$Compiler$Nitpick$PatternMatches$specializeRowByAnything, matrix),
									$temp$vector = patterns;
								matrix = $temp$matrix;
								vector = $temp$vector;
								continue isUseful;
							} else {
								var alts = _v3.a;
								var isUsefulAlt = function (_v4) {
									var name = _v4.a;
									var arity = _v4.c;
									return A2(
										$author$project$Compiler$Nitpick$PatternMatches$isUseful,
										A2(
											$author$project$Extra$Type$Maybe$mapMaybe,
											A2($author$project$Compiler$Nitpick$PatternMatches$specializeRowByCtor, name, arity),
											matrix),
										_Utils_ap(
											A2($author$project$Extra$Type$List$replicate, arity, $author$project$Compiler$Nitpick$PatternMatches$Anything),
											patterns));
								};
								return A2($author$project$Extra$Type$List$any, isUsefulAlt, alts);
							}
						default:
							var literal = firstPattern.a;
							var $temp$matrix = A2(
								$author$project$Extra$Type$Maybe$mapMaybe,
								$author$project$Compiler$Nitpick$PatternMatches$specializeRowByLiteral(literal),
								matrix),
								$temp$vector = patterns;
							matrix = $temp$matrix;
							vector = $temp$vector;
							continue isUseful;
					}
				}
			}
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$CInt = function (a) {
	return {$: 'CInt', a: a};
};
var $author$project$Compiler$Nitpick$PatternMatches$Chr = function (a) {
	return {$: 'Chr', a: a};
};
var $author$project$Compiler$Nitpick$PatternMatches$Literal = function (a) {
	return {$: 'Literal', a: a};
};
var $author$project$Compiler$Nitpick$PatternMatches$Str = function (a) {
	return {$: 'Str', a: a};
};
var $author$project$Compiler$Nitpick$PatternMatches$consName = '::';
var $author$project$Compiler$Data$Name$false = 'False';
var $author$project$Compiler$Nitpick$PatternMatches$nilName = '[]';
var $author$project$Compiler$Data$Index$second = $author$project$Compiler$Data$Index$ZeroBased(1);
var $author$project$Compiler$Nitpick$PatternMatches$list = function () {
	var nilCtor = A4($author$project$Compiler$AST$Canonical$Ctor, $author$project$Compiler$Nitpick$PatternMatches$nilName, $author$project$Compiler$Data$Index$first, 0, _List_Nil);
	var consCtor = A4(
		$author$project$Compiler$AST$Canonical$Ctor,
		$author$project$Compiler$Nitpick$PatternMatches$consName,
		$author$project$Compiler$Data$Index$second,
		2,
		_List_fromArray(
			[
				$author$project$Compiler$AST$Canonical$TVar('a'),
				A3(
				$author$project$Compiler$AST$Canonical$TType,
				$author$project$Compiler$Elm$ModuleName$list,
				$author$project$Compiler$Data$Name$list,
				_List_fromArray(
					[
						$author$project$Compiler$AST$Canonical$TVar('a')
					]))
			]));
	return A4(
		$author$project$Compiler$AST$Canonical$Union,
		_List_fromArray(
			['a']),
		_List_fromArray(
			[nilCtor, consCtor]),
		2,
		$author$project$Compiler$AST$Canonical$Normal);
}();
var $author$project$Compiler$Nitpick$PatternMatches$nil = A3($author$project$Compiler$Nitpick$PatternMatches$Ctor, $author$project$Compiler$Nitpick$PatternMatches$list, $author$project$Compiler$Nitpick$PatternMatches$nilName, _List_Nil);
var $author$project$Compiler$Nitpick$PatternMatches$pairName = '#2';
var $author$project$Compiler$Nitpick$PatternMatches$pair = function () {
	var ctor = A4(
		$author$project$Compiler$AST$Canonical$Ctor,
		$author$project$Compiler$Nitpick$PatternMatches$pairName,
		$author$project$Compiler$Data$Index$first,
		2,
		_List_fromArray(
			[
				$author$project$Compiler$AST$Canonical$TVar('a'),
				$author$project$Compiler$AST$Canonical$TVar('b')
			]));
	return A4(
		$author$project$Compiler$AST$Canonical$Union,
		_List_fromArray(
			['a', 'b']),
		_List_fromArray(
			[ctor]),
		1,
		$author$project$Compiler$AST$Canonical$Normal);
}();
var $author$project$Compiler$Nitpick$PatternMatches$tripleName = '#3';
var $author$project$Compiler$Nitpick$PatternMatches$triple = function () {
	var ctor = A4(
		$author$project$Compiler$AST$Canonical$Ctor,
		$author$project$Compiler$Nitpick$PatternMatches$tripleName,
		$author$project$Compiler$Data$Index$first,
		3,
		_List_fromArray(
			[
				$author$project$Compiler$AST$Canonical$TVar('a'),
				$author$project$Compiler$AST$Canonical$TVar('b'),
				$author$project$Compiler$AST$Canonical$TVar('c')
			]));
	return A4(
		$author$project$Compiler$AST$Canonical$Union,
		_List_fromArray(
			['a', 'b', 'c']),
		_List_fromArray(
			[ctor]),
		1,
		$author$project$Compiler$AST$Canonical$Normal);
}();
var $author$project$Compiler$Nitpick$PatternMatches$unitName = '#0';
var $author$project$Compiler$Nitpick$PatternMatches$unit = function () {
	var ctor = A4($author$project$Compiler$AST$Canonical$Ctor, $author$project$Compiler$Nitpick$PatternMatches$unitName, $author$project$Compiler$Data$Index$first, 0, _List_Nil);
	return A4(
		$author$project$Compiler$AST$Canonical$Union,
		_List_Nil,
		_List_fromArray(
			[ctor]),
		1,
		$author$project$Compiler$AST$Canonical$Normal);
}();
var $author$project$Compiler$Nitpick$PatternMatches$cons = F2(
	function (hd, tl) {
		return A3(
			$author$project$Compiler$Nitpick$PatternMatches$Ctor,
			$author$project$Compiler$Nitpick$PatternMatches$list,
			$author$project$Compiler$Nitpick$PatternMatches$consName,
			_List_fromArray(
				[
					$author$project$Compiler$Nitpick$PatternMatches$simplify(hd),
					tl
				]));
	});
var $author$project$Compiler$Nitpick$PatternMatches$simplify = function (_v0) {
	simplify:
	while (true) {
		var pattern = _v0.b;
		switch (pattern.$) {
			case 'PAnything':
				return $author$project$Compiler$Nitpick$PatternMatches$Anything;
			case 'PVar':
				return $author$project$Compiler$Nitpick$PatternMatches$Anything;
			case 'PRecord':
				return $author$project$Compiler$Nitpick$PatternMatches$Anything;
			case 'PUnit':
				return A3($author$project$Compiler$Nitpick$PatternMatches$Ctor, $author$project$Compiler$Nitpick$PatternMatches$unit, $author$project$Compiler$Nitpick$PatternMatches$unitName, _List_Nil);
			case 'PTuple':
				if (pattern.c.$ === 'Nothing') {
					var a = pattern.a;
					var b = pattern.b;
					var _v2 = pattern.c;
					return A3(
						$author$project$Compiler$Nitpick$PatternMatches$Ctor,
						$author$project$Compiler$Nitpick$PatternMatches$pair,
						$author$project$Compiler$Nitpick$PatternMatches$pairName,
						_List_fromArray(
							[
								$author$project$Compiler$Nitpick$PatternMatches$simplify(a),
								$author$project$Compiler$Nitpick$PatternMatches$simplify(b)
							]));
				} else {
					var a = pattern.a;
					var b = pattern.b;
					var c = pattern.c.a;
					return A3(
						$author$project$Compiler$Nitpick$PatternMatches$Ctor,
						$author$project$Compiler$Nitpick$PatternMatches$triple,
						$author$project$Compiler$Nitpick$PatternMatches$tripleName,
						_List_fromArray(
							[
								$author$project$Compiler$Nitpick$PatternMatches$simplify(a),
								$author$project$Compiler$Nitpick$PatternMatches$simplify(b),
								$author$project$Compiler$Nitpick$PatternMatches$simplify(c)
							]));
				}
			case 'PCtor':
				var union = pattern.c;
				var name = pattern.d;
				var args = pattern.f;
				return A3(
					$author$project$Compiler$Nitpick$PatternMatches$Ctor,
					union,
					name,
					A2(
						$author$project$Extra$Type$List$map,
						function (_v3) {
							var arg = _v3.c;
							return $author$project$Compiler$Nitpick$PatternMatches$simplify(arg);
						},
						args));
			case 'PList':
				var entries = pattern.a;
				return A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Nitpick$PatternMatches$cons, $author$project$Compiler$Nitpick$PatternMatches$nil, entries);
			case 'PCons':
				var hd = pattern.a;
				var tl = pattern.b;
				return A2(
					$author$project$Compiler$Nitpick$PatternMatches$cons,
					hd,
					$author$project$Compiler$Nitpick$PatternMatches$simplify(tl));
			case 'PAlias':
				var subPattern = pattern.a;
				var $temp$_v0 = subPattern;
				_v0 = $temp$_v0;
				continue simplify;
			case 'PInt':
				var _int = pattern.a;
				return $author$project$Compiler$Nitpick$PatternMatches$Literal(
					$author$project$Compiler$Nitpick$PatternMatches$CInt(_int));
			case 'PStr':
				var str = pattern.a;
				return $author$project$Compiler$Nitpick$PatternMatches$Literal(
					$author$project$Compiler$Nitpick$PatternMatches$Str(str));
			case 'PChr':
				var chr = pattern.a;
				return $author$project$Compiler$Nitpick$PatternMatches$Literal(
					$author$project$Compiler$Nitpick$PatternMatches$Chr(chr));
			default:
				var union = pattern.a;
				var bool = pattern.b;
				return A3(
					$author$project$Compiler$Nitpick$PatternMatches$Ctor,
					union,
					bool ? $author$project$Compiler$Data$Name$true : $author$project$Compiler$Data$Name$false,
					_List_Nil);
		}
	}
};
var $author$project$Compiler$Nitpick$PatternMatches$toSimplifiedUsefulRows = F3(
	function (overallRegion, checkedRows, uncheckedPatterns) {
		toSimplifiedUsefulRows:
		while (true) {
			if (!uncheckedPatterns.b) {
				return $author$project$Extra$Type$Either$Right(checkedRows);
			} else {
				var pattern = uncheckedPatterns.a;
				var region = pattern.a;
				var rest = uncheckedPatterns.b;
				var nextRow = _List_fromArray(
					[
						$author$project$Compiler$Nitpick$PatternMatches$simplify(pattern)
					]);
				if (A2($author$project$Compiler$Nitpick$PatternMatches$isUseful, checkedRows, nextRow)) {
					var $temp$overallRegion = overallRegion,
						$temp$checkedRows = A2($elm$core$List$cons, nextRow, checkedRows),
						$temp$uncheckedPatterns = rest;
					overallRegion = $temp$overallRegion;
					checkedRows = $temp$checkedRows;
					uncheckedPatterns = $temp$uncheckedPatterns;
					continue toSimplifiedUsefulRows;
				} else {
					return $author$project$Extra$Type$Either$Left(
						A3(
							$author$project$Compiler$Nitpick$PatternMatches$Redundant,
							overallRegion,
							region,
							$author$project$Extra$Type$List$length(checkedRows) + 1));
				}
			}
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$toNonRedundantRows = F2(
	function (region, patterns) {
		return A3($author$project$Compiler$Nitpick$PatternMatches$toSimplifiedUsefulRows, region, _List_Nil, patterns);
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkPatterns = F4(
	function (region, context, patterns, errors) {
		var _v0 = A2($author$project$Compiler$Nitpick$PatternMatches$toNonRedundantRows, region, patterns);
		if (_v0.$ === 'Left') {
			var err = _v0.a;
			return A2($elm$core$List$cons, err, errors);
		} else {
			var matrix = _v0.a;
			var _v1 = A2($author$project$Compiler$Nitpick$PatternMatches$isExhaustive, matrix, 1);
			if (!_v1.b) {
				return errors;
			} else {
				var badPatterns = _v1;
				return A2(
					$elm$core$List$cons,
					A3(
						$author$project$Compiler$Nitpick$PatternMatches$Incomplete,
						region,
						context,
						A2($author$project$Extra$Type$List$map, $author$project$Extra$Type$List$head, badPatterns)),
					errors);
			}
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkArg = F2(
	function (pattern, errors) {
		var region = pattern.a;
		return A4(
			$author$project$Compiler$Nitpick$PatternMatches$checkPatterns,
			region,
			$author$project$Compiler$Nitpick$PatternMatches$BadArg,
			_List_fromArray(
				[pattern]),
			errors);
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkTypedArg = F2(
	function (_v0, errors) {
		var pattern = _v0.a;
		var region = pattern.a;
		return A4(
			$author$project$Compiler$Nitpick$PatternMatches$checkPatterns,
			region,
			$author$project$Compiler$Nitpick$PatternMatches$BadArg,
			_List_fromArray(
				[pattern]),
			errors);
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkCaseBranch = F2(
	function (_v7, _v8) {
		var pattern = _v7.a;
		var expr = _v7.b;
		var patterns = _v8.a;
		var errors = _v8.b;
		return _Utils_Tuple2(
			A2($elm$core$List$cons, pattern, patterns),
			A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, expr, errors));
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkCases = F3(
	function (region, branches, errors) {
		var _v6 = A3(
			$author$project$Extra$Type$List$foldr,
			$author$project$Compiler$Nitpick$PatternMatches$checkCaseBranch,
			_Utils_Tuple2(_List_Nil, errors),
			branches);
		var patterns = _v6.a;
		var newErrors = _v6.b;
		return A4($author$project$Compiler$Nitpick$PatternMatches$checkPatterns, region, $author$project$Compiler$Nitpick$PatternMatches$BadCase, patterns, newErrors);
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkDef = F2(
	function (def, errors) {
		if (def.$ === 'Def') {
			var args = def.b;
			var body = def.c;
			return A3(
				$author$project$Extra$Type$List$foldr,
				$author$project$Compiler$Nitpick$PatternMatches$checkArg,
				A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, body, errors),
				args);
		} else {
			var args = def.c;
			var body = def.d;
			return A3(
				$author$project$Extra$Type$List$foldr,
				$author$project$Compiler$Nitpick$PatternMatches$checkTypedArg,
				A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, body, errors),
				args);
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkExpr = F2(
	function (_v2, errors) {
		checkExpr:
		while (true) {
			var region = _v2.a;
			var expression = _v2.b;
			switch (expression.$) {
				case 'VarLocal':
					return errors;
				case 'VarTopLevel':
					return errors;
				case 'VarKernel':
					return errors;
				case 'VarForeign':
					return errors;
				case 'VarCtor':
					return errors;
				case 'VarDebug':
					return errors;
				case 'VarOperator':
					return errors;
				case 'Chr':
					return errors;
				case 'Str':
					return errors;
				case 'CInt':
					return errors;
				case 'CFloat':
					return errors;
				case 'CList':
					var entries = expression.a;
					return A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Nitpick$PatternMatches$checkExpr, errors, entries);
				case 'Negate':
					var expr = expression.a;
					var $temp$_v2 = expr,
						$temp$errors = errors;
					_v2 = $temp$_v2;
					errors = $temp$errors;
					continue checkExpr;
				case 'Binop':
					var left = expression.e;
					var right = expression.f;
					return A2(
						$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
						left,
						A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, right, errors));
				case 'Lambda':
					var args = expression.a;
					var body = expression.b;
					return A3(
						$author$project$Extra$Type$List$foldr,
						$author$project$Compiler$Nitpick$PatternMatches$checkArg,
						A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, body, errors),
						args);
				case 'Call':
					var func = expression.a;
					var args = expression.b;
					return A2(
						$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
						func,
						A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Nitpick$PatternMatches$checkExpr, errors, args));
				case 'If':
					var branches = expression.a;
					var _finally = expression.b;
					return A3(
						$author$project$Extra$Type$List$foldr,
						$author$project$Compiler$Nitpick$PatternMatches$checkIfBranch,
						A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, _finally, errors),
						branches);
				case 'Let':
					var def = expression.a;
					var body = expression.b;
					return A2(
						$author$project$Compiler$Nitpick$PatternMatches$checkDef,
						def,
						A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, body, errors));
				case 'LetRec':
					var defs = expression.a;
					var body = expression.b;
					return A3(
						$author$project$Extra$Type$List$foldr,
						$author$project$Compiler$Nitpick$PatternMatches$checkDef,
						A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, body, errors),
						defs);
				case 'LetDestruct':
					var pattern = expression.a;
					var reg = pattern.a;
					var expr = expression.b;
					var body = expression.c;
					return A4(
						$author$project$Compiler$Nitpick$PatternMatches$checkPatterns,
						reg,
						$author$project$Compiler$Nitpick$PatternMatches$BadDestruct,
						_List_fromArray(
							[pattern]),
						A2(
							$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
							expr,
							A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, body, errors)));
				case 'Case':
					var expr = expression.a;
					var branches = expression.b;
					return A2(
						$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
						expr,
						A3($author$project$Compiler$Nitpick$PatternMatches$checkCases, region, branches, errors));
				case 'Accessor':
					return errors;
				case 'Access':
					var record = expression.a;
					var $temp$_v2 = record,
						$temp$errors = errors;
					_v2 = $temp$_v2;
					errors = $temp$errors;
					continue checkExpr;
				case 'Update':
					var record = expression.b;
					var fields = expression.c;
					return A2(
						$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
						record,
						A3($author$project$Extra$Type$Map$foldr, $author$project$Compiler$Nitpick$PatternMatches$checkField, errors, fields));
				case 'Record':
					var fields = expression.a;
					return A3($author$project$Extra$Type$Map$foldr, $author$project$Compiler$Nitpick$PatternMatches$checkExpr, errors, fields);
				case 'Unit':
					return errors;
				case 'Tuple':
					var a = expression.a;
					var b = expression.b;
					var maybeC = expression.c;
					return A2(
						$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
						a,
						A2(
							$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
							b,
							function () {
								if (maybeC.$ === 'Nothing') {
									return errors;
								} else {
									var c = maybeC.a;
									return A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, c, errors);
								}
							}()));
				default:
					return errors;
			}
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkField = F2(
	function (_v1, errors) {
		var expr = _v1.b;
		return A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, expr, errors);
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkIfBranch = F2(
	function (_v0, errs) {
		var condition = _v0.a;
		var branch = _v0.b;
		return A2(
			$author$project$Compiler$Nitpick$PatternMatches$checkExpr,
			condition,
			A2($author$project$Compiler$Nitpick$PatternMatches$checkExpr, branch, errs));
	});
var $author$project$Compiler$Nitpick$PatternMatches$checkDecls = F3(
	function (decls, errors, cont) {
		checkDecls:
		while (true) {
			switch (decls.$) {
				case 'Declare':
					var def = decls.a;
					var subDecls = decls.b;
					var $temp$decls = subDecls,
						$temp$errors = errors,
						$temp$cont = A2(
						$elm$core$Basics$composeR,
						$author$project$Compiler$Nitpick$PatternMatches$checkDef(def),
						cont);
					decls = $temp$decls;
					errors = $temp$errors;
					cont = $temp$cont;
					continue checkDecls;
				case 'DeclareRec':
					var def = decls.a;
					var defs = decls.b;
					var subDecls = decls.c;
					return A3(
						$author$project$Extra$Type$List$foldr,
						$author$project$Compiler$Nitpick$PatternMatches$checkDef,
						A3(
							$author$project$Compiler$Nitpick$PatternMatches$checkDecls,
							subDecls,
							errors,
							A2(
								$elm$core$Basics$composeR,
								$author$project$Compiler$Nitpick$PatternMatches$checkDef(def),
								cont)),
						defs);
				default:
					return cont(errors);
			}
		}
	});
var $author$project$Compiler$Nitpick$PatternMatches$check = function (_v0) {
	var decls = _v0.c;
	var _v1 = A3($author$project$Compiler$Nitpick$PatternMatches$checkDecls, decls, _List_Nil, $elm$core$Basics$identity);
	if (!_v1.b) {
		return $author$project$Extra$Type$Either$Right(_Utils_Tuple0);
	} else {
		var e = _v1.a;
		var es = _v1.b;
		return $author$project$Extra$Type$Either$Left(
			A2($author$project$Compiler$Data$NonEmptyList$CList, e, es));
	}
};
var $author$project$Compiler$Compile$nitpick = function (canonical) {
	var _v0 = $author$project$Compiler$Nitpick$PatternMatches$check(canonical);
	if (_v0.$ === 'Right') {
		return $author$project$Extra$Type$Either$Right(_Utils_Tuple0);
	} else {
		var errors = _v0.a;
		return $author$project$Extra$Type$Either$Left(
			$author$project$Compiler$Reporting$Error$BadPatterns(errors));
	}
};
var $author$project$Compiler$Reporting$Error$BadMains = F2(
	function (a, b) {
		return {$: 'BadMains', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Render$Type$Localizer$All = {$: 'All'};
var $author$project$Compiler$Reporting$Render$Type$Localizer$Import = F2(
	function (a, b) {
		return {$: 'Import', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Render$Type$Localizer$Localizer = function (a) {
	return {$: 'Localizer', a: a};
};
var $author$project$Compiler$Reporting$Render$Type$Localizer$Only = function (a) {
	return {$: 'Only', a: a};
};
var $author$project$Compiler$Reporting$Render$Type$Localizer$addType = F2(
	function (exposed, types) {
		switch (exposed.$) {
			case 'Lower':
				return types;
			case 'Upper':
				var _v1 = exposed.a;
				var name = _v1.b;
				return A2($author$project$Extra$Type$Set$insert, name, types);
			default:
				return types;
		}
	});
var $author$project$Compiler$Reporting$Render$Type$Localizer$toExposing = function (exposing_) {
	if (exposing_.$ === 'Open') {
		return $author$project$Compiler$Reporting$Render$Type$Localizer$All;
	} else {
		var exposedList = exposing_.a;
		return $author$project$Compiler$Reporting$Render$Type$Localizer$Only(
			A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Reporting$Render$Type$Localizer$addType, $author$project$Extra$Type$Set$empty, exposedList));
	}
};
var $author$project$Compiler$Reporting$Render$Type$Localizer$toPair = function (_v0) {
	var _v1 = _v0.a;
	var name = _v1.b;
	var alias = _v0.b;
	var exposing_ = _v0.c;
	return _Utils_Tuple2(
		name,
		A2(
			$author$project$Compiler$Reporting$Render$Type$Localizer$Import,
			alias,
			$author$project$Compiler$Reporting$Render$Type$Localizer$toExposing(exposing_)));
};
var $author$project$Compiler$Reporting$Render$Type$Localizer$fromModule = function (modul) {
	var imports = modul.c;
	return $author$project$Compiler$Reporting$Render$Type$Localizer$Localizer(
		$author$project$Extra$Type$Map$fromList(
			A2(
				$elm$core$List$cons,
				_Utils_Tuple2(
					$author$project$Compiler$AST$Source$getName(modul),
					A2($author$project$Compiler$Reporting$Render$Type$Localizer$Import, $elm$core$Maybe$Nothing, $author$project$Compiler$Reporting$Render$Type$Localizer$All)),
				A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Render$Type$Localizer$toPair, imports))));
};
var $author$project$Compiler$Optimize$Module$addRecordCtorField = F3(
	function (name, _v0, fields) {
		return A4($author$project$Extra$Type$Map$insertWith, $elm$core$Basics$add, name, 1, fields);
	});
var $author$project$Compiler$AST$Optimized$toGlobalComparable = function (_v0) {
	var moduleName = _v0.a;
	var name = _v0.b;
	return _Utils_Tuple2(
		$author$project$Compiler$Elm$ModuleName$toComparable(moduleName),
		name);
};
var $author$project$Compiler$Optimize$Module$addAlias = F4(
	function (home, name, _v0, graph) {
		var tipe = _v0.b;
		var main = graph.a;
		var nodes = graph.b;
		var fieldCounts = graph.c;
		if ((tipe.$ === 'TRecord') && (tipe.b.$ === 'Nothing')) {
			var fields = tipe.a;
			var _v2 = tipe.b;
			var _function = A2(
				$author$project$Compiler$AST$Optimized$Function,
				A2(
					$author$project$Extra$Type$List$map,
					$elm$core$Tuple$first,
					$author$project$Compiler$AST$Canonical$fieldsToList(fields)),
				$author$project$Compiler$AST$Optimized$Record(
					A2(
						$author$project$Extra$Type$Map$mapWithKey,
						F2(
							function (field, _v3) {
								return $author$project$Compiler$AST$Optimized$VarLocal(field);
							}),
						fields)));
			var node = A2($author$project$Compiler$AST$Optimized$Define, _function, $author$project$Extra$Type$Set$empty);
			return A3(
				$author$project$Compiler$AST$Optimized$LocalGraph,
				main,
				A3(
					$author$project$Extra$Type$Map$insert,
					$author$project$Compiler$AST$Optimized$toGlobalComparable(
						A2($author$project$Compiler$AST$Optimized$Global, home, name)),
					node,
					nodes),
				A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Compiler$Optimize$Module$addRecordCtorField, fieldCounts, fields));
		} else {
			return graph;
		}
	});
var $author$project$Compiler$Optimize$Module$addAliases = F3(
	function (home, aliases, graph) {
		return A3(
			$author$project$Extra$Type$Map$foldrWithKey,
			$author$project$Compiler$Optimize$Module$addAlias(home),
			graph,
			aliases);
	});
var $author$project$Compiler$Reporting$Error$Main$BadCycle = F3(
	function (a, b, c) {
		return {$: 'BadCycle', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Warning$MissingTypeAnnotation = {$: 'MissingTypeAnnotation'};
var $author$project$Compiler$Reporting$Error$Main$BadFlags = F2(
	function (a, b) {
		return {$: 'BadFlags', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Main$BadType = F2(
	function (a, b) {
		return {$: 'BadType', a: a, b: b};
	});
var $author$project$Compiler$Optimize$Module$addToGraph = F4(
	function (name, node, fields, _v0) {
		var main = _v0.a;
		var nodes = _v0.b;
		var fieldCounts = _v0.c;
		return A3(
			$author$project$Compiler$AST$Optimized$LocalGraph,
			main,
			A3(
				$author$project$Extra$Type$Map$insert,
				$author$project$Compiler$AST$Optimized$toGlobalComparable(name),
				node,
				nodes),
			A3($author$project$Extra$Type$Map$unionWith, $elm$core$Basics$add, fields, fieldCounts));
	});
var $author$project$Compiler$Optimize$Names$Tracker = function (a) {
	return {$: 'Tracker', a: a};
};
var $author$project$Compiler$Optimize$Names$bind = F2(
	function (_v0, callback) {
		var k = _v0.a;
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (n, d, f) {
					var _v1 = A3(k, n, d, f);
					var n1 = _v1.a;
					var d1 = _v1.b;
					var f1 = _v1.c;
					var a = _v1.d;
					var _v2 = callback(a);
					var kb = _v2.a;
					return A3(kb, n1, d1, f1);
				}));
	});
var $author$project$Extra$Type$List$concat = $elm$core$List$concat;
var $author$project$Compiler$Optimize$Names$andThen = $author$project$Extra$Class$Monad$andThen($author$project$Compiler$Optimize$Names$bind);
var $author$project$Extra$Class$Foldable$foldlM = F6(
	function (pFoldr, pReturn, pBind, f, z0, xs) {
		return A4(
			pFoldr,
			F3(
				function (x, k, z) {
					return A2(
						pBind,
						A2(f, z, x),
						k);
				}),
			pReturn,
			xs,
			z0);
	});
var $author$project$Extra$Type$List$foldlM = F5(
	function (pReturn, pBind, f, z, l) {
		return A6($author$project$Extra$Class$Foldable$foldlM, $author$project$Extra$Type$List$foldr, pReturn, pBind, f, z, l);
	});
var $author$project$Compiler$Optimize$Names$Cok = F4(
	function (a, b, c, d) {
		return {$: 'Cok', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Data$Name$writeDigitsAtEnd = F2(
	function (n, s) {
		return _Utils_ap(
			s,
			$elm$core$String$fromInt(n));
	});
var $author$project$Compiler$Data$Name$fromVarIndex = function (n) {
	return A2($author$project$Compiler$Data$Name$writeDigitsAtEnd, n, '_v');
};
var $author$project$Compiler$Optimize$Names$generate = $author$project$Compiler$Optimize$Names$Tracker(
	F3(
		function (uid, deps, fields) {
			return A4(
				$author$project$Compiler$Optimize$Names$Cok,
				uid + 1,
				deps,
				fields,
				$author$project$Compiler$Data$Name$fromVarIndex(uid));
		}));
var $author$project$Compiler$Optimize$Names$pure = function (value) {
	return $author$project$Compiler$Optimize$Names$Tracker(
		F3(
			function (n, d, f) {
				return A4($author$project$Compiler$Optimize$Names$Cok, n, d, f, value);
			}));
};
var $author$project$Compiler$Optimize$Names$addOne = F2(
	function (name, fields) {
		return A4($author$project$Extra$Type$Map$insertWith, $elm$core$Basics$add, name, 1, fields);
	});
var $author$project$Compiler$Optimize$Names$registerFieldList = F2(
	function (names, value) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, deps, fields) {
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						uid,
						deps,
						A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Optimize$Names$addOne, fields, names),
						value);
				}));
	});
var $author$project$Compiler$Optimize$Names$return = $author$project$Compiler$Optimize$Names$pure;
var $author$project$Compiler$Data$Index$third = $author$project$Compiler$Data$Index$ZeroBased(2);
var $author$project$Compiler$Optimize$Expression$destructCtorArg = F3(
	function (path, revDs, _v11) {
		var index = _v11.a;
		var arg = _v11.c;
		return A3(
			$author$project$Compiler$Optimize$Expression$destructHelp,
			A2($author$project$Compiler$AST$Optimized$Index, index, path),
			arg,
			revDs);
	});
var $author$project$Compiler$Optimize$Expression$destructHelp = F3(
	function (path, _v1, revDs) {
		destructHelp:
		while (true) {
			var region = _v1.a;
			var pattern = _v1.b;
			switch (pattern.$) {
				case 'PAnything':
					return $author$project$Compiler$Optimize$Names$pure(revDs);
				case 'PVar':
					var name = pattern.a;
					return $author$project$Compiler$Optimize$Names$pure(
						A2(
							$elm$core$List$cons,
							A2($author$project$Compiler$AST$Optimized$Destructor, name, path),
							revDs));
				case 'PRecord':
					var fields = pattern.a;
					var toDestruct = function (name) {
						return A2(
							$author$project$Compiler$AST$Optimized$Destructor,
							name,
							A2($author$project$Compiler$AST$Optimized$Field, name, path));
					};
					return A2(
						$author$project$Compiler$Optimize$Names$registerFieldList,
						fields,
						_Utils_ap(
							A2($author$project$Extra$Type$List$map, toDestruct, fields),
							revDs));
				case 'PAlias':
					var subPattern = pattern.a;
					var name = pattern.b;
					return A3(
						$author$project$Compiler$Optimize$Expression$destructHelp,
						$author$project$Compiler$AST$Optimized$Root(name),
						subPattern,
						A2(
							$elm$core$List$cons,
							A2($author$project$Compiler$AST$Optimized$Destructor, name, path),
							revDs));
				case 'PUnit':
					return $author$project$Compiler$Optimize$Names$pure(revDs);
				case 'PTuple':
					if (pattern.c.$ === 'Nothing') {
						var a = pattern.a;
						var b = pattern.b;
						var _v3 = pattern.c;
						return A4($author$project$Compiler$Optimize$Expression$destructTwo, path, a, b, revDs);
					} else {
						var a = pattern.a;
						var b = pattern.b;
						var c = pattern.c.a;
						if (path.$ === 'Root') {
							return A2(
								$author$project$Compiler$Optimize$Names$andThen,
								A2(
									$author$project$Compiler$Optimize$Expression$destructHelp,
									A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$third, path),
									c),
								A2(
									$author$project$Compiler$Optimize$Names$andThen,
									A2(
										$author$project$Compiler$Optimize$Expression$destructHelp,
										A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$second, path),
										b),
									A3(
										$author$project$Compiler$Optimize$Expression$destructHelp,
										A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$first, path),
										a,
										revDs)));
						} else {
							return A2(
								$author$project$Compiler$Optimize$Names$bind,
								$author$project$Compiler$Optimize$Names$generate,
								function (name) {
									var newRoot = $author$project$Compiler$AST$Optimized$Root(name);
									return A2(
										$author$project$Compiler$Optimize$Names$andThen,
										A2(
											$author$project$Compiler$Optimize$Expression$destructHelp,
											A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$third, newRoot),
											c),
										A2(
											$author$project$Compiler$Optimize$Names$andThen,
											A2(
												$author$project$Compiler$Optimize$Expression$destructHelp,
												A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$second, newRoot),
												b),
											A3(
												$author$project$Compiler$Optimize$Expression$destructHelp,
												A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$first, newRoot),
												a,
												A2(
													$elm$core$List$cons,
													A2($author$project$Compiler$AST$Optimized$Destructor, name, path),
													revDs))));
								});
						}
					}
				case 'PList':
					if (!pattern.a.b) {
						return $author$project$Compiler$Optimize$Names$pure(revDs);
					} else {
						var _v5 = pattern.a;
						var hd = _v5.a;
						var tl = _v5.b;
						return A4(
							$author$project$Compiler$Optimize$Expression$destructTwo,
							path,
							hd,
							A2(
								$author$project$Compiler$Reporting$Annotation$At,
								region,
								$author$project$Compiler$AST$Canonical$PList(tl)),
							revDs);
					}
				case 'PCons':
					var hd = pattern.a;
					var tl = pattern.b;
					return A4($author$project$Compiler$Optimize$Expression$destructTwo, path, hd, tl, revDs);
				case 'PChr':
					return $author$project$Compiler$Optimize$Names$pure(revDs);
				case 'PStr':
					return $author$project$Compiler$Optimize$Names$pure(revDs);
				case 'PInt':
					return $author$project$Compiler$Optimize$Names$pure(revDs);
				case 'PBool':
					return $author$project$Compiler$Optimize$Names$pure(revDs);
				default:
					var _v6 = pattern.c;
					var opts = _v6.d;
					var args = pattern.f;
					if (args.b && (!args.b.b)) {
						var _v8 = args.a;
						var arg = _v8.c;
						switch (opts.$) {
							case 'Normal':
								var $temp$path = A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$first, path),
									$temp$_v1 = arg,
									$temp$revDs = revDs;
								path = $temp$path;
								_v1 = $temp$_v1;
								revDs = $temp$revDs;
								continue destructHelp;
							case 'Unbox':
								var $temp$path = $author$project$Compiler$AST$Optimized$Unbox(path),
									$temp$_v1 = arg,
									$temp$revDs = revDs;
								path = $temp$path;
								_v1 = $temp$_v1;
								revDs = $temp$revDs;
								continue destructHelp;
							default:
								var $temp$path = A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$first, path),
									$temp$_v1 = arg,
									$temp$revDs = revDs;
								path = $temp$path;
								_v1 = $temp$_v1;
								revDs = $temp$revDs;
								continue destructHelp;
						}
					} else {
						if (path.$ === 'Root') {
							return A5(
								$author$project$Extra$Type$List$foldlM,
								$author$project$Compiler$Optimize$Names$return,
								$author$project$Compiler$Optimize$Names$bind,
								$author$project$Compiler$Optimize$Expression$destructCtorArg(path),
								revDs,
								args);
						} else {
							return A2(
								$author$project$Compiler$Optimize$Names$bind,
								$author$project$Compiler$Optimize$Names$generate,
								function (name) {
									return A5(
										$author$project$Extra$Type$List$foldlM,
										$author$project$Compiler$Optimize$Names$return,
										$author$project$Compiler$Optimize$Names$bind,
										$author$project$Compiler$Optimize$Expression$destructCtorArg(
											$author$project$Compiler$AST$Optimized$Root(name)),
										A2(
											$elm$core$List$cons,
											A2($author$project$Compiler$AST$Optimized$Destructor, name, path),
											revDs),
										args);
								});
						}
					}
			}
		}
	});
var $author$project$Compiler$Optimize$Expression$destructTwo = F4(
	function (path, a, b, revDs) {
		if (path.$ === 'Root') {
			return A2(
				$author$project$Compiler$Optimize$Names$andThen,
				A2(
					$author$project$Compiler$Optimize$Expression$destructHelp,
					A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$second, path),
					b),
				A3(
					$author$project$Compiler$Optimize$Expression$destructHelp,
					A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$first, path),
					a,
					revDs));
		} else {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Names$generate,
				function (name) {
					var newRoot = $author$project$Compiler$AST$Optimized$Root(name);
					return A2(
						$author$project$Compiler$Optimize$Names$andThen,
						A2(
							$author$project$Compiler$Optimize$Expression$destructHelp,
							A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$second, newRoot),
							b),
						A3(
							$author$project$Compiler$Optimize$Expression$destructHelp,
							A2($author$project$Compiler$AST$Optimized$Index, $author$project$Compiler$Data$Index$first, newRoot),
							a,
							A2(
								$elm$core$List$cons,
								A2($author$project$Compiler$AST$Optimized$Destructor, name, path),
								revDs)));
				});
		}
	});
var $author$project$Compiler$Optimize$Expression$destruct = function (pattern) {
	var ptrn = pattern.b;
	switch (ptrn.$) {
		case 'PVar':
			var name = ptrn.a;
			return $author$project$Compiler$Optimize$Names$pure(
				_Utils_Tuple2(name, _List_Nil));
		case 'PAlias':
			var subPattern = ptrn.a;
			var name = ptrn.b;
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				A3(
					$author$project$Compiler$Optimize$Expression$destructHelp,
					$author$project$Compiler$AST$Optimized$Root(name),
					subPattern,
					_List_Nil),
				function (revDs) {
					return $author$project$Compiler$Optimize$Names$pure(
						_Utils_Tuple2(
							name,
							$author$project$Extra$Type$List$reverse(revDs)));
				});
		default:
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Names$generate,
				function (name) {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						A3(
							$author$project$Compiler$Optimize$Expression$destructHelp,
							$author$project$Compiler$AST$Optimized$Root(name),
							pattern,
							_List_Nil),
						function (revDs) {
							return $author$project$Compiler$Optimize$Names$pure(
								_Utils_Tuple2(
									name,
									$author$project$Extra$Type$List$reverse(revDs)));
						});
				});
	}
};
var $author$project$Compiler$Optimize$Names$fmap = F2(
	function (func, _v0) {
		var kv = _v0.a;
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (n, d, f) {
					var _v1 = A3(kv, n, d, f);
					var n1 = _v1.a;
					var d1 = _v1.b;
					var f1 = _v1.c;
					var value = _v1.d;
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						n1,
						d1,
						f1,
						func(value));
				}));
	});
var $author$project$Compiler$Optimize$Names$andMap = F2(
	function (_v0, _v1) {
		var kv = _v0.a;
		var kf = _v1.a;
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (n, d, f) {
					var _v2 = A3(kf, n, d, f);
					var n1 = _v2.a;
					var d1 = _v2.b;
					var f1 = _v2.c;
					var func = _v2.d;
					var _v3 = A3(kv, n1, d1, f1);
					var n2 = _v3.a;
					var d2 = _v3.b;
					var f2 = _v3.c;
					var value = _v3.d;
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						n2,
						d2,
						f2,
						func(value));
				}));
	});
var $author$project$Compiler$Optimize$Names$liftA2 = A2($author$project$Extra$Class$Applicative$liftA2, $author$project$Compiler$Optimize$Names$fmap, $author$project$Compiler$Optimize$Names$andMap);
var $elm$core$List$unzip = function (pairs) {
	var step = F2(
		function (_v0, _v1) {
			var x = _v0.a;
			var y = _v0.b;
			var xs = _v1.a;
			var ys = _v1.b;
			return _Utils_Tuple2(
				A2($elm$core$List$cons, x, xs),
				A2($elm$core$List$cons, y, ys));
		});
	return A3(
		$elm$core$List$foldr,
		step,
		_Utils_Tuple2(_List_Nil, _List_Nil),
		pairs);
};
var $author$project$Extra$Type$List$unzip = $elm$core$List$unzip;
var $author$project$Compiler$Optimize$Expression$destructArgs = function (args) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		A2(
			$author$project$Compiler$Optimize$Names$fmap,
			$author$project$Extra$Type$List$unzip,
			A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Optimize$Names$pure, $author$project$Compiler$Optimize$Names$liftA2, $author$project$Compiler$Optimize$Expression$destruct, args)),
		function (_v0) {
			var argNames = _v0.a;
			var destructorLists = _v0.b;
			return $author$project$Compiler$Optimize$Names$return(
				_Utils_Tuple2(
					argNames,
					$author$project$Extra$Type$List$concat(destructorLists)));
		});
};
var $author$project$Compiler$Optimize$Expression$destructCase = F2(
	function (rootName, pattern) {
		return A2(
			$author$project$Compiler$Optimize$Names$fmap,
			$author$project$Extra$Type$List$reverse,
			A3(
				$author$project$Compiler$Optimize$Expression$destructHelp,
				$author$project$Compiler$AST$Optimized$Root(rootName),
				pattern,
				_List_Nil));
	});
var $author$project$Compiler$Data$Name$negate = 'negate';
var $author$project$Extra$Type$Maybe$catMaybes = $author$project$Extra$Type$Maybe$mapMaybe($elm$core$Basics$identity);
var $author$project$Compiler$Optimize$DecisionTree$Branch = F2(
	function (a, b) {
		return {$: 'Branch', a: a, b: b};
	});
var $author$project$Compiler$Optimize$DecisionTree$Decision = F3(
	function (a, b, c) {
		return {$: 'Decision', a: a, b: b, c: c};
	});
var $author$project$Compiler$Optimize$DecisionTree$Match = function (a) {
	return {$: 'Match', a: a};
};
var $author$project$Compiler$Optimize$DecisionTree$needsTests = function (_v0) {
	var pattern = _v0.b;
	switch (pattern.$) {
		case 'PVar':
			return false;
		case 'PAnything':
			return false;
		case 'PRecord':
			return false;
		case 'PCtor':
			return true;
		case 'PList':
			return true;
		case 'PCons':
			return true;
		case 'PUnit':
			return true;
		case 'PTuple':
			return true;
		case 'PChr':
			return true;
		case 'PStr':
			return true;
		case 'PInt':
			return true;
		case 'PBool':
			return true;
		default:
			return _Debug_todo(
				'Compiler.Optimize.DecisionTree',
				{
					start: {line: 551, column: 7},
					end: {line: 551, column: 17}
				})('aliases should never reach \'isIrrelevantTo\' function');
	}
};
var $author$project$Compiler$Optimize$DecisionTree$checkForMatch = function (branches) {
	if (branches.b) {
		var _v1 = branches.a;
		var goal = _v1.a;
		var patterns = _v1.b;
		return A2(
			$author$project$Extra$Type$List$all,
			A2(
				$elm$core$Basics$composeL,
				A2($elm$core$Basics$composeL, $elm$core$Basics$not, $author$project$Compiler$Optimize$DecisionTree$needsTests),
				$elm$core$Tuple$second),
			patterns) ? $elm$core$Maybe$Just(goal) : $elm$core$Maybe$Nothing;
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Compiler$Optimize$DecisionTree$dearg = function (_v0) {
	var pattern = _v0.c;
	return pattern;
};
var $author$project$Compiler$Optimize$DecisionTree$subPositions = F2(
	function (path, patterns) {
		return A2(
			$author$project$Compiler$Data$Index$indexedMap,
			F2(
				function (index, pattern) {
					return _Utils_Tuple2(
						A2($author$project$Compiler$Optimize$DecisionTree$Index, index, path),
						pattern);
				}),
			patterns);
	});
var $author$project$Compiler$Optimize$DecisionTree$flatten = F2(
	function (pathPattern, otherPathPatterns) {
		flatten:
		while (true) {
			var path = pathPattern.a;
			var _v0 = pathPattern.b;
			var region = _v0.a;
			var pattern = _v0.b;
			switch (pattern.$) {
				case 'PVar':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PAnything':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PCtor':
					var _v2 = pattern.c;
					var numAlts = _v2.c;
					var ctorArgs = pattern.f;
					if (numAlts === 1) {
						var _v3 = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Optimize$DecisionTree$dearg, ctorArgs);
						if (_v3.b && (!_v3.b.b)) {
							var arg = _v3.a;
							var $temp$pathPattern = _Utils_Tuple2(
								$author$project$Compiler$Optimize$DecisionTree$Unbox(path),
								arg),
								$temp$otherPathPatterns = otherPathPatterns;
							pathPattern = $temp$pathPattern;
							otherPathPatterns = $temp$otherPathPatterns;
							continue flatten;
						} else {
							var args = _v3;
							return A3(
								$author$project$Extra$Type$List$foldr,
								$author$project$Compiler$Optimize$DecisionTree$flatten,
								otherPathPatterns,
								A2($author$project$Compiler$Optimize$DecisionTree$subPositions, path, args));
						}
					} else {
						return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
					}
				case 'PTuple':
					var a = pattern.a;
					var b = pattern.b;
					var maybeC = pattern.c;
					return A2(
						$author$project$Compiler$Optimize$DecisionTree$flatten,
						_Utils_Tuple2(
							A2($author$project$Compiler$Optimize$DecisionTree$Index, $author$project$Compiler$Data$Index$first, path),
							a),
						A2(
							$author$project$Compiler$Optimize$DecisionTree$flatten,
							_Utils_Tuple2(
								A2($author$project$Compiler$Optimize$DecisionTree$Index, $author$project$Compiler$Data$Index$second, path),
								b),
							function () {
								if (maybeC.$ === 'Nothing') {
									return otherPathPatterns;
								} else {
									var c = maybeC.a;
									return A2(
										$author$project$Compiler$Optimize$DecisionTree$flatten,
										_Utils_Tuple2(
											A2($author$project$Compiler$Optimize$DecisionTree$Index, $author$project$Compiler$Data$Index$third, path),
											c),
										otherPathPatterns);
								}
							}()));
				case 'PUnit':
					return otherPathPatterns;
				case 'PAlias':
					var realPattern = pattern.a;
					var alias = pattern.b;
					return A2(
						$author$project$Compiler$Optimize$DecisionTree$flatten,
						_Utils_Tuple2(path, realPattern),
						A2(
							$elm$core$List$cons,
							_Utils_Tuple2(
								path,
								A2(
									$author$project$Compiler$Reporting$Annotation$At,
									region,
									$author$project$Compiler$AST$Canonical$PVar(alias))),
							otherPathPatterns));
				case 'PRecord':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PList':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PCons':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PChr':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PStr':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				case 'PInt':
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
				default:
					return A2($elm$core$List$cons, pathPattern, otherPathPatterns);
			}
		}
	});
var $author$project$Compiler$Optimize$DecisionTree$flattenPatterns = function (_v0) {
	var goal = _v0.a;
	var pathPatterns = _v0.b;
	return A2(
		$author$project$Compiler$Optimize$DecisionTree$Branch,
		goal,
		A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Optimize$DecisionTree$flatten, _List_Nil, pathPatterns));
};
var $author$project$Compiler$Optimize$DecisionTree$Found = F3(
	function (a, b, c) {
		return {$: 'Found', a: a, b: b, c: c};
	});
var $author$project$Compiler$Optimize$DecisionTree$NotFound = {$: 'NotFound'};
var $author$project$Compiler$Optimize$DecisionTree$extract = F2(
	function (selectedPath, pathPatterns) {
		if (!pathPatterns.b) {
			return $author$project$Compiler$Optimize$DecisionTree$NotFound;
		} else {
			var first = pathPatterns.a;
			var path = first.a;
			var pattern = first.b;
			var rest = pathPatterns.b;
			if (_Utils_eq(path, selectedPath)) {
				return A3($author$project$Compiler$Optimize$DecisionTree$Found, _List_Nil, pattern, rest);
			} else {
				var _v1 = A2($author$project$Compiler$Optimize$DecisionTree$extract, selectedPath, rest);
				if (_v1.$ === 'NotFound') {
					return $author$project$Compiler$Optimize$DecisionTree$NotFound;
				} else {
					var start = _v1.a;
					var foundPattern = _v1.b;
					var end = _v1.c;
					return A3(
						$author$project$Compiler$Optimize$DecisionTree$Found,
						A2($elm$core$List$cons, first, start),
						foundPattern,
						end);
				}
			}
		}
	});
var $author$project$Extra$Type$Maybe$maybeToList = function (l) {
	if (l.$ === 'Nothing') {
		return _List_Nil;
	} else {
		var x = l.a;
		return _List_fromArray(
			[x]);
	}
};
var $author$project$Compiler$Optimize$DecisionTree$toRelevantBranch = F3(
	function (test, path, branch) {
		var goal = branch.a;
		var pathPatterns = branch.b;
		var _v0 = A2($author$project$Compiler$Optimize$DecisionTree$extract, path, pathPatterns);
		if (_v0.$ === 'Found') {
			var start = _v0.a;
			var _v1 = _v0.b;
			var region = _v1.a;
			var pattern = _v1.b;
			var end = _v0.c;
			switch (pattern.$) {
				case 'PCtor':
					var _v3 = pattern.c;
					var numAlts = _v3.c;
					var name = pattern.d;
					var ctorArgs = pattern.f;
					if (test.$ === 'IsCtor') {
						var testName = test.b;
						return _Utils_eq(name, testName) ? $elm$core$Maybe$Just(
							A2(
								$author$project$Compiler$Optimize$DecisionTree$Branch,
								goal,
								function () {
									var args = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Optimize$DecisionTree$dearg, ctorArgs);
									var otherwise = function (_v6) {
										return _Utils_ap(
											start,
											_Utils_ap(
												A2($author$project$Compiler$Optimize$DecisionTree$subPositions, path, args),
												end));
									};
									if (args.b && (!args.b.b)) {
										var arg = args.a;
										return (numAlts === 1) ? _Utils_ap(
											start,
											A2(
												$elm$core$List$cons,
												_Utils_Tuple2(
													$author$project$Compiler$Optimize$DecisionTree$Unbox(path),
													arg),
												end)) : otherwise(_Utils_Tuple0);
									} else {
										return otherwise(_Utils_Tuple0);
									}
								}())) : $elm$core$Maybe$Nothing;
					} else {
						return $elm$core$Maybe$Nothing;
					}
				case 'PList':
					if (!pattern.a.b) {
						if (test.$ === 'IsNil') {
							return $elm$core$Maybe$Just(
								A2(
									$author$project$Compiler$Optimize$DecisionTree$Branch,
									goal,
									_Utils_ap(start, end)));
						} else {
							return $elm$core$Maybe$Nothing;
						}
					} else {
						var _v8 = pattern.a;
						var hd = _v8.a;
						var tl = _v8.b;
						if (test.$ === 'IsCons') {
							var tl_ = A2(
								$author$project$Compiler$Reporting$Annotation$At,
								region,
								$author$project$Compiler$AST$Canonical$PList(tl));
							return $elm$core$Maybe$Just(
								A2(
									$author$project$Compiler$Optimize$DecisionTree$Branch,
									goal,
									_Utils_ap(
										start,
										_Utils_ap(
											A2(
												$author$project$Compiler$Optimize$DecisionTree$subPositions,
												path,
												_List_fromArray(
													[hd, tl_])),
											end))));
						} else {
							return $elm$core$Maybe$Nothing;
						}
					}
				case 'PCons':
					var hd = pattern.a;
					var tl = pattern.b;
					if (test.$ === 'IsCons') {
						return $elm$core$Maybe$Just(
							A2(
								$author$project$Compiler$Optimize$DecisionTree$Branch,
								goal,
								_Utils_ap(
									start,
									_Utils_ap(
										A2(
											$author$project$Compiler$Optimize$DecisionTree$subPositions,
											path,
											_List_fromArray(
												[hd, tl])),
										end))));
					} else {
						return $elm$core$Maybe$Nothing;
					}
				case 'PChr':
					var chr = pattern.a;
					if (test.$ === 'IsChr') {
						var testChr = test.a;
						return _Utils_eq(chr, testChr) ? $elm$core$Maybe$Just(
							A2(
								$author$project$Compiler$Optimize$DecisionTree$Branch,
								goal,
								_Utils_ap(start, end))) : $elm$core$Maybe$Nothing;
					} else {
						return $elm$core$Maybe$Nothing;
					}
				case 'PStr':
					var str = pattern.a;
					if (test.$ === 'IsStr') {
						var testStr = test.a;
						return _Utils_eq(str, testStr) ? $elm$core$Maybe$Just(
							A2(
								$author$project$Compiler$Optimize$DecisionTree$Branch,
								goal,
								_Utils_ap(start, end))) : $elm$core$Maybe$Nothing;
					} else {
						return $elm$core$Maybe$Nothing;
					}
				case 'PInt':
					var _int = pattern.a;
					if (test.$ === 'IsInt') {
						var testInt = test.a;
						return _Utils_eq(_int, testInt) ? $elm$core$Maybe$Just(
							A2(
								$author$project$Compiler$Optimize$DecisionTree$Branch,
								goal,
								_Utils_ap(start, end))) : $elm$core$Maybe$Nothing;
					} else {
						return $elm$core$Maybe$Nothing;
					}
				case 'PBool':
					var bool = pattern.b;
					if (test.$ === 'IsBool') {
						var testBool = test.a;
						return _Utils_eq(bool, testBool) ? $elm$core$Maybe$Just(
							A2(
								$author$project$Compiler$Optimize$DecisionTree$Branch,
								goal,
								_Utils_ap(start, end))) : $elm$core$Maybe$Nothing;
					} else {
						return $elm$core$Maybe$Nothing;
					}
				case 'PUnit':
					return $elm$core$Maybe$Just(
						A2(
							$author$project$Compiler$Optimize$DecisionTree$Branch,
							goal,
							_Utils_ap(start, end)));
				case 'PTuple':
					var a = pattern.a;
					var b = pattern.b;
					var maybeC = pattern.c;
					return $elm$core$Maybe$Just(
						A2(
							$author$project$Compiler$Optimize$DecisionTree$Branch,
							goal,
							_Utils_ap(
								start,
								_Utils_ap(
									A2(
										$author$project$Compiler$Optimize$DecisionTree$subPositions,
										path,
										A2(
											$elm$core$List$cons,
											a,
											A2(
												$elm$core$List$cons,
												b,
												$author$project$Extra$Type$Maybe$maybeToList(maybeC)))),
									end))));
				case 'PVar':
					return $elm$core$Maybe$Just(branch);
				case 'PAnything':
					return $elm$core$Maybe$Just(branch);
				case 'PRecord':
					return $elm$core$Maybe$Just(branch);
				default:
					return $elm$core$Maybe$Just(branch);
			}
		} else {
			return $elm$core$Maybe$Just(branch);
		}
	});
var $author$project$Compiler$Optimize$DecisionTree$edgesFor = F3(
	function (path, branches, test) {
		return _Utils_Tuple2(
			test,
			A2(
				$author$project$Extra$Type$Maybe$mapMaybe,
				A2($author$project$Compiler$Optimize$DecisionTree$toRelevantBranch, test, path),
				branches));
	});
var $author$project$Compiler$Optimize$DecisionTree$isComplete = function (tests) {
	var _v0 = $author$project$Extra$Type$List$head(tests);
	switch (_v0.$) {
		case 'IsCtor':
			var numAlts = _v0.d;
			return _Utils_eq(
				numAlts,
				$author$project$Extra$Type$List$length(tests));
		case 'IsCons':
			return $author$project$Extra$Type$List$length(tests) === 2;
		case 'IsNil':
			return $author$project$Extra$Type$List$length(tests) === 2;
		case 'IsTuple':
			return true;
		case 'IsChr':
			return false;
		case 'IsStr':
			return false;
		case 'IsInt':
			return false;
		default:
			return $author$project$Extra$Type$List$length(tests) === 2;
	}
};
var $author$project$Compiler$Optimize$DecisionTree$isIrrelevantTo = F2(
	function (selectedPath, _v0) {
		var pathPatterns = _v0.b;
		var _v1 = A2($author$project$Extra$Type$List$lookup, selectedPath, pathPatterns);
		if (_v1.$ === 'Nothing') {
			return true;
		} else {
			var pattern = _v1.a;
			return !$author$project$Compiler$Optimize$DecisionTree$needsTests(pattern);
		}
	});
var $author$project$Compiler$Optimize$DecisionTree$testAtPath = F2(
	function (selectedPath, _v0) {
		var pathPatterns = _v0.b;
		return A2(
			$author$project$Extra$Type$Maybe$bind,
			A2($author$project$Extra$Type$List$lookup, selectedPath, pathPatterns),
			function (_v1) {
				var pattern = _v1.b;
				switch (pattern.$) {
					case 'PCtor':
						var home = pattern.a;
						var _v3 = pattern.c;
						var numAlts = _v3.c;
						var opts = _v3.d;
						var name = pattern.d;
						var index = pattern.e;
						return $elm$core$Maybe$Just(
							A5($author$project$Compiler$Optimize$DecisionTree$IsCtor, home, name, index, numAlts, opts));
					case 'PList':
						var ps = pattern.a;
						return $elm$core$Maybe$Just(
							function () {
								if (!ps.b) {
									return $author$project$Compiler$Optimize$DecisionTree$IsNil;
								} else {
									return $author$project$Compiler$Optimize$DecisionTree$IsCons;
								}
							}());
					case 'PCons':
						return $elm$core$Maybe$Just($author$project$Compiler$Optimize$DecisionTree$IsCons);
					case 'PTuple':
						return $elm$core$Maybe$Just($author$project$Compiler$Optimize$DecisionTree$IsTuple);
					case 'PUnit':
						return $elm$core$Maybe$Just($author$project$Compiler$Optimize$DecisionTree$IsTuple);
					case 'PVar':
						return $elm$core$Maybe$Nothing;
					case 'PAnything':
						return $elm$core$Maybe$Nothing;
					case 'PInt':
						var _int = pattern.a;
						return $elm$core$Maybe$Just(
							$author$project$Compiler$Optimize$DecisionTree$IsInt(_int));
					case 'PStr':
						var str = pattern.a;
						return $elm$core$Maybe$Just(
							$author$project$Compiler$Optimize$DecisionTree$IsStr(str));
					case 'PChr':
						var chr = pattern.a;
						return $elm$core$Maybe$Just(
							$author$project$Compiler$Optimize$DecisionTree$IsChr(chr));
					case 'PBool':
						var bool = pattern.b;
						return $elm$core$Maybe$Just(
							$author$project$Compiler$Optimize$DecisionTree$IsBool(bool));
					case 'PRecord':
						return $elm$core$Maybe$Nothing;
					default:
						return _Debug_todo(
							'Compiler.Optimize.DecisionTree',
							{
								start: {line: 381, column: 9},
								end: {line: 381, column: 19}
							})('aliases should never reach \'testAtPath\' function');
				}
			});
	});
var $author$project$Compiler$AST$Canonical$ctorOptsToString = function (ctorOpts) {
	switch (ctorOpts.$) {
		case 'Normal':
			return 'Normal';
		case 'Enum':
			return 'Enum';
		default:
			return 'Unbox';
	}
};
var $author$project$Compiler$Data$Index$toMachine = function (_v0) {
	var index = _v0.a;
	return index;
};
var $author$project$Compiler$Elm$Package$toString = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return author + ('/' + project);
};
var $author$project$Compiler$Elm$ModuleName$toString = function (_v0) {
	var pkg = _v0.a;
	var name = _v0.b;
	return $author$project$Compiler$Elm$Package$toString(pkg) + ('/' + name);
};
var $author$project$Compiler$Optimize$DecisionTree$toTestComparable = function (test) {
	switch (test.$) {
		case 'IsCtor':
			var home = test.a;
			var name = test.b;
			var index = test.c;
			var numAlts = test.d;
			var opts = test.e;
			return 'ctor:' + ($author$project$Compiler$Elm$ModuleName$toString(home) + (':' + (name + (':' + ($elm$core$String$fromInt(
				$author$project$Compiler$Data$Index$toMachine(index)) + (':' + ($elm$core$String$fromInt(numAlts) + (':' + $author$project$Compiler$AST$Canonical$ctorOptsToString(opts)))))))));
		case 'IsCons':
			return 'cons';
		case 'IsNil':
			return 'nil';
		case 'IsTuple':
			return 'tuple';
		case 'IsInt':
			var _int = test.a;
			return 'int:' + $elm$core$String$fromInt(_int);
		case 'IsChr':
			var chr = test.a;
			return 'chr:' + chr;
		case 'IsStr':
			var str = test.a;
			return 'str:' + str;
		default:
			var bool = test.a;
			return 'bool:' + (bool ? 'True' : 'False');
	}
};
var $author$project$Compiler$Optimize$DecisionTree$testsAtPath = F2(
	function (selectedPath, branches) {
		var skipVisited = F2(
			function (test, curr) {
				var uniqueTests = curr.a;
				var visitedTests = curr.b;
				var testComparable = $author$project$Compiler$Optimize$DecisionTree$toTestComparable(test);
				return A2($author$project$Extra$Type$Set$member, testComparable, visitedTests) ? curr : _Utils_Tuple2(
					A2($elm$core$List$cons, test, uniqueTests),
					A2($author$project$Extra$Type$Set$insert, testComparable, visitedTests));
			});
		var allTests = A2(
			$author$project$Extra$Type$Maybe$mapMaybe,
			$author$project$Compiler$Optimize$DecisionTree$testAtPath(selectedPath),
			branches);
		return A3(
			$author$project$Extra$Type$List$foldr,
			skipVisited,
			_Utils_Tuple2(_List_Nil, $author$project$Extra$Type$Set$empty),
			allTests).a;
	});
var $author$project$Compiler$Optimize$DecisionTree$gatherEdges = F2(
	function (branches, path) {
		var relevantTests = A2($author$project$Compiler$Optimize$DecisionTree$testsAtPath, path, branches);
		var fallbacks = $author$project$Compiler$Optimize$DecisionTree$isComplete(relevantTests) ? _List_Nil : A2(
			$author$project$Extra$Type$List$filter,
			$author$project$Compiler$Optimize$DecisionTree$isIrrelevantTo(path),
			branches);
		var allEdges = A2(
			$author$project$Extra$Type$List$map,
			A2($author$project$Compiler$Optimize$DecisionTree$edgesFor, path, branches),
			relevantTests);
		return _Utils_Tuple2(allEdges, fallbacks);
	});
var $author$project$Compiler$Optimize$DecisionTree$addWeights = F2(
	function (toWeight, paths) {
		return A2(
			$author$project$Extra$Type$List$map,
			function (path) {
				return _Utils_Tuple2(
					path,
					toWeight(path));
			},
			paths);
	});
var $author$project$Compiler$Optimize$DecisionTree$bests = function (allPaths) {
	if (!allPaths.b) {
		return _Debug_todo(
			'Compiler.Optimize.DecisionTree',
			{
				start: {line: 590, column: 7},
				end: {line: 590, column: 17}
			})('Cannot choose the best of zero paths. This should never happen.');
	} else {
		var _v1 = allPaths.a;
		var headPath = _v1.a;
		var headWeight = _v1.b;
		var weightedPaths = allPaths.b;
		var gatherMinimum = F2(
			function (acc, _v2) {
				var minWeight = acc.a;
				var paths = acc.b;
				var path = _v2.a;
				var weight = _v2.b;
				return _Utils_eq(weight, minWeight) ? _Utils_Tuple2(
					minWeight,
					A2($elm$core$List$cons, path, paths)) : ((_Utils_cmp(weight, minWeight) < 0) ? _Utils_Tuple2(
					weight,
					_List_fromArray(
						[path])) : acc);
			});
		return A3(
			$author$project$Extra$Type$List$foldl,
			gatherMinimum,
			_Utils_Tuple2(
				headWeight,
				_List_fromArray(
					[headPath])),
			weightedPaths).b;
	}
};
var $author$project$Compiler$Optimize$DecisionTree$getPatterns = function (_v0) {
	var patterns = _v0.b;
	return patterns;
};
var $author$project$Compiler$Optimize$DecisionTree$isChoicePath = function (_v0) {
	var path = _v0.a;
	var pattern = _v0.b;
	return $author$project$Compiler$Optimize$DecisionTree$needsTests(pattern) ? $elm$core$Maybe$Just(path) : $elm$core$Maybe$Nothing;
};
var $author$project$Compiler$Optimize$DecisionTree$smallBranchingFactor = F2(
	function (branches, path) {
		var _v0 = A2($author$project$Compiler$Optimize$DecisionTree$gatherEdges, branches, path);
		var edges = _v0.a;
		var fallback = _v0.b;
		return $author$project$Extra$Type$List$length(edges) + ($author$project$Extra$Type$List$null(fallback) ? 0 : 1);
	});
var $author$project$Compiler$Optimize$DecisionTree$smallDefaults = F2(
	function (branches, path) {
		return $author$project$Extra$Type$List$length(
			A2(
				$author$project$Extra$Type$List$filter,
				$author$project$Compiler$Optimize$DecisionTree$isIrrelevantTo(path),
				branches));
	});
var $author$project$Compiler$Optimize$DecisionTree$pickPath = function (branches) {
	var allPaths = A2(
		$author$project$Extra$Type$Maybe$mapMaybe,
		$author$project$Compiler$Optimize$DecisionTree$isChoicePath,
		A2($author$project$Extra$Type$List$concatMap, $author$project$Compiler$Optimize$DecisionTree$getPatterns, branches));
	var _v0 = $author$project$Compiler$Optimize$DecisionTree$bests(
		A2(
			$author$project$Compiler$Optimize$DecisionTree$addWeights,
			$author$project$Compiler$Optimize$DecisionTree$smallDefaults(branches),
			allPaths));
	if (_v0.b && (!_v0.b.b)) {
		var path = _v0.a;
		return path;
	} else {
		var tiedPaths = _v0;
		return $author$project$Extra$Type$List$head(
			$author$project$Compiler$Optimize$DecisionTree$bests(
				A2(
					$author$project$Compiler$Optimize$DecisionTree$addWeights,
					$author$project$Compiler$Optimize$DecisionTree$smallBranchingFactor(branches),
					tiedPaths)));
	}
};
var $author$project$Compiler$Optimize$DecisionTree$toDecisionTree = function (rawBranches) {
	toDecisionTree:
	while (true) {
		var branches = A2($author$project$Extra$Type$List$map, $author$project$Compiler$Optimize$DecisionTree$flattenPatterns, rawBranches);
		var _v0 = $author$project$Compiler$Optimize$DecisionTree$checkForMatch(branches);
		if (_v0.$ === 'Just') {
			var goal = _v0.a;
			return $author$project$Compiler$Optimize$DecisionTree$Match(goal);
		} else {
			var path = $author$project$Compiler$Optimize$DecisionTree$pickPath(branches);
			var _v1 = A2($author$project$Compiler$Optimize$DecisionTree$gatherEdges, branches, path);
			var edges = _v1.a;
			var fallback = _v1.b;
			var decisionEdges = A2(
				$author$project$Extra$Type$List$map,
				$elm$core$Tuple$mapSecond($author$project$Compiler$Optimize$DecisionTree$toDecisionTree),
				edges);
			var _v2 = _Utils_Tuple2(decisionEdges, fallback);
			if (!_v2.b.b) {
				if (_v2.a.b && (!_v2.a.b.b)) {
					var _v3 = _v2.a;
					var _v4 = _v3.a;
					var decisionTree = _v4.b;
					return decisionTree;
				} else {
					return A3($author$project$Compiler$Optimize$DecisionTree$Decision, path, decisionEdges, $elm$core$Maybe$Nothing);
				}
			} else {
				if (!_v2.a.b) {
					var _v5 = _v2.b;
					var $temp$rawBranches = fallback;
					rawBranches = $temp$rawBranches;
					continue toDecisionTree;
				} else {
					return A3(
						$author$project$Compiler$Optimize$DecisionTree$Decision,
						path,
						decisionEdges,
						$elm$core$Maybe$Just(
							$author$project$Compiler$Optimize$DecisionTree$toDecisionTree(fallback)));
				}
			}
		}
	}
};
var $author$project$Compiler$Optimize$DecisionTree$compile = function (rawBranches) {
	var format = function (_v0) {
		var pattern = _v0.a;
		var index = _v0.b;
		return A2(
			$author$project$Compiler$Optimize$DecisionTree$Branch,
			index,
			_List_fromArray(
				[
					_Utils_Tuple2($author$project$Compiler$Optimize$DecisionTree$Empty, pattern)
				]));
	};
	return $author$project$Compiler$Optimize$DecisionTree$toDecisionTree(
		A2($author$project$Extra$Type$List$map, format, rawBranches));
};
var $author$project$Compiler$Optimize$Case$countTargets = function (decisionTree) {
	switch (decisionTree.$) {
		case 'Leaf':
			var target = decisionTree.a;
			return A2($author$project$Extra$Type$Map$singleton, target, 1);
		case 'Chain':
			var success = decisionTree.b;
			var failure = decisionTree.c;
			return A3(
				$author$project$Extra$Type$Map$unionWith,
				$elm$core$Basics$add,
				$author$project$Compiler$Optimize$Case$countTargets(success),
				$author$project$Compiler$Optimize$Case$countTargets(failure));
		default:
			var tests = decisionTree.b;
			var fallback = decisionTree.c;
			return A3(
				$author$project$Extra$Type$Map$unionsWith,
				$author$project$Extra$Type$List$foldl,
				$elm$core$Basics$add,
				A2(
					$author$project$Extra$Type$List$map,
					$author$project$Compiler$Optimize$Case$countTargets,
					A2(
						$elm$core$List$cons,
						fallback,
						A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, tests))));
	}
};
var $author$project$Compiler$Optimize$Case$createChoices = F2(
	function (targetCounts, _v0) {
		var target = _v0.a;
		var branch = _v0.b;
		return (A2($author$project$Extra$Type$Map$ex, targetCounts, target) === 1) ? _Utils_Tuple2(
			_Utils_Tuple2(
				target,
				$author$project$Compiler$AST$Optimized$Inline(branch)),
			$elm$core$Maybe$Nothing) : _Utils_Tuple2(
			_Utils_Tuple2(
				target,
				$author$project$Compiler$AST$Optimized$Jump(target)),
			$elm$core$Maybe$Just(
				_Utils_Tuple2(target, branch)));
	});
var $author$project$Compiler$Optimize$Case$indexify = F2(
	function (index, _v0) {
		var pattern = _v0.a;
		var branch = _v0.b;
		return _Utils_Tuple2(
			_Utils_Tuple2(pattern, index),
			_Utils_Tuple2(index, branch));
	});
var $author$project$Compiler$Optimize$Case$insertChoices = F2(
	function (choiceDict, decider) {
		var go = $author$project$Compiler$Optimize$Case$insertChoices(choiceDict);
		switch (decider.$) {
			case 'Leaf':
				var target = decider.a;
				return $author$project$Compiler$AST$Optimized$Leaf(
					A2($author$project$Extra$Type$Map$ex, choiceDict, target));
			case 'Chain':
				var testChain = decider.a;
				var success = decider.b;
				var failure = decider.c;
				return A3(
					$author$project$Compiler$AST$Optimized$Chain,
					testChain,
					go(success),
					go(failure));
			default:
				var path = decider.a;
				var tests = decider.b;
				var fallback = decider.c;
				return A3(
					$author$project$Compiler$AST$Optimized$FanOut,
					path,
					A2(
						$author$project$Extra$Type$List$map,
						$elm$core$Tuple$mapSecond(go),
						tests),
					go(fallback));
		}
	});
var $author$project$Extra$Type$List$init = A2(
	$elm$core$Basics$composeR,
	$author$project$Extra$Type$List$reverse,
	A2(
		$elm$core$Basics$composeR,
		$author$project$Extra$Type$List$drop(1),
		$author$project$Extra$Type$List$reverse));
var $author$project$Compiler$Optimize$Case$toChain = F4(
	function (path, test, successTree, failureTree) {
		var failure = $author$project$Compiler$Optimize$Case$treeToDecider(failureTree);
		var success_ = $author$project$Compiler$Optimize$Case$treeToDecider(successTree);
		var otherwise = function (_v15) {
			return A3(
				$author$project$Compiler$AST$Optimized$Chain,
				_List_fromArray(
					[
						_Utils_Tuple2(path, test)
					]),
				success_,
				failure);
		};
		if (success_.$ === 'Chain') {
			var testChain = success_.a;
			var success = success_.b;
			var subFailure = success_.c;
			return _Utils_eq(failure, subFailure) ? A3(
				$author$project$Compiler$AST$Optimized$Chain,
				A2(
					$elm$core$List$cons,
					_Utils_Tuple2(path, test),
					testChain),
				success,
				failure) : otherwise(_Utils_Tuple0);
		} else {
			return otherwise(_Utils_Tuple0);
		}
	});
var $author$project$Compiler$Optimize$Case$treeToDecider = function (tree) {
	treeToDecider:
	while (true) {
		if (tree.$ === 'Match') {
			var target = tree.a;
			return $author$project$Compiler$AST$Optimized$Leaf(target);
		} else {
			if (tree.c.$ === 'Nothing') {
				if (!tree.b.b) {
					var _v1 = tree.c;
					return _Debug_todo(
						'Compiler.Optimize.Case',
						{
							start: {line: 59, column: 7},
							end: {line: 59, column: 17}
						})('compiler bug, somehow created an empty decision tree');
				} else {
					if (!tree.b.b.b) {
						var _v2 = tree.b;
						var _v3 = _v2.a;
						var subTree = _v3.b;
						var _v4 = tree.c;
						var $temp$tree = subTree;
						tree = $temp$tree;
						continue treeToDecider;
					} else {
						if (!tree.b.b.b.b) {
							var path = tree.a;
							var _v7 = tree.b;
							var _v8 = _v7.a;
							var test = _v8.a;
							var successTree = _v8.b;
							var _v9 = _v7.b;
							var _v10 = _v9.a;
							var failureTree = _v10.b;
							var _v11 = tree.c;
							return A4($author$project$Compiler$Optimize$Case$toChain, path, test, successTree, failureTree);
						} else {
							var path = tree.a;
							var edges = tree.b;
							var _v12 = tree.c;
							var _v13 = _Utils_Tuple2(
								$author$project$Extra$Type$List$init(edges),
								$author$project$Extra$Type$List$last(edges).b);
							var necessaryTests = _v13.a;
							var fallback = _v13.b;
							return A3(
								$author$project$Compiler$AST$Optimized$FanOut,
								path,
								A2(
									$author$project$Extra$Type$List$map,
									$elm$core$Tuple$mapSecond($author$project$Compiler$Optimize$Case$treeToDecider),
									necessaryTests),
								$author$project$Compiler$Optimize$Case$treeToDecider(fallback));
						}
					}
				}
			} else {
				if (!tree.b.b) {
					var subTree = tree.c.a;
					var $temp$tree = subTree;
					tree = $temp$tree;
					continue treeToDecider;
				} else {
					if (!tree.b.b.b) {
						var path = tree.a;
						var _v5 = tree.b;
						var _v6 = _v5.a;
						var test = _v6.a;
						var successTree = _v6.b;
						var failureTree = tree.c.a;
						return A4($author$project$Compiler$Optimize$Case$toChain, path, test, successTree, failureTree);
					} else {
						var path = tree.a;
						var edges = tree.b;
						var fallback = tree.c.a;
						return A3(
							$author$project$Compiler$AST$Optimized$FanOut,
							path,
							A2(
								$author$project$Extra$Type$List$map,
								$elm$core$Tuple$mapSecond($author$project$Compiler$Optimize$Case$treeToDecider),
								edges),
							$author$project$Compiler$Optimize$Case$treeToDecider(fallback));
					}
				}
			}
		}
	}
};
var $author$project$Compiler$Optimize$Case$optimize = F3(
	function (temp, root, optBranches) {
		var _v0 = $author$project$Extra$Type$List$unzip(
			A3(
				$author$project$Extra$Type$List$zipWith,
				$author$project$Compiler$Optimize$Case$indexify,
				A2(
					$author$project$Extra$Type$List$range,
					0,
					$author$project$Extra$Type$List$length(optBranches) - 1),
				optBranches));
		var patterns = _v0.a;
		var indexedBranches = _v0.b;
		var decider = $author$project$Compiler$Optimize$Case$treeToDecider(
			$author$project$Compiler$Optimize$DecisionTree$compile(patterns));
		var targetCounts = $author$project$Compiler$Optimize$Case$countTargets(decider);
		var _v1 = $author$project$Extra$Type$List$unzip(
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Optimize$Case$createChoices(targetCounts),
				indexedBranches));
		var choices = _v1.a;
		var maybeJumps = _v1.b;
		return A4(
			$author$project$Compiler$AST$Optimized$Case,
			temp,
			root,
			A2(
				$author$project$Compiler$Optimize$Case$insertChoices,
				$author$project$Extra$Type$Map$fromList(choices),
				decider),
			$author$project$Extra$Type$Maybe$catMaybes(maybeJumps));
	});
var $author$project$Compiler$Data$Name$identity_ = 'identity';
var $author$project$Compiler$Optimize$Names$identity_ = A2($author$project$Compiler$AST$Optimized$Global, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$identity_);
var $author$project$Compiler$Optimize$Names$registerCtor = F4(
	function (home, name, index, opts) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, deps, fields) {
					var global = A2($author$project$Compiler$AST$Optimized$Global, home, name);
					var newDeps = A2(
						$author$project$Extra$Type$Set$insert,
						$author$project$Compiler$AST$Optimized$toGlobalComparable(global),
						deps);
					switch (opts.$) {
						case 'Normal':
							return A4(
								$author$project$Compiler$Optimize$Names$Cok,
								uid,
								newDeps,
								fields,
								$author$project$Compiler$AST$Optimized$VarGlobal(global));
						case 'Enum':
							return A4(
								$author$project$Compiler$Optimize$Names$Cok,
								uid,
								newDeps,
								fields,
								function () {
									var otherwise = function (_v2) {
										return A2($author$project$Compiler$AST$Optimized$VarEnum, global, index);
									};
									switch (name) {
										case 'True':
											return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) ? $author$project$Compiler$AST$Optimized$CBool(true) : otherwise(_Utils_Tuple0);
										case 'False':
											return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) ? $author$project$Compiler$AST$Optimized$CBool(false) : otherwise(_Utils_Tuple0);
										default:
											return otherwise(_Utils_Tuple0);
									}
								}());
						default:
							return A4(
								$author$project$Compiler$Optimize$Names$Cok,
								uid,
								A2(
									$author$project$Extra$Type$Set$insert,
									$author$project$Compiler$AST$Optimized$toGlobalComparable($author$project$Compiler$Optimize$Names$identity_),
									newDeps),
								fields,
								$author$project$Compiler$AST$Optimized$VarBox(global));
					}
				}));
	});
var $author$project$Compiler$Optimize$Names$registerDebug = F3(
	function (name, home, region) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, deps, fields) {
					var global = A2($author$project$Compiler$AST$Optimized$Global, $author$project$Compiler$Elm$ModuleName$debug, name);
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						uid,
						A2(
							$author$project$Extra$Type$Set$insert,
							$author$project$Compiler$AST$Optimized$toGlobalComparable(global),
							deps),
						fields,
						A4($author$project$Compiler$AST$Optimized$VarDebug, name, home, region, $elm$core$Maybe$Nothing));
				}));
	});
var $author$project$Compiler$Optimize$Names$registerField = F2(
	function (name, value) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, d, fields) {
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						uid,
						d,
						A4($author$project$Extra$Type$Map$insertWith, $elm$core$Basics$add, name, 1, fields),
						value);
				}));
	});
var $author$project$Compiler$Optimize$Names$toOne = function (_v0) {
	return 1;
};
var $author$project$Compiler$Optimize$Names$registerFieldDict = F2(
	function (newFields, value) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, d, fields) {
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						uid,
						d,
						A3(
							$author$project$Extra$Type$Map$unionWith,
							$elm$core$Basics$add,
							fields,
							A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Optimize$Names$toOne, newFields)),
						value);
				}));
	});
var $author$project$Compiler$Optimize$Names$registerGlobal = F2(
	function (home, name) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, deps, fields) {
					var global = A2($author$project$Compiler$AST$Optimized$Global, home, name);
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						uid,
						A2(
							$author$project$Extra$Type$Set$insert,
							$author$project$Compiler$AST$Optimized$toGlobalComparable(global),
							deps),
						fields,
						$author$project$Compiler$AST$Optimized$VarGlobal(global));
				}));
	});
var $author$project$Compiler$Data$Name$dollar = '$';
var $author$project$Compiler$Elm$Package$kernel = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'kernel');
var $author$project$Compiler$AST$Optimized$toKernelGlobal = function (shortName) {
	return A2(
		$author$project$Compiler$AST$Optimized$Global,
		A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$kernel, shortName),
		$author$project$Compiler$Data$Name$dollar);
};
var $author$project$Compiler$Optimize$Names$registerKernel = F2(
	function (home, value) {
		return $author$project$Compiler$Optimize$Names$Tracker(
			F3(
				function (uid, deps, fields) {
					return A4(
						$author$project$Compiler$Optimize$Names$Cok,
						uid,
						A2(
							$author$project$Extra$Type$Set$insert,
							$author$project$Compiler$AST$Optimized$toGlobalComparable(
								$author$project$Compiler$AST$Optimized$toKernelGlobal(home)),
							deps),
						fields,
						value);
				}));
	});
var $author$project$Compiler$Optimize$Expression$decidecHasTailCall = function (decider) {
	switch (decider.$) {
		case 'Leaf':
			var choice = decider.a;
			if (choice.$ === 'Inline') {
				var expr = choice.a;
				return $author$project$Compiler$Optimize$Expression$hasTailCall(expr);
			} else {
				return false;
			}
		case 'Chain':
			var success = decider.b;
			var failure = decider.c;
			return $author$project$Compiler$Optimize$Expression$decidecHasTailCall(success) || $author$project$Compiler$Optimize$Expression$decidecHasTailCall(failure);
		default:
			var tests = decider.b;
			var fallback = decider.c;
			return $author$project$Compiler$Optimize$Expression$decidecHasTailCall(fallback) || A2(
				$author$project$Extra$Type$List$any,
				A2($elm$core$Basics$composeL, $author$project$Compiler$Optimize$Expression$decidecHasTailCall, $elm$core$Tuple$second),
				tests);
	}
};
var $author$project$Compiler$Optimize$Expression$hasTailCall = function (expression) {
	hasTailCall:
	while (true) {
		switch (expression.$) {
			case 'TailCall':
				return true;
			case 'If':
				var branches = expression.a;
				var _finally = expression.b;
				return $author$project$Compiler$Optimize$Expression$hasTailCall(_finally) || A2(
					$author$project$Extra$Type$List$any,
					A2($elm$core$Basics$composeL, $author$project$Compiler$Optimize$Expression$hasTailCall, $elm$core$Tuple$second),
					branches);
			case 'Let':
				var body = expression.b;
				var $temp$expression = body;
				expression = $temp$expression;
				continue hasTailCall;
			case 'Destruct':
				var body = expression.b;
				var $temp$expression = body;
				expression = $temp$expression;
				continue hasTailCall;
			case 'Case':
				var decider = expression.c;
				var jumps = expression.d;
				return $author$project$Compiler$Optimize$Expression$decidecHasTailCall(decider) || A2(
					$author$project$Extra$Type$List$any,
					A2($elm$core$Basics$composeL, $author$project$Compiler$Optimize$Expression$hasTailCall, $elm$core$Tuple$second),
					jumps);
			default:
				return false;
		}
	}
};
var $author$project$Compiler$Optimize$Expression$toTailDef = F4(
	function (name, argNames, destructors, body) {
		return $author$project$Compiler$Optimize$Expression$hasTailCall(body) ? A3(
			$author$project$Compiler$AST$Optimized$TailDef,
			name,
			argNames,
			A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, body, destructors)) : A2(
			$author$project$Compiler$AST$Optimized$Def,
			name,
			A2(
				$author$project$Compiler$AST$Optimized$Function,
				argNames,
				A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, body, destructors)));
	});
var $author$project$Extra$Type$Map$traverseWithKey = F4(
	function (pPure, pLiftA2, f, ma) {
		return A3(
			$author$project$Extra$Type$Map$foldrWithKey,
			F3(
				function (k, a, fdb) {
					return A3(
						pLiftA2,
						F2(
							function (b, db) {
								return A3($author$project$Extra$Type$Map$insert, k, b, db);
							}),
						A2(f, k, a),
						fdb);
				}),
			pPure($author$project$Extra$Type$Map$empty),
			ma);
	});
var $author$project$Extra$Type$Map$traverse = F3(
	function (pPure, pLiftA2, f) {
		return A3(
			$author$project$Extra$Type$Map$traverseWithKey,
			pPure,
			pLiftA2,
			function (_v0) {
				return f;
			});
	});
var $author$project$Extra$Type$Maybe$traverse = F4(
	function (pPure, pFmap, f, ma) {
		if (ma.$ === 'Just') {
			var a = ma.a;
			return A2(
				pFmap,
				$elm$core$Maybe$Just,
				f(a));
		} else {
			return pPure($elm$core$Maybe$Nothing);
		}
	});
var $author$project$Compiler$Data$Name$utils = 'Utils';
var $author$project$Compiler$Optimize$Expression$optimize = F2(
	function (cycle, _v19) {
		var region = _v19.a;
		var expression = _v19.b;
		switch (expression.$) {
			case 'VarLocal':
				var name = expression.a;
				return $author$project$Compiler$Optimize$Names$pure(
					$author$project$Compiler$AST$Optimized$VarLocal(name));
			case 'VarTopLevel':
				var home = expression.a;
				var name = expression.b;
				return A2($author$project$Extra$Type$Set$member, name, cycle) ? $author$project$Compiler$Optimize$Names$pure(
					A2($author$project$Compiler$AST$Optimized$VarCycle, home, name)) : A2($author$project$Compiler$Optimize$Names$registerGlobal, home, name);
			case 'VarKernel':
				var home = expression.a;
				var name = expression.b;
				return A2(
					$author$project$Compiler$Optimize$Names$registerKernel,
					home,
					A2($author$project$Compiler$AST$Optimized$VarKernel, home, name));
			case 'VarForeign':
				var home = expression.a;
				var name = expression.b;
				return A2($author$project$Compiler$Optimize$Names$registerGlobal, home, name);
			case 'VarCtor':
				var opts = expression.a;
				var home = expression.b;
				var name = expression.c;
				var index = expression.d;
				return A4($author$project$Compiler$Optimize$Names$registerCtor, home, name, index, opts);
			case 'VarDebug':
				var home = expression.a;
				var name = expression.b;
				return A3($author$project$Compiler$Optimize$Names$registerDebug, name, home, region);
			case 'VarOperator':
				var home = expression.b;
				var name = expression.c;
				return A2($author$project$Compiler$Optimize$Names$registerGlobal, home, name);
			case 'Chr':
				var chr = expression.a;
				return A2(
					$author$project$Compiler$Optimize$Names$registerKernel,
					$author$project$Compiler$Data$Name$utils,
					$author$project$Compiler$AST$Optimized$Chr(chr));
			case 'Str':
				var str = expression.a;
				return $author$project$Compiler$Optimize$Names$pure(
					$author$project$Compiler$AST$Optimized$Str(str));
			case 'CInt':
				var _int = expression.a;
				return $author$project$Compiler$Optimize$Names$pure(
					$author$project$Compiler$AST$Optimized$CInt(_int));
			case 'CFloat':
				var _float = expression.a;
				return $author$project$Compiler$Optimize$Names$pure(
					$author$project$Compiler$AST$Optimized$CFloat(_float));
			case 'CList':
				var entries = expression.a;
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A4(
						$author$project$Extra$Type$List$traverse,
						$author$project$Compiler$Optimize$Names$pure,
						$author$project$Compiler$Optimize$Names$liftA2,
						$author$project$Compiler$Optimize$Expression$optimize(cycle),
						entries),
					A2($author$project$Compiler$Optimize$Names$registerKernel, $author$project$Compiler$Data$Name$list, $author$project$Compiler$AST$Optimized$CList));
			case 'Negate':
				var expr = expression.a;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$negate),
					function (func) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr),
							function (arg) {
								return $author$project$Compiler$Optimize$Names$pure(
									A2(
										$author$project$Compiler$AST$Optimized$Call,
										func,
										_List_fromArray(
											[arg])));
							});
					});
			case 'Binop':
				var home = expression.b;
				var name = expression.c;
				var left = expression.e;
				var right = expression.f;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					A2($author$project$Compiler$Optimize$Names$registerGlobal, home, name),
					function (optFunc) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, left),
							function (optLeft) {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A2($author$project$Compiler$Optimize$Expression$optimize, cycle, right),
									function (optRight) {
										return $author$project$Compiler$Optimize$Names$return(
											A2(
												$author$project$Compiler$AST$Optimized$Call,
												optFunc,
												_List_fromArray(
													[optLeft, optRight])));
									});
							});
					});
			case 'Lambda':
				var args = expression.a;
				var body = expression.b;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Expression$destructArgs(args),
					function (_v21) {
						var argNames = _v21.a;
						var destructors = _v21.b;
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, body),
							function (obody) {
								return $author$project$Compiler$Optimize$Names$pure(
									A2(
										$author$project$Compiler$AST$Optimized$Function,
										argNames,
										A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, obody, destructors)));
							});
					});
			case 'Call':
				var func = expression.a;
				var args = expression.b;
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A4(
						$author$project$Extra$Type$List$traverse,
						$author$project$Compiler$Optimize$Names$pure,
						$author$project$Compiler$Optimize$Names$liftA2,
						$author$project$Compiler$Optimize$Expression$optimize(cycle),
						args),
					A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A2($author$project$Compiler$Optimize$Expression$optimize, cycle, func),
						$author$project$Compiler$Optimize$Names$pure($author$project$Compiler$AST$Optimized$Call)));
			case 'If':
				var branches = expression.a;
				var _finally = expression.b;
				var optimizeBranch = function (_v22) {
					var condition = _v22.a;
					var branch = _v22.b;
					return A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A2($author$project$Compiler$Optimize$Expression$optimize, cycle, branch),
						A2(
							$author$project$Compiler$Optimize$Names$andMap,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, condition),
							$author$project$Compiler$Optimize$Names$pure($elm$core$Tuple$pair)));
				};
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A2($author$project$Compiler$Optimize$Expression$optimize, cycle, _finally),
					A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Optimize$Names$pure, $author$project$Compiler$Optimize$Names$liftA2, optimizeBranch, branches),
						$author$project$Compiler$Optimize$Names$pure($author$project$Compiler$AST$Optimized$If)));
			case 'Let':
				var def = expression.a;
				var body = expression.b;
				return A2(
					$author$project$Compiler$Optimize$Names$andThen,
					A2($author$project$Compiler$Optimize$Expression$optimizeDef, cycle, def),
					A2($author$project$Compiler$Optimize$Expression$optimize, cycle, body));
			case 'LetRec':
				var defs = expression.a;
				var body = expression.b;
				if (defs.b && (!defs.b.b)) {
					var def = defs.a;
					return A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A2($author$project$Compiler$Optimize$Expression$optimize, cycle, body),
						A2(
							$author$project$Compiler$Optimize$Names$andMap,
							A2($author$project$Compiler$Optimize$Expression$optimizePotentialTailCallDef, cycle, def),
							$author$project$Compiler$Optimize$Names$pure($author$project$Compiler$AST$Optimized$Let)));
				} else {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						A2($author$project$Compiler$Optimize$Expression$optimize, cycle, body),
						function (obody) {
							return A5(
								$author$project$Extra$Type$List$foldlM,
								$author$project$Compiler$Optimize$Names$return,
								$author$project$Compiler$Optimize$Names$bind,
								F2(
									function (bod, def) {
										return A3($author$project$Compiler$Optimize$Expression$optimizeDef, cycle, def, bod);
									}),
								obody,
								defs);
						});
				}
			case 'LetDestruct':
				var pattern = expression.a;
				var expr = expression.b;
				var body = expression.c;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Expression$destruct(pattern),
					function (_v24) {
						var name = _v24.a;
						var destructs = _v24.b;
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr),
							function (oexpr) {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A2($author$project$Compiler$Optimize$Expression$optimize, cycle, body),
									function (obody) {
										return $author$project$Compiler$Optimize$Names$pure(
											A2(
												$author$project$Compiler$AST$Optimized$Let,
												A2($author$project$Compiler$AST$Optimized$Def, name, oexpr),
												A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, obody, destructs)));
									});
							});
					});
			case 'Case':
				var expr = expression.a;
				var branches = expression.b;
				var optimizeBranch = F2(
					function (root, _v26) {
						var pattern = _v26.a;
						var branch = _v26.b;
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$destructCase, root, pattern),
							function (destructors) {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A2($author$project$Compiler$Optimize$Expression$optimize, cycle, branch),
									function (obranch) {
										return $author$project$Compiler$Optimize$Names$pure(
											_Utils_Tuple2(
												pattern,
												A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, obranch, destructors)));
									});
							});
					});
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Names$generate,
					function (temp) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr),
							function (oexpr) {
								if (oexpr.$ === 'VarLocal') {
									var root = oexpr.a;
									return A2(
										$author$project$Compiler$Optimize$Names$fmap,
										A2($author$project$Compiler$Optimize$Case$optimize, temp, root),
										A4(
											$author$project$Extra$Type$List$traverse,
											$author$project$Compiler$Optimize$Names$pure,
											$author$project$Compiler$Optimize$Names$liftA2,
											optimizeBranch(root),
											branches));
								} else {
									return A2(
										$author$project$Compiler$Optimize$Names$bind,
										A4(
											$author$project$Extra$Type$List$traverse,
											$author$project$Compiler$Optimize$Names$pure,
											$author$project$Compiler$Optimize$Names$liftA2,
											optimizeBranch(temp),
											branches),
										function (obranches) {
											return $author$project$Compiler$Optimize$Names$return(
												A2(
													$author$project$Compiler$AST$Optimized$Let,
													A2($author$project$Compiler$AST$Optimized$Def, temp, oexpr),
													A3($author$project$Compiler$Optimize$Case$optimize, temp, temp, obranches)));
										});
								}
							});
					});
			case 'Accessor':
				var field = expression.a;
				return A2(
					$author$project$Compiler$Optimize$Names$registerField,
					field,
					$author$project$Compiler$AST$Optimized$Accessor(field));
			case 'Access':
				var record = expression.a;
				var _v27 = expression.b;
				var field = _v27.b;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					A2($author$project$Compiler$Optimize$Expression$optimize, cycle, record),
					function (optRecord) {
						return A2(
							$author$project$Compiler$Optimize$Names$registerField,
							field,
							A2($author$project$Compiler$AST$Optimized$Access, optRecord, field));
					});
			case 'Update':
				var record = expression.b;
				var updates = expression.c;
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A4(
						$author$project$Extra$Type$Map$traverse,
						$author$project$Compiler$Optimize$Names$pure,
						$author$project$Compiler$Optimize$Names$liftA2,
						$author$project$Compiler$Optimize$Expression$optimizeUpdate(cycle),
						updates),
					A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A2($author$project$Compiler$Optimize$Expression$optimize, cycle, record),
						A2($author$project$Compiler$Optimize$Names$registerFieldDict, updates, $author$project$Compiler$AST$Optimized$Update)));
			case 'Record':
				var fields = expression.a;
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A4(
						$author$project$Extra$Type$Map$traverse,
						$author$project$Compiler$Optimize$Names$pure,
						$author$project$Compiler$Optimize$Names$liftA2,
						$author$project$Compiler$Optimize$Expression$optimize(cycle),
						fields),
					A2($author$project$Compiler$Optimize$Names$registerFieldDict, fields, $author$project$Compiler$AST$Optimized$Record));
			case 'Unit':
				return A2($author$project$Compiler$Optimize$Names$registerKernel, $author$project$Compiler$Data$Name$utils, $author$project$Compiler$AST$Optimized$Unit);
			case 'Tuple':
				var a = expression.a;
				var b = expression.b;
				var maybeC = expression.c;
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A4(
						$author$project$Extra$Type$Maybe$traverse,
						$author$project$Compiler$Optimize$Names$pure,
						$author$project$Compiler$Optimize$Names$fmap,
						$author$project$Compiler$Optimize$Expression$optimize(cycle),
						maybeC),
					A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A2($author$project$Compiler$Optimize$Expression$optimize, cycle, b),
						A2(
							$author$project$Compiler$Optimize$Names$andMap,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, a),
							A2($author$project$Compiler$Optimize$Names$registerKernel, $author$project$Compiler$Data$Name$utils, $author$project$Compiler$AST$Optimized$Tuple))));
			default:
				var src = expression.a;
				var _v28 = expression.b;
				var attributes = _v28.a;
				var uniforms = _v28.b;
				return $author$project$Compiler$Optimize$Names$pure(
					A3($author$project$Compiler$AST$Optimized$Shader, src, attributes, uniforms));
		}
	});
var $author$project$Compiler$Optimize$Expression$optimizeDef = F3(
	function (cycle, def, body) {
		if (def.$ === 'Def') {
			var _v17 = def.a;
			var name = _v17.b;
			var args = def.b;
			var expr = def.c;
			return A5($author$project$Compiler$Optimize$Expression$optimizeDefHelp, cycle, name, args, expr, body);
		} else {
			var _v18 = def.a;
			var name = _v18.b;
			var typedArgs = def.c;
			var expr = def.d;
			return A5(
				$author$project$Compiler$Optimize$Expression$optimizeDefHelp,
				cycle,
				name,
				A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, typedArgs),
				expr,
				body);
		}
	});
var $author$project$Compiler$Optimize$Expression$optimizeDefHelp = F5(
	function (cycle, name, args, expr, body) {
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr),
			function (oexpr) {
				if (!args.b) {
					return $author$project$Compiler$Optimize$Names$pure(
						A2(
							$author$project$Compiler$AST$Optimized$Let,
							A2($author$project$Compiler$AST$Optimized$Def, name, oexpr),
							body));
				} else {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						$author$project$Compiler$Optimize$Expression$destructArgs(args),
						function (_v15) {
							var argNames = _v15.a;
							var destructors = _v15.b;
							var ofunc = A2(
								$author$project$Compiler$AST$Optimized$Function,
								argNames,
								A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, oexpr, destructors));
							return $author$project$Compiler$Optimize$Names$pure(
								A2(
									$author$project$Compiler$AST$Optimized$Let,
									A2($author$project$Compiler$AST$Optimized$Def, name, ofunc),
									body));
						});
				}
			});
	});
var $author$project$Compiler$Optimize$Expression$optimizePotentialTailCall = F4(
	function (cycle, name, args, expr) {
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			$author$project$Compiler$Optimize$Expression$destructArgs(args),
			function (_v13) {
				var argNames = _v13.a;
				var destructors = _v13.b;
				return A2(
					$author$project$Compiler$Optimize$Names$fmap,
					A3($author$project$Compiler$Optimize$Expression$toTailDef, name, argNames, destructors),
					A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, name, argNames, expr));
			});
	});
var $author$project$Compiler$Optimize$Expression$optimizePotentialTailCallDef = F2(
	function (cycle, def) {
		if (def.$ === 'Def') {
			var _v11 = def.a;
			var name = _v11.b;
			var args = def.b;
			var expr = def.c;
			return A4($author$project$Compiler$Optimize$Expression$optimizePotentialTailCall, cycle, name, args, expr);
		} else {
			var _v12 = def.a;
			var name = _v12.b;
			var typedArgs = def.c;
			var expr = def.d;
			return A4(
				$author$project$Compiler$Optimize$Expression$optimizePotentialTailCall,
				cycle,
				name,
				A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, typedArgs),
				expr);
		}
	});
var $author$project$Compiler$Optimize$Expression$optimizeTail = F4(
	function (cycle, rootName, argNames, locExpr) {
		var expression = locExpr.b;
		switch (expression.$) {
			case 'Call':
				var func = expression.a;
				var args = expression.b;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					A4(
						$author$project$Extra$Type$List$traverse,
						$author$project$Compiler$Optimize$Names$pure,
						$author$project$Compiler$Optimize$Names$liftA2,
						$author$project$Compiler$Optimize$Expression$optimize(cycle),
						args),
					function (oargs) {
						var isMatchingName = function () {
							var _v4 = $author$project$Compiler$Reporting$Annotation$toValue(func);
							switch (_v4.$) {
								case 'VarLocal':
									var name = _v4.a;
									return _Utils_eq(rootName, name);
								case 'VarTopLevel':
									var name = _v4.b;
									return _Utils_eq(rootName, name);
								default:
									return false;
							}
						}();
						if (isMatchingName) {
							var _v2 = A3(
								$author$project$Compiler$Data$Index$indexedZipWith,
								F3(
									function (_v3, a, b) {
										return _Utils_Tuple2(a, b);
									}),
								argNames,
								oargs);
							if (_v2.$ === 'LengthMatch') {
								var pairs = _v2.a;
								return $author$project$Compiler$Optimize$Names$pure(
									A2($author$project$Compiler$AST$Optimized$TailCall, rootName, pairs));
							} else {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A2($author$project$Compiler$Optimize$Expression$optimize, cycle, func),
									function (ofunc) {
										return $author$project$Compiler$Optimize$Names$pure(
											A2($author$project$Compiler$AST$Optimized$Call, ofunc, oargs));
									});
							}
						} else {
							return A2(
								$author$project$Compiler$Optimize$Names$bind,
								A2($author$project$Compiler$Optimize$Expression$optimize, cycle, func),
								function (ofunc) {
									return $author$project$Compiler$Optimize$Names$pure(
										A2($author$project$Compiler$AST$Optimized$Call, ofunc, oargs));
								});
						}
					});
			case 'If':
				var branches = expression.a;
				var _finally = expression.b;
				var optimizeBranch = function (_v5) {
					var condition = _v5.a;
					var branch = _v5.b;
					return A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, branch),
						A2(
							$author$project$Compiler$Optimize$Names$andMap,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, condition),
							$author$project$Compiler$Optimize$Names$pure($elm$core$Tuple$pair)));
				};
				return A2(
					$author$project$Compiler$Optimize$Names$andMap,
					A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, _finally),
					A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Optimize$Names$pure, $author$project$Compiler$Optimize$Names$liftA2, optimizeBranch, branches),
						$author$project$Compiler$Optimize$Names$pure($author$project$Compiler$AST$Optimized$If)));
			case 'Let':
				var def = expression.a;
				var body = expression.b;
				return A2(
					$author$project$Compiler$Optimize$Names$andThen,
					A2($author$project$Compiler$Optimize$Expression$optimizeDef, cycle, def),
					A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, body));
			case 'LetRec':
				var defs = expression.a;
				var body = expression.b;
				if (defs.b && (!defs.b.b)) {
					var def = defs.a;
					return A2(
						$author$project$Compiler$Optimize$Names$andMap,
						A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, body),
						A2(
							$author$project$Compiler$Optimize$Names$andMap,
							A2($author$project$Compiler$Optimize$Expression$optimizePotentialTailCallDef, cycle, def),
							$author$project$Compiler$Optimize$Names$pure($author$project$Compiler$AST$Optimized$Let)));
				} else {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, body),
						function (obody) {
							return A5(
								$author$project$Extra$Type$List$foldlM,
								$author$project$Compiler$Optimize$Names$return,
								$author$project$Compiler$Optimize$Names$bind,
								F2(
									function (bod, def) {
										return A3($author$project$Compiler$Optimize$Expression$optimizeDef, cycle, def, bod);
									}),
								obody,
								defs);
						});
				}
			case 'LetDestruct':
				var pattern = expression.a;
				var expr = expression.b;
				var body = expression.c;
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Expression$destruct(pattern),
					function (_v7) {
						var dname = _v7.a;
						var destructors = _v7.b;
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr),
							function (oexpr) {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, body),
									function (obody) {
										return $author$project$Compiler$Optimize$Names$pure(
											A2(
												$author$project$Compiler$AST$Optimized$Let,
												A2($author$project$Compiler$AST$Optimized$Def, dname, oexpr),
												A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, obody, destructors)));
									});
							});
					});
			case 'Case':
				var expr = expression.a;
				var branches = expression.b;
				var optimizeBranch = F2(
					function (root, _v9) {
						var pattern = _v9.a;
						var branch = _v9.b;
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$destructCase, root, pattern),
							function (destructors) {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A4($author$project$Compiler$Optimize$Expression$optimizeTail, cycle, rootName, argNames, branch),
									function (obranch) {
										return $author$project$Compiler$Optimize$Names$pure(
											_Utils_Tuple2(
												pattern,
												A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, obranch, destructors)));
									});
							});
					});
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Names$generate,
					function (temp) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr),
							function (oexpr) {
								if (oexpr.$ === 'VarLocal') {
									var root = oexpr.a;
									return A2(
										$author$project$Compiler$Optimize$Names$fmap,
										A2($author$project$Compiler$Optimize$Case$optimize, temp, root),
										A4(
											$author$project$Extra$Type$List$traverse,
											$author$project$Compiler$Optimize$Names$pure,
											$author$project$Compiler$Optimize$Names$liftA2,
											optimizeBranch(root),
											branches));
								} else {
									return A2(
										$author$project$Compiler$Optimize$Names$bind,
										A4(
											$author$project$Extra$Type$List$traverse,
											$author$project$Compiler$Optimize$Names$pure,
											$author$project$Compiler$Optimize$Names$liftA2,
											optimizeBranch(temp),
											branches),
										function (obranches) {
											return $author$project$Compiler$Optimize$Names$return(
												A2(
													$author$project$Compiler$AST$Optimized$Let,
													A2($author$project$Compiler$AST$Optimized$Def, temp, oexpr),
													A3($author$project$Compiler$Optimize$Case$optimize, temp, temp, obranches)));
										});
								}
							});
					});
			default:
				return A2($author$project$Compiler$Optimize$Expression$optimize, cycle, locExpr);
		}
	});
var $author$project$Compiler$Optimize$Expression$optimizeUpdate = F2(
	function (cycle, _v0) {
		var expr = _v0.b;
		return A2($author$project$Compiler$Optimize$Expression$optimize, cycle, expr);
	});
var $author$project$Compiler$Optimize$Names$run = function (_v0) {
	var k = _v0.a;
	var _v1 = A3(k, 0, $author$project$Extra$Type$Set$empty, $author$project$Extra$Type$Map$empty);
	var deps = _v1.b;
	var fields = _v1.c;
	var value = _v1.d;
	return _Utils_Tuple3(deps, fields, value);
};
var $elm$core$Set$union = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$union, dict1, dict2));
	});
var $author$project$Extra$Type$Set$union = $elm$core$Set$union;
var $author$project$Compiler$Optimize$Module$addDefNode = F6(
	function (home, name, args, body, mainDeps, graph) {
		var _v0 = $author$project$Compiler$Optimize$Names$run(
			function () {
				if (!args.b) {
					return A2($author$project$Compiler$Optimize$Expression$optimize, $author$project$Extra$Type$Set$empty, body);
				} else {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						$author$project$Compiler$Optimize$Expression$destructArgs(args),
						function (_v2) {
							var argNames = _v2.a;
							var destructors = _v2.b;
							return A2(
								$author$project$Compiler$Optimize$Names$bind,
								A2($author$project$Compiler$Optimize$Expression$optimize, $author$project$Extra$Type$Set$empty, body),
								function (obody) {
									return $author$project$Compiler$Optimize$Names$pure(
										A2(
											$author$project$Compiler$AST$Optimized$Function,
											argNames,
											A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$Destruct, obody, destructors)));
								});
						});
				}
			}());
		var deps = _v0.a;
		var fields = _v0.b;
		var def = _v0.c;
		return A4(
			$author$project$Compiler$Optimize$Module$addToGraph,
			A2($author$project$Compiler$AST$Optimized$Global, home, name),
			A2(
				$author$project$Compiler$AST$Optimized$Define,
				def,
				A2($author$project$Extra$Type$Set$union, deps, mainDeps)),
			fields,
			graph);
	});
var $author$project$Compiler$Data$Name$l_main = 'main';
var $author$project$Compiler$Data$Name$node = 'Node';
var $author$project$Compiler$Data$Name$platform = 'Platform';
var $author$project$Compiler$Elm$ModuleName$platform = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$platform);
var $author$project$Compiler$Data$Name$program = 'Program';
var $author$project$Compiler$Elm$ModuleName$jsonDecode = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$json, 'Json.Decode');
var $author$project$Compiler$Optimize$Port$decode = function (name) {
	return A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$jsonDecode, name);
};
var $author$project$Compiler$Optimize$Port$decodeTuple0 = A2(
	$author$project$Compiler$Optimize$Names$bind,
	$author$project$Compiler$Optimize$Port$decode('null'),
	function (_null) {
		return $author$project$Compiler$Optimize$Names$return(
			A2(
				$author$project$Compiler$AST$Optimized$Call,
				_null,
				_List_fromArray(
					[$author$project$Compiler$AST$Optimized$Unit])));
	});
var $author$project$Compiler$Data$Name$toElmString = $elm$core$Basics$identity;
var $author$project$Compiler$Optimize$Port$toLocal = function (index) {
	return $author$project$Compiler$AST$Optimized$VarLocal(
		$author$project$Compiler$Data$Name$fromVarIndex(index));
};
var $author$project$Compiler$Optimize$Port$decodeArray = function (tipe) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		$author$project$Compiler$Optimize$Port$decode('array'),
		function (array) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Port$toDecoder(tipe),
				function (decoder) {
					return $author$project$Compiler$Optimize$Names$return(
						A2(
							$author$project$Compiler$AST$Optimized$Call,
							array,
							_List_fromArray(
								[decoder])));
				});
		});
};
var $author$project$Compiler$Optimize$Port$decodeList = function (tipe) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		$author$project$Compiler$Optimize$Port$decode('list'),
		function (list) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Port$toDecoder(tipe),
				function (decoder) {
					return $author$project$Compiler$Optimize$Names$return(
						A2(
							$author$project$Compiler$AST$Optimized$Call,
							list,
							_List_fromArray(
								[decoder])));
				});
		});
};
var $author$project$Compiler$Optimize$Port$decodeMaybe = function (tipe) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$maybe, 'Nothing'),
		function (nothing) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$maybe, 'Just'),
				function (just) {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						$author$project$Compiler$Optimize$Port$decode('oneOf'),
						function (oneOf) {
							return A2(
								$author$project$Compiler$Optimize$Names$bind,
								$author$project$Compiler$Optimize$Port$decode('null'),
								function (_null) {
									return A2(
										$author$project$Compiler$Optimize$Names$bind,
										$author$project$Compiler$Optimize$Port$decode('map'),
										function (map_) {
											return A2(
												$author$project$Compiler$Optimize$Names$bind,
												$author$project$Compiler$Optimize$Port$toDecoder(tipe),
												function (subDecoder) {
													return $author$project$Compiler$Optimize$Names$return(
														A2(
															$author$project$Compiler$AST$Optimized$Call,
															oneOf,
															_List_fromArray(
																[
																	$author$project$Compiler$AST$Optimized$CList(
																	_List_fromArray(
																		[
																			A2(
																			$author$project$Compiler$AST$Optimized$Call,
																			_null,
																			_List_fromArray(
																				[nothing])),
																			A2(
																			$author$project$Compiler$AST$Optimized$Call,
																			map_,
																			_List_fromArray(
																				[just, subDecoder]))
																		]))
																])));
												});
										});
								});
						});
				});
		});
};
var $author$project$Compiler$Optimize$Port$decodeRecord = function (fields) {
	var toFieldExpr = F2(
		function (name, _v7) {
			return $author$project$Compiler$AST$Optimized$VarLocal(name);
		});
	var record = $author$project$Compiler$AST$Optimized$Record(
		A2($author$project$Extra$Type$Map$mapWithKey, toFieldExpr, fields));
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		$author$project$Compiler$Optimize$Port$decode('succeed'),
		function (succeed) {
			return A2(
				$author$project$Compiler$Optimize$Names$andThen,
				A4(
					$author$project$Extra$Type$List$foldlM,
					$author$project$Compiler$Optimize$Names$return,
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Port$fieldAndThen,
					A2(
						$author$project$Compiler$AST$Optimized$Call,
						succeed,
						_List_fromArray(
							[record]))),
				A2(
					$author$project$Compiler$Optimize$Names$registerFieldDict,
					fields,
					$author$project$Extra$Type$Map$toList(fields)));
		});
};
var $author$project$Compiler$Optimize$Port$decodeTuple = F3(
	function (a, b, maybeC) {
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			$author$project$Compiler$Optimize$Port$decode('succeed'),
			function (succeed) {
				if (maybeC.$ === 'Nothing') {
					var tuple = A3(
						$author$project$Compiler$AST$Optimized$Tuple,
						$author$project$Compiler$Optimize$Port$toLocal(0),
						$author$project$Compiler$Optimize$Port$toLocal(1),
						$elm$core$Maybe$Nothing);
					return A2(
						$author$project$Compiler$Optimize$Names$andThen,
						A2($author$project$Compiler$Optimize$Port$indexAndThen, 0, a),
						A3(
							$author$project$Compiler$Optimize$Port$indexAndThen,
							1,
							b,
							A2(
								$author$project$Compiler$AST$Optimized$Call,
								succeed,
								_List_fromArray(
									[tuple]))));
				} else {
					var c = maybeC.a;
					var tuple = A3(
						$author$project$Compiler$AST$Optimized$Tuple,
						$author$project$Compiler$Optimize$Port$toLocal(0),
						$author$project$Compiler$Optimize$Port$toLocal(1),
						$elm$core$Maybe$Just(
							$author$project$Compiler$Optimize$Port$toLocal(2)));
					return A2(
						$author$project$Compiler$Optimize$Names$andThen,
						A2($author$project$Compiler$Optimize$Port$indexAndThen, 0, a),
						A2(
							$author$project$Compiler$Optimize$Names$andThen,
							A2($author$project$Compiler$Optimize$Port$indexAndThen, 1, b),
							A3(
								$author$project$Compiler$Optimize$Port$indexAndThen,
								2,
								c,
								A2(
									$author$project$Compiler$AST$Optimized$Call,
									succeed,
									_List_fromArray(
										[tuple])))));
				}
			});
	});
var $author$project$Compiler$Optimize$Port$fieldAndThen = F2(
	function (decoder, _v4) {
		var key = _v4.a;
		var _v5 = _v4.b;
		var tipe = _v5.b;
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			$author$project$Compiler$Optimize$Port$decode('andThen'),
			function (andThen) {
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Port$decode('field'),
					function (field) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							$author$project$Compiler$Optimize$Port$toDecoder(tipe),
							function (typeDecoder) {
								return $author$project$Compiler$Optimize$Names$return(
									A2(
										$author$project$Compiler$AST$Optimized$Call,
										andThen,
										_List_fromArray(
											[
												A2(
												$author$project$Compiler$AST$Optimized$Function,
												_List_fromArray(
													[key]),
												decoder),
												A2(
												$author$project$Compiler$AST$Optimized$Call,
												field,
												_List_fromArray(
													[
														$author$project$Compiler$AST$Optimized$Str(
														$author$project$Compiler$Data$Name$toElmString(key)),
														typeDecoder
													]))
											])));
							});
					});
			});
	});
var $author$project$Compiler$Optimize$Port$indexAndThen = F3(
	function (i, tipe, decoder) {
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			$author$project$Compiler$Optimize$Port$decode('andThen'),
			function (andThen) {
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Port$decode('index'),
					function (index) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							$author$project$Compiler$Optimize$Port$toDecoder(tipe),
							function (typeDecoder) {
								return $author$project$Compiler$Optimize$Names$return(
									A2(
										$author$project$Compiler$AST$Optimized$Call,
										andThen,
										_List_fromArray(
											[
												A2(
												$author$project$Compiler$AST$Optimized$Function,
												_List_fromArray(
													[
														$author$project$Compiler$Data$Name$fromVarIndex(i)
													]),
												decoder),
												A2(
												$author$project$Compiler$AST$Optimized$Call,
												index,
												_List_fromArray(
													[
														$author$project$Compiler$AST$Optimized$CInt(i),
														typeDecoder
													]))
											])));
							});
					});
			});
	});
var $author$project$Compiler$Optimize$Port$toDecoder = function (tipe) {
	toDecoder:
	while (true) {
		switch (tipe.$) {
			case 'TLambda':
				return _Debug_todo(
					'Compiler.Optimize.Port',
					{
						start: {line: 162, column: 7},
						end: {line: 162, column: 17}
					})('functions should not be allowed through input ports');
			case 'TVar':
				return _Debug_todo(
					'Compiler.Optimize.Port',
					{
						start: {line: 165, column: 7},
						end: {line: 165, column: 17}
					})('type variables should not be allowed through input ports');
			case 'TAlias':
				var args = tipe.c;
				var alias_ = tipe.d;
				var $temp$tipe = A2($author$project$Compiler$AST$Utils$Type$dealias, args, alias_);
				tipe = $temp$tipe;
				continue toDecoder;
			case 'TUnit':
				return $author$project$Compiler$Optimize$Port$decodeTuple0;
			case 'TTuple':
				var a = tipe.a;
				var b = tipe.b;
				var c = tipe.c;
				return A3($author$project$Compiler$Optimize$Port$decodeTuple, a, b, c);
			case 'TType':
				var name = tipe.b;
				var args = tipe.c;
				var otherwise = function (_v2) {
					return _Debug_todo(
						'Compiler.Optimize.Port',
						{
							start: {line: 179, column: 11},
							end: {line: 179, column: 21}
						})('toDecoder: bad type');
				};
				if (!args.b) {
					return _Utils_eq(name, $author$project$Compiler$Data$Name$float) ? $author$project$Compiler$Optimize$Port$decode('float') : (_Utils_eq(name, $author$project$Compiler$Data$Name$int) ? $author$project$Compiler$Optimize$Port$decode('int') : (_Utils_eq(name, $author$project$Compiler$Data$Name$bool) ? $author$project$Compiler$Optimize$Port$decode('bool') : (_Utils_eq(name, $author$project$Compiler$Data$Name$string) ? $author$project$Compiler$Optimize$Port$decode('string') : (_Utils_eq(name, $author$project$Compiler$Data$Name$value) ? $author$project$Compiler$Optimize$Port$decode('value') : otherwise(_Utils_Tuple0)))));
				} else {
					if (!args.b.b) {
						var arg = args.a;
						return _Utils_eq(name, $author$project$Compiler$Data$Name$maybe) ? $author$project$Compiler$Optimize$Port$decodeMaybe(arg) : (_Utils_eq(name, $author$project$Compiler$Data$Name$list) ? $author$project$Compiler$Optimize$Port$decodeList(arg) : (_Utils_eq(name, $author$project$Compiler$Data$Name$array) ? $author$project$Compiler$Optimize$Port$decodeArray(arg) : otherwise(_Utils_Tuple0)));
					} else {
						return otherwise(_Utils_Tuple0);
					}
				}
			default:
				if (tipe.b.$ === 'Just') {
					return _Debug_todo(
						'Compiler.Optimize.Port',
						{
							start: {line: 200, column: 7},
							end: {line: 200, column: 17}
						})('toDecoder: bad record');
				} else {
					var fields = tipe.a;
					var _v3 = tipe.b;
					return $author$project$Compiler$Optimize$Port$decodeRecord(fields);
				}
		}
	}
};
var $author$project$Compiler$Optimize$Port$toFlagsDecoder = function (tipe) {
	if (tipe.$ === 'TUnit') {
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			$author$project$Compiler$Optimize$Port$decode('succeed'),
			function (succeed) {
				return $author$project$Compiler$Optimize$Names$return(
					A2(
						$author$project$Compiler$AST$Optimized$Call,
						succeed,
						_List_fromArray(
							[$author$project$Compiler$AST$Optimized$Unit])));
			});
	} else {
		return $author$project$Compiler$Optimize$Port$toDecoder(tipe);
	}
};
var $author$project$Compiler$Data$Name$virtualDom = 'VirtualDom';
var $author$project$Compiler$Elm$Package$virtualDom = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'virtual-dom');
var $author$project$Compiler$Elm$ModuleName$virtualDom = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$virtualDom, $author$project$Compiler$Data$Name$virtualDom);
var $author$project$Compiler$Optimize$Module$addDefHelp = F7(
	function (region, annotations, home, name, args, body, graph) {
		var nodes = graph.b;
		var fieldCounts = graph.c;
		if (!_Utils_eq(name, $author$project$Compiler$Data$Name$l_main)) {
			return $author$project$Compiler$Reporting$Result$ok(
				A6($author$project$Compiler$Optimize$Module$addDefNode, home, name, args, body, $author$project$Extra$Type$Set$empty, graph));
		} else {
			var addMain = function (_v9) {
				var deps = _v9.a;
				var fields = _v9.b;
				var main = _v9.c;
				return A6(
					$author$project$Compiler$Optimize$Module$addDefNode,
					home,
					name,
					args,
					body,
					deps,
					A3(
						$author$project$Compiler$AST$Optimized$LocalGraph,
						$elm$core$Maybe$Just(main),
						nodes,
						A3($author$project$Extra$Type$Map$unionWith, $elm$core$Basics$add, fields, fieldCounts)));
			};
			var _v0 = A2($author$project$Extra$Type$Map$ex, annotations, name);
			var tipe = _v0.b;
			var otherwise = function (_v8) {
				return $author$project$Compiler$Reporting$Result$throw(
					A2($author$project$Compiler$Reporting$Error$Main$BadType, region, tipe));
			};
			var _v1 = $author$project$Compiler$AST$Utils$Type$deepDealias(tipe);
			_v1$2:
			while (true) {
				if ((_v1.$ === 'TType') && _v1.c.b) {
					if (!_v1.c.b.b) {
						var hm = _v1.a;
						var nm = _v1.b;
						var _v2 = _v1.c;
						return (_Utils_eq(hm, $author$project$Compiler$Elm$ModuleName$virtualDom) && _Utils_eq(nm, $author$project$Compiler$Data$Name$node)) ? $author$project$Compiler$Reporting$Result$ok(
							addMain(
								$author$project$Compiler$Optimize$Names$run(
									A2($author$project$Compiler$Optimize$Names$registerKernel, $author$project$Compiler$Data$Name$virtualDom, $author$project$Compiler$AST$Optimized$Static)))) : otherwise(_Utils_Tuple0);
					} else {
						if (_v1.c.b.b.b && (!_v1.c.b.b.b.b)) {
							var hm = _v1.a;
							var nm = _v1.b;
							var _v3 = _v1.c;
							var flags = _v3.a;
							var _v4 = _v3.b;
							var _v5 = _v4.b;
							var message = _v5.a;
							if (_Utils_eq(hm, $author$project$Compiler$Elm$ModuleName$platform) && _Utils_eq(nm, $author$project$Compiler$Data$Name$program)) {
								var _v6 = $author$project$Compiler$Canonicalize$Effects$checkPayload(flags);
								if (_v6.$ === 'Right') {
									return $author$project$Compiler$Reporting$Result$ok(
										addMain(
											$author$project$Compiler$Optimize$Names$run(
												A2(
													$author$project$Compiler$Optimize$Names$fmap,
													$author$project$Compiler$AST$Optimized$Dynamic(message),
													$author$project$Compiler$Optimize$Port$toFlagsDecoder(flags)))));
								} else {
									var _v7 = _v6.a;
									var invalidPayload = _v7.b;
									return $author$project$Compiler$Reporting$Result$throw(
										A2($author$project$Compiler$Reporting$Error$Main$BadFlags, region, invalidPayload));
								}
							} else {
								return otherwise(_Utils_Tuple0);
							}
						} else {
							break _v1$2;
						}
					}
				} else {
					break _v1$2;
				}
			}
			return otherwise(_Utils_Tuple0);
		}
	});
var $author$project$Compiler$Reporting$Result$warn = function (warning) {
	return $author$project$Compiler$Reporting$Result$CResult(
		F2(
			function (i, warnings) {
				return A3(
					$author$project$Compiler$Reporting$Result$Rgood,
					i,
					A2($elm$core$List$cons, warning, warnings),
					_Utils_Tuple0);
			}));
};
var $author$project$Compiler$Optimize$Module$addDef = F4(
	function (home, annotations, def, graph) {
		if (def.$ === 'Def') {
			var _v1 = def.a;
			var region = _v1.a;
			var name = _v1.b;
			var args = def.b;
			var body = def.c;
			return A2(
				$author$project$Compiler$Reporting$Result$bind,
				$author$project$Compiler$Reporting$Result$warn($author$project$Compiler$Reporting$Warning$MissingTypeAnnotation),
				function (_v2) {
					return A7($author$project$Compiler$Optimize$Module$addDefHelp, region, annotations, home, name, args, body, graph);
				});
		} else {
			var _v3 = def.a;
			var region = _v3.a;
			var name = _v3.b;
			var typedArgs = def.c;
			var body = def.d;
			return A7(
				$author$project$Compiler$Optimize$Module$addDefHelp,
				region,
				annotations,
				home,
				name,
				A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, typedArgs),
				body,
				graph);
		}
	});
var $author$project$Compiler$Optimize$Module$State = F2(
	function (a, b) {
		return {$: 'State', a: a, b: b};
	});
var $author$project$Compiler$Optimize$Module$addLink = F4(
	function (home, link, def, links) {
		if (def.$ === 'Def') {
			var _v1 = def.a;
			var name = _v1.b;
			return A3(
				$author$project$Extra$Type$Map$insert,
				$author$project$Compiler$AST$Optimized$toGlobalComparable(
					A2($author$project$Compiler$AST$Optimized$Global, home, name)),
				link,
				links);
		} else {
			var _v2 = def.a;
			var name = _v2.b;
			return A3(
				$author$project$Extra$Type$Map$insert,
				$author$project$Compiler$AST$Optimized$toGlobalComparable(
					A2($author$project$Compiler$AST$Optimized$Global, home, name)),
				link,
				links);
		}
	});
var $author$project$Compiler$Optimize$Module$addRecDefHelp = F5(
	function (cycle, _v0, name, args, body) {
		var values = _v0.a;
		var funcs = _v0.b;
		if (!args.b) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				A2($author$project$Compiler$Optimize$Expression$optimize, cycle, body),
				function (obody) {
					return $author$project$Compiler$Optimize$Names$pure(
						A2(
							$author$project$Compiler$Optimize$Module$State,
							A2(
								$elm$core$List$cons,
								_Utils_Tuple2(name, obody),
								values),
							funcs));
				});
		} else {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				A4($author$project$Compiler$Optimize$Expression$optimizePotentialTailCall, cycle, name, args, body),
				function (odef) {
					return $author$project$Compiler$Optimize$Names$pure(
						A2(
							$author$project$Compiler$Optimize$Module$State,
							values,
							A2($elm$core$List$cons, odef, funcs)));
				});
		}
	});
var $author$project$Compiler$Optimize$Module$addRecDef = F3(
	function (cycle, state, def) {
		if (def.$ === 'Def') {
			var _v1 = def.a;
			var name = _v1.b;
			var args = def.b;
			var body = def.c;
			return A5($author$project$Compiler$Optimize$Module$addRecDefHelp, cycle, state, name, args, body);
		} else {
			var _v2 = def.a;
			var name = _v2.b;
			var args = def.c;
			var body = def.d;
			return A5(
				$author$project$Compiler$Optimize$Module$addRecDefHelp,
				cycle,
				state,
				name,
				A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, args),
				body);
		}
	});
var $author$project$Compiler$Optimize$Module$addValueName = F2(
	function (def, names) {
		if (def.$ === 'Def') {
			var _v1 = def.a;
			var name = _v1.b;
			var args = def.b;
			return $author$project$Extra$Type$List$null(args) ? A2($author$project$Extra$Type$Set$insert, name, names) : names;
		} else {
			var _v2 = def.a;
			var name = _v2.b;
			var args = def.c;
			return $author$project$Extra$Type$List$null(args) ? A2($author$project$Extra$Type$Set$insert, name, names) : names;
		}
	});
var $author$project$Compiler$Optimize$Module$toName = function (def) {
	if (def.$ === 'Def') {
		var _v1 = def.a;
		var name = _v1.b;
		return name;
	} else {
		var _v2 = def.a;
		var name = _v2.b;
		return name;
	}
};
var $author$project$Compiler$Optimize$Module$addRecDefs = F3(
	function (home, defs, _v0) {
		var main = _v0.a;
		var nodes = _v0.b;
		var fieldCounts = _v0.c;
		var names = $author$project$Extra$Type$List$reverse(
			A2($author$project$Extra$Type$List$map, $author$project$Compiler$Optimize$Module$toName, defs));
		var cycleName = A2(
			$author$project$Compiler$AST$Optimized$Global,
			home,
			$author$project$Compiler$Data$Name$fromManyNames(names));
		var links = A3(
			$author$project$Extra$Type$List$foldr,
			A2(
				$author$project$Compiler$Optimize$Module$addLink,
				home,
				$author$project$Compiler$AST$Optimized$Link(cycleName)),
			$author$project$Extra$Type$Map$empty,
			defs);
		var cycle = A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Optimize$Module$addValueName, $author$project$Extra$Type$Set$empty, defs);
		var _v1 = $author$project$Compiler$Optimize$Names$run(
			A5(
				$author$project$Extra$Type$List$foldlM,
				$author$project$Compiler$Optimize$Names$return,
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Module$addRecDef(cycle),
				A2($author$project$Compiler$Optimize$Module$State, _List_Nil, _List_Nil),
				defs));
		var deps = _v1.a;
		var fields = _v1.b;
		var _v2 = _v1.c;
		var values = _v2.a;
		var funcs = _v2.b;
		return A3(
			$author$project$Compiler$AST$Optimized$LocalGraph,
			main,
			A3(
				$author$project$Extra$Type$Map$insert,
				$author$project$Compiler$AST$Optimized$toGlobalComparable(cycleName),
				A4($author$project$Compiler$AST$Optimized$Cycle, names, values, funcs, deps),
				A2($author$project$Extra$Type$Map$union, links, nodes)),
			A3($author$project$Extra$Type$Map$unionWith, $elm$core$Basics$add, fields, fieldCounts));
	});
var $author$project$Compiler$Optimize$Module$defToName = function (def) {
	if (def.$ === 'Def') {
		var _v1 = def.a;
		var name = _v1.b;
		return name;
	} else {
		var _v2 = def.a;
		var name = _v2.b;
		return name;
	}
};
var $author$project$Compiler$Optimize$Module$findMain = function (defs) {
	findMain:
	while (true) {
		if (!defs.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			var def = defs.a;
			var rest = defs.b;
			if (def.$ === 'Def') {
				var _v2 = def.a;
				var region = _v2.a;
				var name = _v2.b;
				if (_Utils_eq(name, $author$project$Compiler$Data$Name$l_main)) {
					return $elm$core$Maybe$Just(region);
				} else {
					var $temp$defs = rest;
					defs = $temp$defs;
					continue findMain;
				}
			} else {
				var _v3 = def.a;
				var region = _v3.a;
				var name = _v3.b;
				if (_Utils_eq(name, $author$project$Compiler$Data$Name$l_main)) {
					return $elm$core$Maybe$Just(region);
				} else {
					var $temp$defs = rest;
					defs = $temp$defs;
					continue findMain;
				}
			}
		}
	}
};
var $author$project$Compiler$Optimize$Module$addDeclsHelp = F3(
	function (home, annotations, _v0) {
		var decls = _v0.a;
		var graph = _v0.b;
		switch (decls.$) {
			case 'Declare':
				var def = decls.a;
				var subDecls = decls.b;
				return A2(
					$author$project$Compiler$Reporting$Result$fmap,
					function (g) {
						return $author$project$Compiler$Reporting$Result$Loop(
							_Utils_Tuple2(subDecls, g));
					},
					A4($author$project$Compiler$Optimize$Module$addDef, home, annotations, def, graph));
			case 'DeclareRec':
				var d = decls.a;
				var ds = decls.b;
				var subDecls = decls.c;
				var defs = A2($elm$core$List$cons, d, ds);
				var _v2 = $author$project$Compiler$Optimize$Module$findMain(defs);
				if (_v2.$ === 'Nothing') {
					return $author$project$Compiler$Reporting$Result$return(
						$author$project$Compiler$Reporting$Result$Loop(
							_Utils_Tuple2(
								subDecls,
								A3($author$project$Compiler$Optimize$Module$addRecDefs, home, defs, graph))));
				} else {
					var region = _v2.a;
					return $author$project$Compiler$Reporting$Result$throw(
						A3(
							$author$project$Compiler$Reporting$Error$Main$BadCycle,
							region,
							$author$project$Compiler$Optimize$Module$defToName(d),
							A2($author$project$Extra$Type$List$map, $author$project$Compiler$Optimize$Module$defToName, ds)));
				}
			default:
				return $author$project$Compiler$Reporting$Result$return(
					$author$project$Compiler$Reporting$Result$Done(graph));
		}
	});
var $author$project$Compiler$Optimize$Module$addDecls = F4(
	function (home, annotations, decls, graph) {
		return A2(
			$author$project$Compiler$Reporting$Result$loop,
			A2($author$project$Compiler$Optimize$Module$addDeclsHelp, home, annotations),
			_Utils_Tuple2(decls, graph));
	});
var $author$project$Compiler$Optimize$Port$encode = function (name) {
	return A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$jsonEncode, name);
};
var $author$project$Compiler$Optimize$Port$encodeArray = function (tipe) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		$author$project$Compiler$Optimize$Port$encode('array'),
		function (array) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Port$toEncoder(tipe),
				function (encoder) {
					return $author$project$Compiler$Optimize$Names$return(
						A2(
							$author$project$Compiler$AST$Optimized$Call,
							array,
							_List_fromArray(
								[encoder])));
				});
		});
};
var $author$project$Compiler$Optimize$Port$encodeList = function (tipe) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		$author$project$Compiler$Optimize$Port$encode('list'),
		function (list) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Port$toEncoder(tipe),
				function (encoder) {
					return $author$project$Compiler$Optimize$Names$return(
						A2(
							$author$project$Compiler$AST$Optimized$Call,
							list,
							_List_fromArray(
								[encoder])));
				});
		});
};
var $author$project$Compiler$Optimize$Port$encodeMaybe = function (tipe) {
	return A2(
		$author$project$Compiler$Optimize$Names$bind,
		$author$project$Compiler$Optimize$Port$encode('null'),
		function (_null) {
			return A2(
				$author$project$Compiler$Optimize$Names$bind,
				$author$project$Compiler$Optimize$Port$toEncoder(tipe),
				function (encoder) {
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$maybe, 'destruct'),
						function (destruct) {
							return $author$project$Compiler$Optimize$Names$return(
								A2(
									$author$project$Compiler$AST$Optimized$Function,
									_List_fromArray(
										[$author$project$Compiler$Data$Name$dollar]),
									A2(
										$author$project$Compiler$AST$Optimized$Call,
										destruct,
										_List_fromArray(
											[
												_null,
												encoder,
												$author$project$Compiler$AST$Optimized$VarLocal($author$project$Compiler$Data$Name$dollar)
											]))));
						});
				});
		});
};
var $author$project$Compiler$Optimize$Port$encodeTuple = F3(
	function (a, b, maybeC) {
		var let_ = F3(
			function (arg, index, body) {
				return A2(
					$author$project$Compiler$AST$Optimized$Destruct,
					A2(
						$author$project$Compiler$AST$Optimized$Destructor,
						arg,
						A2(
							$author$project$Compiler$AST$Optimized$Index,
							index,
							$author$project$Compiler$AST$Optimized$Root($author$project$Compiler$Data$Name$dollar))),
					body);
			});
		var encodeArg = F2(
			function (arg, tipe) {
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					$author$project$Compiler$Optimize$Port$toEncoder(tipe),
					function (encoder) {
						return $author$project$Compiler$Optimize$Names$return(
							A2(
								$author$project$Compiler$AST$Optimized$Call,
								encoder,
								_List_fromArray(
									[
										$author$project$Compiler$AST$Optimized$VarLocal(arg)
									])));
					});
			});
		return A2(
			$author$project$Compiler$Optimize$Names$bind,
			$author$project$Compiler$Optimize$Port$encode('list'),
			function (list) {
				return A2(
					$author$project$Compiler$Optimize$Names$bind,
					A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$identity_),
					function (identity_) {
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							A2(encodeArg, 'a', a),
							function (arg1) {
								return A2(
									$author$project$Compiler$Optimize$Names$bind,
									A2(encodeArg, 'b', b),
									function (arg2) {
										if (maybeC.$ === 'Nothing') {
											return $author$project$Compiler$Optimize$Names$return(
												A2(
													$author$project$Compiler$AST$Optimized$Function,
													_List_fromArray(
														[$author$project$Compiler$Data$Name$dollar]),
													A3(
														let_,
														'a',
														$author$project$Compiler$Data$Index$first,
														A3(
															let_,
															'b',
															$author$project$Compiler$Data$Index$second,
															A2(
																$author$project$Compiler$AST$Optimized$Call,
																list,
																_List_fromArray(
																	[
																		identity_,
																		$author$project$Compiler$AST$Optimized$CList(
																		_List_fromArray(
																			[arg1, arg2]))
																	]))))));
										} else {
											var c = maybeC.a;
											return A2(
												$author$project$Compiler$Optimize$Names$bind,
												A2(encodeArg, 'c', c),
												function (arg3) {
													return $author$project$Compiler$Optimize$Names$return(
														A2(
															$author$project$Compiler$AST$Optimized$Function,
															_List_fromArray(
																[$author$project$Compiler$Data$Name$dollar]),
															A3(
																let_,
																'a',
																$author$project$Compiler$Data$Index$first,
																A3(
																	let_,
																	'b',
																	$author$project$Compiler$Data$Index$second,
																	A3(
																		let_,
																		'c',
																		$author$project$Compiler$Data$Index$third,
																		A2(
																			$author$project$Compiler$AST$Optimized$Call,
																			list,
																			_List_fromArray(
																				[
																					identity_,
																					$author$project$Compiler$AST$Optimized$CList(
																					_List_fromArray(
																						[arg1, arg2, arg3]))
																				])))))));
												});
										}
									});
							});
					});
			});
	});
var $author$project$Compiler$Optimize$Port$toEncoder = function (tipe) {
	toEncoder:
	while (true) {
		switch (tipe.$) {
			case 'TAlias':
				var args = tipe.c;
				var alias_ = tipe.d;
				var $temp$tipe = A2($author$project$Compiler$AST$Utils$Type$dealias, args, alias_);
				tipe = $temp$tipe;
				continue toEncoder;
			case 'TLambda':
				return _Debug_todo(
					'Compiler.Optimize.Port',
					{
						start: {line: 31, column: 7},
						end: {line: 31, column: 17}
					})('toEncoder: function');
			case 'TVar':
				return _Debug_todo(
					'Compiler.Optimize.Port',
					{
						start: {line: 34, column: 7},
						end: {line: 34, column: 17}
					})('toEncoder: type variable');
			case 'TUnit':
				return A2(
					$author$project$Compiler$Optimize$Names$fmap,
					$author$project$Compiler$AST$Optimized$Function(
						_List_fromArray(
							[$author$project$Compiler$Data$Name$dollar])),
					$author$project$Compiler$Optimize$Port$encode('null'));
			case 'TTuple':
				var a = tipe.a;
				var b = tipe.b;
				var c = tipe.c;
				return A3($author$project$Compiler$Optimize$Port$encodeTuple, a, b, c);
			case 'TType':
				var name = tipe.b;
				var args = tipe.c;
				var otherwise = function (_v2) {
					return _Debug_todo(
						'Compiler.Optimize.Port',
						{
							start: {line: 45, column: 11},
							end: {line: 45, column: 21}
						})('toEncoder: bad custom type');
				};
				if (!args.b) {
					return _Utils_eq(name, $author$project$Compiler$Data$Name$float) ? $author$project$Compiler$Optimize$Port$encode('float') : (_Utils_eq(name, $author$project$Compiler$Data$Name$int) ? $author$project$Compiler$Optimize$Port$encode('int') : (_Utils_eq(name, $author$project$Compiler$Data$Name$bool) ? $author$project$Compiler$Optimize$Port$encode('bool') : (_Utils_eq(name, $author$project$Compiler$Data$Name$string) ? $author$project$Compiler$Optimize$Port$encode('string') : (_Utils_eq(name, $author$project$Compiler$Data$Name$value) ? A2($author$project$Compiler$Optimize$Names$registerGlobal, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$identity_) : otherwise(_Utils_Tuple0)))));
				} else {
					if (!args.b.b) {
						var arg = args.a;
						return _Utils_eq(name, $author$project$Compiler$Data$Name$maybe) ? $author$project$Compiler$Optimize$Port$encodeMaybe(arg) : (_Utils_eq(name, $author$project$Compiler$Data$Name$list) ? $author$project$Compiler$Optimize$Port$encodeList(arg) : (_Utils_eq(name, $author$project$Compiler$Data$Name$array) ? $author$project$Compiler$Optimize$Port$encodeArray(arg) : otherwise(_Utils_Tuple0)));
					} else {
						return otherwise(_Utils_Tuple0);
					}
				}
			default:
				if (tipe.b.$ === 'Just') {
					return _Debug_todo(
						'Compiler.Optimize.Port',
						{
							start: {line: 66, column: 7},
							end: {line: 66, column: 17}
						})('toEncoder: bad record');
				} else {
					var fields = tipe.a;
					var _v3 = tipe.b;
					var encodeField = function (_v4) {
						var name = _v4.a;
						var _v5 = _v4.b;
						var fieldType = _v5.b;
						return A2(
							$author$project$Compiler$Optimize$Names$bind,
							$author$project$Compiler$Optimize$Port$toEncoder(fieldType),
							function (encoder) {
								var value = A2(
									$author$project$Compiler$AST$Optimized$Call,
									encoder,
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$AST$Optimized$Access,
											$author$project$Compiler$AST$Optimized$VarLocal($author$project$Compiler$Data$Name$dollar),
											name)
										]));
								return $author$project$Compiler$Optimize$Names$return(
									A3(
										$author$project$Compiler$AST$Optimized$Tuple,
										$author$project$Compiler$AST$Optimized$Str(
											$author$project$Compiler$Data$Name$toElmString(name)),
										value,
										$elm$core$Maybe$Nothing));
							});
					};
					return A2(
						$author$project$Compiler$Optimize$Names$bind,
						$author$project$Compiler$Optimize$Port$encode('object'),
						function (object) {
							return A2(
								$author$project$Compiler$Optimize$Names$bind,
								A4(
									$author$project$Extra$Type$List$traverse,
									$author$project$Compiler$Optimize$Names$pure,
									$author$project$Compiler$Optimize$Names$liftA2,
									encodeField,
									$author$project$Extra$Type$Map$toList(fields)),
								function (keyValuePairs) {
									return A2(
										$author$project$Compiler$Optimize$Names$registerFieldDict,
										fields,
										A2(
											$author$project$Compiler$AST$Optimized$Function,
											_List_fromArray(
												[$author$project$Compiler$Data$Name$dollar]),
											A2(
												$author$project$Compiler$AST$Optimized$Call,
												object,
												_List_fromArray(
													[
														$author$project$Compiler$AST$Optimized$CList(keyValuePairs)
													]))));
								});
						});
				}
		}
	}
};
var $author$project$Compiler$Optimize$Module$addPort = F4(
	function (home, name, port_, graph) {
		if (port_.$ === 'Incoming') {
			var payloadType = port_.b;
			var _v1 = $author$project$Compiler$Optimize$Names$run(
				$author$project$Compiler$Optimize$Port$toDecoder(payloadType));
			var deps = _v1.a;
			var fields = _v1.b;
			var decoder = _v1.c;
			var node = A2($author$project$Compiler$AST$Optimized$PortIncoming, decoder, deps);
			return A4(
				$author$project$Compiler$Optimize$Module$addToGraph,
				A2($author$project$Compiler$AST$Optimized$Global, home, name),
				node,
				fields,
				graph);
		} else {
			var payloadType = port_.b;
			var _v2 = $author$project$Compiler$Optimize$Names$run(
				$author$project$Compiler$Optimize$Port$toEncoder(payloadType));
			var deps = _v2.a;
			var fields = _v2.b;
			var encoder = _v2.c;
			var node = A2($author$project$Compiler$AST$Optimized$PortOutgoing, encoder, deps);
			return A4(
				$author$project$Compiler$Optimize$Module$addToGraph,
				A2($author$project$Compiler$AST$Optimized$Global, home, name),
				node,
				fields,
				graph);
		}
	});
var $author$project$Compiler$Optimize$Module$addEffects = F3(
	function (home, effects, graph) {
		var main = graph.a;
		var nodes = graph.b;
		var fields = graph.c;
		switch (effects.$) {
			case 'NoEffects':
				return graph;
			case 'Ports':
				var ports = effects.a;
				return A3(
					$author$project$Extra$Type$Map$foldrWithKey,
					$author$project$Compiler$Optimize$Module$addPort(home),
					graph,
					ports);
			default:
				var manager = effects.d;
				var sub = A2($author$project$Compiler$AST$Optimized$Global, home, 'subscription');
				var fx = A2($author$project$Compiler$AST$Optimized$Global, home, '$fx$');
				var link = $author$project$Compiler$AST$Optimized$Link(fx);
				var cmd = A2($author$project$Compiler$AST$Optimized$Global, home, 'command');
				var newNodes = function () {
					switch (manager.$) {
						case 'CCmd':
							return A3(
								$author$project$Extra$Type$Map$insert,
								$author$project$Compiler$AST$Optimized$toGlobalComparable(cmd),
								link,
								A3(
									$author$project$Extra$Type$Map$insert,
									$author$project$Compiler$AST$Optimized$toGlobalComparable(fx),
									$author$project$Compiler$AST$Optimized$Manager($author$project$Compiler$AST$Optimized$CCmd),
									nodes));
						case 'CSub':
							return A3(
								$author$project$Extra$Type$Map$insert,
								$author$project$Compiler$AST$Optimized$toGlobalComparable(sub),
								link,
								A3(
									$author$project$Extra$Type$Map$insert,
									$author$project$Compiler$AST$Optimized$toGlobalComparable(fx),
									$author$project$Compiler$AST$Optimized$Manager($author$project$Compiler$AST$Optimized$CSub),
									nodes));
						default:
							return A3(
								$author$project$Extra$Type$Map$insert,
								$author$project$Compiler$AST$Optimized$toGlobalComparable(cmd),
								link,
								A3(
									$author$project$Extra$Type$Map$insert,
									$author$project$Compiler$AST$Optimized$toGlobalComparable(sub),
									link,
									A3(
										$author$project$Extra$Type$Map$insert,
										$author$project$Compiler$AST$Optimized$toGlobalComparable(fx),
										$author$project$Compiler$AST$Optimized$Manager($author$project$Compiler$AST$Optimized$Fx),
										nodes)));
					}
				}();
				return A3($author$project$Compiler$AST$Optimized$LocalGraph, main, newNodes, fields);
		}
	});
var $author$project$Compiler$Optimize$Module$addCtorNode = F4(
	function (home, opts, nodes, _v0) {
		var name = _v0.a;
		var index = _v0.b;
		var numArgs = _v0.c;
		var node = function () {
			switch (opts.$) {
				case 'Normal':
					return A2($author$project$Compiler$AST$Optimized$Ctor, index, numArgs);
				case 'Unbox':
					return $author$project$Compiler$AST$Optimized$Box;
				default:
					return $author$project$Compiler$AST$Optimized$Enum(index);
			}
		}();
		return A3(
			$author$project$Extra$Type$Map$insert,
			$author$project$Compiler$AST$Optimized$toGlobalComparable(
				A2($author$project$Compiler$AST$Optimized$Global, home, name)),
			node,
			nodes);
	});
var $author$project$Compiler$Optimize$Module$addUnion = F3(
	function (home, _v0, nodes) {
		var ctors = _v0.b;
		var opts = _v0.d;
		return A3(
			$author$project$Extra$Type$List$foldl,
			A2($author$project$Compiler$Optimize$Module$addCtorNode, home, opts),
			nodes,
			ctors);
	});
var $author$project$Compiler$Optimize$Module$addUnions = F3(
	function (home, unions, _v0) {
		var main = _v0.a;
		var nodes = _v0.b;
		var fields = _v0.c;
		return A3(
			$author$project$Compiler$AST$Optimized$LocalGraph,
			main,
			A3(
				$author$project$Extra$Type$Map$foldr,
				$author$project$Compiler$Optimize$Module$addUnion(home),
				nodes,
				unions),
			fields);
	});
var $author$project$Compiler$Optimize$Module$optimize = F2(
	function (annotations, _v0) {
		var home = _v0.a;
		var decls = _v0.c;
		var unions = _v0.d;
		var aliases = _v0.e;
		var effects = _v0.g;
		return A4(
			$author$project$Compiler$Optimize$Module$addDecls,
			home,
			annotations,
			decls,
			A3(
				$author$project$Compiler$Optimize$Module$addEffects,
				home,
				effects,
				A3(
					$author$project$Compiler$Optimize$Module$addUnions,
					home,
					unions,
					A3(
						$author$project$Compiler$Optimize$Module$addAliases,
						home,
						aliases,
						A3($author$project$Compiler$AST$Optimized$LocalGraph, $elm$core$Maybe$Nothing, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty)))));
	});
var $author$project$Compiler$Compile$optimize = F3(
	function (modul, annotations, canonical) {
		var _v0 = $author$project$Compiler$Reporting$Result$run(
			A2($author$project$Compiler$Optimize$Module$optimize, annotations, canonical)).b;
		if (_v0.$ === 'Right') {
			var localGraph = _v0.a;
			return $author$project$Extra$Type$Either$Right(localGraph);
		} else {
			var errors = _v0.a;
			return $author$project$Extra$Type$Either$Left(
				A2(
					$author$project$Compiler$Reporting$Error$BadMains,
					$author$project$Compiler$Reporting$Render$Type$Localizer$fromModule(modul),
					errors));
		}
	});
var $author$project$Compiler$Reporting$Error$BadTypes = F2(
	function (a, b) {
		return {$: 'BadTypes', a: a, b: b};
	});
var $author$project$Extra$System$IO$Pure$bind = F3(
	function (ma, callback, s0) {
		var _v0 = ma(s0);
		var a = _v0.a;
		var s1 = _v0.b;
		return A2(callback, a, s1);
	});
var $author$project$Extra$System$IO$Pure$andThen = $author$project$Extra$Class$Monad$andThen($author$project$Extra$System$IO$Pure$bind);
var $author$project$Compiler$Type$Type$CSaveTheEnvironment = {$: 'CSaveTheEnvironment'};
var $author$project$Compiler$Reporting$Error$Type$Access = function (a) {
	return {$: 'Access', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Accessor = function (a) {
	return {$: 'Accessor', a: a};
};
var $author$project$Compiler$Type$Type$AppN = F3(
	function (a, b, c) {
		return {$: 'AppN', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Type$CAnd = function (a) {
	return {$: 'CAnd', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$CChar = {$: 'CChar'};
var $author$project$Compiler$Type$Type$CEqual = F4(
	function (a, b, c, d) {
		return {$: 'CEqual', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Type$CFloat = {$: 'CFloat'};
var $author$project$Compiler$Type$Type$CForeign = F4(
	function (a, b, c, d) {
		return {$: 'CForeign', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Type$CLet = F5(
	function (a, b, c, d, e) {
		return {$: 'CLet', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Reporting$Error$Type$CList = {$: 'CList'};
var $author$project$Compiler$Type$Type$CLocal = F3(
	function (a, b, c) {
		return {$: 'CLocal', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Type$CString = {$: 'CString'};
var $author$project$Compiler$Type$Type$CTrue = {$: 'CTrue'};
var $author$project$Compiler$Reporting$Error$Type$CallArg = F2(
	function (a, b) {
		return {$: 'CallArg', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$CallArity = F2(
	function (a, b) {
		return {$: 'CallArity', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$CallResult = function (a) {
	return {$: 'CallResult', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Case = {$: 'Case'};
var $author$project$Compiler$Reporting$Error$Type$CaseBranch = function (a) {
	return {$: 'CaseBranch', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Destructure = {$: 'Destructure'};
var $author$project$Compiler$Type$Type$EmptyRecordN = {$: 'EmptyRecordN'};
var $author$project$Compiler$Reporting$Error$Type$FromAnnotation = F4(
	function (a, b, c, d) {
		return {$: 'FromAnnotation', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Type$FromContext = F3(
	function (a, b, c) {
		return {$: 'FromContext', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Type$FunN = F2(
	function (a, b) {
		return {$: 'FunN', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$If = {$: 'If'};
var $author$project$Compiler$Reporting$Error$Type$IfBranch = function (a) {
	return {$: 'IfBranch', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$IfCondition = {$: 'IfCondition'};
var $author$project$Compiler$Type$Constrain$Expression$Info = F3(
	function (a, b, c) {
		return {$: 'Info', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Type$Lambda = {$: 'Lambda'};
var $author$project$Compiler$Reporting$Error$Type$ListEntry = function (a) {
	return {$: 'ListEntry', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Negate = {$: 'Negate'};
var $author$project$Compiler$Reporting$Error$Type$NoExpectation = function (a) {
	return {$: 'NoExpectation', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Number = {$: 'Number'};
var $author$project$Compiler$Reporting$Error$Type$OpLeft = function (a) {
	return {$: 'OpLeft', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$OpName = function (a) {
	return {$: 'OpName', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$OpRight = function (a) {
	return {$: 'OpRight', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$PCaseMatch = function (a) {
	return {$: 'PCaseMatch', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$PFromContext = F3(
	function (a, b, c) {
		return {$: 'PFromContext', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Type$PNoExpectation = function (a) {
	return {$: 'PNoExpectation', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Record = {$: 'Record'};
var $author$project$Compiler$Reporting$Error$Type$RecordAccess = F4(
	function (a, b, c, d) {
		return {$: 'RecordAccess', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Type$RecordN = F2(
	function (a, b) {
		return {$: 'RecordN', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$RecordUpdateKeys = F2(
	function (a, b) {
		return {$: 'RecordUpdateKeys', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$RecordUpdateValue = function (a) {
	return {$: 'RecordUpdateValue', a: a};
};
var $author$project$Compiler$Type$Constrain$Pattern$State = F3(
	function (a, b, c) {
		return {$: 'State', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Type$Tuple = {$: 'Tuple'};
var $author$project$Compiler$Type$Type$TupleN = F3(
	function (a, b, c) {
		return {$: 'TupleN', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Type$TypedBody = {$: 'TypedBody'};
var $author$project$Compiler$Reporting$Error$Type$TypedCaseBranch = function (a) {
	return {$: 'TypedCaseBranch', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$TypedIfBranch = function (a) {
	return {$: 'TypedIfBranch', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Unit = {$: 'Unit'};
var $author$project$Compiler$Type$Type$UnitN = {$: 'UnitN'};
var $author$project$Compiler$Type$Type$VarN = function (a) {
	return {$: 'VarN', a: a};
};
var $author$project$Compiler$Type$Type$CPattern = F4(
	function (a, b, c, d) {
		return {$: 'CPattern', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Type$PBool = {$: 'PBool'};
var $author$project$Compiler$Reporting$Error$Type$PChr = {$: 'PChr'};
var $author$project$Compiler$Reporting$Error$Type$PCtor = function (a) {
	return {$: 'PCtor', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$PCtorArg = F2(
	function (a, b) {
		return {$: 'PCtorArg', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$PInt = {$: 'PInt'};
var $author$project$Compiler$Reporting$Error$Type$PList = {$: 'PList'};
var $author$project$Compiler$Reporting$Error$Type$PListEntry = function (a) {
	return {$: 'PListEntry', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$PRecord = {$: 'PRecord'};
var $author$project$Compiler$Reporting$Error$Type$PStr = {$: 'PStr'};
var $author$project$Compiler$Reporting$Error$Type$PTail = {$: 'PTail'};
var $author$project$Compiler$Reporting$Error$Type$PTuple = {$: 'PTuple'};
var $author$project$Compiler$Reporting$Error$Type$PUnit = {$: 'PUnit'};
var $author$project$Compiler$Type$Constrain$Pattern$getType = function (expectation) {
	if (expectation.$ === 'PNoExpectation') {
		var tipe = expectation.a;
		return tipe;
	} else {
		var tipe = expectation.c;
		return tipe;
	}
};
var $author$project$Compiler$Type$Constrain$Pattern$addToHeaders = F4(
	function (region, name, expectation, _v0) {
		var headers = _v0.a;
		var vars = _v0.b;
		var revCons = _v0.c;
		var tipe = $author$project$Compiler$Type$Constrain$Pattern$getType(expectation);
		var newHeaders = A3(
			$author$project$Extra$Type$Map$insert,
			name,
			A2($author$project$Compiler$Reporting$Annotation$At, region, tipe),
			headers);
		return A3($author$project$Compiler$Type$Constrain$Pattern$State, newHeaders, vars, revCons);
	});
var $author$project$Compiler$Type$Type$bool = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$basics, 'Bool', _List_Nil);
var $author$project$Compiler$Data$Name$char = 'Char';
var $author$project$Compiler$Elm$ModuleName$char = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$char);
var $author$project$Compiler$Type$Type$char = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$char, 'Char', _List_Nil);
var $author$project$Extra$System$IO$Pure$fmap = F3(
	function (f, ma, s0) {
		var _v0 = ma(s0);
		var a = _v0.a;
		var s1 = _v0.b;
		return _Utils_Tuple2(
			f(a),
			s1);
	});
var $author$project$Extra$System$IO$Pure$Done = function (a) {
	return {$: 'Done', a: a};
};
var $author$project$Extra$System$IO$Pure$Loop = function (a) {
	return {$: 'Loop', a: a};
};
var $author$project$Extra$System$IO$Pure$pure = F2(
	function (a, s) {
		return _Utils_Tuple2(a, s);
	});
var $author$project$Extra$System$IO$Pure$return = $author$project$Extra$System$IO$Pure$pure;
var $author$project$Extra$System$IO$Pure$foldlMHelpList = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(result));
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(rest, b));
				},
				A2(callback, result, a));
		}
	});
var $author$project$Extra$System$IO$Pure$loop = F3(
	function (callback, loopState, ioState) {
		loop:
		while (true) {
			var _v0 = A2(callback, loopState, ioState);
			if (_v0.a.$ === 'Loop') {
				var newLoopState = _v0.a.a;
				var newIOState = _v0.b;
				var $temp$callback = callback,
					$temp$loopState = newLoopState,
					$temp$ioState = newIOState;
				callback = $temp$callback;
				loopState = $temp$loopState;
				ioState = $temp$ioState;
				continue loop;
			} else {
				var a = _v0.a.a;
				var newIOState = _v0.b;
				return _Utils_Tuple2(a, newIOState);
			}
		}
	});
var $author$project$Extra$System$IO$Pure$foldlMList = F3(
	function (callback, zero, list) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$foldlMHelpList(callback),
			_Utils_Tuple2(list, zero));
	});
var $author$project$Compiler$Type$Type$AliasN = F4(
	function (a, b, c, d) {
		return {$: 'AliasN', a: a, b: b, c: c, d: d};
	});
var $author$project$Extra$Class$Applicative$andMap = F3(
	function (pLiftA2, fa, fab) {
		return A3(pLiftA2, $elm$core$Basics$identity, fab, fa);
	});
var $author$project$Extra$System$IO$Pure$liftA2 = F4(
	function (f, ma, mb, s0) {
		var _v0 = ma(s0);
		var a = _v0.a;
		var s1 = _v0.b;
		var _v1 = mb(s1);
		var b = _v1.a;
		var s2 = _v1.b;
		return _Utils_Tuple2(
			A2(f, a, b),
			s2);
	});
var $author$project$Extra$System$IO$Pure$andMap = $author$project$Extra$Class$Applicative$andMap($author$project$Extra$System$IO$Pure$liftA2);
var $author$project$Extra$System$IO$Pure$traverseListHelp = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(
					$elm$core$List$reverse(result)));
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(
							rest,
							A2($elm$core$List$cons, b, result)));
				},
				callback(a));
		}
	});
var $author$project$Extra$System$IO$Pure$traverseList = F2(
	function (callback, list) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$traverseListHelp(callback),
			_Utils_Tuple2(list, _List_Nil));
	});
var $author$project$Extra$System$IO$Pure$traverseMapHelp = F2(
	function (callback, _v0) {
		var pairs = _v0.a;
		var result = _v0.b;
		if (!pairs.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(result));
		} else {
			var _v2 = pairs.a;
			var k = _v2.a;
			var a = _v2.b;
			var rest = pairs.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(
							rest,
							A3($author$project$Extra$Type$Map$insert, k, b, result)));
				},
				callback(a));
		}
	});
var $author$project$Extra$System$IO$Pure$traverseMap = F2(
	function (callback, map) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$traverseMapHelp(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$Map$toList(map),
				$author$project$Extra$Type$Map$empty));
	});
var $author$project$Extra$Type$Tuple$traverseSecond = F3(
	function (pFmap, f, _v0) {
		var x = _v0.a;
		var a = _v0.b;
		return A2(
			pFmap,
			function (b) {
				return _Utils_Tuple2(x, b);
			},
			f(a));
	});
var $author$project$Compiler$Type$Instantiate$fromSrcFieldType = F2(
	function (freeVars, _v3) {
		var tipe = _v3.b;
		return A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVars, tipe);
	});
var $author$project$Compiler$Type$Instantiate$fromSrcType = F2(
	function (freeVars, sourceType) {
		switch (sourceType.$) {
			case 'TLambda':
				var arg = sourceType.a;
				var result = sourceType.b;
				return A2(
					$author$project$Extra$System$IO$Pure$andMap,
					A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVars, result),
					A2(
						$author$project$Extra$System$IO$Pure$andMap,
						A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVars, arg),
						$author$project$Extra$System$IO$Pure$pure($author$project$Compiler$Type$Type$FunN)));
			case 'TVar':
				var name = sourceType.a;
				return $author$project$Extra$System$IO$Pure$return(
					A2($author$project$Extra$Type$Map$ex, freeVars, name));
			case 'TType':
				var home = sourceType.a;
				var name = sourceType.b;
				var args = sourceType.c;
				return A2(
					$author$project$Extra$System$IO$Pure$fmap,
					A2($author$project$Compiler$Type$Type$AppN, home, name),
					A2(
						$author$project$Extra$System$IO$Pure$traverseList,
						$author$project$Compiler$Type$Instantiate$fromSrcType(freeVars),
						args));
			case 'TAlias':
				var home = sourceType.a;
				var name = sourceType.b;
				var args = sourceType.c;
				var aliasedType = sourceType.d;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$traverseList,
						A2(
							$author$project$Extra$Type$Tuple$traverseSecond,
							$author$project$Extra$System$IO$Pure$fmap,
							$author$project$Compiler$Type$Instantiate$fromSrcType(freeVars)),
						args),
					function (targs) {
						return A2(
							$author$project$Extra$System$IO$Pure$fmap,
							A3($author$project$Compiler$Type$Type$AliasN, home, name, targs),
							function () {
								if (aliasedType.$ === 'Filled') {
									var realType = aliasedType.a;
									return A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVars, realType);
								} else {
									var realType = aliasedType.a;
									return A2(
										$author$project$Compiler$Type$Instantiate$fromSrcType,
										$author$project$Extra$Type$Map$fromList(targs),
										realType);
								}
							}());
					});
			case 'TTuple':
				var a = sourceType.a;
				var b = sourceType.b;
				var maybeC = sourceType.c;
				return A2(
					$author$project$Extra$System$IO$Pure$andMap,
					A4(
						$author$project$Extra$Type$Maybe$traverse,
						$author$project$Extra$System$IO$Pure$pure,
						$author$project$Extra$System$IO$Pure$fmap,
						$author$project$Compiler$Type$Instantiate$fromSrcType(freeVars),
						maybeC),
					A2(
						$author$project$Extra$System$IO$Pure$andMap,
						A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVars, b),
						A2(
							$author$project$Extra$System$IO$Pure$andMap,
							A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVars, a),
							$author$project$Extra$System$IO$Pure$pure($author$project$Compiler$Type$Type$TupleN))));
			case 'TUnit':
				return $author$project$Extra$System$IO$Pure$return($author$project$Compiler$Type$Type$UnitN);
			default:
				var fields = sourceType.a;
				var maybeExt = sourceType.b;
				return A2(
					$author$project$Extra$System$IO$Pure$andMap,
					function () {
						if (maybeExt.$ === 'Nothing') {
							return $author$project$Extra$System$IO$Pure$return($author$project$Compiler$Type$Type$EmptyRecordN);
						} else {
							var ext = maybeExt.a;
							return $author$project$Extra$System$IO$Pure$return(
								A2($author$project$Extra$Type$Map$ex, freeVars, ext));
						}
					}(),
					A2(
						$author$project$Extra$System$IO$Pure$andMap,
						A2(
							$author$project$Extra$System$IO$Pure$traverseMap,
							$author$project$Compiler$Type$Instantiate$fromSrcFieldType(freeVars),
							fields),
						$author$project$Extra$System$IO$Pure$pure($author$project$Compiler$Type$Type$RecordN)));
		}
	});
var $author$project$Compiler$Type$Type$int = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$basics, 'Int', _List_Nil);
var $author$project$Compiler$Type$Type$Descriptor = F4(
	function (a, b, c, d) {
		return {$: 'Descriptor', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Type$Mark = function (a) {
	return {$: 'Mark', a: a};
};
var $author$project$Compiler$Type$Type$noMark = $author$project$Compiler$Type$Type$Mark(2);
var $author$project$Compiler$Type$Type$noRank = 0;
var $author$project$Compiler$Type$Type$makeDescriptor = function (content) {
	return A4($author$project$Compiler$Type$Type$Descriptor, content, $author$project$Compiler$Type$Type$noRank, $author$project$Compiler$Type$Type$noMark, $elm$core$Maybe$Nothing);
};
var $author$project$Compiler$Type$Type$FlexVar = function (a) {
	return {$: 'FlexVar', a: a};
};
var $author$project$Compiler$Type$Type$unnamedFlexVar = $author$project$Compiler$Type$Type$FlexVar($elm$core$Maybe$Nothing);
var $author$project$Compiler$Type$Type$flexVarDescriptor = $author$project$Compiler$Type$Type$makeDescriptor($author$project$Compiler$Type$Type$unnamedFlexVar);
var $author$project$Compiler$Type$UnionFind$Info = F2(
	function (a, b) {
		return {$: 'Info', a: a, b: b};
	});
var $author$project$Compiler$Type$UnionFind$Pt = function (a) {
	return {$: 'Pt', a: a};
};
var $author$project$Extra$System$IO$Pure$liftS = F4(
	function (getter, setter, state1, s2) {
		var _v0 = state1(
			getter(s2));
		var a = _v0.a;
		var s1 = _v0.b;
		return _Utils_Tuple2(
			a,
			A2(setter, s1, s2));
	});
var $author$project$Compiler$Type$UnionFind$liftD = A2(
	$author$project$Extra$System$IO$Pure$liftS,
	function (_v0) {
		var _v1 = _v0.a;
		var x = _v1.b;
		return x;
	},
	F2(
		function (x, _v2) {
			var _v3 = _v2.a;
			var ai = _v3.a;
			var ci = _v3.c;
			var b = _v2.b;
			return _Utils_Tuple2(
				_Utils_Tuple3(ai, x, ci),
				b);
		}));
var $author$project$Compiler$Type$UnionFind$liftI = A2(
	$author$project$Extra$System$IO$Pure$liftS,
	function (_v0) {
		var _v1 = _v0.a;
		var x = _v1.c;
		return x;
	},
	F2(
		function (x, _v2) {
			var _v3 = _v2.a;
			var ai = _v3.a;
			var bi = _v3.b;
			var b = _v2.b;
			return _Utils_Tuple2(
				_Utils_Tuple3(ai, bi, x),
				b);
		}));
var $author$project$Compiler$Type$UnionFind$liftW = A2(
	$author$project$Extra$System$IO$Pure$liftS,
	function (_v0) {
		var _v1 = _v0.a;
		var x = _v1.a;
		return x;
	},
	F2(
		function (x, _v2) {
			var _v3 = _v2.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var b = _v2.b;
			return _Utils_Tuple2(
				_Utils_Tuple3(x, bi, ci),
				b);
		}));
var $author$project$Extra$System$IORef$IORef = function (a) {
	return {$: 'IORef', a: a};
};
var $author$project$Extra$System$IORef$new = F2(
	function (a, _v0) {
		var nextId = _v0.a;
		var map = _v0.b;
		return _Utils_Tuple2(
			$author$project$Extra$System$IORef$IORef(nextId),
			_Utils_Tuple2(
				nextId + 1,
				A3($author$project$Extra$Type$Map$insert, nextId, a, map)));
	});
var $author$project$Compiler$Type$UnionFind$fresh = function (value) {
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$UnionFind$liftW(
			$author$project$Extra$System$IORef$new(1)),
		function (weight) {
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$UnionFind$liftD(
					$author$project$Extra$System$IORef$new(value)),
				function (desc) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$UnionFind$liftI(
							$author$project$Extra$System$IORef$new(
								A2($author$project$Compiler$Type$UnionFind$Info, weight, desc))),
						function (link) {
							return $author$project$Extra$System$IO$Pure$return(
								$author$project$Compiler$Type$UnionFind$Pt(link));
						});
				});
		});
};
var $author$project$Compiler$Type$Type$mkFlexVar = $author$project$Compiler$Type$UnionFind$fresh($author$project$Compiler$Type$Type$flexVarDescriptor);
var $author$project$Compiler$Type$Type$FlexSuper = F2(
	function (a, b) {
		return {$: 'FlexSuper', a: a, b: b};
	});
var $author$project$Compiler$Type$Type$Appendable = {$: 'Appendable'};
var $author$project$Compiler$Type$Type$CompAppend = {$: 'CompAppend'};
var $author$project$Compiler$Type$Type$Comparable = {$: 'Comparable'};
var $author$project$Compiler$Type$Type$Number = {$: 'Number'};
var $author$project$Compiler$Data$Name$prefix_appendable = 'appendable';
var $author$project$Compiler$Data$Name$isAppendableType = $author$project$Compiler$Data$Utf8$startsWith($author$project$Compiler$Data$Name$prefix_appendable);
var $author$project$Compiler$Data$Name$prefix_compappend = 'compappend';
var $author$project$Compiler$Data$Name$isCompappendType = $author$project$Compiler$Data$Utf8$startsWith($author$project$Compiler$Data$Name$prefix_compappend);
var $author$project$Compiler$Data$Name$prefix_comparable = 'comparable';
var $author$project$Compiler$Data$Name$isComparableType = $author$project$Compiler$Data$Utf8$startsWith($author$project$Compiler$Data$Name$prefix_comparable);
var $author$project$Compiler$Data$Name$prefix_number = 'number';
var $author$project$Compiler$Data$Name$isNumberType = $author$project$Compiler$Data$Utf8$startsWith($author$project$Compiler$Data$Name$prefix_number);
var $author$project$Compiler$Type$Type$toSuper = function (name) {
	return $author$project$Compiler$Data$Name$isNumberType(name) ? $elm$core$Maybe$Just($author$project$Compiler$Type$Type$Number) : ($author$project$Compiler$Data$Name$isComparableType(name) ? $elm$core$Maybe$Just($author$project$Compiler$Type$Type$Comparable) : ($author$project$Compiler$Data$Name$isAppendableType(name) ? $elm$core$Maybe$Just($author$project$Compiler$Type$Type$Appendable) : ($author$project$Compiler$Data$Name$isCompappendType(name) ? $elm$core$Maybe$Just($author$project$Compiler$Type$Type$CompAppend) : $elm$core$Maybe$Nothing)));
};
var $author$project$Compiler$Type$Type$nameToFlex = function (name) {
	return $author$project$Compiler$Type$UnionFind$fresh(
		$author$project$Compiler$Type$Type$makeDescriptor(
			A4(
				$author$project$Extra$Type$Maybe$maybe,
				$author$project$Compiler$Type$Type$FlexVar,
				$author$project$Compiler$Type$Type$FlexSuper,
				$author$project$Compiler$Type$Type$toSuper(name),
				$elm$core$Maybe$Just(name))));
};
var $author$project$Compiler$Type$Type$string = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$string, 'String', _List_Nil);
var $author$project$Compiler$Type$Constrain$Pattern$add = F3(
	function (_v6, expectation, state) {
		var region = _v6.a;
		var pattern = _v6.b;
		switch (pattern.$) {
			case 'PAnything':
				return $author$project$Extra$System$IO$Pure$return(state);
			case 'PVar':
				var name = pattern.a;
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Constrain$Pattern$addToHeaders, region, name, expectation, state));
			case 'PAlias':
				var realPattern = pattern.a;
				var name = pattern.b;
				return A3(
					$author$project$Compiler$Type$Constrain$Pattern$add,
					realPattern,
					expectation,
					A4($author$project$Compiler$Type$Constrain$Pattern$addToHeaders, region, name, expectation, state));
			case 'PUnit':
				var unitCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PUnit, $author$project$Compiler$Type$Type$UnitN, expectation);
				var _v8 = state;
				var headers = _v8.a;
				var vars = _v8.b;
				var revCons = _v8.c;
				return $author$project$Extra$System$IO$Pure$return(
					A3(
						$author$project$Compiler$Type$Constrain$Pattern$State,
						headers,
						vars,
						A2($elm$core$List$cons, unitCon, revCons)));
			case 'PTuple':
				var a = pattern.a;
				var b = pattern.b;
				var maybeC = pattern.c;
				return A6($author$project$Compiler$Type$Constrain$Pattern$addTuple, region, a, b, maybeC, expectation, state);
			case 'PCtor':
				var home = pattern.a;
				var typeName = pattern.b;
				var _v9 = pattern.c;
				var typeVars = _v9.a;
				var ctorName = pattern.d;
				var args = pattern.f;
				return A8($author$project$Compiler$Type$Constrain$Pattern$addCtor, region, home, typeName, typeVars, ctorName, args, expectation, state);
			case 'PList':
				var patterns = pattern.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (entryVar) {
						var entryType = $author$project$Compiler$Type$Type$VarN(entryVar);
						var listType = A3(
							$author$project$Compiler$Type$Type$AppN,
							$author$project$Compiler$Elm$ModuleName$list,
							$author$project$Compiler$Data$Name$list,
							_List_fromArray(
								[entryType]));
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3(
								$author$project$Extra$System$IO$Pure$foldlMList,
								A2($author$project$Compiler$Type$Constrain$Pattern$addEntry, region, entryType),
								state,
								A2($author$project$Compiler$Data$Index$indexedMap, $elm$core$Tuple$pair, patterns)),
							function (_v10) {
								var headers = _v10.a;
								var vars = _v10.b;
								var revCons = _v10.c;
								var listCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PList, listType, expectation);
								return $author$project$Extra$System$IO$Pure$return(
									A3(
										$author$project$Compiler$Type$Constrain$Pattern$State,
										headers,
										A2($elm$core$List$cons, entryVar, vars),
										A2($elm$core$List$cons, listCon, revCons)));
							});
					});
			case 'PCons':
				var headPattern = pattern.a;
				var tailPattern = pattern.b;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (entryVar) {
						var entryType = $author$project$Compiler$Type$Type$VarN(entryVar);
						var headExpectation = $author$project$Compiler$Reporting$Error$Type$PNoExpectation(entryType);
						var listType = A3(
							$author$project$Compiler$Type$Type$AppN,
							$author$project$Compiler$Elm$ModuleName$list,
							$author$project$Compiler$Data$Name$list,
							_List_fromArray(
								[entryType]));
						var tailExpectation = A3($author$project$Compiler$Reporting$Error$Type$PFromContext, region, $author$project$Compiler$Reporting$Error$Type$PTail, listType);
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A2(
								$author$project$Extra$System$IO$Pure$andThen,
								A2($author$project$Compiler$Type$Constrain$Pattern$add, headPattern, headExpectation),
								A3($author$project$Compiler$Type$Constrain$Pattern$add, tailPattern, tailExpectation, state)),
							function (_v11) {
								var headers = _v11.a;
								var vars = _v11.b;
								var revCons = _v11.c;
								var listCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PList, listType, expectation);
								return $author$project$Extra$System$IO$Pure$return(
									A3(
										$author$project$Compiler$Type$Constrain$Pattern$State,
										headers,
										A2($elm$core$List$cons, entryVar, vars),
										A2($elm$core$List$cons, listCon, revCons)));
							});
					});
			case 'PRecord':
				var fields = pattern.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (extVar) {
						var extType = $author$project$Compiler$Type$Type$VarN(extVar);
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A2(
								$author$project$Extra$System$IO$Pure$traverseList,
								function (field) {
									return A2(
										$author$project$Extra$System$IO$Pure$fmap,
										$elm$core$Tuple$pair(field),
										$author$project$Compiler$Type$Type$mkFlexVar);
								},
								fields),
							function (fieldVars) {
								var fieldTypes = $author$project$Extra$Type$Map$fromList(
									A2(
										$author$project$Extra$Type$List$map,
										$elm$core$Tuple$mapSecond($author$project$Compiler$Type$Type$VarN),
										fieldVars));
								var recordType = A2($author$project$Compiler$Type$Type$RecordN, fieldTypes, extType);
								var recordCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PRecord, recordType, expectation);
								var _v12 = state;
								var headers = _v12.a;
								var vars = _v12.b;
								var revCons = _v12.c;
								return $author$project$Extra$System$IO$Pure$return(
									A3(
										$author$project$Compiler$Type$Constrain$Pattern$State,
										A2(
											$author$project$Extra$Type$Map$union,
											headers,
											A2(
												$author$project$Extra$Type$Map$map,
												$author$project$Compiler$Reporting$Annotation$At(region),
												fieldTypes)),
										_Utils_ap(
											A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, fieldVars),
											A2($elm$core$List$cons, extVar, vars)),
										A2($elm$core$List$cons, recordCon, revCons)));
							});
					});
			case 'PInt':
				var intCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PInt, $author$project$Compiler$Type$Type$int, expectation);
				var _v13 = state;
				var headers = _v13.a;
				var vars = _v13.b;
				var revCons = _v13.c;
				return $author$project$Extra$System$IO$Pure$return(
					A3(
						$author$project$Compiler$Type$Constrain$Pattern$State,
						headers,
						vars,
						A2($elm$core$List$cons, intCon, revCons)));
			case 'PStr':
				var strCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PStr, $author$project$Compiler$Type$Type$string, expectation);
				var _v14 = state;
				var headers = _v14.a;
				var vars = _v14.b;
				var revCons = _v14.c;
				return $author$project$Extra$System$IO$Pure$return(
					A3(
						$author$project$Compiler$Type$Constrain$Pattern$State,
						headers,
						vars,
						A2($elm$core$List$cons, strCon, revCons)));
			case 'PChr':
				var chrCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PChr, $author$project$Compiler$Type$Type$char, expectation);
				var _v15 = state;
				var headers = _v15.a;
				var vars = _v15.b;
				var revCons = _v15.c;
				return $author$project$Extra$System$IO$Pure$return(
					A3(
						$author$project$Compiler$Type$Constrain$Pattern$State,
						headers,
						vars,
						A2($elm$core$List$cons, chrCon, revCons)));
			default:
				var boolCon = A4($author$project$Compiler$Type$Type$CPattern, region, $author$project$Compiler$Reporting$Error$Type$PBool, $author$project$Compiler$Type$Type$bool, expectation);
				var _v16 = state;
				var headers = _v16.a;
				var vars = _v16.b;
				var revCons = _v16.c;
				return $author$project$Extra$System$IO$Pure$return(
					A3(
						$author$project$Compiler$Type$Constrain$Pattern$State,
						headers,
						vars,
						A2($elm$core$List$cons, boolCon, revCons)));
		}
	});
var $author$project$Compiler$Type$Constrain$Pattern$addCtor = F8(
	function (region, home, typeName, typeVarNames, ctorName, args, expectation, state) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A2(
				$author$project$Extra$System$IO$Pure$traverseList,
				function (_var) {
					return A2(
						$author$project$Extra$System$IO$Pure$fmap,
						$elm$core$Tuple$pair(_var),
						$author$project$Compiler$Type$Type$nameToFlex(_var));
				},
				typeVarNames),
			function (varPairs) {
				var typePairs = A2(
					$author$project$Extra$Type$List$map,
					$elm$core$Tuple$mapSecond($author$project$Compiler$Type$Type$VarN),
					varPairs);
				var freeVarDict = $author$project$Extra$Type$Map$fromList(typePairs);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Extra$System$IO$Pure$foldlMList,
						A3($author$project$Compiler$Type$Constrain$Pattern$addCtorArg, region, ctorName, freeVarDict),
						state,
						args),
					function (_v5) {
						var headers = _v5.a;
						var vars = _v5.b;
						var revCons = _v5.c;
						var ctorType = A3(
							$author$project$Compiler$Type$Type$AppN,
							home,
							typeName,
							A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, typePairs));
						var ctorCon = A4(
							$author$project$Compiler$Type$Type$CPattern,
							region,
							$author$project$Compiler$Reporting$Error$Type$PCtor(ctorName),
							ctorType,
							expectation);
						return $author$project$Extra$System$IO$Pure$return(
							A3(
								$author$project$Compiler$Type$Constrain$Pattern$State,
								headers,
								_Utils_ap(
									A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, varPairs),
									vars),
								A2($elm$core$List$cons, ctorCon, revCons)));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Pattern$addCtorArg = F5(
	function (region, ctorName, freeVarDict, state, _v4) {
		var index = _v4.a;
		var srcType = _v4.b;
		var pattern = _v4.c;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A2($author$project$Compiler$Type$Instantiate$fromSrcType, freeVarDict, srcType),
			function (tipe) {
				var expectation = A3(
					$author$project$Compiler$Reporting$Error$Type$PFromContext,
					region,
					A2($author$project$Compiler$Reporting$Error$Type$PCtorArg, ctorName, index),
					tipe);
				return A3($author$project$Compiler$Type$Constrain$Pattern$add, pattern, expectation, state);
			});
	});
var $author$project$Compiler$Type$Constrain$Pattern$addEntry = F4(
	function (listRegion, tipe, state, _v3) {
		var index = _v3.a;
		var pattern = _v3.b;
		var expectation = A3(
			$author$project$Compiler$Reporting$Error$Type$PFromContext,
			listRegion,
			$author$project$Compiler$Reporting$Error$Type$PListEntry(index),
			tipe);
		return A3($author$project$Compiler$Type$Constrain$Pattern$add, pattern, expectation, state);
	});
var $author$project$Compiler$Type$Constrain$Pattern$addTuple = F6(
	function (region, a, b, maybeC, expectation, state) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (aVar) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (bVar) {
						var bType = $author$project$Compiler$Type$Type$VarN(bVar);
						var aType = $author$project$Compiler$Type$Type$VarN(aVar);
						if (maybeC.$ === 'Nothing') {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A2(
									$author$project$Extra$System$IO$Pure$andThen,
									A2($author$project$Compiler$Type$Constrain$Pattern$simpleAdd, b, bType),
									A3($author$project$Compiler$Type$Constrain$Pattern$simpleAdd, a, aType, state)),
								function (_v1) {
									var headers = _v1.a;
									var vars = _v1.b;
									var revCons = _v1.c;
									var tupleCon = A4(
										$author$project$Compiler$Type$Type$CPattern,
										region,
										$author$project$Compiler$Reporting$Error$Type$PTuple,
										A3($author$project$Compiler$Type$Type$TupleN, aType, bType, $elm$core$Maybe$Nothing),
										expectation);
									return $author$project$Extra$System$IO$Pure$return(
										A3(
											$author$project$Compiler$Type$Constrain$Pattern$State,
											headers,
											A2(
												$elm$core$List$cons,
												aVar,
												A2($elm$core$List$cons, bVar, vars)),
											A2($elm$core$List$cons, tupleCon, revCons)));
								});
						} else {
							var c = maybeC.a;
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Compiler$Type$Type$mkFlexVar,
								function (cVar) {
									var cType = $author$project$Compiler$Type$Type$VarN(cVar);
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A2(
											$author$project$Extra$System$IO$Pure$andThen,
											A2($author$project$Compiler$Type$Constrain$Pattern$simpleAdd, c, cType),
											A2(
												$author$project$Extra$System$IO$Pure$andThen,
												A2($author$project$Compiler$Type$Constrain$Pattern$simpleAdd, b, bType),
												A3($author$project$Compiler$Type$Constrain$Pattern$simpleAdd, a, aType, state))),
										function (_v2) {
											var headers = _v2.a;
											var vars = _v2.b;
											var revCons = _v2.c;
											var tupleCon = A4(
												$author$project$Compiler$Type$Type$CPattern,
												region,
												$author$project$Compiler$Reporting$Error$Type$PTuple,
												A3(
													$author$project$Compiler$Type$Type$TupleN,
													aType,
													bType,
													$elm$core$Maybe$Just(cType)),
												expectation);
											return $author$project$Extra$System$IO$Pure$return(
												A3(
													$author$project$Compiler$Type$Constrain$Pattern$State,
													headers,
													A2(
														$elm$core$List$cons,
														aVar,
														A2(
															$elm$core$List$cons,
															bVar,
															A2($elm$core$List$cons, cVar, vars))),
													A2($elm$core$List$cons, tupleCon, revCons)));
										});
								});
						}
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Pattern$simpleAdd = F3(
	function (pattern, patternType, state) {
		return A3(
			$author$project$Compiler$Type$Constrain$Pattern$add,
			pattern,
			$author$project$Compiler$Reporting$Error$Type$PNoExpectation(patternType),
			state);
	});
var $author$project$Compiler$Type$Constrain$Expression$Args = F4(
	function (a, b, c, d) {
		return {$: 'Args', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Constrain$Expression$argsHelp = F2(
	function (args, state) {
		if (!args.b) {
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$Type$mkFlexVar,
				function (resultVar) {
					var resultType = $author$project$Compiler$Type$Type$VarN(resultVar);
					return $author$project$Extra$System$IO$Pure$return(
						A4(
							$author$project$Compiler$Type$Constrain$Expression$Args,
							_List_fromArray(
								[resultVar]),
							resultType,
							resultType,
							state));
				});
		} else {
			var pattern = args.a;
			var otherArgs = args.b;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$Type$mkFlexVar,
				function (argVar) {
					var argType = $author$project$Compiler$Type$Type$VarN(argVar);
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2(
							$author$project$Extra$System$IO$Pure$andThen,
							$author$project$Compiler$Type$Constrain$Expression$argsHelp(otherArgs),
							A3(
								$author$project$Compiler$Type$Constrain$Pattern$add,
								pattern,
								$author$project$Compiler$Reporting$Error$Type$PNoExpectation(argType),
								state)),
						function (_v1) {
							var vars = _v1.a;
							var tipe = _v1.b;
							var result = _v1.c;
							var newState = _v1.d;
							return $author$project$Extra$System$IO$Pure$return(
								A4(
									$author$project$Compiler$Type$Constrain$Expression$Args,
									A2($elm$core$List$cons, argVar, vars),
									A2($author$project$Compiler$Type$Type$FunN, argType, tipe),
									result,
									newState));
						});
				});
		}
	});
var $author$project$Compiler$Type$Constrain$Pattern$emptyState = A3($author$project$Compiler$Type$Constrain$Pattern$State, $author$project$Extra$Type$Map$empty, _List_Nil, _List_Nil);
var $author$project$Compiler$Type$Constrain$Expression$constrainArgs = function (args) {
	return A2($author$project$Compiler$Type$Constrain$Expression$argsHelp, args, $author$project$Compiler$Type$Constrain$Pattern$emptyState);
};
var $author$project$Compiler$Reporting$Error$Type$Shader = {$: 'Shader'};
var $author$project$Compiler$Type$Type$exists = F2(
	function (flexVars, constraint) {
		return A5($author$project$Compiler$Type$Type$CLet, _List_Nil, flexVars, $author$project$Extra$Type$Map$empty, constraint, $author$project$Compiler$Type$Type$CTrue);
	});
var $author$project$Compiler$Data$Name$shader = 'Shader';
var $elm$core$Set$foldl = F3(
	function (func, initialState, _v0) {
		var dict = _v0.a;
		return A3(
			$elm$core$Dict$foldl,
			F3(
				function (key, _v1, state) {
					return A2(func, key, state);
				}),
			initialState,
			dict);
	});
var $author$project$Extra$Type$Set$foldl = F3(
	function (f, z, s) {
		return A3(
			$elm$core$Set$foldl,
			F2(
				function (e, acc) {
					return A2(f, acc, e);
				}),
			z,
			s);
	});
var $author$project$Compiler$Elm$Package$webgl = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm_explorations, 'webgl');
var $author$project$Compiler$Elm$ModuleName$texture = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$webgl, 'WebGL.Texture');
var $author$project$Compiler$Type$Type$texture = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$texture, 'Texture', _List_Nil);
var $author$project$Compiler$Type$Constrain$Expression$glToType = function (types) {
	return A3(
		$author$project$Extra$Type$Set$foldl,
		F2(
			function (map, name) {
				return A3($author$project$Extra$Type$Map$insert, name, $author$project$Compiler$Type$Type$texture, map);
			}),
		$author$project$Extra$Type$Map$empty,
		types);
};
var $elm$core$Set$isEmpty = function (_v0) {
	var dict = _v0.a;
	return $elm$core$Dict$isEmpty(dict);
};
var $author$project$Extra$Type$Set$null = $elm$core$Set$isEmpty;
var $author$project$Compiler$Type$Constrain$Expression$toShaderRecord = F2(
	function (types, baseRecType) {
		return $author$project$Extra$Type$Set$null(types) ? baseRecType : A2(
			$author$project$Compiler$Type$Type$RecordN,
			$author$project$Compiler$Type$Constrain$Expression$glToType(types),
			baseRecType);
	});
var $author$project$Compiler$Elm$ModuleName$webgl = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$webgl, 'WebGL');
var $author$project$Compiler$Type$Constrain$Expression$constrainShader = F3(
	function (region, _v0, expected) {
		var attributes = _v0.a;
		var uniforms = _v0.b;
		var varyings = _v0.c;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (attrVar) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (unifVar) {
						var unifType = $author$project$Compiler$Type$Type$VarN(unifVar);
						var attrType = $author$project$Compiler$Type$Type$VarN(attrVar);
						var shaderType = A3(
							$author$project$Compiler$Type$Type$AppN,
							$author$project$Compiler$Elm$ModuleName$webgl,
							$author$project$Compiler$Data$Name$shader,
							_List_fromArray(
								[
									A2($author$project$Compiler$Type$Constrain$Expression$toShaderRecord, attributes, attrType),
									A2($author$project$Compiler$Type$Constrain$Expression$toShaderRecord, uniforms, unifType),
									A2($author$project$Compiler$Type$Constrain$Expression$toShaderRecord, varyings, $author$project$Compiler$Type$Type$EmptyRecordN)
								]));
						return $author$project$Extra$System$IO$Pure$return(
							A2(
								$author$project$Compiler$Type$Type$exists,
								_List_fromArray(
									[attrVar, unifVar]),
								A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Shader, shaderType, expected)));
					});
			});
	});
var $author$project$Compiler$Reporting$Error$Type$PTypedArg = F2(
	function (a, b) {
		return {$: 'PTypedArg', a: a, b: b};
	});
var $author$project$Compiler$Type$Constrain$Expression$TypedArgs = F3(
	function (a, b, c) {
		return {$: 'TypedArgs', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Constrain$Expression$typedArgsHelp = F6(
	function (rtv, name, index, args, srcResultType, state) {
		if (!args.b) {
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2($author$project$Compiler$Type$Instantiate$fromSrcType, rtv, srcResultType),
				function (resultType) {
					return $author$project$Extra$System$IO$Pure$return(
						A3($author$project$Compiler$Type$Constrain$Expression$TypedArgs, resultType, resultType, state));
				});
		} else {
			var _v1 = args.a;
			var pattern = _v1.a;
			var region = pattern.a;
			var srcType = _v1.b;
			var otherArgs = args.b;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2($author$project$Compiler$Type$Instantiate$fromSrcType, rtv, srcType),
				function (argType) {
					var expected = A3(
						$author$project$Compiler$Reporting$Error$Type$PFromContext,
						region,
						A2($author$project$Compiler$Reporting$Error$Type$PTypedArg, name, index),
						argType);
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2(
							$author$project$Extra$System$IO$Pure$andThen,
							A5(
								$author$project$Compiler$Type$Constrain$Expression$typedArgsHelp,
								rtv,
								name,
								$author$project$Compiler$Data$Index$next(index),
								otherArgs,
								srcResultType),
							A3($author$project$Compiler$Type$Constrain$Pattern$add, pattern, expected, state)),
						function (_v2) {
							var tipe = _v2.a;
							var resultType = _v2.b;
							var newState = _v2.c;
							return $author$project$Extra$System$IO$Pure$return(
								A3(
									$author$project$Compiler$Type$Constrain$Expression$TypedArgs,
									A2($author$project$Compiler$Type$Type$FunN, argType, tipe),
									resultType,
									newState));
						});
				});
		}
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainTypedArgs = F4(
	function (rtv, name, args, srcResultType) {
		return A6($author$project$Compiler$Type$Constrain$Expression$typedArgsHelp, rtv, name, $author$project$Compiler$Data$Index$first, args, srcResultType, $author$project$Compiler$Type$Constrain$Pattern$emptyState);
	});
var $elm$core$Dict$values = function (dict) {
	return A3(
		$elm$core$Dict$foldr,
		F3(
			function (key, value, valueList) {
				return A2($elm$core$List$cons, value, valueList);
			}),
		_List_Nil,
		dict);
};
var $author$project$Extra$Type$Map$elems = $elm$core$Dict$values;
var $author$project$Compiler$Type$Constrain$Expression$emptyInfo = A3($author$project$Compiler$Type$Constrain$Expression$Info, _List_Nil, _List_Nil, $author$project$Extra$Type$Map$empty);
var $author$project$Compiler$Type$Type$float = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$basics, 'Float', _List_Nil);
var $author$project$Compiler$Type$Constrain$Expression$getAccessName = function (_v0) {
	var expr = _v0.b;
	switch (expr.$) {
		case 'VarLocal':
			var name = expr.a;
			return $elm$core$Maybe$Just(name);
		case 'VarTopLevel':
			var name = expr.b;
			return $elm$core$Maybe$Just(name);
		case 'VarForeign':
			var name = expr.b;
			return $elm$core$Maybe$Just(name);
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Compiler$Reporting$Error$Type$CtorName = function (a) {
	return {$: 'CtorName', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$FuncName = function (a) {
	return {$: 'FuncName', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$NoName = {$: 'NoName'};
var $author$project$Compiler$Type$Constrain$Expression$getName = function (_v0) {
	var expr = _v0.b;
	switch (expr.$) {
		case 'VarLocal':
			var name = expr.a;
			return $author$project$Compiler$Reporting$Error$Type$FuncName(name);
		case 'VarTopLevel':
			var name = expr.b;
			return $author$project$Compiler$Reporting$Error$Type$FuncName(name);
		case 'VarForeign':
			var name = expr.b;
			return $author$project$Compiler$Reporting$Error$Type$FuncName(name);
		case 'VarCtor':
			var name = expr.c;
			return $author$project$Compiler$Reporting$Error$Type$CtorName(name);
		case 'VarOperator':
			var op = expr.a;
			return $author$project$Compiler$Reporting$Error$Type$OpName(op);
		case 'VarKernel':
			var name = expr.b;
			return $author$project$Compiler$Reporting$Error$Type$FuncName(name);
		default:
			return $author$project$Compiler$Reporting$Error$Type$NoName;
	}
};
var $author$project$Compiler$Type$Constrain$Expression$indexedForAHelp = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var index = _v0.b;
		var result = _v0.c;
		if (!list.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(
					$author$project$Extra$Type$List$reverse(result)));
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple3(
							rest,
							index + 1,
							A2($elm$core$List$cons, b, result)));
				},
				A2(
					callback,
					$author$project$Compiler$Data$Index$ZeroBased(index),
					a));
		}
	});
var $author$project$Compiler$Type$Constrain$Expression$indexedForA = F2(
	function (list, func) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Compiler$Type$Constrain$Expression$indexedForAHelp(func),
			_Utils_Tuple3(list, 0, _List_Nil));
	});
var $author$project$Compiler$Type$Type$unnamedFlexSuper = function (_super) {
	return A2($author$project$Compiler$Type$Type$FlexSuper, _super, $elm$core$Maybe$Nothing);
};
var $author$project$Compiler$Type$Type$flexNumberDescriptor = $author$project$Compiler$Type$Type$makeDescriptor(
	$author$project$Compiler$Type$Type$unnamedFlexSuper($author$project$Compiler$Type$Type$Number));
var $author$project$Compiler$Type$Type$mkFlexNumber = $author$project$Compiler$Type$UnionFind$fresh($author$project$Compiler$Type$Type$flexNumberDescriptor);
var $author$project$Compiler$Type$Type$RigidSuper = F2(
	function (a, b) {
		return {$: 'RigidSuper', a: a, b: b};
	});
var $author$project$Compiler$Type$Type$RigidVar = function (a) {
	return {$: 'RigidVar', a: a};
};
var $author$project$Compiler$Type$Type$nameToRigid = function (name) {
	return $author$project$Compiler$Type$UnionFind$fresh(
		$author$project$Compiler$Type$Type$makeDescriptor(
			A4(
				$author$project$Extra$Type$Maybe$maybe,
				$author$project$Compiler$Type$Type$RigidVar,
				$author$project$Compiler$Type$Type$RigidSuper,
				$author$project$Compiler$Type$Type$toSuper(name),
				name)));
};
var $author$project$Compiler$Reporting$Annotation$toRegion = function (_v0) {
	var region = _v0.a;
	return region;
};
var $author$project$Extra$System$IO$Pure$traverseWithKeyHelp = F2(
	function (callback, _v0) {
		var pairs = _v0.a;
		var result = _v0.b;
		if (!pairs.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(result));
		} else {
			var _v2 = pairs.a;
			var k = _v2.a;
			var a = _v2.b;
			var rest = pairs.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(
							rest,
							A3($author$project$Extra$Type$Map$insert, k, b, result)));
				},
				A2(callback, k, a));
		}
	});
var $author$project$Extra$System$IO$Pure$traverseWithKey = F2(
	function (callback, map) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$traverseWithKeyHelp(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$Map$toList(map),
				$author$project$Extra$Type$Map$empty));
	});
var $author$project$Extra$Type$List$unzip3 = A2(
	$author$project$Extra$Type$List$foldr,
	F2(
		function (_v0, _v1) {
			var a = _v0.a;
			var b = _v0.b;
			var c = _v0.c;
			var la = _v1.a;
			var lb = _v1.b;
			var lc = _v1.c;
			return _Utils_Tuple3(
				A2($elm$core$List$cons, a, la),
				A2($elm$core$List$cons, b, lb),
				A2($elm$core$List$cons, c, lc));
		}),
	_Utils_Tuple3(_List_Nil, _List_Nil, _List_Nil));
var $author$project$Compiler$Type$Constrain$Expression$constrain = F3(
	function (rtv, _v40, expected) {
		var region = _v40.a;
		var expression = _v40.b;
		switch (expression.$) {
			case 'VarLocal':
				var name = expression.a;
				return $author$project$Extra$System$IO$Pure$return(
					A3($author$project$Compiler$Type$Type$CLocal, region, name, expected));
			case 'VarTopLevel':
				var name = expression.b;
				return $author$project$Extra$System$IO$Pure$return(
					A3($author$project$Compiler$Type$Type$CLocal, region, name, expected));
			case 'VarKernel':
				return $author$project$Extra$System$IO$Pure$return($author$project$Compiler$Type$Type$CTrue);
			case 'VarForeign':
				var name = expression.b;
				var annotation = expression.c;
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CForeign, region, name, annotation, expected));
			case 'VarCtor':
				var name = expression.c;
				var annotation = expression.e;
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CForeign, region, name, annotation, expected));
			case 'VarDebug':
				var name = expression.b;
				var annotation = expression.c;
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CForeign, region, name, annotation, expected));
			case 'VarOperator':
				var op = expression.a;
				var annotation = expression.d;
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CForeign, region, op, annotation, expected));
			case 'Str':
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$CString, $author$project$Compiler$Type$Type$string, expected));
			case 'Chr':
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$CChar, $author$project$Compiler$Type$Type$char, expected));
			case 'CInt':
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexNumber,
					function (_var) {
						return $author$project$Extra$System$IO$Pure$return(
							A2(
								$author$project$Compiler$Type$Type$exists,
								_List_fromArray(
									[_var]),
								A4(
									$author$project$Compiler$Type$Type$CEqual,
									region,
									$author$project$Compiler$Reporting$Error$Type$Number,
									$author$project$Compiler$Type$Type$VarN(_var),
									expected)));
					});
			case 'CFloat':
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$CFloat, $author$project$Compiler$Type$Type$float, expected));
			case 'CList':
				var elements = expression.a;
				return A4($author$project$Compiler$Type$Constrain$Expression$constrainList, rtv, region, elements, expected);
			case 'Negate':
				var expr = expression.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexNumber,
					function (numberVar) {
						var numberType = $author$project$Compiler$Type$Type$VarN(numberVar);
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3(
								$author$project$Compiler$Type$Constrain$Expression$constrain,
								rtv,
								expr,
								A3($author$project$Compiler$Reporting$Error$Type$FromContext, region, $author$project$Compiler$Reporting$Error$Type$Negate, numberType)),
							function (numberCon) {
								var negateCon = A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Number, numberType, expected);
								return $author$project$Extra$System$IO$Pure$return(
									A2(
										$author$project$Compiler$Type$Type$exists,
										_List_fromArray(
											[numberVar]),
										$author$project$Compiler$Type$Type$CAnd(
											_List_fromArray(
												[numberCon, negateCon]))));
							});
					});
			case 'Binop':
				var op = expression.a;
				var annotation = expression.d;
				var leftExpr = expression.e;
				var rightExpr = expression.f;
				return A7($author$project$Compiler$Type$Constrain$Expression$constrainBinop, rtv, region, op, annotation, leftExpr, rightExpr, expected);
			case 'Lambda':
				var args = expression.a;
				var body = expression.b;
				return A5($author$project$Compiler$Type$Constrain$Expression$constrainLambda, rtv, region, args, body, expected);
			case 'Call':
				var func = expression.a;
				var args = expression.b;
				return A5($author$project$Compiler$Type$Constrain$Expression$constrainCall, rtv, region, func, args, expected);
			case 'If':
				var branches = expression.a;
				var _finally = expression.b;
				return A5($author$project$Compiler$Type$Constrain$Expression$constrainIf, rtv, region, branches, _finally, expected);
			case 'Case':
				var expr = expression.a;
				var branches = expression.b;
				return A5($author$project$Compiler$Type$Constrain$Expression$constrainCase, rtv, region, expr, branches, expected);
			case 'Let':
				var def = expression.a;
				var body = expression.b;
				return A2(
					$author$project$Extra$System$IO$Pure$andThen,
					A2($author$project$Compiler$Type$Constrain$Expression$constrainDef, rtv, def),
					A3($author$project$Compiler$Type$Constrain$Expression$constrain, rtv, body, expected));
			case 'LetRec':
				var defs = expression.a;
				var body = expression.b;
				return A2(
					$author$project$Extra$System$IO$Pure$andThen,
					A2($author$project$Compiler$Type$Constrain$Expression$constrainRecursiveDefs, rtv, defs),
					A3($author$project$Compiler$Type$Constrain$Expression$constrain, rtv, body, expected));
			case 'LetDestruct':
				var pattern = expression.a;
				var expr = expression.b;
				var body = expression.c;
				return A2(
					$author$project$Extra$System$IO$Pure$andThen,
					A4($author$project$Compiler$Type$Constrain$Expression$constrainDestruct, rtv, region, pattern, expr),
					A3($author$project$Compiler$Type$Constrain$Expression$constrain, rtv, body, expected));
			case 'Accessor':
				var field = expression.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (extVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$Type$mkFlexVar,
							function (fieldVar) {
								var fieldType = $author$project$Compiler$Type$Type$VarN(fieldVar);
								var extType = $author$project$Compiler$Type$Type$VarN(extVar);
								var recordType = A2(
									$author$project$Compiler$Type$Type$RecordN,
									A2($author$project$Extra$Type$Map$singleton, field, fieldType),
									extType);
								return $author$project$Extra$System$IO$Pure$return(
									A2(
										$author$project$Compiler$Type$Type$exists,
										_List_fromArray(
											[fieldVar, extVar]),
										A4(
											$author$project$Compiler$Type$Type$CEqual,
											region,
											$author$project$Compiler$Reporting$Error$Type$Accessor(field),
											A2($author$project$Compiler$Type$Type$FunN, recordType, fieldType),
											expected)));
							});
					});
			case 'Access':
				var expr = expression.a;
				var _v42 = expression.b;
				var accessRegion = _v42.a;
				var field = _v42.b;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (extVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$Type$mkFlexVar,
							function (fieldVar) {
								var fieldType = $author$project$Compiler$Type$Type$VarN(fieldVar);
								var extType = $author$project$Compiler$Type$Type$VarN(extVar);
								var recordType = A2(
									$author$project$Compiler$Type$Type$RecordN,
									A2($author$project$Extra$Type$Map$singleton, field, fieldType),
									extType);
								var context = A4(
									$author$project$Compiler$Reporting$Error$Type$RecordAccess,
									$author$project$Compiler$Reporting$Annotation$toRegion(expr),
									$author$project$Compiler$Type$Constrain$Expression$getAccessName(expr),
									accessRegion,
									field);
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A3(
										$author$project$Compiler$Type$Constrain$Expression$constrain,
										rtv,
										expr,
										A3($author$project$Compiler$Reporting$Error$Type$FromContext, region, context, recordType)),
									function (recordCon) {
										return $author$project$Extra$System$IO$Pure$return(
											A2(
												$author$project$Compiler$Type$Type$exists,
												_List_fromArray(
													[fieldVar, extVar]),
												$author$project$Compiler$Type$Type$CAnd(
													_List_fromArray(
														[
															recordCon,
															A4(
															$author$project$Compiler$Type$Type$CEqual,
															region,
															$author$project$Compiler$Reporting$Error$Type$Access(field),
															fieldType,
															expected)
														]))));
									});
							});
					});
			case 'Update':
				var name = expression.a;
				var expr = expression.b;
				var fields = expression.c;
				return A6($author$project$Compiler$Type$Constrain$Expression$constrainUpdate, rtv, region, name, expr, fields, expected);
			case 'Record':
				var fields = expression.a;
				return A4($author$project$Compiler$Type$Constrain$Expression$constrainRecord, rtv, region, fields, expected);
			case 'Unit':
				return $author$project$Extra$System$IO$Pure$return(
					A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Unit, $author$project$Compiler$Type$Type$UnitN, expected));
			case 'Tuple':
				var a = expression.a;
				var b = expression.b;
				var maybeC = expression.c;
				return A6($author$project$Compiler$Type$Constrain$Expression$constrainTuple, rtv, region, a, b, maybeC, expected);
			default:
				var types = expression.b;
				return A3($author$project$Compiler$Type$Constrain$Expression$constrainShader, region, types, expected);
		}
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainArg = F5(
	function (rtv, region, maybeName, index, arg) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (argVar) {
				var argType = $author$project$Compiler$Type$Type$VarN(argVar);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Constrain$Expression$constrain,
						rtv,
						arg,
						A3(
							$author$project$Compiler$Reporting$Error$Type$FromContext,
							region,
							A2($author$project$Compiler$Reporting$Error$Type$CallArg, maybeName, index),
							argType)),
					function (argCon) {
						return $author$project$Extra$System$IO$Pure$return(
							_Utils_Tuple3(argVar, argType, argCon));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainBinop = F7(
	function (rtv, region, op, annotation, leftExpr, rightExpr, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (leftVar) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (rightVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$Type$mkFlexVar,
							function (answerVar) {
								var rightType = $author$project$Compiler$Type$Type$VarN(rightVar);
								var leftType = $author$project$Compiler$Type$Type$VarN(leftVar);
								var answerType = $author$project$Compiler$Type$Type$VarN(answerVar);
								var binopType = A2(
									$author$project$Compiler$Type$Type$FunN,
									leftType,
									A2($author$project$Compiler$Type$Type$FunN, rightType, answerType));
								var opCon = A4(
									$author$project$Compiler$Type$Type$CForeign,
									region,
									op,
									annotation,
									$author$project$Compiler$Reporting$Error$Type$NoExpectation(binopType));
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A3(
										$author$project$Compiler$Type$Constrain$Expression$constrain,
										rtv,
										leftExpr,
										A3(
											$author$project$Compiler$Reporting$Error$Type$FromContext,
											region,
											$author$project$Compiler$Reporting$Error$Type$OpLeft(op),
											leftType)),
									function (leftCon) {
										return A2(
											$author$project$Extra$System$IO$Pure$bind,
											A3(
												$author$project$Compiler$Type$Constrain$Expression$constrain,
												rtv,
												rightExpr,
												A3(
													$author$project$Compiler$Reporting$Error$Type$FromContext,
													region,
													$author$project$Compiler$Reporting$Error$Type$OpRight(op),
													rightType)),
											function (rightCon) {
												return $author$project$Extra$System$IO$Pure$return(
													A2(
														$author$project$Compiler$Type$Type$exists,
														_List_fromArray(
															[leftVar, rightVar, answerVar]),
														$author$project$Compiler$Type$Type$CAnd(
															_List_fromArray(
																[
																	opCon,
																	leftCon,
																	rightCon,
																	A4(
																	$author$project$Compiler$Type$Type$CEqual,
																	region,
																	$author$project$Compiler$Reporting$Error$Type$CallResult(
																		$author$project$Compiler$Reporting$Error$Type$OpName(op)),
																	answerType,
																	expected)
																]))));
											});
									});
							});
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainCall = F5(
	function (rtv, region, func, args, expected) {
		var funcRegion = func.a;
		var maybeName = $author$project$Compiler$Type$Constrain$Expression$getName(func);
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (funcVar) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (resultVar) {
						var resultType = $author$project$Compiler$Type$Type$VarN(resultVar);
						var funcType = $author$project$Compiler$Type$Type$VarN(funcVar);
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3(
								$author$project$Compiler$Type$Constrain$Expression$constrain,
								rtv,
								func,
								$author$project$Compiler$Reporting$Error$Type$NoExpectation(funcType)),
							function (funcCon) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2(
										$author$project$Extra$System$IO$Pure$fmap,
										$author$project$Extra$Type$List$unzip3,
										A2(
											$author$project$Compiler$Type$Constrain$Expression$indexedForA,
											args,
											A3($author$project$Compiler$Type$Constrain$Expression$constrainArg, rtv, region, maybeName))),
									function (_v39) {
										var argVars = _v39.a;
										var argTypes = _v39.b;
										var argCons = _v39.c;
										var category = $author$project$Compiler$Reporting$Error$Type$CallResult(maybeName);
										var arityType = A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Type$Type$FunN, resultType, argTypes);
										return $author$project$Extra$System$IO$Pure$return(
											A2(
												$author$project$Compiler$Type$Type$exists,
												A2(
													$elm$core$List$cons,
													funcVar,
													A2($elm$core$List$cons, resultVar, argVars)),
												$author$project$Compiler$Type$Type$CAnd(
													_List_fromArray(
														[
															funcCon,
															A4(
															$author$project$Compiler$Type$Type$CEqual,
															funcRegion,
															category,
															funcType,
															A3(
																$author$project$Compiler$Reporting$Error$Type$FromContext,
																region,
																A2(
																	$author$project$Compiler$Reporting$Error$Type$CallArity,
																	maybeName,
																	$author$project$Extra$Type$List$length(args)),
																arityType)),
															$author$project$Compiler$Type$Type$CAnd(argCons),
															A4($author$project$Compiler$Type$Type$CEqual, region, category, resultType, expected)
														]))));
									});
							});
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainCase = F5(
	function (rtv, region, expr, branches, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (ptrnVar) {
				var ptrnType = $author$project$Compiler$Type$Type$VarN(ptrnVar);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Constrain$Expression$constrain,
						rtv,
						expr,
						$author$project$Compiler$Reporting$Error$Type$NoExpectation(ptrnType)),
					function (exprCon) {
						if (expected.$ === 'FromAnnotation') {
							var name = expected.a;
							var arity = expected.b;
							var tipe = expected.d;
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A2(
									$author$project$Compiler$Type$Constrain$Expression$indexedForA,
									branches,
									F2(
										function (index, branch) {
											return A4(
												$author$project$Compiler$Type$Constrain$Expression$constrainCaseBranch,
												rtv,
												branch,
												A3(
													$author$project$Compiler$Reporting$Error$Type$PFromContext,
													region,
													$author$project$Compiler$Reporting$Error$Type$PCaseMatch(index),
													ptrnType),
												A4(
													$author$project$Compiler$Reporting$Error$Type$FromAnnotation,
													name,
													arity,
													$author$project$Compiler$Reporting$Error$Type$TypedCaseBranch(index),
													tipe));
										})),
								function (branchCons) {
									return $author$project$Extra$System$IO$Pure$return(
										A2(
											$author$project$Compiler$Type$Type$exists,
											_List_fromArray(
												[ptrnVar]),
											$author$project$Compiler$Type$Type$CAnd(
												A2($elm$core$List$cons, exprCon, branchCons))));
								});
						} else {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Compiler$Type$Type$mkFlexVar,
								function (branchVar) {
									var branchType = $author$project$Compiler$Type$Type$VarN(branchVar);
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A2(
											$author$project$Compiler$Type$Constrain$Expression$indexedForA,
											branches,
											F2(
												function (index, branch) {
													return A4(
														$author$project$Compiler$Type$Constrain$Expression$constrainCaseBranch,
														rtv,
														branch,
														A3(
															$author$project$Compiler$Reporting$Error$Type$PFromContext,
															region,
															$author$project$Compiler$Reporting$Error$Type$PCaseMatch(index),
															ptrnType),
														A3(
															$author$project$Compiler$Reporting$Error$Type$FromContext,
															region,
															$author$project$Compiler$Reporting$Error$Type$CaseBranch(index),
															branchType));
												})),
										function (branchCons) {
											return $author$project$Extra$System$IO$Pure$return(
												A2(
													$author$project$Compiler$Type$Type$exists,
													_List_fromArray(
														[ptrnVar, branchVar]),
													$author$project$Compiler$Type$Type$CAnd(
														_List_fromArray(
															[
																exprCon,
																$author$project$Compiler$Type$Type$CAnd(branchCons),
																A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Case, branchType, expected)
															]))));
										});
								});
						}
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainCaseBranch = F4(
	function (rtv, _v36, pExpect, bExpect) {
		var pattern = _v36.a;
		var expr = _v36.b;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A3($author$project$Compiler$Type$Constrain$Pattern$add, pattern, pExpect, $author$project$Compiler$Type$Constrain$Pattern$emptyState),
			function (_v37) {
				var headers = _v37.a;
				var pvars = _v37.b;
				var revCons = _v37.c;
				return A2(
					$author$project$Extra$System$IO$Pure$fmap,
					A4(
						$author$project$Compiler$Type$Type$CLet,
						_List_Nil,
						pvars,
						headers,
						$author$project$Compiler$Type$Type$CAnd(
							$author$project$Extra$Type$List$reverse(revCons))),
					A3($author$project$Compiler$Type$Constrain$Expression$constrain, rtv, expr, bExpect));
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainDef = F3(
	function (rtv, def, bodyCon) {
		if (def.$ === 'Def') {
			var _v29 = def.a;
			var region = _v29.a;
			var name = _v29.b;
			var args = def.b;
			var expr = def.c;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$Constrain$Expression$constrainArgs(args),
				function (_v30) {
					var vars = _v30.a;
					var tipe = _v30.b;
					var resultType = _v30.c;
					var _v31 = _v30.d;
					var headers = _v31.a;
					var pvars = _v31.b;
					var revCons = _v31.c;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A3(
							$author$project$Compiler$Type$Constrain$Expression$constrain,
							rtv,
							expr,
							$author$project$Compiler$Reporting$Error$Type$NoExpectation(resultType)),
						function (exprCon) {
							return $author$project$Extra$System$IO$Pure$return(
								A5(
									$author$project$Compiler$Type$Type$CLet,
									_List_Nil,
									vars,
									A2(
										$author$project$Extra$Type$Map$singleton,
										name,
										A2($author$project$Compiler$Reporting$Annotation$At, region, tipe)),
									A5(
										$author$project$Compiler$Type$Type$CLet,
										_List_Nil,
										pvars,
										headers,
										$author$project$Compiler$Type$Type$CAnd(
											$author$project$Extra$Type$List$reverse(revCons)),
										exprCon),
									bodyCon));
						});
				});
		} else {
			var _v32 = def.a;
			var region = _v32.a;
			var name = _v32.b;
			var freeVars = def.b;
			var typedArgs = def.c;
			var expr = def.d;
			var srcResultType = def.e;
			var newNames = A2($author$project$Extra$Type$Map$difference, freeVars, rtv);
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2(
					$author$project$Extra$System$IO$Pure$traverseWithKey,
					F2(
						function (n, _v33) {
							return $author$project$Compiler$Type$Type$nameToRigid(n);
						}),
					newNames),
				function (newRigids) {
					var newRtv = A2(
						$author$project$Extra$Type$Map$union,
						rtv,
						A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Type$Type$VarN, newRigids));
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A4($author$project$Compiler$Type$Constrain$Expression$constrainTypedArgs, newRtv, name, typedArgs, srcResultType),
						function (_v34) {
							var tipe = _v34.a;
							var resultType = _v34.b;
							var _v35 = _v34.c;
							var headers = _v35.a;
							var pvars = _v35.b;
							var revCons = _v35.c;
							var expected = A4(
								$author$project$Compiler$Reporting$Error$Type$FromAnnotation,
								name,
								$author$project$Extra$Type$List$length(typedArgs),
								$author$project$Compiler$Reporting$Error$Type$TypedBody,
								resultType);
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A3($author$project$Compiler$Type$Constrain$Expression$constrain, newRtv, expr, expected),
								function (exprCon) {
									return $author$project$Extra$System$IO$Pure$return(
										A5(
											$author$project$Compiler$Type$Type$CLet,
											$author$project$Extra$Type$Map$elems(newRigids),
											_List_Nil,
											A2(
												$author$project$Extra$Type$Map$singleton,
												name,
												A2($author$project$Compiler$Reporting$Annotation$At, region, tipe)),
											A5(
												$author$project$Compiler$Type$Type$CLet,
												_List_Nil,
												pvars,
												headers,
												$author$project$Compiler$Type$Type$CAnd(
													$author$project$Extra$Type$List$reverse(revCons)),
												exprCon),
											bodyCon));
								});
						});
				});
		}
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainDestruct = F5(
	function (rtv, region, pattern, expr, bodyCon) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (patternVar) {
				var patternType = $author$project$Compiler$Type$Type$VarN(patternVar);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Constrain$Pattern$add,
						pattern,
						$author$project$Compiler$Reporting$Error$Type$PNoExpectation(patternType),
						$author$project$Compiler$Type$Constrain$Pattern$emptyState),
					function (_v27) {
						var headers = _v27.a;
						var pvars = _v27.b;
						var revCons = _v27.c;
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3(
								$author$project$Compiler$Type$Constrain$Expression$constrain,
								rtv,
								expr,
								A3($author$project$Compiler$Reporting$Error$Type$FromContext, region, $author$project$Compiler$Reporting$Error$Type$Destructure, patternType)),
							function (exprCon) {
								return $author$project$Extra$System$IO$Pure$return(
									A5(
										$author$project$Compiler$Type$Type$CLet,
										_List_Nil,
										A2($elm$core$List$cons, patternVar, pvars),
										headers,
										$author$project$Compiler$Type$Type$CAnd(
											$author$project$Extra$Type$List$reverse(
												A2($elm$core$List$cons, exprCon, revCons))),
										bodyCon));
							});
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainField = F2(
	function (rtv, expr) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (_var) {
				var tipe = $author$project$Compiler$Type$Type$VarN(_var);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Constrain$Expression$constrain,
						rtv,
						expr,
						$author$project$Compiler$Reporting$Error$Type$NoExpectation(tipe)),
					function (con) {
						return $author$project$Extra$System$IO$Pure$return(
							_Utils_Tuple3(_var, tipe, con));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainIf = F5(
	function (rtv, region, branches, _final, expected) {
		var boolExpect = A3($author$project$Compiler$Reporting$Error$Type$FromContext, region, $author$project$Compiler$Reporting$Error$Type$IfCondition, $author$project$Compiler$Type$Type$bool);
		var _v23 = A3(
			$author$project$Extra$Type$List$foldr,
			F2(
				function (_v24, _v25) {
					var c = _v24.a;
					var e = _v24.b;
					var cs = _v25.a;
					var es = _v25.b;
					return _Utils_Tuple2(
						A2($elm$core$List$cons, c, cs),
						A2($elm$core$List$cons, e, es));
				}),
			_Utils_Tuple2(
				_List_Nil,
				_List_fromArray(
					[_final])),
			branches);
		var conditions = _v23.a;
		var exprs = _v23.b;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A2(
				$author$project$Extra$System$IO$Pure$traverseList,
				function (c) {
					return A3($author$project$Compiler$Type$Constrain$Expression$constrain, rtv, c, boolExpect);
				},
				conditions),
			function (condCons) {
				if (expected.$ === 'FromAnnotation') {
					var name = expected.a;
					var arity = expected.b;
					var tipe = expected.d;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2(
							$author$project$Compiler$Type$Constrain$Expression$indexedForA,
							exprs,
							F2(
								function (index, expr) {
									return A3(
										$author$project$Compiler$Type$Constrain$Expression$constrain,
										rtv,
										expr,
										A4(
											$author$project$Compiler$Reporting$Error$Type$FromAnnotation,
											name,
											arity,
											$author$project$Compiler$Reporting$Error$Type$TypedIfBranch(index),
											tipe));
								})),
						function (branchCons) {
							return $author$project$Extra$System$IO$Pure$return(
								$author$project$Compiler$Type$Type$CAnd(
									_List_fromArray(
										[
											$author$project$Compiler$Type$Type$CAnd(condCons),
											$author$project$Compiler$Type$Type$CAnd(branchCons)
										])));
						});
				} else {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$Type$mkFlexVar,
						function (branchVar) {
							var branchType = $author$project$Compiler$Type$Type$VarN(branchVar);
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A2(
									$author$project$Compiler$Type$Constrain$Expression$indexedForA,
									exprs,
									F2(
										function (index, expr) {
											return A3(
												$author$project$Compiler$Type$Constrain$Expression$constrain,
												rtv,
												expr,
												A3(
													$author$project$Compiler$Reporting$Error$Type$FromContext,
													region,
													$author$project$Compiler$Reporting$Error$Type$IfBranch(index),
													branchType));
										})),
								function (branchCons) {
									return $author$project$Extra$System$IO$Pure$return(
										A2(
											$author$project$Compiler$Type$Type$exists,
											_List_fromArray(
												[branchVar]),
											$author$project$Compiler$Type$Type$CAnd(
												_List_fromArray(
													[
														$author$project$Compiler$Type$Type$CAnd(condCons),
														$author$project$Compiler$Type$Type$CAnd(branchCons),
														A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$If, branchType, expected)
													]))));
								});
						});
				}
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainLambda = F5(
	function (rtv, region, args, body, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Constrain$Expression$constrainArgs(args),
			function (_v21) {
				var vars = _v21.a;
				var tipe = _v21.b;
				var resultType = _v21.c;
				var _v22 = _v21.d;
				var headers = _v22.a;
				var pvars = _v22.b;
				var revCons = _v22.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Constrain$Expression$constrain,
						rtv,
						body,
						$author$project$Compiler$Reporting$Error$Type$NoExpectation(resultType)),
					function (bodyCon) {
						return $author$project$Extra$System$IO$Pure$return(
							A2(
								$author$project$Compiler$Type$Type$exists,
								vars,
								$author$project$Compiler$Type$Type$CAnd(
									_List_fromArray(
										[
											A5(
											$author$project$Compiler$Type$Type$CLet,
											_List_Nil,
											pvars,
											headers,
											$author$project$Compiler$Type$Type$CAnd(
												$author$project$Extra$Type$List$reverse(revCons)),
											bodyCon),
											A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Lambda, tipe, expected)
										]))));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainList = F4(
	function (rtv, region, entries, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (entryVar) {
				var entryType = $author$project$Compiler$Type$Type$VarN(entryVar);
				var listType = A3(
					$author$project$Compiler$Type$Type$AppN,
					$author$project$Compiler$Elm$ModuleName$list,
					$author$project$Compiler$Data$Name$list,
					_List_fromArray(
						[entryType]));
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Compiler$Type$Constrain$Expression$indexedForA,
						entries,
						A3($author$project$Compiler$Type$Constrain$Expression$constrainListEntry, rtv, region, entryType)),
					function (entryCons) {
						return $author$project$Extra$System$IO$Pure$return(
							A2(
								$author$project$Compiler$Type$Type$exists,
								_List_fromArray(
									[entryVar]),
								$author$project$Compiler$Type$Type$CAnd(
									_List_fromArray(
										[
											$author$project$Compiler$Type$Type$CAnd(entryCons),
											A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$CList, listType, expected)
										]))));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainListEntry = F5(
	function (rtv, region, tipe, index, expr) {
		return A3(
			$author$project$Compiler$Type$Constrain$Expression$constrain,
			rtv,
			expr,
			A3(
				$author$project$Compiler$Reporting$Error$Type$FromContext,
				region,
				$author$project$Compiler$Reporting$Error$Type$ListEntry(index),
				tipe));
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainRecord = F4(
	function (rtv, region, fields, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A2(
				$author$project$Extra$System$IO$Pure$traverseMap,
				$author$project$Compiler$Type$Constrain$Expression$constrainField(rtv),
				fields),
			function (dict) {
				var vars = A3(
					$author$project$Extra$Type$Map$foldr,
					F2(
						function (_v20, vs) {
							var v = _v20.a;
							return A2($elm$core$List$cons, v, vs);
						}),
					_List_Nil,
					dict);
				var getType = function (_v19) {
					var t = _v19.b;
					return t;
				};
				var recordType = A2(
					$author$project$Compiler$Type$Type$RecordN,
					A2($author$project$Extra$Type$Map$map, getType, dict),
					$author$project$Compiler$Type$Type$EmptyRecordN);
				var recordCon = A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Record, recordType, expected);
				var cons = A3(
					$author$project$Extra$Type$Map$foldr,
					F2(
						function (_v18, cs) {
							var c = _v18.c;
							return A2($elm$core$List$cons, c, cs);
						}),
					_List_fromArray(
						[recordCon]),
					dict);
				return $author$project$Extra$System$IO$Pure$return(
					A2(
						$author$project$Compiler$Type$Type$exists,
						vars,
						$author$project$Compiler$Type$Type$CAnd(cons)));
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainRecursiveDefs = F3(
	function (rtv, defs, bodyCon) {
		return A5($author$project$Compiler$Type$Constrain$Expression$recDefsHelp, rtv, defs, bodyCon, $author$project$Compiler$Type$Constrain$Expression$emptyInfo, $author$project$Compiler$Type$Constrain$Expression$emptyInfo);
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainTuple = F6(
	function (rtv, region, a, b, maybeC, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (aVar) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (bVar) {
						var bType = $author$project$Compiler$Type$Type$VarN(bVar);
						var aType = $author$project$Compiler$Type$Type$VarN(aVar);
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3(
								$author$project$Compiler$Type$Constrain$Expression$constrain,
								rtv,
								a,
								$author$project$Compiler$Reporting$Error$Type$NoExpectation(aType)),
							function (aCon) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A3(
										$author$project$Compiler$Type$Constrain$Expression$constrain,
										rtv,
										b,
										$author$project$Compiler$Reporting$Error$Type$NoExpectation(bType)),
									function (bCon) {
										if (maybeC.$ === 'Nothing') {
											var tupleType = A3($author$project$Compiler$Type$Type$TupleN, aType, bType, $elm$core$Maybe$Nothing);
											var tupleCon = A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Tuple, tupleType, expected);
											return $author$project$Extra$System$IO$Pure$return(
												A2(
													$author$project$Compiler$Type$Type$exists,
													_List_fromArray(
														[aVar, bVar]),
													$author$project$Compiler$Type$Type$CAnd(
														_List_fromArray(
															[aCon, bCon, tupleCon]))));
										} else {
											var c = maybeC.a;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												$author$project$Compiler$Type$Type$mkFlexVar,
												function (cVar) {
													var cType = $author$project$Compiler$Type$Type$VarN(cVar);
													return A2(
														$author$project$Extra$System$IO$Pure$bind,
														A3(
															$author$project$Compiler$Type$Constrain$Expression$constrain,
															rtv,
															c,
															$author$project$Compiler$Reporting$Error$Type$NoExpectation(cType)),
														function (cCon) {
															var tupleType = A3(
																$author$project$Compiler$Type$Type$TupleN,
																aType,
																bType,
																$elm$core$Maybe$Just(cType));
															var tupleCon = A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Tuple, tupleType, expected);
															return $author$project$Extra$System$IO$Pure$return(
																A2(
																	$author$project$Compiler$Type$Type$exists,
																	_List_fromArray(
																		[aVar, bVar, cVar]),
																	$author$project$Compiler$Type$Type$CAnd(
																		_List_fromArray(
																			[aCon, bCon, cCon, tupleCon]))));
														});
												});
										}
									});
							});
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainUpdate = F6(
	function (rtv, region, name, expr, fields, expected) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (extVar) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$traverseWithKey,
						A2($author$project$Compiler$Type$Constrain$Expression$constrainUpdateField, rtv, region),
						fields),
					function (fieldDict) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$Type$mkFlexVar,
							function (recordVar) {
								var vars = A3(
									$author$project$Extra$Type$Map$foldr,
									F2(
										function (_v16, vs) {
											var v = _v16.a;
											return A2($elm$core$List$cons, v, vs);
										}),
									_List_fromArray(
										[recordVar, extVar]),
									fieldDict);
								var recordType = $author$project$Compiler$Type$Type$VarN(recordVar);
								var recordCon = A4($author$project$Compiler$Type$Type$CEqual, region, $author$project$Compiler$Reporting$Error$Type$Record, recordType, expected);
								var fieldsType = A2(
									$author$project$Compiler$Type$Type$RecordN,
									A2(
										$author$project$Extra$Type$Map$map,
										function (_v15) {
											var t = _v15.b;
											return t;
										},
										fieldDict),
									$author$project$Compiler$Type$Type$VarN(extVar));
								var fieldsCon = A4(
									$author$project$Compiler$Type$Type$CEqual,
									region,
									$author$project$Compiler$Reporting$Error$Type$Record,
									recordType,
									$author$project$Compiler$Reporting$Error$Type$NoExpectation(fieldsType));
								var cons = A3(
									$author$project$Extra$Type$Map$foldr,
									F2(
										function (_v14, cs) {
											var c = _v14.c;
											return A2($elm$core$List$cons, c, cs);
										}),
									_List_fromArray(
										[recordCon]),
									fieldDict);
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A3(
										$author$project$Compiler$Type$Constrain$Expression$constrain,
										rtv,
										expr,
										A3(
											$author$project$Compiler$Reporting$Error$Type$FromContext,
											region,
											A2($author$project$Compiler$Reporting$Error$Type$RecordUpdateKeys, name, fields),
											recordType)),
									function (con) {
										return $author$project$Extra$System$IO$Pure$return(
											A2(
												$author$project$Compiler$Type$Type$exists,
												vars,
												$author$project$Compiler$Type$Type$CAnd(
													A2(
														$elm$core$List$cons,
														fieldsCon,
														A2($elm$core$List$cons, con, cons)))));
									});
							});
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$constrainUpdateField = F4(
	function (rtv, region, field, _v13) {
		var expr = _v13.b;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (_var) {
				var tipe = $author$project$Compiler$Type$Type$VarN(_var);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Constrain$Expression$constrain,
						rtv,
						expr,
						A3(
							$author$project$Compiler$Reporting$Error$Type$FromContext,
							region,
							$author$project$Compiler$Reporting$Error$Type$RecordUpdateValue(field),
							tipe)),
					function (con) {
						return $author$project$Extra$System$IO$Pure$return(
							_Utils_Tuple3(_var, tipe, con));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Expression$recDefsHelp = F5(
	function (rtv, defs, bodyCon, rigidInfo, flexInfo) {
		if (!defs.b) {
			var _v1 = rigidInfo;
			var rigidVars = _v1.a;
			var rigidCons = _v1.b;
			var rigidHeaders = _v1.c;
			var _v2 = flexInfo;
			var flexVars = _v2.a;
			var flexCons = _v2.b;
			var flexHeaders = _v2.c;
			return $author$project$Extra$System$IO$Pure$return(
				A5(
					$author$project$Compiler$Type$Type$CLet,
					rigidVars,
					_List_Nil,
					rigidHeaders,
					$author$project$Compiler$Type$Type$CTrue,
					A5(
						$author$project$Compiler$Type$Type$CLet,
						_List_Nil,
						flexVars,
						flexHeaders,
						A5(
							$author$project$Compiler$Type$Type$CLet,
							_List_Nil,
							_List_Nil,
							flexHeaders,
							$author$project$Compiler$Type$Type$CTrue,
							$author$project$Compiler$Type$Type$CAnd(flexCons)),
						$author$project$Compiler$Type$Type$CAnd(
							_List_fromArray(
								[
									$author$project$Compiler$Type$Type$CAnd(rigidCons),
									bodyCon
								])))));
		} else {
			var def = defs.a;
			var otherDefs = defs.b;
			if (def.$ === 'Def') {
				var _v4 = def.a;
				var region = _v4.a;
				var name = _v4.b;
				var args = def.b;
				var expr = def.c;
				var _v5 = flexInfo;
				var flexVars = _v5.a;
				var flexCons = _v5.b;
				var flexHeaders = _v5.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Compiler$Type$Constrain$Expression$argsHelp,
						args,
						A3($author$project$Compiler$Type$Constrain$Pattern$State, $author$project$Extra$Type$Map$empty, flexVars, _List_Nil)),
					function (_v6) {
						var newFlexVars = _v6.a;
						var tipe = _v6.b;
						var resultType = _v6.c;
						var _v7 = _v6.d;
						var headers = _v7.a;
						var pvars = _v7.b;
						var revCons = _v7.c;
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3(
								$author$project$Compiler$Type$Constrain$Expression$constrain,
								rtv,
								expr,
								$author$project$Compiler$Reporting$Error$Type$NoExpectation(resultType)),
							function (exprCon) {
								var defCon = A5(
									$author$project$Compiler$Type$Type$CLet,
									_List_Nil,
									pvars,
									headers,
									$author$project$Compiler$Type$Type$CAnd(
										$author$project$Extra$Type$List$reverse(revCons)),
									exprCon);
								return A5(
									$author$project$Compiler$Type$Constrain$Expression$recDefsHelp,
									rtv,
									otherDefs,
									bodyCon,
									rigidInfo,
									A3(
										$author$project$Compiler$Type$Constrain$Expression$Info,
										newFlexVars,
										A2($elm$core$List$cons, defCon, flexCons),
										A3(
											$author$project$Extra$Type$Map$insert,
											name,
											A2($author$project$Compiler$Reporting$Annotation$At, region, tipe),
											flexHeaders)));
							});
					});
			} else {
				var _v8 = def.a;
				var region = _v8.a;
				var name = _v8.b;
				var freeVars = def.b;
				var typedArgs = def.c;
				var expr = def.d;
				var srcResultType = def.e;
				var newNames = A2($author$project$Extra$Type$Map$difference, freeVars, rtv);
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$traverseWithKey,
						F2(
							function (n, _v9) {
								return $author$project$Compiler$Type$Type$nameToRigid(n);
							}),
						newNames),
					function (newRigids) {
						var newRtv = A2(
							$author$project$Extra$Type$Map$union,
							rtv,
							A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Type$Type$VarN, newRigids));
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A4($author$project$Compiler$Type$Constrain$Expression$constrainTypedArgs, newRtv, name, typedArgs, srcResultType),
							function (_v10) {
								var tipe = _v10.a;
								var resultType = _v10.b;
								var _v11 = _v10.c;
								var headers = _v11.a;
								var pvars = _v11.b;
								var revCons = _v11.c;
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A3(
										$author$project$Compiler$Type$Constrain$Expression$constrain,
										newRtv,
										expr,
										A4(
											$author$project$Compiler$Reporting$Error$Type$FromAnnotation,
											name,
											$author$project$Extra$Type$List$length(typedArgs),
											$author$project$Compiler$Reporting$Error$Type$TypedBody,
											resultType)),
									function (exprCon) {
										var defCon = A5(
											$author$project$Compiler$Type$Type$CLet,
											_List_Nil,
											pvars,
											headers,
											$author$project$Compiler$Type$Type$CAnd(
												$author$project$Extra$Type$List$reverse(revCons)),
											exprCon);
										var _v12 = rigidInfo;
										var rigidVars = _v12.a;
										var rigidCons = _v12.b;
										var rigidHeaders = _v12.c;
										return A5(
											$author$project$Compiler$Type$Constrain$Expression$recDefsHelp,
											rtv,
											otherDefs,
											bodyCon,
											A3(
												$author$project$Compiler$Type$Constrain$Expression$Info,
												A3($author$project$Extra$Type$Map$foldr, $elm$core$List$cons, rigidVars, newRigids),
												A2(
													$elm$core$List$cons,
													A5(
														$author$project$Compiler$Type$Type$CLet,
														$author$project$Extra$Type$Map$elems(newRigids),
														_List_Nil,
														$author$project$Extra$Type$Map$empty,
														defCon,
														$author$project$Compiler$Type$Type$CTrue),
													rigidCons),
												A3(
													$author$project$Extra$Type$Map$insert,
													name,
													A2($author$project$Compiler$Reporting$Annotation$At, region, tipe),
													rigidHeaders)),
											flexInfo);
									});
							});
					});
			}
		}
	});
var $author$project$Compiler$Type$Constrain$Module$constrainDeclsHelp = F3(
	function (decls, finalConstraint, cont) {
		constrainDeclsHelp:
		while (true) {
			switch (decls.$) {
				case 'Declare':
					var def = decls.a;
					var otherDecls = decls.b;
					var $temp$decls = otherDecls,
						$temp$finalConstraint = finalConstraint,
						$temp$cont = A2(
						$elm$core$Basics$composeR,
						$author$project$Extra$System$IO$Pure$andThen(
							A2($author$project$Compiler$Type$Constrain$Expression$constrainDef, $author$project$Extra$Type$Map$empty, def)),
						cont);
					decls = $temp$decls;
					finalConstraint = $temp$finalConstraint;
					cont = $temp$cont;
					continue constrainDeclsHelp;
				case 'DeclareRec':
					var def = decls.a;
					var defs = decls.b;
					var otherDecls = decls.c;
					var $temp$decls = otherDecls,
						$temp$finalConstraint = finalConstraint,
						$temp$cont = A2(
						$elm$core$Basics$composeR,
						$author$project$Extra$System$IO$Pure$andThen(
							A2(
								$author$project$Compiler$Type$Constrain$Expression$constrainRecursiveDefs,
								$author$project$Extra$Type$Map$empty,
								A2($elm$core$List$cons, def, defs))),
						cont);
					decls = $temp$decls;
					finalConstraint = $temp$finalConstraint;
					cont = $temp$cont;
					continue constrainDeclsHelp;
				default:
					return cont(
						$author$project$Extra$System$IO$Pure$return(finalConstraint));
			}
		}
	});
var $author$project$Compiler$Type$Constrain$Module$constrainDecls = F2(
	function (decls, finalConstraint) {
		return A3($author$project$Compiler$Type$Constrain$Module$constrainDeclsHelp, decls, finalConstraint, $elm$core$Basics$identity);
	});
var $author$project$Compiler$Reporting$Error$Type$Effects = {$: 'Effects'};
var $author$project$Compiler$Type$Constrain$Module$toMapType = F4(
	function (home, tipe, a, b) {
		return A2(
			$author$project$Compiler$Type$Type$FunN,
			A2($author$project$Compiler$Type$Type$FunN, a, b),
			A2(
				$author$project$Compiler$Type$Type$FunN,
				A3(
					$author$project$Compiler$Type$Type$AppN,
					home,
					tipe,
					_List_fromArray(
						[a])),
				A3(
					$author$project$Compiler$Type$Type$AppN,
					home,
					tipe,
					_List_fromArray(
						[b]))));
	});
var $author$project$Compiler$Reporting$Annotation$zero = A2(
	$author$project$Compiler$Reporting$Annotation$Region,
	A2($author$project$Compiler$Reporting$Annotation$Position, 0, 0),
	A2($author$project$Compiler$Reporting$Annotation$Position, 0, 0));
var $author$project$Compiler$Type$Constrain$Module$checkMap = F4(
	function (name, home, tipe, constraint) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (a) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (b) {
						var mapType = A4(
							$author$project$Compiler$Type$Constrain$Module$toMapType,
							home,
							tipe,
							$author$project$Compiler$Type$Type$VarN(a),
							$author$project$Compiler$Type$Type$VarN(b));
						var mapCon = A3(
							$author$project$Compiler$Type$Type$CLocal,
							$author$project$Compiler$Reporting$Annotation$zero,
							name,
							$author$project$Compiler$Reporting$Error$Type$NoExpectation(mapType));
						return $author$project$Extra$System$IO$Pure$return(
							A5(
								$author$project$Compiler$Type$Type$CLet,
								_List_fromArray(
									[a, b]),
								_List_Nil,
								$author$project$Extra$Type$Map$empty,
								mapCon,
								constraint));
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Module$effectList = F3(
	function (home, name, msg) {
		return A3(
			$author$project$Compiler$Type$Type$AppN,
			$author$project$Compiler$Elm$ModuleName$list,
			$author$project$Compiler$Data$Name$list,
			_List_fromArray(
				[
					A3(
					$author$project$Compiler$Type$Type$AppN,
					home,
					name,
					_List_fromArray(
						[msg]))
				]));
	});
var $author$project$Compiler$Data$Name$router = 'Router';
var $author$project$Compiler$Type$Constrain$Module$router = F2(
	function (msg, self) {
		return A3(
			$author$project$Compiler$Type$Type$AppN,
			$author$project$Compiler$Elm$ModuleName$platform,
			$author$project$Compiler$Data$Name$router,
			_List_fromArray(
				[msg, self]));
	});
var $author$project$Compiler$Type$Type$never = A3($author$project$Compiler$Type$Type$AppN, $author$project$Compiler$Elm$ModuleName$basics, 'Never', _List_Nil);
var $author$project$Compiler$Data$Name$task = 'Task';
var $author$project$Compiler$Type$Constrain$Module$task = function (answer) {
	return A3(
		$author$project$Compiler$Type$Type$AppN,
		$author$project$Compiler$Elm$ModuleName$platform,
		$author$project$Compiler$Data$Name$task,
		_List_fromArray(
			[$author$project$Compiler$Type$Type$never, answer]));
};
var $author$project$Compiler$Type$Constrain$Module$constrainEffects = F5(
	function (home, r0, r1, r2, manager) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (s0) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$mkFlexVar,
					function (s1) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$Type$mkFlexVar,
							function (s2) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									$author$project$Compiler$Type$Type$mkFlexVar,
									function (m1) {
										return A2(
											$author$project$Extra$System$IO$Pure$bind,
											$author$project$Compiler$Type$Type$mkFlexVar,
											function (m2) {
												return A2(
													$author$project$Extra$System$IO$Pure$bind,
													$author$project$Compiler$Type$Type$mkFlexVar,
													function (sm1) {
														return A2(
															$author$project$Extra$System$IO$Pure$bind,
															$author$project$Compiler$Type$Type$mkFlexVar,
															function (sm2) {
																var state2 = $author$project$Compiler$Type$Type$VarN(s2);
																var state1 = $author$project$Compiler$Type$Type$VarN(s1);
																var state0 = $author$project$Compiler$Type$Type$VarN(s0);
																var self2 = $author$project$Compiler$Type$Type$VarN(sm2);
																var self1 = $author$project$Compiler$Type$Type$VarN(sm1);
																var msg2 = $author$project$Compiler$Type$Type$VarN(m2);
																var onSelfMsg = A2(
																	$author$project$Compiler$Type$Type$FunN,
																	A2($author$project$Compiler$Type$Constrain$Module$router, msg2, self2),
																	A2(
																		$author$project$Compiler$Type$Type$FunN,
																		self2,
																		A2(
																			$author$project$Compiler$Type$Type$FunN,
																			state2,
																			$author$project$Compiler$Type$Constrain$Module$task(state2))));
																var msg1 = $author$project$Compiler$Type$Type$VarN(m1);
																var onEffects = function () {
																	switch (manager.$) {
																		case 'CCmd':
																			var cmd = manager.a;
																			return A2(
																				$author$project$Compiler$Type$Type$FunN,
																				A2($author$project$Compiler$Type$Constrain$Module$router, msg1, self1),
																				A2(
																					$author$project$Compiler$Type$Type$FunN,
																					A3($author$project$Compiler$Type$Constrain$Module$effectList, home, cmd, msg1),
																					A2(
																						$author$project$Compiler$Type$Type$FunN,
																						state1,
																						$author$project$Compiler$Type$Constrain$Module$task(state1))));
																		case 'CSub':
																			var sub = manager.a;
																			return A2(
																				$author$project$Compiler$Type$Type$FunN,
																				A2($author$project$Compiler$Type$Constrain$Module$router, msg1, self1),
																				A2(
																					$author$project$Compiler$Type$Type$FunN,
																					A3($author$project$Compiler$Type$Constrain$Module$effectList, home, sub, msg1),
																					A2(
																						$author$project$Compiler$Type$Type$FunN,
																						state1,
																						$author$project$Compiler$Type$Constrain$Module$task(state1))));
																		default:
																			var cmd = manager.a;
																			var sub = manager.b;
																			return A2(
																				$author$project$Compiler$Type$Type$FunN,
																				A2($author$project$Compiler$Type$Constrain$Module$router, msg1, self1),
																				A2(
																					$author$project$Compiler$Type$Type$FunN,
																					A3($author$project$Compiler$Type$Constrain$Module$effectList, home, cmd, msg1),
																					A2(
																						$author$project$Compiler$Type$Type$FunN,
																						A3($author$project$Compiler$Type$Constrain$Module$effectList, home, sub, msg1),
																						A2(
																							$author$project$Compiler$Type$Type$FunN,
																							state1,
																							$author$project$Compiler$Type$Constrain$Module$task(state1)))));
																	}
																}();
																var effectCons = $author$project$Compiler$Type$Type$CAnd(
																	_List_fromArray(
																		[
																			A3(
																			$author$project$Compiler$Type$Type$CLocal,
																			r0,
																			'init',
																			$author$project$Compiler$Reporting$Error$Type$NoExpectation(
																				$author$project$Compiler$Type$Constrain$Module$task(state0))),
																			A3(
																			$author$project$Compiler$Type$Type$CLocal,
																			r1,
																			'onEffects',
																			$author$project$Compiler$Reporting$Error$Type$NoExpectation(onEffects)),
																			A3(
																			$author$project$Compiler$Type$Type$CLocal,
																			r2,
																			'onSelfMsg',
																			$author$project$Compiler$Reporting$Error$Type$NoExpectation(onSelfMsg)),
																			A4(
																			$author$project$Compiler$Type$Type$CEqual,
																			r1,
																			$author$project$Compiler$Reporting$Error$Type$Effects,
																			state0,
																			$author$project$Compiler$Reporting$Error$Type$NoExpectation(state1)),
																			A4(
																			$author$project$Compiler$Type$Type$CEqual,
																			r2,
																			$author$project$Compiler$Reporting$Error$Type$Effects,
																			state0,
																			$author$project$Compiler$Reporting$Error$Type$NoExpectation(state2)),
																			A4(
																			$author$project$Compiler$Type$Type$CEqual,
																			r2,
																			$author$project$Compiler$Reporting$Error$Type$Effects,
																			self1,
																			$author$project$Compiler$Reporting$Error$Type$NoExpectation(self2))
																		]));
																return A2(
																	$author$project$Extra$System$IO$Pure$fmap,
																	A4(
																		$author$project$Compiler$Type$Type$CLet,
																		_List_Nil,
																		_List_fromArray(
																			[s0, s1, s2, m1, m2, sm1, sm2]),
																		$author$project$Extra$Type$Map$empty,
																		effectCons),
																	function () {
																		switch (manager.$) {
																			case 'CCmd':
																				var cmd = manager.a;
																				return A4($author$project$Compiler$Type$Constrain$Module$checkMap, 'cmdMap', home, cmd, $author$project$Compiler$Type$Type$CSaveTheEnvironment);
																			case 'CSub':
																				var sub = manager.a;
																				return A4($author$project$Compiler$Type$Constrain$Module$checkMap, 'subMap', home, sub, $author$project$Compiler$Type$Type$CSaveTheEnvironment);
																			default:
																				var cmd = manager.a;
																				var sub = manager.b;
																				return A2(
																					$author$project$Extra$System$IO$Pure$andThen,
																					A3($author$project$Compiler$Type$Constrain$Module$checkMap, 'cmdMap', home, cmd),
																					A4($author$project$Compiler$Type$Constrain$Module$checkMap, 'subMap', home, sub, $author$project$Compiler$Type$Type$CSaveTheEnvironment));
																		}
																	}());
															});
													});
											});
									});
							});
					});
			});
	});
var $author$project$Compiler$Type$Constrain$Module$letCmd = F3(
	function (home, tipe, constraint) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (msgVar) {
				var msg = $author$project$Compiler$Type$Type$VarN(msgVar);
				var cmdType = A2(
					$author$project$Compiler$Type$Type$FunN,
					A3(
						$author$project$Compiler$Type$Type$AppN,
						home,
						tipe,
						_List_fromArray(
							[msg])),
					A3(
						$author$project$Compiler$Type$Type$AppN,
						$author$project$Compiler$Elm$ModuleName$cmd,
						$author$project$Compiler$Data$Name$cmd,
						_List_fromArray(
							[msg])));
				var header = A2(
					$author$project$Extra$Type$Map$singleton,
					'command',
					A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, cmdType));
				return $author$project$Extra$System$IO$Pure$return(
					A5(
						$author$project$Compiler$Type$Type$CLet,
						_List_fromArray(
							[msgVar]),
						_List_Nil,
						header,
						$author$project$Compiler$Type$Type$CTrue,
						constraint));
			});
	});
var $author$project$Compiler$Type$Constrain$Module$letPort = F3(
	function (name, port_, makeConstraint) {
		if (port_.$ === 'Incoming') {
			var freeVars = port_.a;
			var srcType = port_.c;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2(
					$author$project$Extra$System$IO$Pure$traverseWithKey,
					F2(
						function (k, _v1) {
							return $author$project$Compiler$Type$Type$nameToRigid(k);
						}),
					freeVars),
				function (vars) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2(
							$author$project$Compiler$Type$Instantiate$fromSrcType,
							A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Type$Type$VarN, vars),
							srcType),
						function (tipe) {
							var header = A2(
								$author$project$Extra$Type$Map$singleton,
								name,
								A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, tipe));
							return A2(
								$author$project$Extra$System$IO$Pure$fmap,
								A4(
									$author$project$Compiler$Type$Type$CLet,
									$author$project$Extra$Type$Map$elems(vars),
									_List_Nil,
									header,
									$author$project$Compiler$Type$Type$CTrue),
								makeConstraint);
						});
				});
		} else {
			var freeVars = port_.a;
			var srcType = port_.c;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2(
					$author$project$Extra$System$IO$Pure$traverseWithKey,
					F2(
						function (k, _v2) {
							return $author$project$Compiler$Type$Type$nameToRigid(k);
						}),
					freeVars),
				function (vars) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2(
							$author$project$Compiler$Type$Instantiate$fromSrcType,
							A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Type$Type$VarN, vars),
							srcType),
						function (tipe) {
							var header = A2(
								$author$project$Extra$Type$Map$singleton,
								name,
								A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, tipe));
							return A2(
								$author$project$Extra$System$IO$Pure$fmap,
								A4(
									$author$project$Compiler$Type$Type$CLet,
									$author$project$Extra$Type$Map$elems(vars),
									_List_Nil,
									header,
									$author$project$Compiler$Type$Type$CTrue),
								makeConstraint);
						});
				});
		}
	});
var $author$project$Compiler$Type$Constrain$Module$letSub = F3(
	function (home, tipe, constraint) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Type$mkFlexVar,
			function (msgVar) {
				var msg = $author$project$Compiler$Type$Type$VarN(msgVar);
				var subType = A2(
					$author$project$Compiler$Type$Type$FunN,
					A3(
						$author$project$Compiler$Type$Type$AppN,
						home,
						tipe,
						_List_fromArray(
							[msg])),
					A3(
						$author$project$Compiler$Type$Type$AppN,
						$author$project$Compiler$Elm$ModuleName$sub,
						$author$project$Compiler$Data$Name$sub,
						_List_fromArray(
							[msg])));
				var header = A2(
					$author$project$Extra$Type$Map$singleton,
					'subscription',
					A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, subType));
				return $author$project$Extra$System$IO$Pure$return(
					A5(
						$author$project$Compiler$Type$Type$CLet,
						_List_fromArray(
							[msgVar]),
						_List_Nil,
						header,
						$author$project$Compiler$Type$Type$CTrue,
						constraint));
			});
	});
var $author$project$Compiler$Type$Constrain$Module$constrain = function (_v0) {
	var home = _v0.a;
	var decls = _v0.c;
	var effects = _v0.g;
	switch (effects.$) {
		case 'NoEffects':
			return A2($author$project$Compiler$Type$Constrain$Module$constrainDecls, decls, $author$project$Compiler$Type$Type$CSaveTheEnvironment);
		case 'Ports':
			var ports = effects.a;
			return A3(
				$author$project$Extra$Type$Map$foldrWithKey,
				$author$project$Compiler$Type$Constrain$Module$letPort,
				A2($author$project$Compiler$Type$Constrain$Module$constrainDecls, decls, $author$project$Compiler$Type$Type$CSaveTheEnvironment),
				ports);
		default:
			var r0 = effects.a;
			var r1 = effects.b;
			var r2 = effects.c;
			var manager = effects.d;
			switch (manager.$) {
				case 'CCmd':
					var cmdName = manager.a;
					return A2(
						$author$project$Extra$System$IO$Pure$andThen,
						A2($author$project$Compiler$Type$Constrain$Module$letCmd, home, cmdName),
						A2(
							$author$project$Extra$System$IO$Pure$andThen,
							$author$project$Compiler$Type$Constrain$Module$constrainDecls(decls),
							A5($author$project$Compiler$Type$Constrain$Module$constrainEffects, home, r0, r1, r2, manager)));
				case 'CSub':
					var subName = manager.a;
					return A2(
						$author$project$Extra$System$IO$Pure$andThen,
						A2($author$project$Compiler$Type$Constrain$Module$letSub, home, subName),
						A2(
							$author$project$Extra$System$IO$Pure$andThen,
							$author$project$Compiler$Type$Constrain$Module$constrainDecls(decls),
							A5($author$project$Compiler$Type$Constrain$Module$constrainEffects, home, r0, r1, r2, manager)));
				default:
					var cmdName = manager.a;
					var subName = manager.b;
					return A2(
						$author$project$Extra$System$IO$Pure$andThen,
						A2($author$project$Compiler$Type$Constrain$Module$letCmd, home, cmdName),
						A2(
							$author$project$Extra$System$IO$Pure$andThen,
							A2($author$project$Compiler$Type$Constrain$Module$letSub, home, subName),
							A2(
								$author$project$Extra$System$IO$Pure$andThen,
								$author$project$Compiler$Type$Constrain$Module$constrainDecls(decls),
								A5($author$project$Compiler$Type$Constrain$Module$constrainEffects, home, r0, r1, r2, manager))));
			}
	}
};
var $author$project$Extra$System$IORef$init = _Utils_Tuple2(0, $author$project$Extra$Type$Map$empty);
var $author$project$Compiler$Type$UnionFind$init = _Utils_Tuple3($author$project$Extra$System$IORef$init, $author$project$Extra$System$IORef$init, $author$project$Extra$System$IORef$init);
var $author$project$Compiler$Type$Type$init = $author$project$Compiler$Type$UnionFind$init;
var $author$project$Extra$System$MVector$init = _Utils_Tuple3(0, $author$project$Extra$Type$Map$empty, $author$project$Extra$System$IORef$init);
var $author$project$Compiler$Type$Solve$init = _Utils_Tuple2($author$project$Compiler$Type$Type$init, $author$project$Extra$System$MVector$init);
var $author$project$Extra$System$IO$Pure$performIO = F2(
	function (ma, s) {
		return ma(s).a;
	});
var $author$project$Compiler$Type$Solve$State = F3(
	function (a, b, c) {
		return {$: 'State', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Type$nextMark = function (_v0) {
	var mark = _v0.a;
	return $author$project$Compiler$Type$Type$Mark(mark + 1);
};
var $author$project$Compiler$Type$Solve$emptyState = A3(
	$author$project$Compiler$Type$Solve$State,
	$author$project$Extra$Type$Map$empty,
	$author$project$Compiler$Type$Type$nextMark($author$project$Compiler$Type$Type$noMark),
	_List_Nil);
var $author$project$Compiler$Type$Solve$liftP = A2(
	$author$project$Extra$System$IO$Pure$liftS,
	function (_v0) {
		var x = _v0.b;
		return x;
	},
	F2(
		function (x, _v1) {
			var a = _v1.a;
			return _Utils_Tuple2(a, x);
		}));
var $author$project$Compiler$Type$Type$outermostRank = 1;
var $author$project$Extra$System$MVector$MVector = F2(
	function (a, b) {
		return {$: 'MVector', a: a, b: b};
	});
var $author$project$Extra$System$MVector$replicate = F3(
	function (n, a, _v0) {
		var nextId = _v0.a;
		var map = _v0.b;
		var refState = _v0.c;
		var go = F2(
			function (i, vecIO) {
				go:
				while (true) {
					if (_Utils_cmp(i, n) < 0) {
						var $temp$i = i + 1,
							$temp$vecIO = A3(
							$author$project$Extra$System$IO$Pure$liftA2,
							$author$project$Extra$Type$Map$insert(i),
							$author$project$Extra$System$IORef$new(a),
							vecIO);
						i = $temp$i;
						vecIO = $temp$vecIO;
						continue go;
					} else {
						return vecIO;
					}
				}
			});
		var _v1 = A3(
			go,
			0,
			$author$project$Extra$System$IO$Pure$pure($author$project$Extra$Type$Map$empty),
			refState);
		var vec = _v1.a;
		var nextRefState = _v1.b;
		return _Utils_Tuple2(
			A2($author$project$Extra$System$MVector$MVector, nextId, n),
			_Utils_Tuple3(
				nextId + 1,
				A3($author$project$Extra$Type$Map$insert, nextId, vec, map),
				nextRefState));
	});
var $author$project$Compiler$Reporting$Error$Type$BadExpr = F4(
	function (a, b, c, d) {
		return {$: 'BadExpr', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Type$BadPattern = F4(
	function (a, b, c, d) {
		return {$: 'BadPattern', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Type$Foreign = function (a) {
	return {$: 'Foreign', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$Local = function (a) {
	return {$: 'Local', a: a};
};
var $author$project$Compiler$Type$Solve$addError = F2(
	function (_v0, err) {
		var savedEnv = _v0.a;
		var rank = _v0.b;
		var errors = _v0.c;
		return A3(
			$author$project$Compiler$Type$Solve$State,
			savedEnv,
			rank,
			A2($elm$core$List$cons, err, errors));
	});
var $author$project$Compiler$Type$Type$Alias = F4(
	function (a, b, c, d) {
		return {$: 'Alias', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Type$App1 = F3(
	function (a, b, c) {
		return {$: 'App1', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Type$Fun1 = F2(
	function (a, b) {
		return {$: 'Fun1', a: a, b: b};
	});
var $author$project$Compiler$Type$Type$Record1 = F2(
	function (a, b) {
		return {$: 'Record1', a: a, b: b};
	});
var $author$project$Compiler$Type$Type$Structure = function (a) {
	return {$: 'Structure', a: a};
};
var $author$project$Compiler$Type$Type$Tuple1 = F3(
	function (a, b, c) {
		return {$: 'Tuple1', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Type$EmptyRecord1 = {$: 'EmptyRecord1'};
var $author$project$Compiler$Type$Solve$emptyRecord1 = $author$project$Compiler$Type$Type$Structure($author$project$Compiler$Type$Type$EmptyRecord1);
var $author$project$Extra$System$MVector$getRef = F3(
	function (id, i, map) {
		return A2(
			$elm$core$Maybe$andThen,
			function (vec) {
				return A2($author$project$Extra$Type$Map$lookup, i, vec);
			},
			A2($author$project$Extra$Type$Map$lookup, id, map));
	});
var $author$project$Extra$System$MVector$liftResult = F3(
	function (nextId, map, _v0) {
		var a = _v0.a;
		var refState = _v0.b;
		return _Utils_Tuple2(
			a,
			_Utils_Tuple3(nextId, map, refState));
	});
var $author$project$Extra$System$IORef$read = F2(
	function (_v0, state) {
		var id = _v0.a;
		var map = state.b;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, id, map);
		if (_v1.$ === 'Just') {
			var a = _v1.a;
			return _Utils_Tuple2(a, state);
		} else {
			return _Debug_todo(
				'Extra.System.IORef',
				{
					start: {line: 47, column: 13},
					end: {line: 47, column: 23}
				})('IORef.read: id not found');
		}
	});
var $author$project$Extra$System$IORef$write = F3(
	function (_v0, a, _v1) {
		var id = _v0.a;
		var nextId = _v1.a;
		var map = _v1.b;
		return _Utils_Tuple2(
			_Utils_Tuple0,
			_Utils_Tuple2(
				nextId,
				A3($author$project$Extra$Type$Map$insert, id, a, map)));
	});
var $author$project$Extra$System$IORef$modify = F3(
	function (ref, f, state) {
		var _v0 = A2($author$project$Extra$System$IORef$read, ref, state);
		var a = _v0.a;
		var state_ = _v0.b;
		return A3(
			$author$project$Extra$System$IORef$write,
			ref,
			f(a),
			state_);
	});
var $author$project$Extra$System$MVector$modify = F4(
	function (_v0, f, i, state) {
		var id = _v0.a;
		var nextId = state.a;
		var map = state.b;
		var refState = state.c;
		var _v1 = A3($author$project$Extra$System$MVector$getRef, id, i, map);
		if (_v1.$ === 'Just') {
			var ref = _v1.a;
			return A3(
				$author$project$Extra$System$MVector$liftResult,
				nextId,
				map,
				A3($author$project$Extra$System$IORef$modify, ref, f, refState));
		} else {
			return _Utils_Tuple2(_Utils_Tuple0, state);
		}
	});
var $author$project$Compiler$Type$Solve$register = F3(
	function (rank, pools, content) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$fresh(
				A4($author$project$Compiler$Type$Type$Descriptor, content, rank, $author$project$Compiler$Type$Type$noMark, $elm$core$Maybe$Nothing)),
			function (_var) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Solve$liftP(
						A3(
							$author$project$Extra$System$MVector$modify,
							pools,
							function (l) {
								return A2($elm$core$List$cons, _var, l);
							},
							rank)),
					function (_v0) {
						return $author$project$Extra$System$IO$Pure$return(_var);
					});
			});
	});
var $author$project$Compiler$Type$Type$Unit1 = {$: 'Unit1'};
var $author$project$Compiler$Type$Solve$unit1 = $author$project$Compiler$Type$Type$Structure($author$project$Compiler$Type$Type$Unit1);
var $author$project$Compiler$Type$Solve$typeToVar = F3(
	function (rank, pools, tipe) {
		var go = A2($author$project$Compiler$Type$Solve$typeToVar, rank, pools);
		switch (tipe.$) {
			case 'VarN':
				var v = tipe.a;
				return $author$project$Extra$System$IO$Pure$return(v);
			case 'AppN':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2($author$project$Extra$System$IO$Pure$traverseList, go, args),
					function (argVars) {
						return A3(
							$author$project$Compiler$Type$Solve$register,
							rank,
							pools,
							$author$project$Compiler$Type$Type$Structure(
								A3($author$project$Compiler$Type$Type$App1, home, name, argVars)));
					});
			case 'FunN':
				var a = tipe.a;
				var b = tipe.b;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					go(a),
					function (aVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(b),
							function (bVar) {
								return A3(
									$author$project$Compiler$Type$Solve$register,
									rank,
									pools,
									$author$project$Compiler$Type$Type$Structure(
										A2($author$project$Compiler$Type$Type$Fun1, aVar, bVar)));
							});
					});
			case 'AliasN':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				var aliasType = tipe.d;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$traverseList,
						A2($author$project$Extra$Type$Tuple$traverseSecond, $author$project$Extra$System$IO$Pure$fmap, go),
						args),
					function (argVars) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3($author$project$Compiler$Type$Solve$typeToVar, rank, pools, aliasType),
							function (aliasVar) {
								return A3(
									$author$project$Compiler$Type$Solve$register,
									rank,
									pools,
									A4($author$project$Compiler$Type$Type$Alias, home, name, argVars, aliasVar));
							});
					});
			case 'RecordN':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2($author$project$Extra$System$IO$Pure$traverseMap, go, fields),
					function (fieldVars) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(ext),
							function (extVar) {
								return A3(
									$author$project$Compiler$Type$Solve$register,
									rank,
									pools,
									$author$project$Compiler$Type$Type$Structure(
										A2($author$project$Compiler$Type$Type$Record1, fieldVars, extVar)));
							});
					});
			case 'EmptyRecordN':
				return A3($author$project$Compiler$Type$Solve$register, rank, pools, $author$project$Compiler$Type$Solve$emptyRecord1);
			case 'UnitN':
				return A3($author$project$Compiler$Type$Solve$register, rank, pools, $author$project$Compiler$Type$Solve$unit1);
			default:
				var a = tipe.a;
				var b = tipe.b;
				var c = tipe.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					go(a),
					function (aVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(b),
							function (bVar) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A4($author$project$Extra$Type$Maybe$traverse, $author$project$Extra$System$IO$Pure$pure, $author$project$Extra$System$IO$Pure$fmap, go, c),
									function (cVar) {
										return A3(
											$author$project$Compiler$Type$Solve$register,
											rank,
											pools,
											$author$project$Compiler$Type$Type$Structure(
												A3($author$project$Compiler$Type$Type$Tuple1, aVar, bVar, cVar)));
									});
							});
					});
		}
	});
var $author$project$Compiler$Type$Solve$typeToVariable = F3(
	function (rank, pools, tipe) {
		return A3($author$project$Compiler$Type$Solve$typeToVar, rank, pools, tipe);
	});
var $author$project$Compiler$Type$Solve$expectedToVariable = F3(
	function (rank, pools, expectation) {
		return A3(
			$author$project$Compiler$Type$Solve$typeToVariable,
			rank,
			pools,
			function () {
				switch (expectation.$) {
					case 'NoExpectation':
						var tipe = expectation.a;
						return tipe;
					case 'FromContext':
						var tipe = expectation.c;
						return tipe;
					default:
						var tipe = expectation.d;
						return tipe;
				}
			}());
	});
var $author$project$Extra$System$IO$Pure$mapMListHelp_ = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return A2($author$project$Extra$System$IO$Pure$fmap, $author$project$Extra$System$IO$Pure$Done, result);
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (_v2) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(rest, result));
				},
				callback(a));
		}
	});
var $author$project$Extra$System$IO$Pure$forMList_ = F2(
	function (list, callback) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$mapMListHelp_(callback),
			_Utils_Tuple2(
				list,
				$author$project$Extra$System$IO$Pure$pure(_Utils_Tuple0)));
	});
var $author$project$Extra$System$IO$Pure$foldlMHelpMap = F2(
	function (callback, _v0) {
		var pairs = _v0.a;
		var result = _v0.b;
		if (!pairs.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(result));
		} else {
			var _v2 = pairs.a;
			var a = _v2.b;
			var rest = pairs.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(rest, b));
				},
				A2(callback, result, a));
		}
	});
var $author$project$Extra$System$IO$Pure$foldlMMap = F3(
	function (callback, zero, map) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$foldlMHelpMap(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$Map$toList(map),
				zero));
	});
var $author$project$Extra$Class$Applicative$when = F3(
	function (mPure, c, f) {
		return c ? f(_Utils_Tuple0) : mPure(_Utils_Tuple0);
	});
var $author$project$Extra$System$IO$Pure$when = $author$project$Extra$Class$Applicative$when($author$project$Extra$System$IO$Pure$pure);
var $author$project$Compiler$Type$UnionFind$repr = function (point) {
	var ref = point.a;
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$UnionFind$liftI(
			$author$project$Extra$System$IORef$read(ref)),
		function (pInfo) {
			if (pInfo.$ === 'Info') {
				return $author$project$Extra$System$IO$Pure$return(point);
			} else {
				var point1 = pInfo.a;
				var ref1 = point1.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$UnionFind$repr(point1),
					function (point2) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A2(
								$author$project$Extra$System$IO$Pure$when,
								!_Utils_eq(point2, point1),
								function (_v1) {
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										$author$project$Compiler$Type$UnionFind$liftI(
											$author$project$Extra$System$IORef$read(ref1)),
										function (pInfo1) {
											return $author$project$Compiler$Type$UnionFind$liftI(
												A2($author$project$Extra$System$IORef$write, ref, pInfo1));
										});
								}),
							function (_v2) {
								return $author$project$Extra$System$IO$Pure$return(point2);
							});
					});
			}
		});
};
var $author$project$Compiler$Type$UnionFind$get = function (point) {
	var ref = point.a;
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$UnionFind$liftI(
			$author$project$Extra$System$IORef$read(ref)),
		function (pInfo) {
			if (pInfo.$ === 'Info') {
				var descRef = pInfo.b;
				return $author$project$Compiler$Type$UnionFind$liftD(
					$author$project$Extra$System$IORef$read(descRef));
			} else {
				var ref1 = pInfo.a.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$UnionFind$liftI(
						$author$project$Extra$System$IORef$read(ref1)),
					function (link) {
						if (link.$ === 'Info') {
							var descRef = link.b;
							return $author$project$Compiler$Type$UnionFind$liftD(
								$author$project$Extra$System$IORef$read(descRef));
						} else {
							return A2(
								$author$project$Extra$System$IO$Pure$andThen,
								$author$project$Compiler$Type$UnionFind$get,
								$author$project$Compiler$Type$UnionFind$repr(point));
						}
					});
			}
		});
};
var $elm$core$Basics$min = F2(
	function (x, y) {
		return (_Utils_cmp(x, y) < 0) ? x : y;
	});
var $author$project$Compiler$Type$UnionFind$set = F2(
	function (point, newDesc) {
		var ref = point.a;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$liftI(
				$author$project$Extra$System$IORef$read(ref)),
			function (pInfo) {
				if (pInfo.$ === 'Info') {
					var descRef = pInfo.b;
					return $author$project$Compiler$Type$UnionFind$liftD(
						A2($author$project$Extra$System$IORef$write, descRef, newDesc));
				} else {
					var ref1 = pInfo.a.a;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$UnionFind$liftI(
							$author$project$Extra$System$IORef$read(ref1)),
						function (link) {
							if (link.$ === 'Info') {
								var descRef = link.b;
								return $author$project$Compiler$Type$UnionFind$liftD(
									A2($author$project$Extra$System$IORef$write, descRef, newDesc));
							} else {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									$author$project$Compiler$Type$UnionFind$repr(point),
									function (newPoint) {
										return A2($author$project$Compiler$Type$UnionFind$set, newPoint, newDesc);
									});
							}
						});
				}
			});
	});
var $author$project$Compiler$Type$Solve$adjustRank = F4(
	function (youngMark, visitMark, groupRank, _var) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$get(_var),
			function (_v4) {
				var content = _v4.a;
				var rank = _v4.b;
				var mark = _v4.c;
				var copy = _v4.d;
				if (_Utils_eq(mark, youngMark)) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2(
							$author$project$Compiler$Type$UnionFind$set,
							_var,
							A4($author$project$Compiler$Type$Type$Descriptor, content, rank, visitMark, copy)),
						function (_v5) {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A4($author$project$Compiler$Type$Solve$adjustRankContent, youngMark, visitMark, groupRank, content),
								function (maxRank) {
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A2(
											$author$project$Compiler$Type$UnionFind$set,
											_var,
											A4($author$project$Compiler$Type$Type$Descriptor, content, maxRank, visitMark, copy)),
										function (_v6) {
											return $author$project$Extra$System$IO$Pure$return(maxRank);
										});
								});
						});
				} else {
					if (_Utils_eq(mark, visitMark)) {
						return $author$project$Extra$System$IO$Pure$return(rank);
					} else {
						var minRank = A2($elm$core$Basics$min, groupRank, rank);
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A2(
								$author$project$Compiler$Type$UnionFind$set,
								_var,
								A4($author$project$Compiler$Type$Type$Descriptor, content, minRank, visitMark, copy)),
							function (_v7) {
								return $author$project$Extra$System$IO$Pure$return(minRank);
							});
					}
				}
			});
	});
var $author$project$Compiler$Type$Solve$adjustRankContent = F4(
	function (youngMark, visitMark, groupRank, content) {
		var go = A3($author$project$Compiler$Type$Solve$adjustRank, youngMark, visitMark, groupRank);
		switch (content.$) {
			case 'FlexVar':
				return $author$project$Extra$System$IO$Pure$return(groupRank);
			case 'FlexSuper':
				return $author$project$Extra$System$IO$Pure$return(groupRank);
			case 'RigidVar':
				return $author$project$Extra$System$IO$Pure$return(groupRank);
			case 'RigidSuper':
				return $author$project$Extra$System$IO$Pure$return(groupRank);
			case 'Structure':
				var flatType = content.a;
				switch (flatType.$) {
					case 'App1':
						var args = flatType.c;
						return A3(
							$author$project$Extra$System$IO$Pure$foldlMList,
							F2(
								function (rank, arg) {
									return A2(
										$author$project$Extra$System$IO$Pure$fmap,
										$elm$core$Basics$max(rank),
										go(arg));
								}),
							$author$project$Compiler$Type$Type$outermostRank,
							args);
					case 'Fun1':
						var arg = flatType.a;
						var result = flatType.b;
						return A3(
							$author$project$Extra$System$IO$Pure$liftA2,
							$elm$core$Basics$max,
							go(arg),
							go(result));
					case 'EmptyRecord1':
						return $author$project$Extra$System$IO$Pure$return($author$project$Compiler$Type$Type$outermostRank);
					case 'Record1':
						var fields = flatType.a;
						var extension = flatType.b;
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(extension),
							function (extRank) {
								return A3(
									$author$project$Extra$System$IO$Pure$foldlMMap,
									F2(
										function (rank, field) {
											return A2(
												$author$project$Extra$System$IO$Pure$fmap,
												$elm$core$Basics$max(rank),
												go(field));
										}),
									extRank,
									fields);
							});
					case 'Unit1':
						return $author$project$Extra$System$IO$Pure$return($author$project$Compiler$Type$Type$outermostRank);
					default:
						var a = flatType.a;
						var b = flatType.b;
						var maybeC = flatType.c;
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(a),
							function (ma) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									go(b),
									function (mb) {
										if (maybeC.$ === 'Nothing') {
											return $author$project$Extra$System$IO$Pure$return(
												A2($elm$core$Basics$max, ma, mb));
										} else {
											var c = maybeC.a;
											return A2(
												$author$project$Extra$System$IO$Pure$fmap,
												$elm$core$Basics$max(
													A2($elm$core$Basics$max, ma, mb)),
												go(c));
										}
									});
							});
				}
			case 'Alias':
				var args = content.c;
				return A3(
					$author$project$Extra$System$IO$Pure$foldlMList,
					F2(
						function (rank, _v3) {
							var argVar = _v3.b;
							return A2(
								$author$project$Extra$System$IO$Pure$fmap,
								$elm$core$Basics$max(rank),
								go(argVar));
						}),
					$author$project$Compiler$Type$Type$outermostRank,
					args);
			default:
				return $author$project$Extra$System$IO$Pure$return(groupRank);
		}
	});
var $author$project$Extra$System$IO$Pure$imapMListHelp_ = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var index = _v0.b;
		var result = _v0.c;
		if (!list.b) {
			return A2($author$project$Extra$System$IO$Pure$fmap, $author$project$Extra$System$IO$Pure$Done, result);
		} else {
			var a = list.a;
			var rest = list.b;
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Loop(
					_Utils_Tuple3(
						rest,
						index - 1,
						A2(
							$author$project$Extra$System$IO$Pure$bind,
							A2(callback, index, a),
							function (_v2) {
								return result;
							}))));
		}
	});
var $author$project$Extra$System$IO$Pure$imapMList_ = F2(
	function (callback, list) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$imapMListHelp_(callback),
			_Utils_Tuple3(
				$author$project$Extra$Type$List$reverse(list),
				$author$project$Extra$Type$List$length(list) - 1,
				$author$project$Extra$System$IO$Pure$pure(_Utils_Tuple0)));
	});
var $author$project$Extra$System$IO$Pure$mapMList_ = F2(
	function (callback, list) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$mapMListHelp_(callback),
			_Utils_Tuple2(
				list,
				$author$project$Extra$System$IO$Pure$pure(_Utils_Tuple0)));
	});
var $author$project$Extra$System$MVector$unsafeFreeze = F2(
	function (_v0, state) {
		var id = _v0.a;
		var nextId = state.a;
		var map = state.b;
		var refState = state.c;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, id, map);
		if (_v1.$ === 'Just') {
			var vec = _v1.a;
			return A3(
				$author$project$Extra$System$MVector$liftResult,
				nextId,
				map,
				A3(
					$author$project$Extra$System$IO$Pure$traverseList,
					$author$project$Extra$System$IORef$read,
					$author$project$Extra$Type$Map$elems(vec),
					refState));
		} else {
			return _Utils_Tuple2(_List_Nil, state);
		}
	});
var $author$project$Compiler$Type$Solve$poolToRankTable = F3(
	function (youngMark, youngRank, youngInhabitants) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Solve$liftP(
				A2($author$project$Extra$System$MVector$replicate, youngRank + 1, _List_Nil)),
			function (mutableTable) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$forMList_,
						youngInhabitants,
						function (_var) {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Compiler$Type$UnionFind$get(_var),
								function (_v0) {
									var content = _v0.a;
									var rank = _v0.b;
									var copy = _v0.d;
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A2(
											$author$project$Compiler$Type$UnionFind$set,
											_var,
											A4($author$project$Compiler$Type$Type$Descriptor, content, rank, youngMark, copy)),
										function (_v1) {
											return $author$project$Compiler$Type$Solve$liftP(
												A3(
													$author$project$Extra$System$MVector$modify,
													mutableTable,
													function (l) {
														return A2($elm$core$List$cons, _var, l);
													},
													rank));
										});
								});
						}),
					function (_v2) {
						return $author$project$Compiler$Type$Solve$liftP(
							$author$project$Extra$System$MVector$unsafeFreeze(mutableTable));
					});
			});
	});
var $author$project$Extra$System$MVector$read = F3(
	function (_v0, i, _v1) {
		var id = _v0.a;
		var nextId = _v1.a;
		var map = _v1.b;
		var refState = _v1.c;
		var _v2 = A3($author$project$Extra$System$MVector$getRef, id, i, map);
		if (_v2.$ === 'Just') {
			var ref = _v2.a;
			return A3(
				$author$project$Extra$System$MVector$liftResult,
				nextId,
				map,
				A2($author$project$Extra$System$IORef$read, ref, refState));
		} else {
			return _Debug_todo(
				'Extra.System.MVector',
				{
					start: {line: 81, column: 13},
					end: {line: 81, column: 23}
				})('MVector.read: id not found');
		}
	});
var $author$project$Compiler$Type$UnionFind$redundant = function (_v0) {
	var ref = _v0.a;
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$UnionFind$liftI(
			$author$project$Extra$System$IORef$read(ref)),
		function (pInfo) {
			if (pInfo.$ === 'Info') {
				return $author$project$Extra$System$IO$Pure$return(false);
			} else {
				return $author$project$Extra$System$IO$Pure$return(true);
			}
		});
};
var $author$project$Compiler$Type$Solve$generalize = F4(
	function (youngMark, visitMark, youngRank, pools) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Solve$liftP(
				A2($author$project$Extra$System$MVector$read, pools, youngRank)),
			function (youngVars) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3($author$project$Compiler$Type$Solve$poolToRankTable, youngMark, youngRank, youngVars),
					function (rankTable) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A2(
								$author$project$Extra$System$IO$Pure$imapMList_,
								F2(
									function (rank, table) {
										return A2(
											$author$project$Extra$System$IO$Pure$mapMList_,
											A3($author$project$Compiler$Type$Solve$adjustRank, youngMark, visitMark, rank),
											table);
									}),
								rankTable),
							function (_v0) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2(
										$author$project$Extra$System$IO$Pure$forMList_,
										$author$project$Extra$Type$List$init(rankTable),
										function (vars) {
											return A2(
												$author$project$Extra$System$IO$Pure$forMList_,
												vars,
												function (_var) {
													return A2(
														$author$project$Extra$System$IO$Pure$bind,
														$author$project$Compiler$Type$UnionFind$redundant(_var),
														function (isRedundant) {
															return isRedundant ? $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0) : A2(
																$author$project$Extra$System$IO$Pure$bind,
																$author$project$Compiler$Type$UnionFind$get(_var),
																function (_v1) {
																	var rank = _v1.b;
																	return $author$project$Compiler$Type$Solve$liftP(
																		A3(
																			$author$project$Extra$System$MVector$modify,
																			pools,
																			function (l) {
																				return A2($elm$core$List$cons, _var, l);
																			},
																			rank));
																});
														});
												});
										}),
									function (_v2) {
										return A2(
											$author$project$Extra$System$IO$Pure$forMList_,
											$author$project$Extra$Type$List$last(rankTable),
											function (_var) {
												return A2(
													$author$project$Extra$System$IO$Pure$bind,
													$author$project$Compiler$Type$UnionFind$redundant(_var),
													function (isRedundant) {
														return isRedundant ? $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0) : A2(
															$author$project$Extra$System$IO$Pure$bind,
															$author$project$Compiler$Type$UnionFind$get(_var),
															function (_v3) {
																var content = _v3.a;
																var rank = _v3.b;
																var mark = _v3.c;
																var copy = _v3.d;
																return (_Utils_cmp(rank, youngRank) < 0) ? $author$project$Compiler$Type$Solve$liftP(
																	A3(
																		$author$project$Extra$System$MVector$modify,
																		pools,
																		function (l) {
																			return A2($elm$core$List$cons, _var, l);
																		},
																		rank)) : A2(
																	$author$project$Compiler$Type$UnionFind$set,
																	_var,
																	A4($author$project$Compiler$Type$Type$Descriptor, content, $author$project$Compiler$Type$Type$noRank, mark, copy));
															});
													});
											});
									});
							});
					});
			});
	});
var $author$project$Extra$System$MVector$grow = F3(
	function (mv, n, state) {
		var id = mv.a;
		var len = mv.b;
		var nextId = state.a;
		var map = state.b;
		var refState = state.c;
		var _v0 = A2($author$project$Extra$Type$Map$lookup, id, map);
		if (_v0.$ === 'Just') {
			var vec = _v0.a;
			return _Utils_Tuple2(
				A2($author$project$Extra$System$MVector$MVector, nextId, len + n),
				function () {
					var _v1 = A3(
						$author$project$Extra$System$IO$Pure$traverseMap,
						function (r) {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Extra$System$IORef$read(r),
								$author$project$Extra$System$IORef$new);
						},
						vec,
						refState);
					var copy = _v1.a;
					var nextRefState = _v1.b;
					return _Utils_Tuple3(
						nextId + 1,
						A3($author$project$Extra$Type$Map$insert, nextId, copy, map),
						nextRefState);
				}());
		} else {
			return _Utils_Tuple2(mv, state);
		}
	});
var $author$project$Compiler$Type$UnionFind$modify = F2(
	function (point, func) {
		var ref = point.a;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$liftI(
				$author$project$Extra$System$IORef$read(ref)),
			function (pInfo) {
				if (pInfo.$ === 'Info') {
					var descRef = pInfo.b;
					return $author$project$Compiler$Type$UnionFind$liftD(
						A2($author$project$Extra$System$IORef$modify, descRef, func));
				} else {
					var ref1 = pInfo.a.a;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$UnionFind$liftI(
							$author$project$Extra$System$IORef$read(ref1)),
						function (link) {
							if (link.$ === 'Info') {
								var descRef = link.b;
								return $author$project$Compiler$Type$UnionFind$liftD(
									A2($author$project$Extra$System$IORef$modify, descRef, func));
							} else {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									$author$project$Compiler$Type$UnionFind$repr(point),
									function (newPoint) {
										return A2($author$project$Compiler$Type$UnionFind$modify, newPoint, func);
									});
							}
						});
				}
			});
	});
var $author$project$Compiler$Type$Solve$introduce = F3(
	function (rank, pools, variables) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Solve$liftP(
				A3(
					$author$project$Extra$System$MVector$modify,
					pools,
					function (l) {
						return _Utils_ap(variables, l);
					},
					rank)),
			function (_v0) {
				return A2(
					$author$project$Extra$System$IO$Pure$forMList_,
					variables,
					function (_var) {
						return A2(
							$author$project$Compiler$Type$UnionFind$modify,
							_var,
							function (_v1) {
								var content = _v1.a;
								var mark = _v1.c;
								var copy = _v1.d;
								return A4($author$project$Compiler$Type$Type$Descriptor, content, rank, mark, copy);
							});
					});
			});
	});
var $author$project$Compiler$Reporting$Render$Type$None = {$: 'None'};
var $author$project$Compiler$Reporting$Render$Type$Localizer$empty = $author$project$Compiler$Reporting$Render$Type$Localizer$Localizer($author$project$Extra$Type$Map$empty);
var $author$project$Compiler$Reporting$Render$Type$App = {$: 'App'};
var $author$project$Compiler$Reporting$Render$Type$Func = {$: 'Func'};
var $author$project$Extra$Data$Pretty$cat = A2($elm$core$Basics$composeL, $the_sett$elm_pretty_printer$Pretty$group, $author$project$Extra$Data$Pretty$vcat);
var $author$project$Compiler$Reporting$Doc$cat = $author$project$Extra$Data$Pretty$cat;
var $author$project$Extra$Data$Pretty$hang = $the_sett$elm_pretty_printer$Pretty$hang;
var $author$project$Compiler$Reporting$Doc$hang = $author$project$Extra$Data$Pretty$hang;
var $the_sett$elm_pretty_printer$Pretty$lines = $the_sett$elm_pretty_printer$Pretty$join($the_sett$elm_pretty_printer$Pretty$line);
var $author$project$Extra$Data$Pretty$vsep = $the_sett$elm_pretty_printer$Pretty$lines;
var $author$project$Extra$Data$Pretty$sep = A2($elm$core$Basics$composeL, $the_sett$elm_pretty_printer$Pretty$group, $author$project$Extra$Data$Pretty$vsep);
var $author$project$Compiler$Reporting$Doc$sep = $author$project$Extra$Data$Pretty$sep;
var $author$project$Compiler$Reporting$Render$Type$apply = F3(
	function (context, name, args) {
		if (!args.b) {
			return name;
		} else {
			var applyDoc = A2(
				$author$project$Compiler$Reporting$Doc$hang,
				4,
				$author$project$Compiler$Reporting$Doc$sep(
					A2($elm$core$List$cons, name, args)));
			switch (context.$) {
				case 'App':
					return $author$project$Compiler$Reporting$Doc$cat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('('),
								applyDoc,
								$author$project$Compiler$Reporting$Doc$fromChars(')')
							]));
				case 'Func':
					return applyDoc;
				default:
					return applyDoc;
			}
		}
	});
var $author$project$Compiler$Type$Error$extToDoc = function (ext) {
	switch (ext.$) {
		case 'Closed':
			return $elm$core$Maybe$Nothing;
		case 'FlexOpen':
			var x = ext.a;
			return $elm$core$Maybe$Just(
				$author$project$Compiler$Reporting$Doc$fromName(x));
		default:
			var x = ext.a;
			return $elm$core$Maybe$Just(
				$author$project$Compiler$Reporting$Doc$fromName(x));
	}
};
var $author$project$Extra$Data$Pretty$align = $the_sett$elm_pretty_printer$Pretty$align;
var $author$project$Compiler$Reporting$Doc$align = $author$project$Extra$Data$Pretty$align;
var $the_sett$elm_pretty_printer$Pretty$char = function (c) {
	return A2(
		$the_sett$elm_pretty_printer$Internals$Text,
		$elm$core$String$fromChar(c),
		$elm$core$Maybe$Nothing);
};
var $the_sett$elm_pretty_printer$Pretty$space = $the_sett$elm_pretty_printer$Pretty$char(
	_Utils_chr(' '));
var $the_sett$elm_pretty_printer$Pretty$words = $the_sett$elm_pretty_printer$Pretty$join($the_sett$elm_pretty_printer$Pretty$space);
var $author$project$Extra$Data$Pretty$hsep = $the_sett$elm_pretty_printer$Pretty$words;
var $author$project$Compiler$Reporting$Doc$hsep = $author$project$Extra$Data$Pretty$hsep;
var $author$project$Compiler$Reporting$Render$Type$lambda = F4(
	function (context, arg1, arg2, args) {
		var lambdaDoc = $author$project$Compiler$Reporting$Doc$align(
			$author$project$Compiler$Reporting$Doc$sep(
				A2(
					$elm$core$List$cons,
					arg1,
					A2(
						$author$project$Extra$Type$List$map,
						function (s) {
							return $author$project$Compiler$Reporting$Doc$hsep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fromChars('->'),
										s
									]));
						},
						A2($elm$core$List$cons, arg2, args)))));
		switch (context.$) {
			case 'None':
				return lambdaDoc;
			case 'Func':
				return $author$project$Compiler$Reporting$Doc$hcat(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$fromChars('('),
							lambdaDoc,
							$author$project$Compiler$Reporting$Doc$fromChars(')')
						]));
			default:
				return $author$project$Compiler$Reporting$Doc$hcat(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$fromChars('('),
							lambdaDoc,
							$author$project$Compiler$Reporting$Doc$fromChars(')')
						]));
		}
	});
var $author$project$Compiler$Reporting$Render$Type$entryToDoc = function (_v0) {
	var fieldName = _v0.a;
	var fieldType = _v0.b;
	return A2(
		$author$project$Compiler$Reporting$Doc$hang,
		4,
		$author$project$Compiler$Reporting$Doc$sep(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$hsep(
					_List_fromArray(
						[
							fieldName,
							$author$project$Compiler$Reporting$Doc$fromChars(':')
						])),
					fieldType
				])));
};
var $author$project$Compiler$Reporting$Render$Type$zipWithHelp = F3(
	function (headPrefix, tailPrefix, docs) {
		if (!docs.b) {
			return _List_Nil;
		} else {
			var head = docs.a;
			var tail = docs.b;
			return A2(
				$elm$core$List$cons,
				$author$project$Compiler$Reporting$Doc$hsep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$fromChars(headPrefix),
							head
						])),
				A2(
					$author$project$Extra$Type$List$map,
					function (t) {
						return $author$project$Compiler$Reporting$Doc$hsep(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fromChars(tailPrefix),
									t
								]));
					},
					tail));
		}
	});
var $author$project$Compiler$Reporting$Render$Type$record = F2(
	function (entries, maybeExt) {
		var _v0 = _Utils_Tuple2(
			A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Render$Type$entryToDoc, entries),
			maybeExt);
		if (_v0.b.$ === 'Nothing') {
			if (!_v0.a.b) {
				var _v1 = _v0.b;
				return $author$project$Compiler$Reporting$Doc$fromChars('{}');
			} else {
				var fields = _v0.a;
				var _v2 = _v0.b;
				return $author$project$Compiler$Reporting$Doc$align(
					$author$project$Compiler$Reporting$Doc$sep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$cat(
								A3($author$project$Compiler$Reporting$Render$Type$zipWithHelp, '{', ',', fields)),
								$author$project$Compiler$Reporting$Doc$fromChars('}')
							])));
			}
		} else {
			var fields = _v0.a;
			var ext = _v0.b.a;
			return $author$project$Compiler$Reporting$Doc$align(
				$author$project$Compiler$Reporting$Doc$sep(
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Reporting$Doc$hang,
							4,
							$author$project$Compiler$Reporting$Doc$sep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$hsep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$fromChars('{'),
												ext
											])),
										$author$project$Compiler$Reporting$Doc$cat(
										A3($author$project$Compiler$Reporting$Render$Type$zipWithHelp, '|', ',', fields))
									]))),
							$author$project$Compiler$Reporting$Doc$fromChars('}')
						])));
		}
	});
var $author$project$Compiler$Reporting$Render$Type$Localizer$toChars = F3(
	function (_v0, moduleName, name) {
		var localizer = _v0.a;
		var home = moduleName.b;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, home, localizer);
		if (_v1.$ === 'Nothing') {
			return home + ('.' + name);
		} else {
			var _v2 = _v1.a;
			var alias = _v2.a;
			var exposing_ = _v2.b;
			if (exposing_.$ === 'All') {
				return name;
			} else {
				var set = exposing_.a;
				return A2($author$project$Extra$Type$Set$member, name, set) ? name : ((_Utils_eq(name, $author$project$Compiler$Data$Name$list) && _Utils_eq(moduleName, $author$project$Compiler$Elm$ModuleName$list)) ? 'List' : (A3($author$project$Extra$Type$Maybe$maybe, home, $elm$core$Basics$identity, alias) + ('.' + name)));
			}
		}
	});
var $author$project$Compiler$Reporting$Render$Type$Localizer$toDoc = F3(
	function (localizer, home, name) {
		return $author$project$Compiler$Reporting$Doc$fromChars(
			A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home, name));
	});
var $author$project$Compiler$Reporting$Render$Type$tuple = F3(
	function (a, b, cs) {
		var entries = A3(
			$author$project$Compiler$Reporting$Render$Type$zipWithHelp,
			'(',
			',',
			A2(
				$elm$core$List$cons,
				a,
				A2($elm$core$List$cons, b, cs)));
		return $author$project$Compiler$Reporting$Doc$align(
			$author$project$Compiler$Reporting$Doc$sep(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$cat(entries),
						$author$project$Compiler$Reporting$Doc$fromChars(')')
					])));
	});
var $author$project$Compiler$Type$Error$addField = F4(
	function (localizer, fieldName, fieldType, docs) {
		var t = A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, fieldType);
		var f = $author$project$Compiler$Reporting$Doc$fromName(fieldName);
		return A2(
			$elm$core$List$cons,
			_Utils_Tuple2(f, t),
			docs);
	});
var $author$project$Compiler$Type$Error$aliasToDoc = F5(
	function (localizer, ctx, home, name, args) {
		return A3(
			$author$project$Compiler$Reporting$Render$Type$apply,
			ctx,
			A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home, name),
			A2(
				$author$project$Extra$Type$List$map,
				A2(
					$elm$core$Basics$composeL,
					A2($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App),
					$elm$core$Tuple$second),
				args));
	});
var $author$project$Compiler$Type$Error$fieldsToDocs = F2(
	function (localizer, fields) {
		return A3(
			$author$project$Extra$Type$Map$foldrWithKey,
			$author$project$Compiler$Type$Error$addField(localizer),
			_List_Nil,
			fields);
	});
var $author$project$Compiler$Type$Error$toDoc = F3(
	function (localizer, ctx, tipe) {
		switch (tipe.$) {
			case 'Lambda':
				var a = tipe.a;
				var b = tipe.b;
				var cs = tipe.c;
				return A4(
					$author$project$Compiler$Reporting$Render$Type$lambda,
					ctx,
					A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func, a),
					A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func, b),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func),
						cs));
			case 'Infinite':
				return $author$project$Compiler$Reporting$Doc$fromChars('');
			case 'Error':
				return $author$project$Compiler$Reporting$Doc$fromChars('?');
			case 'FlexVar':
				var name = tipe.a;
				return $author$project$Compiler$Reporting$Doc$fromName(name);
			case 'FlexSuper':
				var name = tipe.b;
				return $author$project$Compiler$Reporting$Doc$fromName(name);
			case 'RigidVar':
				var name = tipe.a;
				return $author$project$Compiler$Reporting$Doc$fromName(name);
			case 'RigidSuper':
				var name = tipe.b;
				return $author$project$Compiler$Reporting$Doc$fromName(name);
			case 'Type':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					ctx,
					A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home, name),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App),
						args));
			case 'Record':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$Reporting$Render$Type$record,
					A2($author$project$Compiler$Type$Error$fieldsToDocs, localizer, fields),
					$author$project$Compiler$Type$Error$extToDoc(ext));
			case 'Unit':
				return $author$project$Compiler$Reporting$Doc$fromChars('()');
			case 'Tuple':
				var a = tipe.a;
				var b = tipe.b;
				var maybeC = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$tuple,
					A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, a),
					A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, b),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None),
						$author$project$Extra$Type$Maybe$maybeToList(maybeC)));
			default:
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A5($author$project$Compiler$Type$Error$aliasToDoc, localizer, ctx, home, name, args);
		}
	});
var $author$project$Extra$Class$StateT$evalStateT = F3(
	function (pFmap, sa, s) {
		return A2(
			pFmap,
			$elm$core$Tuple$first,
			sa(s));
	});
var $author$project$Compiler$Type$Type$evalStateT = $author$project$Extra$Class$StateT$evalStateT($author$project$Extra$System$IO$Pure$fmap);
var $author$project$Compiler$Type$UnionFind$equivalent = F2(
	function (p1, p2) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$repr(p1),
			function (v1) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$UnionFind$repr(p2),
					function (v2) {
						return $author$project$Extra$System$IO$Pure$return(
							_Utils_eq(v1, v2));
					});
			});
	});
var $elm$core$String$right = F2(
	function (n, string) {
		return (n < 1) ? '' : A3(
			$elm$core$String$slice,
			-n,
			$elm$core$String$length(string),
			string);
	});
var $author$project$Compiler$Data$Name$fromTypeVariable = F2(
	function (name, index) {
		if (index <= 0) {
			return name;
		} else {
			var end = A2($elm$core$String$right, 1, name);
			return (('0' <= end) && (end <= '9')) ? (name + ('_' + $elm$core$String$fromInt(index))) : _Utils_ap(
				name,
				$elm$core$String$fromInt(index));
		}
	});
var $author$project$Compiler$Type$Type$addName = F5(
	function (index, givenName, _var, makeContent, takenNames) {
		var indexedName = A2($author$project$Compiler$Data$Name$fromTypeVariable, givenName, index);
		var _v0 = A2($author$project$Extra$Type$Map$lookup, indexedName, takenNames);
		if (_v0.$ === 'Nothing') {
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				_Utils_eq(indexedName, givenName) ? $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0) : A2(
					$author$project$Compiler$Type$UnionFind$modify,
					_var,
					function (_v1) {
						var rank = _v1.b;
						var mark = _v1.c;
						var copy = _v1.d;
						return A4(
							$author$project$Compiler$Type$Type$Descriptor,
							makeContent(indexedName),
							rank,
							mark,
							copy);
					}),
				function (_v2) {
					return $author$project$Extra$System$IO$Pure$return(
						A3($author$project$Extra$Type$Map$insert, indexedName, _var, takenNames));
				});
		} else {
			var otherVar = _v0.a;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2($author$project$Compiler$Type$UnionFind$equivalent, _var, otherVar),
				function (same) {
					return same ? $author$project$Extra$System$IO$Pure$return(takenNames) : A5($author$project$Compiler$Type$Type$addName, index + 1, givenName, _var, makeContent, takenNames);
				});
		}
	});
var $author$project$Extra$System$IO$Pure$foldrMHelpList = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return $author$project$Extra$System$IO$Pure$return(
				$author$project$Extra$System$IO$Pure$Done(result));
		} else {
			var a = list.a;
			var rest = list.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (b) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(rest, b));
				},
				A2(callback, a, result));
		}
	});
var $author$project$Extra$System$IO$Pure$foldrMList = F3(
	function (callback, zero, list) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$foldrMHelpList(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$List$reverse(list),
				zero));
	});
var $author$project$Compiler$Type$Type$getVarNamesMark = $author$project$Compiler$Type$Type$Mark(0);
var $author$project$Compiler$Type$Type$getVarNames = F2(
	function (_var, takenNames) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$get(_var),
			function (_v0) {
				var content = _v0.a;
				var rank = _v0.b;
				var mark = _v0.c;
				var copy = _v0.d;
				return _Utils_eq(mark, $author$project$Compiler$Type$Type$getVarNamesMark) ? $author$project$Extra$System$IO$Pure$return(takenNames) : A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Compiler$Type$UnionFind$set,
						_var,
						A4($author$project$Compiler$Type$Type$Descriptor, content, rank, $author$project$Compiler$Type$Type$getVarNamesMark, copy)),
					function (_v1) {
						switch (content.$) {
							case 'Error':
								return $author$project$Extra$System$IO$Pure$return(takenNames);
							case 'FlexVar':
								var maybeName = content.a;
								if (maybeName.$ === 'Nothing') {
									return $author$project$Extra$System$IO$Pure$return(takenNames);
								} else {
									var name = maybeName.a;
									return A5(
										$author$project$Compiler$Type$Type$addName,
										0,
										name,
										_var,
										A2($elm$core$Basics$composeL, $author$project$Compiler$Type$Type$FlexVar, $elm$core$Maybe$Just),
										takenNames);
								}
							case 'FlexSuper':
								var _super = content.a;
								var maybeName = content.b;
								if (maybeName.$ === 'Nothing') {
									return $author$project$Extra$System$IO$Pure$return(takenNames);
								} else {
									var name = maybeName.a;
									return A5(
										$author$project$Compiler$Type$Type$addName,
										0,
										name,
										_var,
										A2(
											$elm$core$Basics$composeL,
											$author$project$Compiler$Type$Type$FlexSuper(_super),
											$elm$core$Maybe$Just),
										takenNames);
								}
							case 'RigidVar':
								var name = content.a;
								return A5($author$project$Compiler$Type$Type$addName, 0, name, _var, $author$project$Compiler$Type$Type$RigidVar, takenNames);
							case 'RigidSuper':
								var _super = content.a;
								var name = content.b;
								return A5(
									$author$project$Compiler$Type$Type$addName,
									0,
									name,
									_var,
									$author$project$Compiler$Type$Type$RigidSuper(_super),
									takenNames);
							case 'Alias':
								var args = content.c;
								return A3(
									$author$project$Extra$System$IO$Pure$foldrMList,
									$author$project$Compiler$Type$Type$getVarNames,
									takenNames,
									A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, args));
							default:
								var flatType = content.a;
								switch (flatType.$) {
									case 'App1':
										var args = flatType.c;
										return A3($author$project$Extra$System$IO$Pure$foldrMList, $author$project$Compiler$Type$Type$getVarNames, takenNames, args);
									case 'Fun1':
										var arg = flatType.a;
										var body = flatType.b;
										return A2(
											$author$project$Extra$System$IO$Pure$andThen,
											$author$project$Compiler$Type$Type$getVarNames(arg),
											A2($author$project$Compiler$Type$Type$getVarNames, body, takenNames));
									case 'EmptyRecord1':
										return $author$project$Extra$System$IO$Pure$return(takenNames);
									case 'Record1':
										var fields = flatType.a;
										var extension = flatType.b;
										return A2(
											$author$project$Extra$System$IO$Pure$andThen,
											$author$project$Compiler$Type$Type$getVarNames(extension),
											A3(
												$author$project$Extra$System$IO$Pure$foldrMList,
												$author$project$Compiler$Type$Type$getVarNames,
												takenNames,
												$author$project$Extra$Type$Map$elems(fields)));
									case 'Unit1':
										return $author$project$Extra$System$IO$Pure$return(takenNames);
									default:
										if (flatType.c.$ === 'Nothing') {
											var a = flatType.a;
											var b = flatType.b;
											var _v6 = flatType.c;
											return A2(
												$author$project$Extra$System$IO$Pure$andThen,
												$author$project$Compiler$Type$Type$getVarNames(a),
												A2($author$project$Compiler$Type$Type$getVarNames, b, takenNames));
										} else {
											var a = flatType.a;
											var b = flatType.b;
											var c = flatType.c.a;
											return A2(
												$author$project$Extra$System$IO$Pure$andThen,
												$author$project$Compiler$Type$Type$getVarNames(a),
												A2(
													$author$project$Extra$System$IO$Pure$andThen,
													$author$project$Compiler$Type$Type$getVarNames(b),
													A2($author$project$Compiler$Type$Type$getVarNames, c, takenNames)));
										}
								}
						}
					});
			});
	});
var $author$project$Compiler$Type$Type$NameState = F6(
	function (a, b, c, d, e, f) {
		return {$: 'NameState', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $elm$core$Basics$always = F2(
	function (a, _v0) {
		return a;
	});
var $author$project$Compiler$Type$Type$makeNameState = function (taken) {
	return A6(
		$author$project$Compiler$Type$Type$NameState,
		A2(
			$author$project$Extra$Type$Map$map,
			$elm$core$Basics$always(_Utils_Tuple0),
			taken),
		0,
		0,
		0,
		0,
		0);
};
var $author$project$Compiler$Type$Error$Alias = F4(
	function (a, b, c, d) {
		return {$: 'Alias', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Error$Closed = {$: 'Closed'};
var $author$project$Compiler$Type$Error$Error = {$: 'Error'};
var $author$project$Compiler$Type$Error$FlexOpen = function (a) {
	return {$: 'FlexOpen', a: a};
};
var $author$project$Compiler$Type$Error$FlexSuper = F2(
	function (a, b) {
		return {$: 'FlexSuper', a: a, b: b};
	});
var $author$project$Compiler$Type$Error$FlexVar = function (a) {
	return {$: 'FlexVar', a: a};
};
var $author$project$Compiler$Type$Error$Infinite = {$: 'Infinite'};
var $author$project$Compiler$Type$Error$Lambda = F3(
	function (a, b, c) {
		return {$: 'Lambda', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Error$Record = F2(
	function (a, b) {
		return {$: 'Record', a: a, b: b};
	});
var $author$project$Compiler$Type$Error$RigidOpen = function (a) {
	return {$: 'RigidOpen', a: a};
};
var $author$project$Compiler$Type$Error$RigidSuper = F2(
	function (a, b) {
		return {$: 'RigidSuper', a: a, b: b};
	});
var $author$project$Compiler$Type$Error$RigidVar = function (a) {
	return {$: 'RigidVar', a: a};
};
var $author$project$Compiler$Type$Error$Tuple = F3(
	function (a, b, c) {
		return {$: 'Tuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Error$Type = F3(
	function (a, b, c) {
		return {$: 'Type', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Error$Unit = {$: 'Unit'};
var $author$project$Extra$Class$StateT$andMap = F5(
	function (pFmap, pBind, sa, sf, s0) {
		return A2(
			pBind,
			sf(s0),
			function (_v0) {
				var f = _v0.a;
				var s1 = _v0.b;
				return A2(
					pFmap,
					function (_v1) {
						var a = _v1.a;
						var s2 = _v1.b;
						return _Utils_Tuple2(
							f(a),
							s2);
					},
					sa(s1));
			});
	});
var $author$project$Compiler$Type$Type$andMap = A2($author$project$Extra$Class$StateT$andMap, $author$project$Extra$System$IO$Pure$fmap, $author$project$Extra$System$IO$Pure$bind);
var $author$project$Extra$Class$StateT$bind = F4(
	function (pBind, sa, callback, s0) {
		return A2(
			pBind,
			sa(s0),
			function (_v0) {
				var a = _v0.a;
				var s1 = _v0.b;
				return A2(callback, a, s1);
			});
	});
var $author$project$Compiler$Type$Type$bind = $author$project$Extra$Class$StateT$bind($author$project$Extra$System$IO$Pure$bind);
var $author$project$Extra$Class$StateT$fmap = F4(
	function (pFmap, f, sa, s0) {
		return A2(
			pFmap,
			function (_v0) {
				var a = _v0.a;
				var s1 = _v0.b;
				return _Utils_Tuple2(
					f(a),
					s1);
			},
			sa(s0));
	});
var $author$project$Compiler$Type$Type$fmap = $author$project$Extra$Class$StateT$fmap($author$project$Extra$System$IO$Pure$fmap);
var $author$project$Compiler$Type$Type$getContent = function (_v0) {
	var content = _v0.a;
	return content;
};
var $author$project$Compiler$Type$Type$getAppendables = function (_v0) {
	var appendables = _v0.e;
	return appendables;
};
var $author$project$Compiler$Type$Type$getCompAppends = function (_v0) {
	var compAppends = _v0.f;
	return compAppends;
};
var $author$project$Compiler$Type$Type$getComparables = function (_v0) {
	var comparables = _v0.d;
	return comparables;
};
var $author$project$Compiler$Type$Type$getFreshSuperHelp = F3(
	function (prefix, index, taken) {
		getFreshSuperHelp:
		while (true) {
			var name = A2($author$project$Compiler$Data$Name$fromTypeVariable, prefix, index);
			if (A2($author$project$Extra$Type$Map$member, name, taken)) {
				var $temp$prefix = prefix,
					$temp$index = index + 1,
					$temp$taken = taken;
				prefix = $temp$prefix;
				index = $temp$index;
				taken = $temp$taken;
				continue getFreshSuperHelp;
			} else {
				return _Utils_Tuple3(
					name,
					index + 1,
					A3($author$project$Extra$Type$Map$insert, name, _Utils_Tuple0, taken));
			}
		}
	});
var $author$project$Compiler$Type$Type$getTaken = function (_v0) {
	var taken = _v0.a;
	return taken;
};
var $author$project$Extra$Class$StateT$gets = F3(
	function (pReturn, f, s) {
		return pReturn(
			_Utils_Tuple2(
				f(s),
				s));
	});
var $author$project$Compiler$Type$Type$gets = $author$project$Extra$Class$StateT$gets($author$project$Extra$System$IO$Pure$return);
var $author$project$Extra$Class$StateT$modify = F3(
	function (pReturn, f, s) {
		return pReturn(
			_Utils_Tuple2(
				_Utils_Tuple0,
				f(s)));
	});
var $author$project$Compiler$Type$Type$modify = $author$project$Extra$Class$StateT$modify($author$project$Extra$System$IO$Pure$return);
var $author$project$Extra$Class$StateT$pure = F3(
	function (pReturn, a, s) {
		return pReturn(
			_Utils_Tuple2(a, s));
	});
var $author$project$Extra$Class$StateT$return = $author$project$Extra$Class$StateT$pure;
var $author$project$Compiler$Type$Type$return = $author$project$Extra$Class$StateT$return($author$project$Extra$System$IO$Pure$return);
var $author$project$Compiler$Type$Type$setTaken = F2(
	function (taken, _v0) {
		var a = _v0.b;
		var b = _v0.c;
		var c = _v0.d;
		var d = _v0.e;
		var e = _v0.f;
		return A6($author$project$Compiler$Type$Type$NameState, taken, a, b, c, d, e);
	});
var $author$project$Compiler$Type$Type$getFreshSuper = F3(
	function (prefix, getter, setter) {
		return A2(
			$author$project$Compiler$Type$Type$bind,
			$author$project$Compiler$Type$Type$gets(getter),
			function (index) {
				return A2(
					$author$project$Compiler$Type$Type$bind,
					$author$project$Compiler$Type$Type$gets($author$project$Compiler$Type$Type$getTaken),
					function (taken) {
						var _v0 = A3($author$project$Compiler$Type$Type$getFreshSuperHelp, prefix, index, taken);
						var name = _v0.a;
						var newIndex = _v0.b;
						var newTaken = _v0.c;
						return A2(
							$author$project$Compiler$Type$Type$bind,
							$author$project$Compiler$Type$Type$modify(
								A2(
									$elm$core$Basics$composeR,
									$author$project$Compiler$Type$Type$setTaken(newTaken),
									setter(newIndex))),
							function (_v1) {
								return $author$project$Compiler$Type$Type$return(name);
							});
					});
			});
	});
var $author$project$Compiler$Type$Type$getNumbers = function (_v0) {
	var numbers = _v0.c;
	return numbers;
};
var $author$project$Compiler$Type$Type$setAppendables = F2(
	function (appendables, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		var e = _v0.f;
		return A6($author$project$Compiler$Type$Type$NameState, a, b, c, d, appendables, e);
	});
var $author$project$Compiler$Type$Type$setCompAppends = F2(
	function (compAppends, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		var e = _v0.e;
		return A6($author$project$Compiler$Type$Type$NameState, a, b, c, d, e, compAppends);
	});
var $author$project$Compiler$Type$Type$setComparables = F2(
	function (comparables, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.e;
		var e = _v0.f;
		return A6($author$project$Compiler$Type$Type$NameState, a, b, c, comparables, d, e);
	});
var $author$project$Compiler$Type$Type$setNumbers = F2(
	function (numbers, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.d;
		var d = _v0.e;
		var e = _v0.f;
		return A6($author$project$Compiler$Type$Type$NameState, a, b, numbers, c, d, e);
	});
var $author$project$Compiler$Type$Type$getFreshSuperName = function (_super) {
	switch (_super.$) {
		case 'Number':
			return A3($author$project$Compiler$Type$Type$getFreshSuper, 'number', $author$project$Compiler$Type$Type$getNumbers, $author$project$Compiler$Type$Type$setNumbers);
		case 'Comparable':
			return A3($author$project$Compiler$Type$Type$getFreshSuper, 'comparable', $author$project$Compiler$Type$Type$getComparables, $author$project$Compiler$Type$Type$setComparables);
		case 'Appendable':
			return A3($author$project$Compiler$Type$Type$getFreshSuper, 'appendable', $author$project$Compiler$Type$Type$getAppendables, $author$project$Compiler$Type$Type$setAppendables);
		default:
			return A3($author$project$Compiler$Type$Type$getFreshSuper, 'compappend', $author$project$Compiler$Type$Type$getCompAppends, $author$project$Compiler$Type$Type$setCompAppends);
	}
};
var $author$project$Compiler$Data$Name$fromTypeVariableScheme = function (scheme) {
	if (scheme < 26) {
		return $elm$core$String$fromChar(
			$elm$core$Char$fromCode(97 + scheme));
	} else {
		var letter = A2($elm$core$Basics$modBy, 26, scheme);
		var extra = (scheme / 26) | 0;
		return A2(
			$author$project$Compiler$Data$Name$writeDigitsAtEnd,
			extra,
			$elm$core$String$fromChar(
				$elm$core$Char$fromCode(97 + letter)));
	}
};
var $author$project$Compiler$Type$Type$getFreshVarNameHelp = F2(
	function (index, taken) {
		getFreshVarNameHelp:
		while (true) {
			var name = $author$project$Compiler$Data$Name$fromTypeVariableScheme(index);
			if (A2($author$project$Extra$Type$Map$member, name, taken)) {
				var $temp$index = index + 1,
					$temp$taken = taken;
				index = $temp$index;
				taken = $temp$taken;
				continue getFreshVarNameHelp;
			} else {
				return _Utils_Tuple3(
					name,
					index + 1,
					A3($author$project$Extra$Type$Map$insert, name, _Utils_Tuple0, taken));
			}
		}
	});
var $author$project$Compiler$Type$Type$getNormals = function (_v0) {
	var normals = _v0.b;
	return normals;
};
var $author$project$Compiler$Type$Type$setNormals = F2(
	function (normals, _v0) {
		var a = _v0.a;
		var b = _v0.c;
		var c = _v0.d;
		var d = _v0.e;
		var e = _v0.f;
		return A6($author$project$Compiler$Type$Type$NameState, a, normals, b, c, d, e);
	});
var $author$project$Compiler$Type$Type$getFreshVarName = A2(
	$author$project$Compiler$Type$Type$bind,
	$author$project$Compiler$Type$Type$gets($author$project$Compiler$Type$Type$getNormals),
	function (index) {
		return A2(
			$author$project$Compiler$Type$Type$bind,
			$author$project$Compiler$Type$Type$gets($author$project$Compiler$Type$Type$getTaken),
			function (taken) {
				var _v0 = A2($author$project$Compiler$Type$Type$getFreshVarNameHelp, index, taken);
				var name = _v0.a;
				var newIndex = _v0.b;
				var newTaken = _v0.c;
				return A2(
					$author$project$Compiler$Type$Type$bind,
					$author$project$Compiler$Type$Type$modify(
						A2(
							$elm$core$Basics$composeR,
							$author$project$Compiler$Type$Type$setTaken(newTaken),
							$author$project$Compiler$Type$Type$setNormals(newIndex))),
					function (_v1) {
						return $author$project$Compiler$Type$Type$return(name);
					});
			});
	});
var $author$project$Compiler$Type$Type$getMark = function (_v0) {
	var mark = _v0.c;
	return mark;
};
var $author$project$Compiler$Type$Error$iteratedDealias = function (tipe) {
	iteratedDealias:
	while (true) {
		if (tipe.$ === 'Alias') {
			var real = tipe.d;
			var $temp$tipe = real;
			tipe = $temp$tipe;
			continue iteratedDealias;
		} else {
			return tipe;
		}
	}
};
var $author$project$Extra$Class$StateT$liftA2 = F3(
	function (pFmap1, pFmap2, pBind) {
		return A2(
			$author$project$Extra$Class$Applicative$liftA2,
			$author$project$Extra$Class$StateT$fmap(pFmap1),
			A2($author$project$Extra$Class$StateT$andMap, pFmap2, pBind));
	});
var $author$project$Compiler$Type$Type$liftA2 = A3($author$project$Extra$Class$StateT$liftA2, $author$project$Extra$System$IO$Pure$fmap, $author$project$Extra$System$IO$Pure$fmap, $author$project$Extra$System$IO$Pure$bind);
var $author$project$Compiler$Type$Type$liftIO = F2(
	function (ia, s) {
		return A2(
			$author$project$Extra$System$IO$Pure$fmap,
			function (a) {
				return _Utils_Tuple2(a, s);
			},
			ia);
	});
var $author$project$Compiler$Type$Type$occursMark = $author$project$Compiler$Type$Type$Mark(1);
var $author$project$Compiler$Type$Type$pure = $author$project$Extra$Class$StateT$pure($author$project$Extra$System$IO$Pure$return);
var $author$project$Compiler$Type$Type$setContent = F2(
	function (content, _v0) {
		var a = _v0.b;
		var b = _v0.c;
		var c = _v0.d;
		return A4($author$project$Compiler$Type$Type$Descriptor, content, a, b, c);
	});
var $author$project$Compiler$Type$Type$setMark = F2(
	function (mark, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.d;
		return A4($author$project$Compiler$Type$Type$Descriptor, a, b, mark, c);
	});
var $author$project$Compiler$Type$Error$Appendable = {$: 'Appendable'};
var $author$project$Compiler$Type$Error$CompAppend = {$: 'CompAppend'};
var $author$project$Compiler$Type$Error$Comparable = {$: 'Comparable'};
var $author$project$Compiler$Type$Error$Number = {$: 'Number'};
var $author$project$Compiler$Type$Type$superToSuper = function (_super) {
	switch (_super.$) {
		case 'Number':
			return $author$project$Compiler$Type$Error$Number;
		case 'Comparable':
			return $author$project$Compiler$Type$Error$Comparable;
		case 'Appendable':
			return $author$project$Compiler$Type$Error$Appendable;
		default:
			return $author$project$Compiler$Type$Error$CompAppend;
	}
};
var $author$project$Compiler$Type$Type$contentToErrorType = F2(
	function (variable, content) {
		switch (content.$) {
			case 'Structure':
				var term = content.a;
				return $author$project$Compiler$Type$Type$termToErrorType(term);
			case 'FlexVar':
				var maybeName = content.a;
				if (maybeName.$ === 'Just') {
					var name = maybeName.a;
					return $author$project$Compiler$Type$Type$return(
						$author$project$Compiler$Type$Error$FlexVar(name));
				} else {
					return A2(
						$author$project$Compiler$Type$Type$bind,
						$author$project$Compiler$Type$Type$getFreshVarName,
						function (name) {
							return A2(
								$author$project$Compiler$Type$Type$bind,
								$author$project$Compiler$Type$Type$liftIO(
									A2(
										$author$project$Compiler$Type$UnionFind$modify,
										variable,
										$author$project$Compiler$Type$Type$setContent(
											$author$project$Compiler$Type$Type$FlexVar(
												$elm$core$Maybe$Just(name))))),
								function (_v7) {
									return $author$project$Compiler$Type$Type$return(
										$author$project$Compiler$Type$Error$FlexVar(name));
								});
						});
				}
			case 'FlexSuper':
				var _super = content.a;
				var maybeName = content.b;
				if (maybeName.$ === 'Just') {
					var name = maybeName.a;
					return $author$project$Compiler$Type$Type$return(
						A2(
							$author$project$Compiler$Type$Error$FlexSuper,
							$author$project$Compiler$Type$Type$superToSuper(_super),
							name));
				} else {
					return A2(
						$author$project$Compiler$Type$Type$bind,
						$author$project$Compiler$Type$Type$getFreshSuperName(_super),
						function (name) {
							return A2(
								$author$project$Compiler$Type$Type$bind,
								$author$project$Compiler$Type$Type$liftIO(
									A2(
										$author$project$Compiler$Type$UnionFind$modify,
										variable,
										$author$project$Compiler$Type$Type$setContent(
											A2(
												$author$project$Compiler$Type$Type$FlexSuper,
												_super,
												$elm$core$Maybe$Just(name))))),
								function (_v9) {
									return $author$project$Compiler$Type$Type$return(
										A2(
											$author$project$Compiler$Type$Error$FlexSuper,
											$author$project$Compiler$Type$Type$superToSuper(_super),
											name));
								});
						});
				}
			case 'RigidVar':
				var name = content.a;
				return $author$project$Compiler$Type$Type$return(
					$author$project$Compiler$Type$Error$RigidVar(name));
			case 'RigidSuper':
				var _super = content.a;
				var name = content.b;
				return $author$project$Compiler$Type$Type$return(
					A2(
						$author$project$Compiler$Type$Error$RigidSuper,
						$author$project$Compiler$Type$Type$superToSuper(_super),
						name));
			case 'Alias':
				var home = content.a;
				var name = content.b;
				var args = content.c;
				var realVariable = content.d;
				return A2(
					$author$project$Compiler$Type$Type$bind,
					A4(
						$author$project$Extra$Type$List$traverse,
						$author$project$Compiler$Type$Type$pure,
						$author$project$Compiler$Type$Type$liftA2,
						A2($author$project$Extra$Type$Tuple$traverseSecond, $author$project$Compiler$Type$Type$fmap, $author$project$Compiler$Type$Type$variableToErrorType),
						args),
					function (errArgs) {
						return A2(
							$author$project$Compiler$Type$Type$bind,
							$author$project$Compiler$Type$Type$variableToErrorType(realVariable),
							function (errType) {
								return $author$project$Compiler$Type$Type$return(
									A4($author$project$Compiler$Type$Error$Alias, home, name, errArgs, errType));
							});
					});
			default:
				return $author$project$Compiler$Type$Type$return($author$project$Compiler$Type$Error$Error);
		}
	});
var $author$project$Compiler$Type$Type$termToErrorType = function (term) {
	switch (term.$) {
		case 'App1':
			var home = term.a;
			var name = term.b;
			var args = term.c;
			return A2(
				$author$project$Compiler$Type$Type$fmap,
				A2($author$project$Compiler$Type$Error$Type, home, name),
				A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Type$Type$pure, $author$project$Compiler$Type$Type$liftA2, $author$project$Compiler$Type$Type$variableToErrorType, args));
		case 'Fun1':
			var a = term.a;
			var b = term.b;
			return A2(
				$author$project$Compiler$Type$Type$bind,
				$author$project$Compiler$Type$Type$variableToErrorType(a),
				function (arg) {
					return A2(
						$author$project$Compiler$Type$Type$bind,
						$author$project$Compiler$Type$Type$variableToErrorType(b),
						function (result) {
							return $author$project$Compiler$Type$Type$return(
								function () {
									if (result.$ === 'Lambda') {
										var arg1 = result.a;
										var arg2 = result.b;
										var others = result.c;
										return A3(
											$author$project$Compiler$Type$Error$Lambda,
											arg,
											arg1,
											A2($elm$core$List$cons, arg2, others));
									} else {
										return A3($author$project$Compiler$Type$Error$Lambda, arg, result, _List_Nil);
									}
								}());
						});
				});
		case 'EmptyRecord1':
			return $author$project$Compiler$Type$Type$return(
				A2($author$project$Compiler$Type$Error$Record, $author$project$Extra$Type$Map$empty, $author$project$Compiler$Type$Error$Closed));
		case 'Record1':
			var fields = term.a;
			var extension = term.b;
			return A2(
				$author$project$Compiler$Type$Type$bind,
				A4($author$project$Extra$Type$Map$traverse, $author$project$Compiler$Type$Type$pure, $author$project$Compiler$Type$Type$liftA2, $author$project$Compiler$Type$Type$variableToErrorType, fields),
				function (errFields) {
					return A2(
						$author$project$Compiler$Type$Type$bind,
						A2(
							$author$project$Compiler$Type$Type$fmap,
							$author$project$Compiler$Type$Error$iteratedDealias,
							$author$project$Compiler$Type$Type$variableToErrorType(extension)),
						function (errExt) {
							return $author$project$Compiler$Type$Type$return(
								function () {
									switch (errExt.$) {
										case 'Record':
											var subFields = errExt.a;
											var subExt = errExt.b;
											return A2(
												$author$project$Compiler$Type$Error$Record,
												A2($author$project$Extra$Type$Map$union, subFields, errFields),
												subExt);
										case 'FlexVar':
											var ext = errExt.a;
											return A2(
												$author$project$Compiler$Type$Error$Record,
												errFields,
												$author$project$Compiler$Type$Error$FlexOpen(ext));
										case 'RigidVar':
											var ext = errExt.a;
											return A2(
												$author$project$Compiler$Type$Error$Record,
												errFields,
												$author$project$Compiler$Type$Error$RigidOpen(ext));
										default:
											return _Debug_todo(
												'Compiler.Type.Type',
												{
													start: {line: 559, column: 13},
													end: {line: 559, column: 23}
												})('Used toErrorType on a type that is not well-formed');
									}
								}());
						});
				});
		case 'Unit1':
			return $author$project$Compiler$Type$Type$return($author$project$Compiler$Type$Error$Unit);
		default:
			var a = term.a;
			var b = term.b;
			var maybeC = term.c;
			return A2(
				$author$project$Compiler$Type$Type$andMap,
				A4($author$project$Extra$Type$Maybe$traverse, $author$project$Compiler$Type$Type$pure, $author$project$Compiler$Type$Type$fmap, $author$project$Compiler$Type$Type$variableToErrorType, maybeC),
				A2(
					$author$project$Compiler$Type$Type$andMap,
					$author$project$Compiler$Type$Type$variableToErrorType(b),
					A2(
						$author$project$Compiler$Type$Type$andMap,
						$author$project$Compiler$Type$Type$variableToErrorType(a),
						$author$project$Compiler$Type$Type$pure($author$project$Compiler$Type$Error$Tuple))));
	}
};
var $author$project$Compiler$Type$Type$variableToErrorType = function (variable) {
	return A2(
		$author$project$Compiler$Type$Type$bind,
		$author$project$Compiler$Type$Type$liftIO(
			$author$project$Compiler$Type$UnionFind$get(variable)),
		function (descriptor) {
			var mark = $author$project$Compiler$Type$Type$getMark(descriptor);
			return _Utils_eq(mark, $author$project$Compiler$Type$Type$occursMark) ? $author$project$Compiler$Type$Type$return($author$project$Compiler$Type$Error$Infinite) : A2(
				$author$project$Compiler$Type$Type$bind,
				$author$project$Compiler$Type$Type$liftIO(
					A2(
						$author$project$Compiler$Type$UnionFind$modify,
						variable,
						$author$project$Compiler$Type$Type$setMark($author$project$Compiler$Type$Type$occursMark))),
				function (_v0) {
					return A2(
						$author$project$Compiler$Type$Type$bind,
						A2(
							$author$project$Compiler$Type$Type$contentToErrorType,
							variable,
							$author$project$Compiler$Type$Type$getContent(descriptor)),
						function (errType) {
							return A2(
								$author$project$Compiler$Type$Type$bind,
								$author$project$Compiler$Type$Type$liftIO(
									A2(
										$author$project$Compiler$Type$UnionFind$modify,
										variable,
										$author$project$Compiler$Type$Type$setMark(mark))),
								function (_v1) {
									return $author$project$Compiler$Type$Type$return(errType);
								});
						});
				});
		});
};
var $author$project$Compiler$Type$Type$toErrorType = function (variable) {
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		A2($author$project$Compiler$Type$Type$getVarNames, variable, $author$project$Extra$Type$Map$empty),
		function (userNames) {
			return A2(
				$author$project$Compiler$Type$Type$evalStateT,
				$author$project$Compiler$Type$Type$variableToErrorType(variable),
				$author$project$Compiler$Type$Type$makeNameState(userNames));
		});
};
var $the_sett$elm_pretty_printer$Internals$NLine = F3(
	function (a, b, c) {
		return {$: 'NLine', a: a, b: b, c: c};
	});
var $the_sett$elm_pretty_printer$Internals$NNil = {$: 'NNil'};
var $the_sett$elm_pretty_printer$Internals$NText = F3(
	function (a, b, c) {
		return {$: 'NText', a: a, b: b, c: c};
	});
var $the_sett$elm_pretty_printer$Internals$fits = F2(
	function (w, normal) {
		fits:
		while (true) {
			if (w < 0) {
				return false;
			} else {
				switch (normal.$) {
					case 'NNil':
						return true;
					case 'NText':
						var text = normal.a;
						var innerNormal = normal.b;
						var $temp$w = w - $elm$core$String$length(text),
							$temp$normal = innerNormal(_Utils_Tuple0);
						w = $temp$w;
						normal = $temp$normal;
						continue fits;
					default:
						return true;
				}
			}
		}
	});
var $the_sett$elm_pretty_printer$Internals$better = F4(
	function (w, k, doc, doc2Fn) {
		return A2($the_sett$elm_pretty_printer$Internals$fits, w - k, doc) ? doc : doc2Fn(_Utils_Tuple0);
	});
var $the_sett$elm_pretty_printer$Internals$best = F3(
	function (width, startCol, x) {
		var be = F3(
			function (w, k, docs) {
				be:
				while (true) {
					if (!docs.b) {
						return $the_sett$elm_pretty_printer$Internals$NNil;
					} else {
						switch (docs.a.b.$) {
							case 'Empty':
								var _v1 = docs.a;
								var i = _v1.a;
								var _v2 = _v1.b;
								var ds = docs.b;
								var $temp$w = w,
									$temp$k = k,
									$temp$docs = ds;
								w = $temp$w;
								k = $temp$k;
								docs = $temp$docs;
								continue be;
							case 'Concatenate':
								var _v3 = docs.a;
								var i = _v3.a;
								var _v4 = _v3.b;
								var doc = _v4.a;
								var doc2 = _v4.b;
								var ds = docs.b;
								var $temp$w = w,
									$temp$k = k,
									$temp$docs = A2(
									$elm$core$List$cons,
									_Utils_Tuple2(
										i,
										doc(_Utils_Tuple0)),
									A2(
										$elm$core$List$cons,
										_Utils_Tuple2(
											i,
											doc2(_Utils_Tuple0)),
										ds));
								w = $temp$w;
								k = $temp$k;
								docs = $temp$docs;
								continue be;
							case 'Nest':
								var _v5 = docs.a;
								var i = _v5.a;
								var _v6 = _v5.b;
								var j = _v6.a;
								var doc = _v6.b;
								var ds = docs.b;
								var $temp$w = w,
									$temp$k = k,
									$temp$docs = A2(
									$elm$core$List$cons,
									_Utils_Tuple2(
										i + j,
										doc(_Utils_Tuple0)),
									ds);
								w = $temp$w;
								k = $temp$k;
								docs = $temp$docs;
								continue be;
							case 'Text':
								var _v7 = docs.a;
								var i = _v7.a;
								var _v8 = _v7.b;
								var text = _v8.a;
								var maybeTag = _v8.b;
								var ds = docs.b;
								return A3(
									$the_sett$elm_pretty_printer$Internals$NText,
									text,
									function (_v9) {
										return A3(
											be,
											w,
											k + $elm$core$String$length(text),
											ds);
									},
									maybeTag);
							case 'Line':
								var _v10 = docs.a;
								var i = _v10.a;
								var _v11 = _v10.b;
								var vsep = _v11.b;
								var ds = docs.b;
								return A3(
									$the_sett$elm_pretty_printer$Internals$NLine,
									i,
									vsep,
									function (_v12) {
										return A3(
											be,
											w,
											i + $elm$core$String$length(vsep),
											ds);
									});
							case 'Union':
								var _v13 = docs.a;
								var i = _v13.a;
								var _v14 = _v13.b;
								var doc = _v14.a;
								var doc2 = _v14.b;
								var ds = docs.b;
								return A4(
									$the_sett$elm_pretty_printer$Internals$better,
									w,
									k,
									A3(
										be,
										w,
										k,
										A2(
											$elm$core$List$cons,
											_Utils_Tuple2(i, doc),
											ds)),
									function (_v15) {
										return A3(
											be,
											w,
											k,
											A2(
												$elm$core$List$cons,
												_Utils_Tuple2(i, doc2),
												ds));
									});
							case 'Nesting':
								var _v16 = docs.a;
								var i = _v16.a;
								var fn = _v16.b.a;
								var ds = docs.b;
								var $temp$w = w,
									$temp$k = k,
									$temp$docs = A2(
									$elm$core$List$cons,
									_Utils_Tuple2(
										i,
										fn(i)),
									ds);
								w = $temp$w;
								k = $temp$k;
								docs = $temp$docs;
								continue be;
							default:
								var _v17 = docs.a;
								var i = _v17.a;
								var fn = _v17.b.a;
								var ds = docs.b;
								var $temp$w = w,
									$temp$k = k,
									$temp$docs = A2(
									$elm$core$List$cons,
									_Utils_Tuple2(
										i,
										fn(k)),
									ds);
								w = $temp$w;
								k = $temp$k;
								docs = $temp$docs;
								continue be;
						}
					}
				}
			});
		return A3(
			be,
			width,
			startCol,
			_List_fromArray(
				[
					_Utils_Tuple2(0, x)
				]));
	});
var $the_sett$elm_pretty_printer$Internals$layout = function (normal) {
	var layoutInner = F2(
		function (normal2, acc) {
			layoutInner:
			while (true) {
				switch (normal2.$) {
					case 'NNil':
						return acc;
					case 'NText':
						var text = normal2.a;
						var innerNormal = normal2.b;
						var maybeTag = normal2.c;
						var $temp$normal2 = innerNormal(_Utils_Tuple0),
							$temp$acc = A2($elm$core$List$cons, text, acc);
						normal2 = $temp$normal2;
						acc = $temp$acc;
						continue layoutInner;
					default:
						var i = normal2.a;
						var sep = normal2.b;
						var innerNormal = normal2.c;
						var norm = innerNormal(_Utils_Tuple0);
						if (norm.$ === 'NLine') {
							var $temp$normal2 = innerNormal(_Utils_Tuple0),
								$temp$acc = A2($elm$core$List$cons, '\n' + sep, acc);
							normal2 = $temp$normal2;
							acc = $temp$acc;
							continue layoutInner;
						} else {
							var $temp$normal2 = innerNormal(_Utils_Tuple0),
								$temp$acc = A2(
								$elm$core$List$cons,
								'\n' + (A2($the_sett$elm_pretty_printer$Internals$copy, i, ' ') + sep),
								acc);
							normal2 = $temp$normal2;
							acc = $temp$acc;
							continue layoutInner;
						}
				}
			}
		});
	return $elm$core$String$concat(
		$elm$core$List$reverse(
			A2(layoutInner, normal, _List_Nil)));
};
var $the_sett$elm_pretty_printer$Pretty$pretty = F2(
	function (w, doc) {
		return $the_sett$elm_pretty_printer$Internals$layout(
			A3($the_sett$elm_pretty_printer$Internals$best, w, 0, doc));
	});
var $author$project$Extra$Data$Pretty$pretty = F2(
	function (n, doc) {
		return A2($the_sett$elm_pretty_printer$Pretty$pretty, n, doc);
	});
var $author$project$Compiler$Reporting$Doc$toString = function (doc) {
	return A2($author$project$Extra$Data$Pretty$pretty, 80, doc);
};
var $author$project$Compiler$Type$Solve$isGeneric = function (_var) {
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$UnionFind$get(_var),
		function (_v0) {
			var rank = _v0.b;
			return _Utils_eq(rank, $author$project$Compiler$Type$Type$noRank) ? $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0) : A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$Type$toErrorType(_var),
				function (tipe) {
					return _Debug_todo(
						'Compiler.Type.Solve',
						{
							start: {line: 238, column: 7},
							end: {line: 238, column: 17}
						})(
						'You ran into a compiler bug. Here are some details for the developers:\n\n' + ('    ' + ($author$project$Compiler$Reporting$Doc$toString(
							A3($author$project$Compiler$Type$Error$toDoc, $author$project$Compiler$Reporting$Render$Type$Localizer$empty, $author$project$Compiler$Reporting$Render$Type$None, tipe)) + (' [rank = ' + ($elm$core$String$fromInt(rank) + (']\n\n' + ('Please create an <http://sscce.org/> and then report it\n' + 'at <https://github.com/elm/compiler/issues>\n\n')))))));
				});
		});
};
var $author$project$Extra$System$MVector$length = function (_v0) {
	var len = _v0.b;
	return len;
};
var $author$project$Extra$System$IO$Pure$liftM = F2(
	function (f, ma) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			ma,
			function (a) {
				return $author$project$Extra$System$IO$Pure$return(
					f(a));
			});
	});
var $author$project$Extra$System$IO$Pure$liftM2 = F3(
	function (f, ma, mb) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			ma,
			function (a) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					mb,
					function (b) {
						return $author$project$Extra$System$IO$Pure$return(
							A2(f, a, b));
					});
			});
	});
var $author$project$Extra$System$IO$Pure$liftM3 = F4(
	function (f, ma, mb, mc) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			ma,
			function (a) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					mb,
					function (b) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							mc,
							function (c) {
								return $author$project$Extra$System$IO$Pure$return(
									A3(f, a, b, c));
							});
					});
			});
	});
var $author$project$Compiler$Type$Solve$traverseFlatType = F2(
	function (f, flatType) {
		switch (flatType.$) {
			case 'App1':
				var home = flatType.a;
				var name = flatType.b;
				var args = flatType.c;
				return A2(
					$author$project$Extra$System$IO$Pure$liftM,
					A2($author$project$Compiler$Type$Type$App1, home, name),
					A2($author$project$Extra$System$IO$Pure$traverseList, f, args));
			case 'Fun1':
				var a = flatType.a;
				var b = flatType.b;
				return A3(
					$author$project$Extra$System$IO$Pure$liftM2,
					$author$project$Compiler$Type$Type$Fun1,
					f(a),
					f(b));
			case 'EmptyRecord1':
				return $author$project$Extra$System$IO$Pure$pure($author$project$Compiler$Type$Type$EmptyRecord1);
			case 'Record1':
				var fields = flatType.a;
				var ext = flatType.b;
				return A3(
					$author$project$Extra$System$IO$Pure$liftM2,
					$author$project$Compiler$Type$Type$Record1,
					A2($author$project$Extra$System$IO$Pure$traverseMap, f, fields),
					f(ext));
			case 'Unit1':
				return $author$project$Extra$System$IO$Pure$pure($author$project$Compiler$Type$Type$Unit1);
			default:
				var a = flatType.a;
				var b = flatType.b;
				var cs = flatType.c;
				return A4(
					$author$project$Extra$System$IO$Pure$liftM3,
					$author$project$Compiler$Type$Type$Tuple1,
					f(a),
					f(b),
					A4($author$project$Extra$Type$Maybe$traverse, $author$project$Extra$System$IO$Pure$pure, $author$project$Extra$System$IO$Pure$fmap, f, cs));
		}
	});
var $author$project$Compiler$Type$Solve$makeCopyHelp = F3(
	function (maxRank, pools, variable) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$get(variable),
			function (_v0) {
				var content = _v0.a;
				var rank = _v0.b;
				var maybeCopy = _v0.d;
				if (maybeCopy.$ === 'Just') {
					var copy = maybeCopy.a;
					return $author$project$Extra$System$IO$Pure$return(copy);
				} else {
					if (!_Utils_eq(rank, $author$project$Compiler$Type$Type$noRank)) {
						return $author$project$Extra$System$IO$Pure$return(variable);
					} else {
						var makeDescriptor = function (c) {
							return A4($author$project$Compiler$Type$Type$Descriptor, c, maxRank, $author$project$Compiler$Type$Type$noMark, $elm$core$Maybe$Nothing);
						};
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$UnionFind$fresh(
								makeDescriptor(content)),
							function (copy) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									$author$project$Compiler$Type$Solve$liftP(
										A3(
											$author$project$Extra$System$MVector$modify,
											pools,
											function (l) {
												return A2($elm$core$List$cons, copy, l);
											},
											maxRank)),
									function (_v2) {
										return A2(
											$author$project$Extra$System$IO$Pure$bind,
											A2(
												$author$project$Compiler$Type$UnionFind$set,
												variable,
												A4(
													$author$project$Compiler$Type$Type$Descriptor,
													content,
													rank,
													$author$project$Compiler$Type$Type$noMark,
													$elm$core$Maybe$Just(copy))),
											function (_v3) {
												switch (content.$) {
													case 'Structure':
														var term = content.a;
														return A2(
															$author$project$Extra$System$IO$Pure$bind,
															A2(
																$author$project$Compiler$Type$Solve$traverseFlatType,
																A2($author$project$Compiler$Type$Solve$makeCopyHelp, maxRank, pools),
																term),
															function (newTerm) {
																return A2(
																	$author$project$Extra$System$IO$Pure$bind,
																	A2(
																		$author$project$Compiler$Type$UnionFind$set,
																		copy,
																		makeDescriptor(
																			$author$project$Compiler$Type$Type$Structure(newTerm))),
																	function (_v5) {
																		return $author$project$Extra$System$IO$Pure$return(copy);
																	});
															});
													case 'FlexVar':
														return $author$project$Extra$System$IO$Pure$return(copy);
													case 'FlexSuper':
														return $author$project$Extra$System$IO$Pure$return(copy);
													case 'RigidVar':
														var name = content.a;
														return A2(
															$author$project$Extra$System$IO$Pure$bind,
															A2(
																$author$project$Compiler$Type$UnionFind$set,
																copy,
																makeDescriptor(
																	$author$project$Compiler$Type$Type$FlexVar(
																		$elm$core$Maybe$Just(name)))),
															function (_v6) {
																return $author$project$Extra$System$IO$Pure$return(copy);
															});
													case 'RigidSuper':
														var _super = content.a;
														var name = content.b;
														return A2(
															$author$project$Extra$System$IO$Pure$bind,
															A2(
																$author$project$Compiler$Type$UnionFind$set,
																copy,
																makeDescriptor(
																	A2(
																		$author$project$Compiler$Type$Type$FlexSuper,
																		_super,
																		$elm$core$Maybe$Just(name)))),
															function (_v7) {
																return $author$project$Extra$System$IO$Pure$return(copy);
															});
													case 'Alias':
														var home = content.a;
														var name = content.b;
														var args = content.c;
														var realType = content.d;
														return A2(
															$author$project$Extra$System$IO$Pure$bind,
															A2(
																$author$project$Extra$System$IO$Pure$traverseList,
																A2(
																	$author$project$Extra$Type$Tuple$traverseSecond,
																	$author$project$Extra$System$IO$Pure$fmap,
																	A2($author$project$Compiler$Type$Solve$makeCopyHelp, maxRank, pools)),
																args),
															function (newArgs) {
																return A2(
																	$author$project$Extra$System$IO$Pure$bind,
																	A3($author$project$Compiler$Type$Solve$makeCopyHelp, maxRank, pools, realType),
																	function (newRealType) {
																		return A2(
																			$author$project$Extra$System$IO$Pure$bind,
																			A2(
																				$author$project$Compiler$Type$UnionFind$set,
																				copy,
																				makeDescriptor(
																					A4($author$project$Compiler$Type$Type$Alias, home, name, newArgs, newRealType))),
																			function (_v8) {
																				return $author$project$Extra$System$IO$Pure$return(copy);
																			});
																	});
															});
													default:
														return $author$project$Extra$System$IO$Pure$return(copy);
												}
											});
									});
							});
					}
				}
			});
	});
var $author$project$Extra$System$IO$Pure$mapMMapHelp_ = F2(
	function (callback, _v0) {
		var list = _v0.a;
		var result = _v0.b;
		if (!list.b) {
			return A2($author$project$Extra$System$IO$Pure$fmap, $author$project$Extra$System$IO$Pure$Done, result);
		} else {
			var _v2 = list.a;
			var a = _v2.b;
			var rest = list.b;
			return A2(
				$author$project$Extra$System$IO$Pure$fmap,
				function (_v3) {
					return $author$project$Extra$System$IO$Pure$Loop(
						_Utils_Tuple2(rest, result));
				},
				callback(a));
		}
	});
var $author$project$Extra$System$IO$Pure$mapMMap_ = F2(
	function (callback, map) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Extra$System$IO$Pure$mapMMapHelp_(callback),
			_Utils_Tuple2(
				$author$project$Extra$Type$Map$toList(map),
				$author$project$Extra$System$IO$Pure$pure(_Utils_Tuple0)));
	});
var $author$project$Compiler$Type$Solve$restore = function (variable) {
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$UnionFind$get(variable),
		function (_v8) {
			var content = _v8.a;
			var maybeCopy = _v8.d;
			if (maybeCopy.$ === 'Nothing') {
				return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
			} else {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Compiler$Type$UnionFind$set,
						variable,
						A4($author$project$Compiler$Type$Type$Descriptor, content, $author$project$Compiler$Type$Type$noRank, $author$project$Compiler$Type$Type$noMark, $elm$core$Maybe$Nothing)),
					function (_v10) {
						return $author$project$Compiler$Type$Solve$restoreContent(content);
					});
			}
		});
};
var $author$project$Compiler$Type$Solve$restoreContent = function (content) {
	switch (content.$) {
		case 'FlexVar':
			return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
		case 'FlexSuper':
			return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
		case 'RigidVar':
			return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
		case 'RigidSuper':
			return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
		case 'Structure':
			var term = content.a;
			switch (term.$) {
				case 'App1':
					var args = term.c;
					return A2($author$project$Extra$System$IO$Pure$mapMList_, $author$project$Compiler$Type$Solve$restore, args);
				case 'Fun1':
					var arg = term.a;
					var result = term.b;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$Solve$restore(arg),
						function (_v2) {
							return $author$project$Compiler$Type$Solve$restore(result);
						});
				case 'EmptyRecord1':
					return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
				case 'Record1':
					var fields = term.a;
					var ext = term.b;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2($author$project$Extra$System$IO$Pure$mapMMap_, $author$project$Compiler$Type$Solve$restore, fields),
						function (_v3) {
							return $author$project$Compiler$Type$Solve$restore(ext);
						});
				case 'Unit1':
					return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
				default:
					var a = term.a;
					var b = term.b;
					var maybeC = term.c;
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$Solve$restore(a),
						function (_v4) {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Compiler$Type$Solve$restore(b),
								function (_v5) {
									if (maybeC.$ === 'Nothing') {
										return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
									} else {
										var c = maybeC.a;
										return $author$project$Compiler$Type$Solve$restore(c);
									}
								});
						});
			}
		case 'Alias':
			var args = content.c;
			var _var = content.d;
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2(
					$author$project$Extra$System$IO$Pure$mapMList_,
					A2($author$project$Extra$Type$Tuple$traverseSecond, $author$project$Extra$System$IO$Pure$fmap, $author$project$Compiler$Type$Solve$restore),
					args),
				function (_v7) {
					return $author$project$Compiler$Type$Solve$restore(_var);
				});
		default:
			return $author$project$Extra$System$IO$Pure$return(_Utils_Tuple0);
	}
};
var $author$project$Compiler$Type$Solve$makeCopy = F3(
	function (rank, pools, _var) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A3($author$project$Compiler$Type$Solve$makeCopyHelp, rank, pools, _var),
			function (copy) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Solve$restore(_var),
					function (_v0) {
						return $author$project$Extra$System$IO$Pure$return(copy);
					});
			});
	});
var $author$project$Compiler$Type$Type$Error = {$: 'Error'};
var $author$project$Compiler$Reporting$Error$Type$InfiniteType = F3(
	function (a, b, c) {
		return {$: 'InfiniteType', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Occurs$occursHelp = F3(
	function (seen, _var, foundCycle) {
		return A2($author$project$Extra$Type$List$elem, _var, seen) ? $author$project$Extra$System$IO$Pure$return(true) : A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$get(_var),
			function (_v0) {
				var content = _v0.a;
				switch (content.$) {
					case 'FlexVar':
						return $author$project$Extra$System$IO$Pure$return(foundCycle);
					case 'FlexSuper':
						return $author$project$Extra$System$IO$Pure$return(foundCycle);
					case 'RigidVar':
						return $author$project$Extra$System$IO$Pure$return(foundCycle);
					case 'RigidSuper':
						return $author$project$Extra$System$IO$Pure$return(foundCycle);
					case 'Structure':
						var term = content.a;
						var newSeen = A2($elm$core$List$cons, _var, seen);
						switch (term.$) {
							case 'App1':
								var args = term.c;
								return A3(
									$author$project$Extra$System$IO$Pure$foldrMList,
									$author$project$Compiler$Type$Occurs$occursHelp(newSeen),
									foundCycle,
									args);
							case 'Fun1':
								var a = term.a;
								var b = term.b;
								return A2(
									$author$project$Extra$System$IO$Pure$andThen,
									A2($author$project$Compiler$Type$Occurs$occursHelp, newSeen, a),
									A3($author$project$Compiler$Type$Occurs$occursHelp, newSeen, b, foundCycle));
							case 'EmptyRecord1':
								return $author$project$Extra$System$IO$Pure$return(foundCycle);
							case 'Record1':
								var fields = term.a;
								var ext = term.b;
								return A2(
									$author$project$Extra$System$IO$Pure$andThen,
									A2($author$project$Compiler$Type$Occurs$occursHelp, newSeen, ext),
									A3(
										$author$project$Extra$System$IO$Pure$foldrMList,
										$author$project$Compiler$Type$Occurs$occursHelp(newSeen),
										foundCycle,
										$author$project$Extra$Type$Map$elems(fields)));
							case 'Unit1':
								return $author$project$Extra$System$IO$Pure$return(foundCycle);
							default:
								var a = term.a;
								var b = term.b;
								var maybeC = term.c;
								if (maybeC.$ === 'Nothing') {
									return A2(
										$author$project$Extra$System$IO$Pure$andThen,
										A2($author$project$Compiler$Type$Occurs$occursHelp, newSeen, a),
										A3($author$project$Compiler$Type$Occurs$occursHelp, newSeen, b, foundCycle));
								} else {
									var c = maybeC.a;
									return A2(
										$author$project$Extra$System$IO$Pure$andThen,
										A2($author$project$Compiler$Type$Occurs$occursHelp, newSeen, a),
										A2(
											$author$project$Extra$System$IO$Pure$andThen,
											A2($author$project$Compiler$Type$Occurs$occursHelp, newSeen, b),
											A3($author$project$Compiler$Type$Occurs$occursHelp, newSeen, c, foundCycle)));
								}
						}
					case 'Alias':
						var args = content.c;
						return A3(
							$author$project$Extra$System$IO$Pure$foldrMList,
							$author$project$Compiler$Type$Occurs$occursHelp(
								A2($elm$core$List$cons, _var, seen)),
							foundCycle,
							A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, args));
					default:
						return $author$project$Extra$System$IO$Pure$return(foundCycle);
				}
			});
	});
var $author$project$Compiler$Type$Occurs$occurs = function (_var) {
	return A3($author$project$Compiler$Type$Occurs$occursHelp, _List_Nil, _var, false);
};
var $author$project$Compiler$Type$Solve$occurs = F2(
	function (state, _v0) {
		var name = _v0.a;
		var _v1 = _v0.b;
		var region = _v1.a;
		var variable = _v1.b;
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$Occurs$occurs(variable),
			function (hasOccurred) {
				return hasOccurred ? A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Type$toErrorType(variable),
					function (errorType) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$UnionFind$get(variable),
							function (_v2) {
								var rank = _v2.b;
								var mark = _v2.c;
								var copy = _v2.d;
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2(
										$author$project$Compiler$Type$UnionFind$set,
										variable,
										A4($author$project$Compiler$Type$Type$Descriptor, $author$project$Compiler$Type$Type$Error, rank, mark, copy)),
									function (_v3) {
										return $author$project$Extra$System$IO$Pure$return(
											A2(
												$author$project$Compiler$Type$Solve$addError,
												state,
												A3($author$project$Compiler$Reporting$Error$Type$InfiniteType, region, name, errorType)));
									});
							});
					}) : $author$project$Extra$System$IO$Pure$return(state);
			});
	});
var $author$project$Compiler$Type$Solve$patternExpectationToVariable = F3(
	function (rank, pools, expectation) {
		return A3(
			$author$project$Compiler$Type$Solve$typeToVariable,
			rank,
			pools,
			function () {
				if (expectation.$ === 'PNoExpectation') {
					var tipe = expectation.a;
					return tipe;
				} else {
					var tipe = expectation.c;
					return tipe;
				}
			}());
	});
var $author$project$Compiler$Reporting$Error$Type$ptypeReplace = F2(
	function (expectation, tipe) {
		if (expectation.$ === 'PNoExpectation') {
			return $author$project$Compiler$Reporting$Error$Type$PNoExpectation(tipe);
		} else {
			var region = expectation.a;
			var context = expectation.b;
			return A3($author$project$Compiler$Reporting$Error$Type$PFromContext, region, context, tipe);
		}
	});
var $author$project$Compiler$Type$Solve$setEnv = F2(
	function (env, _v0) {
		var a = _v0.b;
		var b = _v0.c;
		return A3($author$project$Compiler$Type$Solve$State, env, a, b);
	});
var $author$project$Compiler$Type$Solve$srcFieldTypeToVar = F4(
	function (rank, pools, flexVars, _v3) {
		var srcTipe = _v3.b;
		return A4($author$project$Compiler$Type$Solve$srcTypeToVar, rank, pools, flexVars, srcTipe);
	});
var $author$project$Compiler$Type$Solve$srcTypeToVar = F4(
	function (rank, pools, flexVars, srcType) {
		var go = A3($author$project$Compiler$Type$Solve$srcTypeToVar, rank, pools, flexVars);
		switch (srcType.$) {
			case 'TLambda':
				var argument = srcType.a;
				var result = srcType.b;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					go(argument),
					function (argVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(result),
							function (resultVar) {
								return A3(
									$author$project$Compiler$Type$Solve$register,
									rank,
									pools,
									$author$project$Compiler$Type$Type$Structure(
										A2($author$project$Compiler$Type$Type$Fun1, argVar, resultVar)));
							});
					});
			case 'TVar':
				var name = srcType.a;
				return $author$project$Extra$System$IO$Pure$return(
					A2($author$project$Extra$Type$Map$ex, flexVars, name));
			case 'TType':
				var home = srcType.a;
				var name = srcType.b;
				var args = srcType.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2($author$project$Extra$System$IO$Pure$traverseList, go, args),
					function (argVars) {
						return A3(
							$author$project$Compiler$Type$Solve$register,
							rank,
							pools,
							$author$project$Compiler$Type$Type$Structure(
								A3($author$project$Compiler$Type$Type$App1, home, name, argVars)));
					});
			case 'TRecord':
				var fields = srcType.a;
				var maybeExt = srcType.b;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$traverseMap,
						A3($author$project$Compiler$Type$Solve$srcFieldTypeToVar, rank, pools, flexVars),
						fields),
					function (fieldVars) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							function () {
								if (maybeExt.$ === 'Nothing') {
									return A3($author$project$Compiler$Type$Solve$register, rank, pools, $author$project$Compiler$Type$Solve$emptyRecord1);
								} else {
									var ext = maybeExt.a;
									return $author$project$Extra$System$IO$Pure$return(
										A2($author$project$Extra$Type$Map$ex, flexVars, ext));
								}
							}(),
							function (extVar) {
								return A3(
									$author$project$Compiler$Type$Solve$register,
									rank,
									pools,
									$author$project$Compiler$Type$Type$Structure(
										A2($author$project$Compiler$Type$Type$Record1, fieldVars, extVar)));
							});
					});
			case 'TUnit':
				return A3($author$project$Compiler$Type$Solve$register, rank, pools, $author$project$Compiler$Type$Solve$unit1);
			case 'TTuple':
				var a = srcType.a;
				var b = srcType.b;
				var c = srcType.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					go(a),
					function (aVar) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							go(b),
							function (bVar) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A4($author$project$Extra$Type$Maybe$traverse, $author$project$Extra$System$IO$Pure$pure, $author$project$Extra$System$IO$Pure$fmap, go, c),
									function (cVar) {
										return A3(
											$author$project$Compiler$Type$Solve$register,
											rank,
											pools,
											$author$project$Compiler$Type$Type$Structure(
												A3($author$project$Compiler$Type$Type$Tuple1, aVar, bVar, cVar)));
									});
							});
					});
			default:
				var home = srcType.a;
				var name = srcType.b;
				var args = srcType.c;
				var aliasType = srcType.d;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A2(
						$author$project$Extra$System$IO$Pure$traverseList,
						A2($author$project$Extra$Type$Tuple$traverseSecond, $author$project$Extra$System$IO$Pure$fmap, go),
						args),
					function (argVars) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							function () {
								if (aliasType.$ === 'Holey') {
									var tipe = aliasType.a;
									return A4(
										$author$project$Compiler$Type$Solve$srcTypeToVar,
										rank,
										pools,
										$author$project$Extra$Type$Map$fromList(argVars),
										tipe);
								} else {
									var tipe = aliasType.a;
									return go(tipe);
								}
							}(),
							function (aliasVar) {
								return A3(
									$author$project$Compiler$Type$Solve$register,
									rank,
									pools,
									A4($author$project$Compiler$Type$Type$Alias, home, name, argVars, aliasVar));
							});
					});
		}
	});
var $author$project$Compiler$Type$Solve$srcTypeToVariable = F4(
	function (rank, pools, freeVars, srcType) {
		var nameToContent = function (name) {
			return $author$project$Compiler$Data$Name$isNumberType(name) ? A2(
				$author$project$Compiler$Type$Type$FlexSuper,
				$author$project$Compiler$Type$Type$Number,
				$elm$core$Maybe$Just(name)) : ($author$project$Compiler$Data$Name$isComparableType(name) ? A2(
				$author$project$Compiler$Type$Type$FlexSuper,
				$author$project$Compiler$Type$Type$Comparable,
				$elm$core$Maybe$Just(name)) : ($author$project$Compiler$Data$Name$isAppendableType(name) ? A2(
				$author$project$Compiler$Type$Type$FlexSuper,
				$author$project$Compiler$Type$Type$Appendable,
				$elm$core$Maybe$Just(name)) : ($author$project$Compiler$Data$Name$isCompappendType(name) ? A2(
				$author$project$Compiler$Type$Type$FlexSuper,
				$author$project$Compiler$Type$Type$CompAppend,
				$elm$core$Maybe$Just(name)) : $author$project$Compiler$Type$Type$FlexVar(
				$elm$core$Maybe$Just(name)))));
		};
		var makeVar = F2(
			function (name, _v1) {
				return $author$project$Compiler$Type$UnionFind$fresh(
					A4(
						$author$project$Compiler$Type$Type$Descriptor,
						nameToContent(name),
						rank,
						$author$project$Compiler$Type$Type$noMark,
						$elm$core$Maybe$Nothing));
			});
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			A2($author$project$Extra$System$IO$Pure$traverseWithKey, makeVar, freeVars),
			function (flexVars) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Solve$liftP(
						A3(
							$author$project$Extra$System$MVector$modify,
							pools,
							function (l) {
								return _Utils_ap(
									$author$project$Extra$Type$Map$elems(flexVars),
									l);
							},
							rank)),
					function (_v0) {
						return A4($author$project$Compiler$Type$Solve$srcTypeToVar, rank, pools, flexVars, srcType);
					});
			});
	});
var $author$project$Compiler$Reporting$Annotation$traverse = F3(
	function (pFmap, func, _v0) {
		var region = _v0.a;
		var value = _v0.b;
		return A2(
			pFmap,
			$author$project$Compiler$Reporting$Annotation$At(region),
			func(value));
	});
var $author$project$Compiler$Reporting$Error$Type$typeReplace = F2(
	function (expectation, tipe) {
		switch (expectation.$) {
			case 'NoExpectation':
				return $author$project$Compiler$Reporting$Error$Type$NoExpectation(tipe);
			case 'FromContext':
				var region = expectation.a;
				var context = expectation.b;
				return A3($author$project$Compiler$Reporting$Error$Type$FromContext, region, context, tipe);
			default:
				var name = expectation.a;
				var arity = expectation.b;
				var context = expectation.c;
				return A4($author$project$Compiler$Reporting$Error$Type$FromAnnotation, name, arity, context, tipe);
		}
	});
var $author$project$Compiler$Type$Unify$CErr = F3(
	function (a, b, c) {
		return {$: 'CErr', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Unify$errorDescriptor = A4($author$project$Compiler$Type$Type$Descriptor, $author$project$Compiler$Type$Type$Error, $author$project$Compiler$Type$Type$noRank, $author$project$Compiler$Type$Type$noMark, $elm$core$Maybe$Nothing);
var $author$project$Compiler$Type$Unify$Context = F4(
	function (a, b, c, d) {
		return {$: 'Context', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Type$Unify$Unify = function (a) {
	return {$: 'Unify', a: a};
};
var $author$project$Compiler$Type$Error$isChar = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$char) && _Utils_eq(name, $author$project$Compiler$Data$Name$char);
	});
var $author$project$Compiler$Type$Unify$isNumber = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) && (_Utils_eq(name, $author$project$Compiler$Data$Name$int) || _Utils_eq(name, $author$project$Compiler$Data$Name$float));
	});
var $author$project$Compiler$Type$Error$isString = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$string) && _Utils_eq(name, $author$project$Compiler$Data$Name$string);
	});
var $author$project$Compiler$Type$Unify$atomMatchesSuper = F3(
	function (_super, home, name) {
		switch (_super.$) {
			case 'Number':
				return A2($author$project$Compiler$Type$Unify$isNumber, home, name);
			case 'Comparable':
				return A2($author$project$Compiler$Type$Unify$isNumber, home, name) || (A2($author$project$Compiler$Type$Error$isString, home, name) || A2($author$project$Compiler$Type$Error$isChar, home, name));
			case 'Appendable':
				return A2($author$project$Compiler$Type$Error$isString, home, name);
			default:
				return A2($author$project$Compiler$Type$Error$isString, home, name);
		}
	});
var $author$project$Compiler$Type$Unify$bind = F2(
	function (_v0, callback) {
		var ka = _v0.a;
		return $author$project$Compiler$Type$Unify$Unify(
			F3(
				function (vars, ok, err) {
					var ok1 = F2(
						function (vars1, a) {
							var _v1 = callback(a);
							var kb = _v1.a;
							return A3(kb, vars1, ok, err);
						});
					return A3(ka, vars, ok1, err);
				}));
	});
var $author$project$Compiler$Type$Unify$combineRigidSupers = F2(
	function (rigid, flex) {
		return _Utils_eq(rigid, flex) || ((_Utils_eq(rigid, $author$project$Compiler$Type$Type$Number) && _Utils_eq(flex, $author$project$Compiler$Type$Type$Comparable)) || (_Utils_eq(rigid, $author$project$Compiler$Type$Type$CompAppend) && (_Utils_eq(flex, $author$project$Compiler$Type$Type$Comparable) || _Utils_eq(flex, $author$project$Compiler$Type$Type$Appendable))));
	});
var $author$project$Compiler$Type$Unify$comparableOccursCheck = function (_v0) {
	var _var = _v0.c;
	return $author$project$Compiler$Type$Unify$Unify(
		F3(
			function (vars, ok, err) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$Occurs$occurs(_var),
					function (hasOccurred) {
						return hasOccurred ? A2(err, vars, _Utils_Tuple0) : A2(ok, vars, _Utils_Tuple0);
					});
			}));
};
var $author$project$Compiler$Type$Unify$register = function (mkVar) {
	return $author$project$Compiler$Type$Unify$Unify(
		F3(
			function (vars, ok, _v0) {
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					mkVar,
					function (_var) {
						return A2(
							ok,
							A2($elm$core$List$cons, _var, vars),
							_var);
					});
			}));
};
var $author$project$Compiler$Type$Unify$fresh = F2(
	function (_v0, content) {
		var _v1 = _v0.b;
		var rank1 = _v1.b;
		var _v2 = _v0.d;
		var rank2 = _v2.b;
		return $author$project$Compiler$Type$Unify$register(
			$author$project$Compiler$Type$UnionFind$fresh(
				A4(
					$author$project$Compiler$Type$Type$Descriptor,
					content,
					A2($elm$core$Basics$min, rank1, rank2),
					$author$project$Compiler$Type$Type$noMark,
					$elm$core$Maybe$Nothing)));
	});
var $author$project$Compiler$Type$Unify$RecordStructure = F2(
	function (a, b) {
		return {$: 'RecordStructure', a: a, b: b};
	});
var $author$project$Compiler$Type$Unify$gatherFields = F2(
	function (fields, variable) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$get(variable),
			function (_v0) {
				var content = _v0.a;
				_v1$2:
				while (true) {
					switch (content.$) {
						case 'Structure':
							if (content.a.$ === 'Record1') {
								var _v2 = content.a;
								var subFields = _v2.a;
								var subExt = _v2.b;
								return A2(
									$author$project$Compiler$Type$Unify$gatherFields,
									A2($author$project$Extra$Type$Map$union, fields, subFields),
									subExt);
							} else {
								break _v1$2;
							}
						case 'Alias':
							var _var = content.d;
							return A2($author$project$Compiler$Type$Unify$gatherFields, fields, _var);
						default:
							break _v1$2;
					}
				}
				return $author$project$Extra$System$IO$Pure$return(
					A2($author$project$Compiler$Type$Unify$RecordStructure, fields, variable));
			});
	});
var $author$project$Compiler$Type$Unify$getFirst = function (_v0) {
	var first = _v0.a;
	return first;
};
var $author$project$Compiler$Type$Unify$getSecond = function (_v0) {
	var second = _v0.c;
	return second;
};
var $author$project$Compiler$Type$Unify$andMap = F2(
	function (_v0, _v1) {
		var kv = _v0.a;
		var kf = _v1.a;
		return $author$project$Compiler$Type$Unify$Unify(
			F3(
				function (vars, ok, err) {
					var ok1 = F2(
						function (vars1, func) {
							var ok2 = F2(
								function (vars2, value) {
									return A2(
										ok,
										vars2,
										func(value));
								});
							return A3(kv, vars1, ok2, err);
						});
					return A3(kf, vars, ok1, err);
				}));
	});
var $author$project$Compiler$Type$Unify$fmap = F2(
	function (func, _v0) {
		var kv = _v0.a;
		return $author$project$Compiler$Type$Unify$Unify(
			F3(
				function (vars, ok, err) {
					var ok1 = F2(
						function (vars1, value) {
							return A2(
								ok,
								vars1,
								func(value));
						});
					return A3(kv, vars, ok1, err);
				}));
	});
var $author$project$Compiler$Type$Unify$liftA2 = A2($author$project$Extra$Class$Applicative$liftA2, $author$project$Compiler$Type$Unify$fmap, $author$project$Compiler$Type$Unify$andMap);
var $author$project$Compiler$Type$UnionFind$Link = function (a) {
	return {$: 'Link', a: a};
};
var $author$project$Compiler$Type$UnionFind$union = F3(
	function (p1, p2, newDesc) {
		return A2(
			$author$project$Extra$System$IO$Pure$bind,
			$author$project$Compiler$Type$UnionFind$repr(p1),
			function (point1) {
				var ref1 = point1.a;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					$author$project$Compiler$Type$UnionFind$repr(p2),
					function (point2) {
						var ref2 = point2.a;
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							$author$project$Compiler$Type$UnionFind$liftI(
								$author$project$Extra$System$IORef$read(ref1)),
							function (info1) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									$author$project$Compiler$Type$UnionFind$liftI(
										$author$project$Extra$System$IORef$read(ref2)),
									function (info2) {
										var _v0 = _Utils_Tuple2(info1, info2);
										if ((_v0.a.$ === 'Info') && (_v0.b.$ === 'Info')) {
											var _v1 = _v0.a;
											var w1 = _v1.a;
											var d1 = _v1.b;
											var _v2 = _v0.b;
											var w2 = _v2.a;
											var d2 = _v2.b;
											return _Utils_eq(point1, point2) ? $author$project$Compiler$Type$UnionFind$liftD(
												A2($author$project$Extra$System$IORef$write, d1, newDesc)) : A2(
												$author$project$Extra$System$IO$Pure$bind,
												$author$project$Compiler$Type$UnionFind$liftW(
													$author$project$Extra$System$IORef$read(w1)),
												function (weight1) {
													return A2(
														$author$project$Extra$System$IO$Pure$bind,
														$author$project$Compiler$Type$UnionFind$liftW(
															$author$project$Extra$System$IORef$read(w2)),
														function (weight2) {
															var newWeight = weight1 + weight2;
															return (_Utils_cmp(weight1, weight2) > -1) ? A2(
																$author$project$Extra$System$IO$Pure$bind,
																$author$project$Compiler$Type$UnionFind$liftI(
																	A2(
																		$author$project$Extra$System$IORef$write,
																		ref2,
																		$author$project$Compiler$Type$UnionFind$Link(point1))),
																function (_v3) {
																	return A2(
																		$author$project$Extra$System$IO$Pure$bind,
																		$author$project$Compiler$Type$UnionFind$liftW(
																			A2($author$project$Extra$System$IORef$write, w1, newWeight)),
																		function (_v4) {
																			return $author$project$Compiler$Type$UnionFind$liftD(
																				A2($author$project$Extra$System$IORef$write, d1, newDesc));
																		});
																}) : A2(
																$author$project$Extra$System$IO$Pure$bind,
																$author$project$Compiler$Type$UnionFind$liftI(
																	A2(
																		$author$project$Extra$System$IORef$write,
																		ref1,
																		$author$project$Compiler$Type$UnionFind$Link(point2))),
																function (_v5) {
																	return A2(
																		$author$project$Extra$System$IO$Pure$bind,
																		$author$project$Compiler$Type$UnionFind$liftW(
																			A2($author$project$Extra$System$IORef$write, w2, newWeight)),
																		function (_v6) {
																			return $author$project$Compiler$Type$UnionFind$liftD(
																				A2($author$project$Extra$System$IORef$write, d2, newDesc));
																		});
																});
														});
												});
										} else {
											return _Debug_todo(
												'Compiler.Type.UnionFind',
												{
													start: {line: 197, column: 8},
													end: {line: 197, column: 18}
												})('UnionFind.union: invalid PointInfos');
										}
									});
							});
					});
			});
	});
var $author$project$Compiler$Type$Unify$merge = F2(
	function (_v0, content) {
		var var1 = _v0.a;
		var _v1 = _v0.b;
		var rank1 = _v1.b;
		var var2 = _v0.c;
		var _v2 = _v0.d;
		var rank2 = _v2.b;
		return $author$project$Compiler$Type$Unify$Unify(
			F3(
				function (vars, ok, _v3) {
					return A2(
						$author$project$Extra$System$IO$Pure$andThen,
						ok(vars),
						A3(
							$author$project$Compiler$Type$UnionFind$union,
							var1,
							var2,
							A4(
								$author$project$Compiler$Type$Type$Descriptor,
								content,
								A2($elm$core$Basics$min, rank1, rank2),
								$author$project$Compiler$Type$Type$noMark,
								$elm$core$Maybe$Nothing)));
				}));
	});
var $author$project$Compiler$Type$Unify$mismatch = $author$project$Compiler$Type$Unify$Unify(
	F3(
		function (vars, _v0, err) {
			return A2(err, vars, _Utils_Tuple0);
		}));
var $author$project$Compiler$Type$Unify$reorient = function (_v0) {
	var var1 = _v0.a;
	var desc1 = _v0.b;
	var var2 = _v0.c;
	var desc2 = _v0.d;
	return A4($author$project$Compiler$Type$Unify$Context, var2, desc2, var1, desc1);
};
var $author$project$Compiler$Type$Unify$return = function (a) {
	return $author$project$Compiler$Type$Unify$Unify(
		F3(
			function (vars, ok, _v0) {
				return A2(ok, vars, a);
			}));
};
var $author$project$Extra$Type$Map$traverseMaybeWithKey = F4(
	function (pPure, pLiftA2, f, dict) {
		return A3(
			$author$project$Extra$Type$Map$foldrWithKey,
			F3(
				function (k, a, fdb) {
					return A3(
						pLiftA2,
						F2(
							function (mb, db) {
								if (mb.$ === 'Just') {
									var b = mb.a;
									return A3($author$project$Extra$Type$Map$insert, k, b, db);
								} else {
									return db;
								}
							}),
						A2(f, k, a),
						fdb);
				}),
			pPure($author$project$Extra$Type$Map$empty),
			dict);
	});
var $author$project$Compiler$Type$Unify$unifyFlex = F3(
	function (context, content, otherContent) {
		switch (otherContent.$) {
			case 'Error':
				return A2($author$project$Compiler$Type$Unify$merge, context, $author$project$Compiler$Type$Type$Error);
			case 'FlexVar':
				var maybeName = otherContent.a;
				return A2(
					$author$project$Compiler$Type$Unify$merge,
					context,
					function () {
						if (maybeName.$ === 'Nothing') {
							return content;
						} else {
							return otherContent;
						}
					}());
			case 'FlexSuper':
				return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
			case 'RigidVar':
				return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
			case 'RigidSuper':
				return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
			case 'Alias':
				return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
			default:
				return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
		}
	});
var $author$project$Compiler$Type$Unify$unifyRigid = F4(
	function (context, maybeSuper, content, otherContent) {
		switch (otherContent.$) {
			case 'FlexVar':
				return A2($author$project$Compiler$Type$Unify$merge, context, content);
			case 'FlexSuper':
				var otherSuper = otherContent.a;
				if (maybeSuper.$ === 'Just') {
					var _super = maybeSuper.a;
					return A2($author$project$Compiler$Type$Unify$combineRigidSupers, _super, otherSuper) ? A2($author$project$Compiler$Type$Unify$merge, context, content) : $author$project$Compiler$Type$Unify$mismatch;
				} else {
					return $author$project$Compiler$Type$Unify$mismatch;
				}
			case 'RigidVar':
				return $author$project$Compiler$Type$Unify$mismatch;
			case 'RigidSuper':
				return $author$project$Compiler$Type$Unify$mismatch;
			case 'Alias':
				return $author$project$Compiler$Type$Unify$mismatch;
			case 'Structure':
				return $author$project$Compiler$Type$Unify$mismatch;
			default:
				return A2($author$project$Compiler$Type$Unify$merge, context, $author$project$Compiler$Type$Type$Error);
		}
	});
var $author$project$Compiler$Type$Unify$actuallyUnify = function (context) {
	var _v83 = context.b;
	var firstContent = _v83.a;
	var _v84 = context.d;
	var secondContent = _v84.a;
	switch (firstContent.$) {
		case 'FlexVar':
			return A3($author$project$Compiler$Type$Unify$unifyFlex, context, firstContent, secondContent);
		case 'FlexSuper':
			var _super = firstContent.a;
			return A4($author$project$Compiler$Type$Unify$unifyFlexSuper, context, _super, firstContent, secondContent);
		case 'RigidVar':
			return A4($author$project$Compiler$Type$Unify$unifyRigid, context, $elm$core$Maybe$Nothing, firstContent, secondContent);
		case 'RigidSuper':
			var _super = firstContent.a;
			return A4(
				$author$project$Compiler$Type$Unify$unifyRigid,
				context,
				$elm$core$Maybe$Just(_super),
				firstContent,
				secondContent);
		case 'Alias':
			var home = firstContent.a;
			var name = firstContent.b;
			var args = firstContent.c;
			var realVar = firstContent.d;
			return A6($author$project$Compiler$Type$Unify$unifyAlias, context, home, name, args, realVar, secondContent);
		case 'Structure':
			var flatType = firstContent.a;
			return A4($author$project$Compiler$Type$Unify$unifyStructure, context, flatType, firstContent, secondContent);
		default:
			return A2($author$project$Compiler$Type$Unify$merge, context, $author$project$Compiler$Type$Type$Error);
	}
};
var $author$project$Compiler$Type$Unify$guardedUnify = F2(
	function (left, right) {
		return $author$project$Compiler$Type$Unify$Unify(
			F3(
				function (vars, ok, err) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						A2($author$project$Compiler$Type$UnionFind$equivalent, left, right),
						function (equivalent) {
							return equivalent ? A2(ok, vars, _Utils_Tuple0) : A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Compiler$Type$UnionFind$get(left),
								function (leftDesc) {
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										$author$project$Compiler$Type$UnionFind$get(right),
										function (rightDesc) {
											var _v82 = $author$project$Compiler$Type$Unify$actuallyUnify(
												A4($author$project$Compiler$Type$Unify$Context, left, leftDesc, right, rightDesc));
											var k = _v82.a;
											return A3(k, vars, ok, err);
										});
								});
						});
				}));
	});
var $author$project$Compiler$Type$Unify$subUnify = F2(
	function (var1, var2) {
		return A2($author$project$Compiler$Type$Unify$guardedUnify, var1, var2);
	});
var $author$project$Compiler$Type$Unify$unifyAlias = F6(
	function (context, home, name, args, realVar, otherContent) {
		switch (otherContent.$) {
			case 'FlexVar':
				return A2(
					$author$project$Compiler$Type$Unify$merge,
					context,
					A4($author$project$Compiler$Type$Type$Alias, home, name, args, realVar));
			case 'FlexSuper':
				return A2(
					$author$project$Compiler$Type$Unify$subUnify,
					realVar,
					$author$project$Compiler$Type$Unify$getSecond(context));
			case 'RigidVar':
				return A2(
					$author$project$Compiler$Type$Unify$subUnify,
					realVar,
					$author$project$Compiler$Type$Unify$getSecond(context));
			case 'RigidSuper':
				return A2(
					$author$project$Compiler$Type$Unify$subUnify,
					realVar,
					$author$project$Compiler$Type$Unify$getSecond(context));
			case 'Alias':
				var otherHome = otherContent.a;
				var otherName = otherContent.b;
				var otherArgs = otherContent.c;
				var otherRealVar = otherContent.d;
				return (_Utils_eq(name, otherName) && _Utils_eq(home, otherHome)) ? $author$project$Compiler$Type$Unify$Unify(
					F3(
						function (vars, ok, err) {
							var ok1 = F2(
								function (vars1, _v81) {
									var _v80 = A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
									var k = _v80.a;
									return A3(k, vars1, ok, err);
								});
							return A5($author$project$Compiler$Type$Unify$unifyAliasArgs, vars, args, otherArgs, ok1, err);
						})) : A2($author$project$Compiler$Type$Unify$subUnify, realVar, otherRealVar);
			case 'Structure':
				return A2(
					$author$project$Compiler$Type$Unify$subUnify,
					realVar,
					$author$project$Compiler$Type$Unify$getSecond(context));
			default:
				return A2($author$project$Compiler$Type$Unify$merge, context, $author$project$Compiler$Type$Type$Error);
		}
	});
var $author$project$Compiler$Type$Unify$unifyAliasArgs = F5(
	function (vars, args1, args2, ok, err) {
		if (args1.b) {
			var _v72 = args1.a;
			var arg1 = _v72.b;
			var others1 = args1.b;
			if (args2.b) {
				var _v74 = args2.a;
				var arg2 = _v74.b;
				var others2 = args2.b;
				var _v75 = A2($author$project$Compiler$Type$Unify$subUnify, arg1, arg2);
				var k = _v75.a;
				return A3(
					k,
					vars,
					F2(
						function (vs, _v76) {
							return A5($author$project$Compiler$Type$Unify$unifyAliasArgs, vs, others1, others2, ok, err);
						}),
					F2(
						function (vs, _v77) {
							return A5($author$project$Compiler$Type$Unify$unifyAliasArgs, vs, others1, others2, err, err);
						}));
			} else {
				return A2(err, vars, _Utils_Tuple0);
			}
		} else {
			if (!args2.b) {
				return A2(ok, vars, _Utils_Tuple0);
			} else {
				return A2(err, vars, _Utils_Tuple0);
			}
		}
	});
var $author$project$Compiler$Type$Unify$unifyArgs = F5(
	function (vars, args1, args2, ok, err) {
		if (args1.b) {
			var arg1 = args1.a;
			var others1 = args1.b;
			if (args2.b) {
				var arg2 = args2.a;
				var others2 = args2.b;
				var _v67 = A2($author$project$Compiler$Type$Unify$subUnify, arg1, arg2);
				var k = _v67.a;
				return A3(
					k,
					vars,
					F2(
						function (vs, _v68) {
							return A5($author$project$Compiler$Type$Unify$unifyArgs, vs, others1, others2, ok, err);
						}),
					F2(
						function (vs, _v69) {
							return A5($author$project$Compiler$Type$Unify$unifyArgs, vs, others1, others2, err, err);
						}));
			} else {
				return A2(err, vars, _Utils_Tuple0);
			}
		} else {
			if (!args2.b) {
				return A2(ok, vars, _Utils_Tuple0);
			} else {
				return A2(err, vars, _Utils_Tuple0);
			}
		}
	});
var $author$project$Compiler$Type$Unify$unifyComparableRecursive = function (_var) {
	return A2(
		$author$project$Compiler$Type$Unify$bind,
		$author$project$Compiler$Type$Unify$register(
			A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$UnionFind$get(_var),
				function (_v64) {
					var rank = _v64.b;
					return $author$project$Compiler$Type$UnionFind$fresh(
						A4(
							$author$project$Compiler$Type$Type$Descriptor,
							$author$project$Compiler$Type$Type$unnamedFlexSuper($author$project$Compiler$Type$Type$Comparable),
							rank,
							$author$project$Compiler$Type$Type$noMark,
							$elm$core$Maybe$Nothing));
				})),
		function (compVar) {
			return A2($author$project$Compiler$Type$Unify$guardedUnify, compVar, _var);
		});
};
var $author$project$Compiler$Type$Unify$unifyField = F2(
	function (_v58, _v59) {
		var actual = _v59.a;
		var expected = _v59.b;
		return $author$project$Compiler$Type$Unify$Unify(
			F3(
				function (vars, ok, _v60) {
					var _v61 = A2($author$project$Compiler$Type$Unify$subUnify, actual, expected);
					var k = _v61.a;
					return A3(
						k,
						vars,
						F2(
							function (vs, _v62) {
								return A2(
									ok,
									vs,
									$elm$core$Maybe$Just(actual));
							}),
						F2(
							function (vs, _v63) {
								return A2(ok, vs, $elm$core$Maybe$Nothing);
							}));
				}));
	});
var $author$project$Compiler$Type$Unify$unifyFlexSuper = F4(
	function (context, _super, content, otherContent) {
		switch (otherContent.$) {
			case 'Structure':
				var flatType = otherContent.a;
				return A3($author$project$Compiler$Type$Unify$unifyFlexSuperStructure, context, _super, flatType);
			case 'RigidVar':
				return $author$project$Compiler$Type$Unify$mismatch;
			case 'RigidSuper':
				var otherSuper = otherContent.a;
				return A2($author$project$Compiler$Type$Unify$combineRigidSupers, otherSuper, _super) ? A2($author$project$Compiler$Type$Unify$merge, context, otherContent) : $author$project$Compiler$Type$Unify$mismatch;
			case 'FlexVar':
				return A2($author$project$Compiler$Type$Unify$merge, context, content);
			case 'FlexSuper':
				var otherSuper = otherContent.a;
				switch (_super.$) {
					case 'Number':
						switch (otherSuper.$) {
							case 'Number':
								return A2($author$project$Compiler$Type$Unify$merge, context, content);
							case 'Comparable':
								return A2($author$project$Compiler$Type$Unify$merge, context, content);
							case 'Appendable':
								return $author$project$Compiler$Type$Unify$mismatch;
							default:
								return $author$project$Compiler$Type$Unify$mismatch;
						}
					case 'Comparable':
						switch (otherSuper.$) {
							case 'Comparable':
								return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
							case 'Number':
								return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
							case 'Appendable':
								return A2(
									$author$project$Compiler$Type$Unify$merge,
									context,
									$author$project$Compiler$Type$Type$unnamedFlexSuper($author$project$Compiler$Type$Type$CompAppend));
							default:
								return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
						}
					case 'Appendable':
						switch (otherSuper.$) {
							case 'Appendable':
								return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
							case 'Comparable':
								return A2(
									$author$project$Compiler$Type$Unify$merge,
									context,
									$author$project$Compiler$Type$Type$unnamedFlexSuper($author$project$Compiler$Type$Type$CompAppend));
							case 'CompAppend':
								return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
							default:
								return $author$project$Compiler$Type$Unify$mismatch;
						}
					default:
						switch (otherSuper.$) {
							case 'Comparable':
								return A2($author$project$Compiler$Type$Unify$merge, context, content);
							case 'Appendable':
								return A2($author$project$Compiler$Type$Unify$merge, context, content);
							case 'CompAppend':
								return A2($author$project$Compiler$Type$Unify$merge, context, content);
							default:
								return $author$project$Compiler$Type$Unify$mismatch;
						}
				}
			case 'Alias':
				var realVar = otherContent.d;
				return A2(
					$author$project$Compiler$Type$Unify$subUnify,
					$author$project$Compiler$Type$Unify$getFirst(context),
					realVar);
			default:
				return A2($author$project$Compiler$Type$Unify$merge, context, $author$project$Compiler$Type$Type$Error);
		}
	});
var $author$project$Compiler$Type$Unify$unifyFlexSuperStructure = F3(
	function (context, _super, flatType) {
		_v39$3:
		while (true) {
			switch (flatType.$) {
				case 'App1':
					if (!flatType.c.b) {
						var home = flatType.a;
						var name = flatType.b;
						return A3($author$project$Compiler$Type$Unify$atomMatchesSuper, _super, home, name) ? A2(
							$author$project$Compiler$Type$Unify$merge,
							context,
							$author$project$Compiler$Type$Type$Structure(flatType)) : $author$project$Compiler$Type$Unify$mismatch;
					} else {
						if (!flatType.c.b.b) {
							var home = flatType.a;
							var name = flatType.b;
							var _v40 = flatType.c;
							var variable = _v40.a;
							if (_Utils_eq(home, $author$project$Compiler$Elm$ModuleName$list) && _Utils_eq(name, $author$project$Compiler$Data$Name$list)) {
								switch (_super.$) {
									case 'Number':
										return $author$project$Compiler$Type$Unify$mismatch;
									case 'Appendable':
										return A2(
											$author$project$Compiler$Type$Unify$merge,
											context,
											$author$project$Compiler$Type$Type$Structure(flatType));
									case 'Comparable':
										return A2(
											$author$project$Compiler$Type$Unify$bind,
											$author$project$Compiler$Type$Unify$comparableOccursCheck(context),
											function (_v42) {
												return A2(
													$author$project$Compiler$Type$Unify$bind,
													$author$project$Compiler$Type$Unify$unifyComparableRecursive(variable),
													function (_v43) {
														return A2(
															$author$project$Compiler$Type$Unify$merge,
															context,
															$author$project$Compiler$Type$Type$Structure(flatType));
													});
											});
									default:
										return A2(
											$author$project$Compiler$Type$Unify$bind,
											$author$project$Compiler$Type$Unify$comparableOccursCheck(context),
											function (_v44) {
												return A2(
													$author$project$Compiler$Type$Unify$bind,
													$author$project$Compiler$Type$Unify$unifyComparableRecursive(variable),
													function (_v45) {
														return A2(
															$author$project$Compiler$Type$Unify$merge,
															context,
															$author$project$Compiler$Type$Type$Structure(flatType));
													});
											});
								}
							} else {
								return $author$project$Compiler$Type$Unify$mismatch;
							}
						} else {
							break _v39$3;
						}
					}
				case 'Tuple1':
					var a = flatType.a;
					var b = flatType.b;
					var maybeC = flatType.c;
					switch (_super.$) {
						case 'Number':
							return $author$project$Compiler$Type$Unify$mismatch;
						case 'Appendable':
							return $author$project$Compiler$Type$Unify$mismatch;
						case 'Comparable':
							return A2(
								$author$project$Compiler$Type$Unify$bind,
								$author$project$Compiler$Type$Unify$comparableOccursCheck(context),
								function (_v47) {
									return A2(
										$author$project$Compiler$Type$Unify$bind,
										$author$project$Compiler$Type$Unify$unifyComparableRecursive(a),
										function (_v48) {
											return A2(
												$author$project$Compiler$Type$Unify$bind,
												$author$project$Compiler$Type$Unify$unifyComparableRecursive(b),
												function (_v49) {
													return A2(
														$author$project$Compiler$Type$Unify$bind,
														function () {
															if (maybeC.$ === 'Nothing') {
																return $author$project$Compiler$Type$Unify$return(_Utils_Tuple0);
															} else {
																var c = maybeC.a;
																return $author$project$Compiler$Type$Unify$unifyComparableRecursive(c);
															}
														}(),
														function (_v51) {
															return A2(
																$author$project$Compiler$Type$Unify$merge,
																context,
																$author$project$Compiler$Type$Type$Structure(flatType));
														});
												});
										});
								});
						default:
							return $author$project$Compiler$Type$Unify$mismatch;
					}
				default:
					break _v39$3;
			}
		}
		return $author$project$Compiler$Type$Unify$mismatch;
	});
var $author$project$Compiler$Type$Unify$unifyRecord = F3(
	function (context, _v32, _v33) {
		var fields1 = _v32.a;
		var ext1 = _v32.b;
		var fields2 = _v33.a;
		var ext2 = _v33.b;
		var uniqueFields2 = A2($author$project$Extra$Type$Map$difference, fields2, fields1);
		var uniqueFields1 = A2($author$project$Extra$Type$Map$difference, fields1, fields2);
		var sharedFields = A3($author$project$Extra$Type$Map$intersectionWith, $elm$core$Tuple$pair, fields1, fields2);
		if ($author$project$Extra$Type$Map$null(uniqueFields1)) {
			return $author$project$Extra$Type$Map$null(uniqueFields2) ? A2(
				$author$project$Compiler$Type$Unify$bind,
				A2($author$project$Compiler$Type$Unify$subUnify, ext1, ext2),
				function (_v34) {
					return A4($author$project$Compiler$Type$Unify$unifySharedFields, context, sharedFields, $author$project$Extra$Type$Map$empty, ext1);
				}) : A2(
				$author$project$Compiler$Type$Unify$bind,
				A2(
					$author$project$Compiler$Type$Unify$fresh,
					context,
					$author$project$Compiler$Type$Type$Structure(
						A2($author$project$Compiler$Type$Type$Record1, uniqueFields2, ext2))),
				function (subRecord) {
					return A2(
						$author$project$Compiler$Type$Unify$bind,
						A2($author$project$Compiler$Type$Unify$subUnify, ext1, subRecord),
						function (_v35) {
							return A4($author$project$Compiler$Type$Unify$unifySharedFields, context, sharedFields, $author$project$Extra$Type$Map$empty, subRecord);
						});
				});
		} else {
			if ($author$project$Extra$Type$Map$null(uniqueFields2)) {
				return A2(
					$author$project$Compiler$Type$Unify$bind,
					A2(
						$author$project$Compiler$Type$Unify$fresh,
						context,
						$author$project$Compiler$Type$Type$Structure(
							A2($author$project$Compiler$Type$Type$Record1, uniqueFields1, ext1))),
					function (subRecord) {
						return A2(
							$author$project$Compiler$Type$Unify$bind,
							A2($author$project$Compiler$Type$Unify$subUnify, subRecord, ext2),
							function (_v36) {
								return A4($author$project$Compiler$Type$Unify$unifySharedFields, context, sharedFields, $author$project$Extra$Type$Map$empty, subRecord);
							});
					});
			} else {
				var otherFields = A2($author$project$Extra$Type$Map$union, uniqueFields1, uniqueFields2);
				return A2(
					$author$project$Compiler$Type$Unify$bind,
					A2($author$project$Compiler$Type$Unify$fresh, context, $author$project$Compiler$Type$Type$unnamedFlexVar),
					function (ext) {
						return A2(
							$author$project$Compiler$Type$Unify$bind,
							A2(
								$author$project$Compiler$Type$Unify$fresh,
								context,
								$author$project$Compiler$Type$Type$Structure(
									A2($author$project$Compiler$Type$Type$Record1, uniqueFields1, ext))),
							function (sub1) {
								return A2(
									$author$project$Compiler$Type$Unify$bind,
									A2(
										$author$project$Compiler$Type$Unify$fresh,
										context,
										$author$project$Compiler$Type$Type$Structure(
											A2($author$project$Compiler$Type$Type$Record1, uniqueFields2, ext))),
									function (sub2) {
										return A2(
											$author$project$Compiler$Type$Unify$bind,
											A2($author$project$Compiler$Type$Unify$subUnify, ext1, sub2),
											function (_v37) {
												return A2(
													$author$project$Compiler$Type$Unify$bind,
													A2($author$project$Compiler$Type$Unify$subUnify, sub1, ext2),
													function (_v38) {
														return A4($author$project$Compiler$Type$Unify$unifySharedFields, context, sharedFields, otherFields, ext);
													});
											});
									});
							});
					});
			}
		}
	});
var $author$project$Compiler$Type$Unify$unifySharedFields = F4(
	function (context, sharedFields, otherFields, ext) {
		return A2(
			$author$project$Compiler$Type$Unify$bind,
			A4($author$project$Extra$Type$Map$traverseMaybeWithKey, $author$project$Compiler$Type$Unify$return, $author$project$Compiler$Type$Unify$liftA2, $author$project$Compiler$Type$Unify$unifyField, sharedFields),
			function (matchingFields) {
				return _Utils_eq(
					$author$project$Extra$Type$Map$size(sharedFields),
					$author$project$Extra$Type$Map$size(matchingFields)) ? A2(
					$author$project$Compiler$Type$Unify$merge,
					context,
					$author$project$Compiler$Type$Type$Structure(
						A2(
							$author$project$Compiler$Type$Type$Record1,
							A2($author$project$Extra$Type$Map$union, matchingFields, otherFields),
							ext))) : $author$project$Compiler$Type$Unify$mismatch;
			});
	});
var $author$project$Compiler$Type$Unify$unifyStructure = F4(
	function (context, flatType, content, otherContent) {
		switch (otherContent.$) {
			case 'FlexVar':
				return A2($author$project$Compiler$Type$Unify$merge, context, content);
			case 'FlexSuper':
				var _super = otherContent.a;
				return A3(
					$author$project$Compiler$Type$Unify$unifyFlexSuperStructure,
					$author$project$Compiler$Type$Unify$reorient(context),
					_super,
					flatType);
			case 'RigidVar':
				return $author$project$Compiler$Type$Unify$mismatch;
			case 'RigidSuper':
				return $author$project$Compiler$Type$Unify$mismatch;
			case 'Alias':
				var realVar = otherContent.d;
				return A2(
					$author$project$Compiler$Type$Unify$subUnify,
					$author$project$Compiler$Type$Unify$getFirst(context),
					realVar);
			case 'Structure':
				var otherFlatType = otherContent.a;
				var _v1 = _Utils_Tuple2(flatType, otherFlatType);
				_v1$9:
				while (true) {
					switch (_v1.a.$) {
						case 'App1':
							if (_v1.b.$ === 'App1') {
								var _v2 = _v1.a;
								var home = _v2.a;
								var name = _v2.b;
								var args = _v2.c;
								var _v3 = _v1.b;
								var otherHome = _v3.a;
								var otherName = _v3.b;
								var otherArgs = _v3.c;
								return (_Utils_eq(home, otherHome) && _Utils_eq(name, otherName)) ? $author$project$Compiler$Type$Unify$Unify(
									F3(
										function (vars, ok, err) {
											var ok1 = F2(
												function (vars1, _v5) {
													var _v4 = A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
													var k = _v4.a;
													return A3(k, vars1, ok, err);
												});
											return A5($author$project$Compiler$Type$Unify$unifyArgs, vars, args, otherArgs, ok1, err);
										})) : $author$project$Compiler$Type$Unify$mismatch;
							} else {
								break _v1$9;
							}
						case 'Fun1':
							if (_v1.b.$ === 'Fun1') {
								var _v6 = _v1.a;
								var arg1 = _v6.a;
								var res1 = _v6.b;
								var _v7 = _v1.b;
								var arg2 = _v7.a;
								var res2 = _v7.b;
								return A2(
									$author$project$Compiler$Type$Unify$bind,
									A2($author$project$Compiler$Type$Unify$subUnify, arg1, arg2),
									function (_v8) {
										return A2(
											$author$project$Compiler$Type$Unify$bind,
											A2($author$project$Compiler$Type$Unify$subUnify, res1, res2),
											function (_v9) {
												return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
											});
									});
							} else {
								break _v1$9;
							}
						case 'EmptyRecord1':
							switch (_v1.b.$) {
								case 'EmptyRecord1':
									var _v10 = _v1.a;
									var _v11 = _v1.b;
									return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
								case 'Record1':
									var _v14 = _v1.a;
									var _v15 = _v1.b;
									var fields = _v15.a;
									var ext = _v15.b;
									return $author$project$Extra$Type$Map$null(fields) ? A2(
										$author$project$Compiler$Type$Unify$subUnify,
										$author$project$Compiler$Type$Unify$getFirst(context),
										ext) : $author$project$Compiler$Type$Unify$mismatch;
								default:
									break _v1$9;
							}
						case 'Record1':
							switch (_v1.b.$) {
								case 'EmptyRecord1':
									var _v12 = _v1.a;
									var fields = _v12.a;
									var ext = _v12.b;
									var _v13 = _v1.b;
									return $author$project$Extra$Type$Map$null(fields) ? A2(
										$author$project$Compiler$Type$Unify$subUnify,
										ext,
										$author$project$Compiler$Type$Unify$getSecond(context)) : $author$project$Compiler$Type$Unify$mismatch;
								case 'Record1':
									var _v16 = _v1.a;
									var fields1 = _v16.a;
									var ext1 = _v16.b;
									var _v17 = _v1.b;
									var fields2 = _v17.a;
									var ext2 = _v17.b;
									return $author$project$Compiler$Type$Unify$Unify(
										F3(
											function (vars, ok, err) {
												return A2(
													$author$project$Extra$System$IO$Pure$bind,
													A2($author$project$Compiler$Type$Unify$gatherFields, fields1, ext1),
													function (structure1) {
														return A2(
															$author$project$Extra$System$IO$Pure$bind,
															A2($author$project$Compiler$Type$Unify$gatherFields, fields2, ext2),
															function (structure2) {
																var _v18 = A3($author$project$Compiler$Type$Unify$unifyRecord, context, structure1, structure2);
																var k = _v18.a;
																return A3(k, vars, ok, err);
															});
													});
											}));
								default:
									break _v1$9;
							}
						case 'Tuple1':
							if (_v1.a.c.$ === 'Nothing') {
								if ((_v1.b.$ === 'Tuple1') && (_v1.b.c.$ === 'Nothing')) {
									var _v19 = _v1.a;
									var a = _v19.a;
									var b = _v19.b;
									var _v20 = _v19.c;
									var _v21 = _v1.b;
									var x = _v21.a;
									var y = _v21.b;
									var _v22 = _v21.c;
									return A2(
										$author$project$Compiler$Type$Unify$bind,
										A2($author$project$Compiler$Type$Unify$subUnify, a, x),
										function (_v23) {
											return A2(
												$author$project$Compiler$Type$Unify$bind,
												A2($author$project$Compiler$Type$Unify$subUnify, b, y),
												function (_v24) {
													return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
												});
										});
								} else {
									break _v1$9;
								}
							} else {
								if ((_v1.b.$ === 'Tuple1') && (_v1.b.c.$ === 'Just')) {
									var _v25 = _v1.a;
									var a = _v25.a;
									var b = _v25.b;
									var c = _v25.c.a;
									var _v26 = _v1.b;
									var x = _v26.a;
									var y = _v26.b;
									var z = _v26.c.a;
									return A2(
										$author$project$Compiler$Type$Unify$bind,
										A2($author$project$Compiler$Type$Unify$subUnify, a, x),
										function (_v27) {
											return A2(
												$author$project$Compiler$Type$Unify$bind,
												A2($author$project$Compiler$Type$Unify$subUnify, b, y),
												function (_v28) {
													return A2(
														$author$project$Compiler$Type$Unify$bind,
														A2($author$project$Compiler$Type$Unify$subUnify, c, z),
														function (_v29) {
															return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
														});
												});
										});
								} else {
									break _v1$9;
								}
							}
						default:
							if (_v1.b.$ === 'Unit1') {
								var _v30 = _v1.a;
								var _v31 = _v1.b;
								return A2($author$project$Compiler$Type$Unify$merge, context, otherContent);
							} else {
								break _v1$9;
							}
					}
				}
				return $author$project$Compiler$Type$Unify$mismatch;
			default:
				return A2($author$project$Compiler$Type$Unify$merge, context, $author$project$Compiler$Type$Type$Error);
		}
	});
var $author$project$Compiler$Type$Unify$COk = function (a) {
	return {$: 'COk', a: a};
};
var $author$project$Compiler$Type$Unify$onSuccess = F2(
	function (vars, _v0) {
		return $author$project$Extra$System$IO$Pure$return(
			$author$project$Compiler$Type$Unify$COk(vars));
	});
var $author$project$Compiler$Type$Unify$unify = F2(
	function (v1, v2) {
		var _v0 = A2($author$project$Compiler$Type$Unify$guardedUnify, v1, v2);
		var k = _v0.a;
		return A3(
			k,
			_List_Nil,
			$author$project$Compiler$Type$Unify$onSuccess,
			F2(
				function (vars, _v1) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$Type$toErrorType(v1),
						function (t1) {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								$author$project$Compiler$Type$Type$toErrorType(v2),
								function (t2) {
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A3($author$project$Compiler$Type$UnionFind$union, v1, v2, $author$project$Compiler$Type$Unify$errorDescriptor),
										function (_v2) {
											return $author$project$Extra$System$IO$Pure$return(
												A3($author$project$Compiler$Type$Unify$CErr, vars, t1, t2));
										});
								});
						});
				}));
	});
var $author$project$Extra$System$MVector$write = F4(
	function (_v0, i, a, state) {
		var id = _v0.a;
		var nextId = state.a;
		var map = state.b;
		var refState = state.c;
		var _v1 = A3($author$project$Extra$System$MVector$getRef, id, i, map);
		if (_v1.$ === 'Just') {
			var ref = _v1.a;
			return A3(
				$author$project$Extra$System$MVector$liftResult,
				nextId,
				map,
				A3($author$project$Extra$System$IORef$write, ref, a, refState));
		} else {
			return _Utils_Tuple2(_Utils_Tuple0, state);
		}
	});
var $author$project$Compiler$Type$Solve$solve = F5(
	function (env, rank, pools, state, constraint) {
		return A2(
			$author$project$Extra$System$IO$Pure$loop,
			$author$project$Compiler$Type$Solve$solveHelp,
			_Utils_Tuple3(
				_Utils_Tuple2(env, rank),
				_Utils_Tuple2(pools, state),
				_Utils_Tuple2(constraint, $elm$core$Basics$identity)));
	});
var $author$project$Compiler$Type$Solve$solveHelp = function (_v0) {
	var _v1 = _v0.a;
	var env = _v1.a;
	var rank = _v1.b;
	var _v2 = _v0.b;
	var pools = _v2.a;
	var state = _v2.b;
	var _v3 = _v0.c;
	var constraint = _v3.a;
	var cont = _v3.b;
	_v4$9:
	while (true) {
		switch (constraint.$) {
			case 'CTrue':
				return A2(
					$author$project$Extra$System$IO$Pure$fmap,
					$author$project$Extra$System$IO$Pure$Done,
					cont(
						$author$project$Extra$System$IO$Pure$return(state)));
			case 'CSaveTheEnvironment':
				return A2(
					$author$project$Extra$System$IO$Pure$fmap,
					$author$project$Extra$System$IO$Pure$Done,
					cont(
						$author$project$Extra$System$IO$Pure$return(
							A2($author$project$Compiler$Type$Solve$setEnv, env, state))));
			case 'CEqual':
				var region = constraint.a;
				var category = constraint.b;
				var tipe = constraint.c;
				var expectation = constraint.d;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3($author$project$Compiler$Type$Solve$typeToVariable, rank, pools, tipe),
					function (actual) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3($author$project$Compiler$Type$Solve$expectedToVariable, rank, pools, expectation),
							function (expected) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2($author$project$Compiler$Type$Unify$unify, actual, expected),
									function (answer) {
										if (answer.$ === 'COk') {
											var vars = answer.a;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v6) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(state)));
												});
										} else {
											var vars = answer.a;
											var actualType = answer.b;
											var expectedType = answer.c;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v7) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(
																A2(
																	$author$project$Compiler$Type$Solve$addError,
																	state,
																	A4(
																		$author$project$Compiler$Reporting$Error$Type$BadExpr,
																		region,
																		category,
																		actualType,
																		A2($author$project$Compiler$Reporting$Error$Type$typeReplace, expectation, expectedType))))));
												});
										}
									});
							});
					});
			case 'CLocal':
				var region = constraint.a;
				var name = constraint.b;
				var expectation = constraint.c;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3(
						$author$project$Compiler$Type$Solve$makeCopy,
						rank,
						pools,
						A2($author$project$Extra$Type$Map$ex, env, name)),
					function (actual) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3($author$project$Compiler$Type$Solve$expectedToVariable, rank, pools, expectation),
							function (expected) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2($author$project$Compiler$Type$Unify$unify, actual, expected),
									function (answer) {
										if (answer.$ === 'COk') {
											var vars = answer.a;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v9) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(state)));
												});
										} else {
											var vars = answer.a;
											var actualType = answer.b;
											var expectedType = answer.c;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v10) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(
																A2(
																	$author$project$Compiler$Type$Solve$addError,
																	state,
																	A4(
																		$author$project$Compiler$Reporting$Error$Type$BadExpr,
																		region,
																		$author$project$Compiler$Reporting$Error$Type$Local(name),
																		actualType,
																		A2($author$project$Compiler$Reporting$Error$Type$typeReplace, expectation, expectedType))))));
												});
										}
									});
							});
					});
			case 'CForeign':
				var region = constraint.a;
				var name = constraint.b;
				var _v11 = constraint.c;
				var freeVars = _v11.a;
				var srcType = _v11.b;
				var expectation = constraint.d;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A4($author$project$Compiler$Type$Solve$srcTypeToVariable, rank, pools, freeVars, srcType),
					function (actual) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3($author$project$Compiler$Type$Solve$expectedToVariable, rank, pools, expectation),
							function (expected) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2($author$project$Compiler$Type$Unify$unify, actual, expected),
									function (answer) {
										if (answer.$ === 'COk') {
											var vars = answer.a;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v13) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(state)));
												});
										} else {
											var vars = answer.a;
											var actualType = answer.b;
											var expectedType = answer.c;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v14) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(
																A2(
																	$author$project$Compiler$Type$Solve$addError,
																	state,
																	A4(
																		$author$project$Compiler$Reporting$Error$Type$BadExpr,
																		region,
																		$author$project$Compiler$Reporting$Error$Type$Foreign(name),
																		actualType,
																		A2($author$project$Compiler$Reporting$Error$Type$typeReplace, expectation, expectedType))))));
												});
										}
									});
							});
					});
			case 'CPattern':
				var region = constraint.a;
				var category = constraint.b;
				var tipe = constraint.c;
				var expectation = constraint.d;
				return A2(
					$author$project$Extra$System$IO$Pure$bind,
					A3($author$project$Compiler$Type$Solve$typeToVariable, rank, pools, tipe),
					function (actual) {
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3($author$project$Compiler$Type$Solve$patternExpectationToVariable, rank, pools, expectation),
							function (expected) {
								return A2(
									$author$project$Extra$System$IO$Pure$bind,
									A2($author$project$Compiler$Type$Unify$unify, actual, expected),
									function (answer) {
										if (answer.$ === 'COk') {
											var vars = answer.a;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v16) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(state)));
												});
										} else {
											var vars = answer.a;
											var actualType = answer.b;
											var expectedType = answer.c;
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A3($author$project$Compiler$Type$Solve$introduce, rank, pools, vars),
												function (_v17) {
													return A2(
														$author$project$Extra$System$IO$Pure$fmap,
														$author$project$Extra$System$IO$Pure$Done,
														cont(
															$author$project$Extra$System$IO$Pure$return(
																A2(
																	$author$project$Compiler$Type$Solve$addError,
																	state,
																	A4(
																		$author$project$Compiler$Reporting$Error$Type$BadPattern,
																		region,
																		category,
																		actualType,
																		A2($author$project$Compiler$Reporting$Error$Type$ptypeReplace, expectation, expectedType))))));
												});
										}
									});
							});
					});
			case 'CAnd':
				var constraints = constraint.a;
				return A2(
					$author$project$Extra$System$IO$Pure$fmap,
					$author$project$Extra$System$IO$Pure$Done,
					cont(
						A3(
							$author$project$Extra$System$IO$Pure$foldlMList,
							A3($author$project$Compiler$Type$Solve$solve, env, rank, pools),
							state,
							constraints)));
			default:
				if (!constraint.a.b) {
					if (constraint.e.$ === 'CTrue') {
						var flexs = constraint.b;
						var headerCon = constraint.d;
						var _v18 = constraint.e;
						return A2(
							$author$project$Extra$System$IO$Pure$bind,
							A3($author$project$Compiler$Type$Solve$introduce, rank, pools, flexs),
							function (_v19) {
								return $author$project$Extra$System$IO$Pure$return(
									$author$project$Extra$System$IO$Pure$Loop(
										_Utils_Tuple3(
											_Utils_Tuple2(env, rank),
											_Utils_Tuple2(pools, state),
											_Utils_Tuple2(headerCon, cont))));
							});
					} else {
						if (!constraint.b.b) {
							var header = constraint.c;
							var headerCon = constraint.d;
							var subCon = constraint.e;
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A5($author$project$Compiler$Type$Solve$solve, env, rank, pools, state, headerCon),
								function (state1) {
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A2(
											$author$project$Extra$System$IO$Pure$traverseMap,
											A2(
												$author$project$Compiler$Reporting$Annotation$traverse,
												$author$project$Extra$System$IO$Pure$fmap,
												A2($author$project$Compiler$Type$Solve$typeToVariable, rank, pools)),
											header),
										function (locals) {
											var newEnv = A2(
												$author$project$Extra$Type$Map$union,
												env,
												A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Reporting$Annotation$toValue, locals));
											return $author$project$Extra$System$IO$Pure$return(
												$author$project$Extra$System$IO$Pure$Loop(
													_Utils_Tuple3(
														_Utils_Tuple2(newEnv, rank),
														_Utils_Tuple2(pools, state1),
														_Utils_Tuple2(
															subCon,
															A2(
																$elm$core$Basics$composeR,
																$author$project$Extra$System$IO$Pure$andThen(
																	function (state2) {
																		return A3(
																			$author$project$Extra$System$IO$Pure$foldlMList,
																			$author$project$Compiler$Type$Solve$occurs,
																			state2,
																			$author$project$Extra$Type$Map$toList(locals));
																	}),
																cont)))));
										});
								});
						} else {
							break _v4$9;
						}
					}
				} else {
					break _v4$9;
				}
		}
	}
	var rigids = constraint.a;
	var flexs = constraint.b;
	var header = constraint.c;
	var headerCon = constraint.d;
	var subCon = constraint.e;
	var poolsLength = $author$project$Extra$System$MVector$length(pools);
	var nextRank = rank + 1;
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		(_Utils_cmp(nextRank, poolsLength) < 0) ? $author$project$Extra$System$IO$Pure$return(pools) : $author$project$Compiler$Type$Solve$liftP(
			A2($author$project$Extra$System$MVector$grow, pools, poolsLength)),
		function (nextPools) {
			var vars = _Utils_ap(rigids, flexs);
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A2(
					$author$project$Extra$System$IO$Pure$forMList_,
					vars,
					function (_var) {
						return A2(
							$author$project$Compiler$Type$UnionFind$modify,
							_var,
							function (_v20) {
								var content = _v20.a;
								var mark = _v20.c;
								var copy = _v20.d;
								return A4($author$project$Compiler$Type$Type$Descriptor, content, nextRank, mark, copy);
							});
					}),
				function (_v21) {
					return A2(
						$author$project$Extra$System$IO$Pure$bind,
						$author$project$Compiler$Type$Solve$liftP(
							A3($author$project$Extra$System$MVector$write, nextPools, nextRank, vars)),
						function (_v22) {
							return A2(
								$author$project$Extra$System$IO$Pure$bind,
								A2(
									$author$project$Extra$System$IO$Pure$traverseMap,
									A2(
										$author$project$Compiler$Reporting$Annotation$traverse,
										$author$project$Extra$System$IO$Pure$fmap,
										A2($author$project$Compiler$Type$Solve$typeToVariable, nextRank, nextPools)),
									header),
								function (locals) {
									return A2(
										$author$project$Extra$System$IO$Pure$bind,
										A5($author$project$Compiler$Type$Solve$solve, env, nextRank, nextPools, state, headerCon),
										function (_v23) {
											var savedEnv = _v23.a;
											var mark = _v23.b;
											var errors = _v23.c;
											var youngMark = mark;
											var visitMark = $author$project$Compiler$Type$Type$nextMark(youngMark);
											var finalMark = $author$project$Compiler$Type$Type$nextMark(visitMark);
											return A2(
												$author$project$Extra$System$IO$Pure$bind,
												A4($author$project$Compiler$Type$Solve$generalize, youngMark, visitMark, nextRank, nextPools),
												function (_v24) {
													return A2(
														$author$project$Extra$System$IO$Pure$bind,
														$author$project$Compiler$Type$Solve$liftP(
															A3($author$project$Extra$System$MVector$write, nextPools, nextRank, _List_Nil)),
														function (_v25) {
															return A2(
																$author$project$Extra$System$IO$Pure$bind,
																A2($author$project$Extra$System$IO$Pure$mapMList_, $author$project$Compiler$Type$Solve$isGeneric, rigids),
																function (_v26) {
																	var tempState = A3($author$project$Compiler$Type$Solve$State, savedEnv, finalMark, errors);
																	var newEnv = A2(
																		$author$project$Extra$Type$Map$union,
																		env,
																		A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Reporting$Annotation$toValue, locals));
																	return $author$project$Extra$System$IO$Pure$return(
																		$author$project$Extra$System$IO$Pure$Loop(
																			_Utils_Tuple3(
																				_Utils_Tuple2(newEnv, rank),
																				_Utils_Tuple2(nextPools, tempState),
																				_Utils_Tuple2(
																					subCon,
																					A2(
																						$elm$core$Basics$composeR,
																						$author$project$Extra$System$IO$Pure$andThen(
																							function (newState) {
																								return A3(
																									$author$project$Extra$System$IO$Pure$foldlMList,
																									$author$project$Compiler$Type$Solve$occurs,
																									newState,
																									$author$project$Extra$Type$Map$toList(locals));
																							}),
																						cont)))));
																});
														});
												});
										});
								});
						});
				});
		});
};
var $author$project$Compiler$Type$Type$fieldToCanType = function (variable) {
	return A2(
		$author$project$Compiler$Type$Type$bind,
		$author$project$Compiler$Type$Type$variableToCanType(variable),
		function (tipe) {
			return $author$project$Compiler$Type$Type$return(
				A2($author$project$Compiler$AST$Canonical$FieldType, 0, tipe));
		});
};
var $author$project$Compiler$Type$Type$termToCanType = function (term) {
	switch (term.$) {
		case 'App1':
			var home = term.a;
			var name = term.b;
			var args = term.c;
			return A2(
				$author$project$Compiler$Type$Type$fmap,
				A2($author$project$Compiler$AST$Canonical$TType, home, name),
				A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Type$Type$pure, $author$project$Compiler$Type$Type$liftA2, $author$project$Compiler$Type$Type$variableToCanType, args));
		case 'Fun1':
			var a = term.a;
			var b = term.b;
			return A2(
				$author$project$Compiler$Type$Type$andMap,
				$author$project$Compiler$Type$Type$variableToCanType(b),
				A2(
					$author$project$Compiler$Type$Type$andMap,
					$author$project$Compiler$Type$Type$variableToCanType(a),
					$author$project$Compiler$Type$Type$pure($author$project$Compiler$AST$Canonical$TLambda)));
		case 'EmptyRecord1':
			return $author$project$Compiler$Type$Type$return(
				A2($author$project$Compiler$AST$Canonical$TRecord, $author$project$Extra$Type$Map$empty, $elm$core$Maybe$Nothing));
		case 'Record1':
			var fields = term.a;
			var extension = term.b;
			return A2(
				$author$project$Compiler$Type$Type$bind,
				A4($author$project$Extra$Type$Map$traverse, $author$project$Compiler$Type$Type$pure, $author$project$Compiler$Type$Type$liftA2, $author$project$Compiler$Type$Type$fieldToCanType, fields),
				function (canFields) {
					return A2(
						$author$project$Compiler$Type$Type$bind,
						A2(
							$author$project$Compiler$Type$Type$fmap,
							$author$project$Compiler$AST$Utils$Type$iteratedDealias,
							$author$project$Compiler$Type$Type$variableToCanType(extension)),
						function (canExt) {
							return $author$project$Compiler$Type$Type$return(
								function () {
									switch (canExt.$) {
										case 'TRecord':
											var subFields = canExt.a;
											var subExt = canExt.b;
											return A2(
												$author$project$Compiler$AST$Canonical$TRecord,
												A2($author$project$Extra$Type$Map$union, subFields, canFields),
												subExt);
										case 'TVar':
											var name = canExt.a;
											return A2(
												$author$project$Compiler$AST$Canonical$TRecord,
												canFields,
												$elm$core$Maybe$Just(name));
										default:
											return _Debug_todo(
												'Compiler.Type.Type',
												{
													start: {line: 431, column: 13},
													end: {line: 431, column: 23}
												})('Used toAnnotation on a type that is not well-formed');
									}
								}());
						});
				});
		case 'Unit1':
			return $author$project$Compiler$Type$Type$return($author$project$Compiler$AST$Canonical$TUnit);
		default:
			var a = term.a;
			var b = term.b;
			var maybeC = term.c;
			return A2(
				$author$project$Compiler$Type$Type$andMap,
				A4($author$project$Extra$Type$Maybe$traverse, $author$project$Compiler$Type$Type$pure, $author$project$Compiler$Type$Type$fmap, $author$project$Compiler$Type$Type$variableToCanType, maybeC),
				A2(
					$author$project$Compiler$Type$Type$andMap,
					$author$project$Compiler$Type$Type$variableToCanType(b),
					A2(
						$author$project$Compiler$Type$Type$andMap,
						$author$project$Compiler$Type$Type$variableToCanType(a),
						$author$project$Compiler$Type$Type$pure($author$project$Compiler$AST$Canonical$TTuple))));
	}
};
var $author$project$Compiler$Type$Type$variableToCanType = function (variable) {
	return A2(
		$author$project$Compiler$Type$Type$bind,
		$author$project$Compiler$Type$Type$liftIO(
			$author$project$Compiler$Type$UnionFind$get(variable)),
		function (_v0) {
			var content = _v0.a;
			switch (content.$) {
				case 'Structure':
					var term = content.a;
					return $author$project$Compiler$Type$Type$termToCanType(term);
				case 'FlexVar':
					var maybeName = content.a;
					if (maybeName.$ === 'Just') {
						var name = maybeName.a;
						return $author$project$Compiler$Type$Type$return(
							$author$project$Compiler$AST$Canonical$TVar(name));
					} else {
						return A2(
							$author$project$Compiler$Type$Type$bind,
							$author$project$Compiler$Type$Type$getFreshVarName,
							function (name) {
								return A2(
									$author$project$Compiler$Type$Type$bind,
									$author$project$Compiler$Type$Type$liftIO(
										A2(
											$author$project$Compiler$Type$UnionFind$modify,
											variable,
											function (_v3) {
												var a = _v3.b;
												var b = _v3.c;
												var c = _v3.d;
												return A4(
													$author$project$Compiler$Type$Type$Descriptor,
													$author$project$Compiler$Type$Type$FlexVar(
														$elm$core$Maybe$Just(name)),
													a,
													b,
													c);
											})),
									function (_v4) {
										return $author$project$Compiler$Type$Type$return(
											$author$project$Compiler$AST$Canonical$TVar(name));
									});
							});
					}
				case 'FlexSuper':
					var _super = content.a;
					var maybeName = content.b;
					if (maybeName.$ === 'Just') {
						var name = maybeName.a;
						return $author$project$Compiler$Type$Type$return(
							$author$project$Compiler$AST$Canonical$TVar(name));
					} else {
						return A2(
							$author$project$Compiler$Type$Type$bind,
							$author$project$Compiler$Type$Type$getFreshSuperName(_super),
							function (name) {
								return A2(
									$author$project$Compiler$Type$Type$bind,
									$author$project$Compiler$Type$Type$liftIO(
										A2(
											$author$project$Compiler$Type$UnionFind$modify,
											variable,
											function (_v6) {
												var a = _v6.b;
												var b = _v6.c;
												var c = _v6.d;
												return A4(
													$author$project$Compiler$Type$Type$Descriptor,
													A2(
														$author$project$Compiler$Type$Type$FlexSuper,
														_super,
														$elm$core$Maybe$Just(name)),
													a,
													b,
													c);
											})),
									function (_v7) {
										return $author$project$Compiler$Type$Type$return(
											$author$project$Compiler$AST$Canonical$TVar(name));
									});
							});
					}
				case 'RigidVar':
					var name = content.a;
					return $author$project$Compiler$Type$Type$return(
						$author$project$Compiler$AST$Canonical$TVar(name));
				case 'RigidSuper':
					var name = content.b;
					return $author$project$Compiler$Type$Type$return(
						$author$project$Compiler$AST$Canonical$TVar(name));
				case 'Alias':
					var home = content.a;
					var name = content.b;
					var args = content.c;
					var realVariable = content.d;
					return A2(
						$author$project$Compiler$Type$Type$bind,
						A4(
							$author$project$Extra$Type$List$traverse,
							$author$project$Compiler$Type$Type$pure,
							$author$project$Compiler$Type$Type$liftA2,
							A2($author$project$Extra$Type$Tuple$traverseSecond, $author$project$Compiler$Type$Type$fmap, $author$project$Compiler$Type$Type$variableToCanType),
							args),
						function (canArgs) {
							return A2(
								$author$project$Compiler$Type$Type$bind,
								$author$project$Compiler$Type$Type$variableToCanType(realVariable),
								function (canType) {
									return $author$project$Compiler$Type$Type$return(
										A4(
											$author$project$Compiler$AST$Canonical$TAlias,
											home,
											name,
											canArgs,
											$author$project$Compiler$AST$Canonical$Filled(canType)));
								});
						});
				default:
					return _Debug_todo(
						'Compiler.Type.Type',
						{
							start: {line: 402, column: 7},
							end: {line: 402, column: 17}
						})('cannot handle Error types in variableToCanType');
			}
		});
};
var $author$project$Compiler$Type$Type$toAnnotation = function (variable) {
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		A2($author$project$Compiler$Type$Type$getVarNames, variable, $author$project$Extra$Type$Map$empty),
		function (userNames) {
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				$author$project$Compiler$Type$Type$variableToCanType(variable)(
					$author$project$Compiler$Type$Type$makeNameState(userNames)),
				function (_v0) {
					var tipe = _v0.a;
					var _v1 = _v0.b;
					var freeVars = _v1.a;
					return $author$project$Extra$System$IO$Pure$return(
						A2($author$project$Compiler$AST$Canonical$Forall, freeVars, tipe));
				});
		});
};
var $author$project$Compiler$Type$Solve$run = function (constraint) {
	return A2(
		$author$project$Extra$System$IO$Pure$bind,
		$author$project$Compiler$Type$Solve$liftP(
			A2($author$project$Extra$System$MVector$replicate, 8, _List_Nil)),
		function (pools) {
			return A2(
				$author$project$Extra$System$IO$Pure$bind,
				A5($author$project$Compiler$Type$Solve$solve, $author$project$Extra$Type$Map$empty, $author$project$Compiler$Type$Type$outermostRank, pools, $author$project$Compiler$Type$Solve$emptyState, constraint),
				function (_v0) {
					var env = _v0.a;
					var errors = _v0.c;
					if (!errors.b) {
						return A2(
							$author$project$Extra$System$IO$Pure$fmap,
							$author$project$Extra$Type$Either$Right,
							A2($author$project$Extra$System$IO$Pure$traverseMap, $author$project$Compiler$Type$Type$toAnnotation, env));
					} else {
						var e = errors.a;
						var es = errors.b;
						return $author$project$Extra$System$IO$Pure$return(
							$author$project$Extra$Type$Either$Left(
								A2($author$project$Compiler$Data$NonEmptyList$CList, e, es)));
					}
				});
		});
};
var $author$project$Compiler$Compile$typeCheck = F2(
	function (modul, canonical) {
		var _v0 = A2(
			$author$project$Extra$System$IO$Pure$performIO,
			A2(
				$author$project$Extra$System$IO$Pure$andThen,
				$author$project$Compiler$Type$Solve$run,
				$author$project$Compiler$Type$Constrain$Module$constrain(canonical)),
			$author$project$Compiler$Type$Solve$init);
		if (_v0.$ === 'Right') {
			var annotations = _v0.a;
			return $author$project$Extra$Type$Either$Right(annotations);
		} else {
			var errors = _v0.a;
			return $author$project$Extra$Type$Either$Left(
				A2(
					$author$project$Compiler$Reporting$Error$BadTypes,
					$author$project$Compiler$Reporting$Render$Type$Localizer$fromModule(modul),
					errors));
		}
	});
var $author$project$Compiler$Compile$compile = F3(
	function (pkg, ifaces, modul) {
		return A2(
			$author$project$Extra$Type$Either$bind,
			A3($author$project$Compiler$Compile$canonicalize, pkg, ifaces, modul),
			function (canonical) {
				return A2(
					$author$project$Extra$Type$Either$bind,
					A2($author$project$Compiler$Compile$typeCheck, modul, canonical),
					function (annotations) {
						return A2(
							$author$project$Extra$Type$Either$bind,
							$author$project$Compiler$Compile$nitpick(canonical),
							function (_v0) {
								return A2(
									$author$project$Extra$Type$Either$bind,
									A3($author$project$Compiler$Compile$optimize, modul, annotations, canonical),
									function (objects) {
										return $author$project$Extra$Type$Either$Right(
											A3($author$project$Compiler$Compile$Artifacts, canonical, annotations, objects));
									});
							});
					});
			});
	});
var $author$project$Builder$Stuff$elmo = F2(
	function (root, name) {
		return A3($author$project$Builder$Stuff$toArtifactPath, root, name, 'elmo');
	});
var $author$project$Compiler$Elm$Interface$restrict = F2(
	function (exports, dict) {
		if (exports.$ === 'ExportEverything') {
			return dict;
		} else {
			var explicitExports = exports.a;
			return A2($author$project$Extra$Type$Map$intersection, dict, explicitExports);
		}
	});
var $author$project$Extra$Type$Map$dropMissing = F3(
	function (pPure, _v0, _v1) {
		return pPure($elm$core$Maybe$Nothing);
	});
var $author$project$Extra$Type$Map$mapMissing = F4(
	function (pPure, f, k, a) {
		return pPure(
			$elm$core$Maybe$Just(
				A2(f, k, a)));
	});
var $author$project$Extra$Type$Map$toBothStep = F6(
	function (pLiftA2, f, k, a, b, fdc) {
		return A3(
			pLiftA2,
			F2(
				function (mc, dc) {
					if (mc.$ === 'Just') {
						var c = mc.a;
						return A3($author$project$Extra$Type$Map$insert, k, c, dc);
					} else {
						return dc;
					}
				}),
			A3(f, k, a, b),
			fdc);
	});
var $author$project$Extra$Type$Map$toSingleStep = F5(
	function (pLiftA2, f, k, a, fdc) {
		return A3(
			pLiftA2,
			F2(
				function (mc, dc) {
					if (mc.$ === 'Just') {
						var c = mc.a;
						return A3($author$project$Extra$Type$Map$insert, k, c, dc);
					} else {
						return dc;
					}
				}),
			A2(f, k, a),
			fdc);
	});
var $author$project$Extra$Type$Map$mergeA = F7(
	function (pPure, pLiftA2, missA, missB, zipAB, ma, mb) {
		return A6(
			$elm$core$Dict$merge,
			A2($author$project$Extra$Type$Map$toSingleStep, pLiftA2, missA),
			A2($author$project$Extra$Type$Map$toBothStep, pLiftA2, zipAB),
			A2($author$project$Extra$Type$Map$toSingleStep, pLiftA2, missB),
			ma,
			mb,
			pPure($author$project$Extra$Type$Map$empty));
	});
var $author$project$Extra$Type$Map$zipWithMatched = F5(
	function (pPure, f, k, a, b) {
		return pPure(
			$elm$core$Maybe$Just(
				A3(f, k, a, b)));
	});
var $author$project$Compiler$Elm$Interface$restrictAliases = F2(
	function (exports, aliases) {
		if (exports.$ === 'ExportEverything') {
			return A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Elm$Interface$PublicAlias, aliases);
		} else {
			var explicitExports = exports.a;
			var onRight = A2(
				$author$project$Extra$Type$Map$mapMissing,
				$elm$core$Basics$identity,
				F2(
					function (_v3, a) {
						return $author$project$Compiler$Elm$Interface$PrivateAlias(a);
					}));
			var onLeft = $author$project$Extra$Type$Map$dropMissing($elm$core$Basics$identity);
			var onBoth = A2(
				$author$project$Extra$Type$Map$zipWithMatched,
				$elm$core$Basics$identity,
				F3(
					function (_v1, _v2, a) {
						return $author$project$Compiler$Elm$Interface$PublicAlias(a);
					}));
			return A7($author$project$Extra$Type$Map$mergeA, $elm$core$Basics$identity, $elm$core$Basics$identity, onLeft, onRight, onBoth, explicitExports, aliases);
		}
	});
var $author$project$Compiler$Elm$Interface$restrictUnions = F2(
	function (exports, unions) {
		if (exports.$ === 'ExportEverything') {
			return A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Elm$Interface$OpenUnion, unions);
		} else {
			var explicitExports = exports.a;
			var onRight = A2(
				$author$project$Extra$Type$Map$mapMissing,
				$elm$core$Basics$identity,
				F2(
					function (_v4, union) {
						return $author$project$Compiler$Elm$Interface$PrivateUnion(union);
					}));
			var onLeft = $author$project$Extra$Type$Map$dropMissing($elm$core$Basics$identity);
			var onBoth = A2(
				$author$project$Extra$Type$Map$zipWithMatched,
				$elm$core$Basics$identity,
				F3(
					function (_v1, _v2, union) {
						var _export = _v2.b;
						switch (_export.$) {
							case 'ExportUnionOpen':
								return $author$project$Compiler$Elm$Interface$OpenUnion(union);
							case 'ExportUnionClosed':
								return $author$project$Compiler$Elm$Interface$ClosedUnion(union);
							default:
								return _Debug_todo(
									'Compiler.Elm.Interface',
									{
										start: {line: 125, column: 37},
										end: {line: 125, column: 47}
									})('impossible exports discovered in restrictUnions');
						}
					}));
			return A7($author$project$Extra$Type$Map$mergeA, $elm$core$Basics$identity, $elm$core$Basics$identity, onLeft, onRight, onBoth, explicitExports, unions);
		}
	});
var $author$project$Compiler$Elm$Interface$toOp = F2(
	function (types, _v0) {
		var associativity = _v0.a;
		var precedence = _v0.b;
		var name = _v0.c;
		return A4(
			$author$project$Compiler$Elm$Interface$Binop,
			name,
			A2($author$project$Extra$Type$Map$ex, types, name),
			associativity,
			precedence);
	});
var $author$project$Compiler$Elm$Interface$fromModule = F3(
	function (home, _v0, annotations) {
		var exports = _v0.b;
		var unions = _v0.d;
		var aliases = _v0.e;
		var binops = _v0.f;
		return A5(
			$author$project$Compiler$Elm$Interface$Interface,
			home,
			A2($author$project$Compiler$Elm$Interface$restrict, exports, annotations),
			A2($author$project$Compiler$Elm$Interface$restrictUnions, exports, unions),
			A2($author$project$Compiler$Elm$Interface$restrictAliases, exports, aliases),
			A2(
				$author$project$Compiler$Elm$Interface$restrict,
				exports,
				A2(
					$author$project$Extra$Type$Map$map,
					$author$project$Compiler$Elm$Interface$toOp(annotations),
					binops)));
	});
var $author$project$Compiler$Elm$Package$dummyName = A2($author$project$Compiler$Elm$Package$toName, 'author', 'project');
var $author$project$Builder$Build$projectTypeToPkg = function (projectType) {
	if (projectType.$ === 'Package') {
		var pkg = projectType.a;
		return pkg;
	} else {
		return $author$project$Compiler$Elm$Package$dummyName;
	}
};
var $author$project$Extra$System$File$createDirectoryIfMissing = F2(
	function (createParents, filePath) {
		return A3(
			$author$project$Extra$System$File$walkFileSystem,
			createParents,
			filePath,
			F2(
				function (maybeNode, now) {
					return _Utils_Tuple2(
						A2(
							$elm$core$Maybe$andThen,
							function (_v0) {
								var directory = _v0.a;
								var fileName = _v0.b;
								var maybeEntry = _v0.c;
								if (maybeEntry.$ === 'Nothing') {
									return $elm$core$Maybe$Just(
										A3(
											$author$project$Extra$Type$Map$insert,
											fileName,
											_Utils_Tuple2(
												now,
												$author$project$Extra$System$File$DirectoryEntry($author$project$Extra$Type$Map$empty)),
											directory));
								} else {
									return $elm$core$Maybe$Nothing;
								}
							},
							maybeNode),
						_Utils_Tuple0);
				}));
	});
var $author$project$Extra$System$File$splitLastName = function (path) {
	_v0$2:
	while (true) {
		if (path.$ === 'Absolute') {
			if (path.a.b) {
				var _v1 = path.a;
				var name = _v1.a;
				var rest = _v1.b;
				return _Utils_Tuple2(
					$author$project$Extra$System$File$Absolute(rest),
					name);
			} else {
				break _v0$2;
			}
		} else {
			if (path.a.b) {
				var _v2 = path.a;
				var name = _v2.a;
				var rest = _v2.b;
				return _Utils_Tuple2(
					$author$project$Extra$System$File$Relative(rest),
					name);
			} else {
				break _v0$2;
			}
		}
	}
	return _Utils_Tuple2(path, '');
};
var $author$project$Extra$System$File$dropLastName = function (path) {
	return $author$project$Extra$System$File$splitLastName(path).a;
};
var $elm$bytes$Bytes$Encode$encode = _Bytes_encode;
var $author$project$Extra$Data$Binary$Put$runPut = $elm$bytes$Bytes$Encode$encode;
var $author$project$Extra$System$File$FileEntry = function (a) {
	return {$: 'FileEntry', a: a};
};
var $author$project$Extra$System$File$writeFile = F2(
	function (filePath, contents) {
		return A3(
			$author$project$Extra$System$File$walkFileSystem,
			false,
			filePath,
			F2(
				function (maybeNode, now) {
					if (maybeNode.$ === 'Just') {
						if ((maybeNode.a.c.$ === 'Just') && (maybeNode.a.c.a.b.$ === 'DirectoryEntry')) {
							var _v1 = maybeNode.a;
							var _v2 = _v1.c.a;
							return _Utils_Tuple2($elm$core$Maybe$Nothing, _Utils_Tuple0);
						} else {
							var _v3 = maybeNode.a;
							var directory = _v3.a;
							var fileName = _v3.b;
							return _Utils_Tuple2(
								$elm$core$Maybe$Just(
									A3(
										$author$project$Extra$Type$Map$insert,
										fileName,
										_Utils_Tuple2(
											now,
											$author$project$Extra$System$File$FileEntry(contents)),
										directory)),
								_Utils_Tuple0);
						}
					} else {
						return _Utils_Tuple2($elm$core$Maybe$Nothing, _Utils_Tuple0);
					}
				}));
	});
var $author$project$Extra$Data$Binary$encodeFile = F3(
	function (binV, path, v) {
		return A2(
			$author$project$Extra$System$File$writeFile,
			path,
			$author$project$Extra$Data$Binary$Put$runPut(
				binV.put(v)));
	});
var $author$project$Builder$File$writeBinary = F3(
	function (binA, path, value) {
		var dir = $author$project$Extra$System$File$dropLastName(path);
		return A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Extra$System$File$createDirectoryIfMissing, true, dir),
			function (_v0) {
				return A3($author$project$Extra$Data$Binary$encodeFile, binA, path, value);
			});
	});
var $author$project$Builder$Build$compile = F5(
	function (_v0, _v1, source, ifaces, modul) {
		var root = _v0.a;
		var projectType = _v0.b;
		var buildID = _v0.d;
		var path = _v1.a;
		var time = _v1.b;
		var deps = _v1.c;
		var main = _v1.d;
		var lastChange = _v1.e;
		var pkg = $author$project$Builder$Build$projectTypeToPkg(projectType);
		var _v2 = A3($author$project$Compiler$Compile$compile, pkg, ifaces, modul);
		if (_v2.$ === 'Right') {
			var _v3 = _v2.a;
			var canonical = _v3.a;
			var annotations = _v3.b;
			var objects = _v3.c;
			var name = $author$project$Compiler$AST$Source$getName(modul);
			var iface = A3($author$project$Compiler$Elm$Interface$fromModule, pkg, canonical, annotations);
			var elmi = A2($author$project$Builder$Stuff$elmi, root, name);
			return A2(
				$author$project$Extra$System$IO$bind,
				A3(
					$author$project$Builder$File$writeBinary,
					$author$project$Compiler$AST$Optimized$bLocalGraph,
					A2($author$project$Builder$Stuff$elmo, root, name),
					objects),
				function (_v4) {
					return A2(
						$author$project$Extra$System$IO$bind,
						A2($author$project$Builder$File$readBinary, $author$project$Compiler$Elm$Interface$bInterface, elmi),
						function (maybeOldi) {
							var otherwise = function (_v7) {
								return A2(
									$author$project$Extra$System$IO$bind,
									A3($author$project$Builder$File$writeBinary, $author$project$Compiler$Elm$Interface$bInterface, elmi, iface),
									function (_v6) {
										var local = A6($author$project$Builder$Elm$Details$Local, path, time, deps, main, buildID, buildID);
										return $author$project$Extra$System$IO$return(
											A3($author$project$Builder$Build$RNew, local, iface, objects));
									});
							};
							if (maybeOldi.$ === 'Just') {
								var oldi = maybeOldi.a;
								if (_Utils_eq(oldi, iface)) {
									var local = A6($author$project$Builder$Elm$Details$Local, path, time, deps, main, lastChange, buildID);
									return $author$project$Extra$System$IO$return(
										A3($author$project$Builder$Build$RSame, local, iface, objects));
								} else {
									return otherwise(_Utils_Tuple0);
								}
							} else {
								return otherwise(_Utils_Tuple0);
							}
						});
				});
		} else {
			var err = _v2.a;
			return $author$project$Extra$System$IO$return(
				$author$project$Builder$Build$RProblem(
					A5(
						$author$project$Compiler$Reporting$Error$Module,
						$author$project$Compiler$AST$Source$getName(modul),
						path,
						time,
						source,
						err)));
		}
	});
var $author$project$Compiler$Reporting$Error$Syntax$ModuleBadEnd = F2(
	function (a, b) {
		return {$: 'ModuleBadEnd', a: a, b: b};
	});
var $author$project$Compiler$AST$Source$Module = F8(
	function (a, b, c, d, e, f, g, h) {
		return {$: 'Module', a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h};
	});
var $author$project$Compiler$AST$Source$NoEffects = {$: 'NoEffects'};
var $author$project$Compiler$AST$Source$Ports = function (a) {
	return {$: 'Ports', a: a};
};
var $author$project$Compiler$Parse$Module$categorizeDecls = F5(
	function (values, unions, aliases, ports, decls) {
		categorizeDecls:
		while (true) {
			if (!decls.b) {
				return _Utils_Tuple2(
					_Utils_Tuple2(values, unions),
					_Utils_Tuple2(aliases, ports));
			} else {
				var decl = decls.a;
				var otherDecls = decls.b;
				switch (decl.$) {
					case 'Value':
						var value = decl.a;
						var $temp$values = A2($elm$core$List$cons, value, values),
							$temp$unions = unions,
							$temp$aliases = aliases,
							$temp$ports = ports,
							$temp$decls = otherDecls;
						values = $temp$values;
						unions = $temp$unions;
						aliases = $temp$aliases;
						ports = $temp$ports;
						decls = $temp$decls;
						continue categorizeDecls;
					case 'Union':
						var union = decl.a;
						var $temp$values = values,
							$temp$unions = A2($elm$core$List$cons, union, unions),
							$temp$aliases = aliases,
							$temp$ports = ports,
							$temp$decls = otherDecls;
						values = $temp$values;
						unions = $temp$unions;
						aliases = $temp$aliases;
						ports = $temp$ports;
						decls = $temp$decls;
						continue categorizeDecls;
					case 'Alias':
						var alias_ = decl.a;
						var $temp$values = values,
							$temp$unions = unions,
							$temp$aliases = A2($elm$core$List$cons, alias_, aliases),
							$temp$ports = ports,
							$temp$decls = otherDecls;
						values = $temp$values;
						unions = $temp$unions;
						aliases = $temp$aliases;
						ports = $temp$ports;
						decls = $temp$decls;
						continue categorizeDecls;
					default:
						var port_ = decl.a;
						var $temp$values = values,
							$temp$unions = unions,
							$temp$aliases = aliases,
							$temp$ports = A2($elm$core$List$cons, port_, ports),
							$temp$decls = otherDecls;
						values = $temp$values;
						unions = $temp$unions;
						aliases = $temp$aliases;
						ports = $temp$ports;
						decls = $temp$decls;
						continue categorizeDecls;
				}
			}
		}
	});
var $author$project$Compiler$AST$Source$Manager = F2(
	function (a, b) {
		return {$: 'Manager', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$NoEffectsOutsideKernel = function (a) {
	return {$: 'NoEffectsOutsideKernel', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$NoPortModulesInPackage = function (a) {
	return {$: 'NoPortModulesInPackage', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$NoPorts = function (a) {
	return {$: 'NoPorts', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$NoPortsInPackage = function (a) {
	return {$: 'NoPortsInPackage', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$UnexpectedPort = function (a) {
	return {$: 'UnexpectedPort', a: a};
};
var $author$project$Compiler$Parse$Module$isKernel = function (projectType) {
	if (projectType.$ === 'Package') {
		var pkg = projectType.a;
		return $author$project$Compiler$Elm$Package$isKernel(pkg);
	} else {
		return false;
	}
};
var $author$project$Compiler$Parse$Module$checkEffects = F3(
	function (projectType, ports, effects) {
		switch (effects.$) {
			case 'NoEffects':
				var region = effects.a;
				if (!ports.b) {
					return $author$project$Extra$Type$Either$Right($author$project$Compiler$AST$Source$NoEffects);
				} else {
					var _v2 = ports.a;
					var name = _v2.a;
					if (projectType.$ === 'Package') {
						return $author$project$Extra$Type$Either$Left(
							$author$project$Compiler$Reporting$Error$Syntax$NoPortsInPackage(name));
					} else {
						return $author$project$Extra$Type$Either$Left(
							$author$project$Compiler$Reporting$Error$Syntax$UnexpectedPort(region));
					}
				}
			case 'Ports':
				var region = effects.a;
				if (projectType.$ === 'Package') {
					return $author$project$Extra$Type$Either$Left(
						$author$project$Compiler$Reporting$Error$Syntax$NoPortModulesInPackage(region));
				} else {
					if (!ports.b) {
						return $author$project$Extra$Type$Either$Left(
							$author$project$Compiler$Reporting$Error$Syntax$NoPorts(region));
					} else {
						return $author$project$Extra$Type$Either$Right(
							$author$project$Compiler$AST$Source$Ports(ports));
					}
				}
			default:
				var region = effects.a;
				var manager = effects.b;
				if ($author$project$Compiler$Parse$Module$isKernel(projectType)) {
					if (!ports.b) {
						return $author$project$Extra$Type$Either$Right(
							A2($author$project$Compiler$AST$Source$Manager, region, manager));
					} else {
						return $author$project$Extra$Type$Either$Left(
							$author$project$Compiler$Reporting$Error$Syntax$UnexpectedPort(region));
					}
				} else {
					return $author$project$Extra$Type$Either$Left(
						$author$project$Compiler$Reporting$Error$Syntax$NoEffectsOutsideKernel(region));
				}
		}
	});
var $author$project$Compiler$Reporting$Annotation$one = A2(
	$author$project$Compiler$Reporting$Annotation$Region,
	A2($author$project$Compiler$Reporting$Annotation$Position, 1, 1),
	A2($author$project$Compiler$Reporting$Annotation$Position, 1, 1));
var $author$project$Compiler$Parse$Module$checkModule = F2(
	function (projectType, _v0) {
		var maybeHeader = _v0.a;
		var imports = _v0.b;
		var infixes = _v0.c;
		var decls = _v0.d;
		var _v1 = A5($author$project$Compiler$Parse$Module$categorizeDecls, _List_Nil, _List_Nil, _List_Nil, _List_Nil, decls);
		var _v2 = _v1.a;
		var values = _v2.a;
		var unions = _v2.b;
		var _v3 = _v1.b;
		var aliases = _v3.a;
		var ports = _v3.b;
		if (maybeHeader.$ === 'Just') {
			var _v5 = maybeHeader.a;
			var name = _v5.a;
			var effects = _v5.b;
			var exports = _v5.c;
			return A2(
				$author$project$Extra$Type$Either$fmap,
				A7(
					$author$project$Compiler$AST$Source$Module,
					$elm$core$Maybe$Just(name),
					exports,
					imports,
					values,
					unions,
					aliases,
					infixes),
				A3($author$project$Compiler$Parse$Module$checkEffects, projectType, ports, effects));
		} else {
			return $author$project$Extra$Type$Either$Right(
				A8(
					$author$project$Compiler$AST$Source$Module,
					$elm$core$Maybe$Nothing,
					A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$one, $author$project$Compiler$AST$Source$Open),
					imports,
					values,
					unions,
					aliases,
					infixes,
					function () {
						if (!ports.b) {
							return $author$project$Compiler$AST$Source$NoEffects;
						} else {
							return $author$project$Compiler$AST$Source$Ports(ports);
						}
					}()));
		}
	});
var $author$project$Compiler$Parse$Module$Module = F4(
	function (a, b, c, d) {
		return {$: 'Module', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Parse$Module$chompDeclsHelp = function (decls) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Reporting$Error$Syntax$DeclStart),
				function (_v0) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Declaration$declaration,
						function (_v1) {
							var decl = _v1.a;
							return $author$project$Compiler$Parse$Primitives$return(
								$author$project$Compiler$Parse$Primitives$Loop(
									A2($elm$core$List$cons, decl, decls)));
						});
				})
			]),
		$author$project$Compiler$Parse$Primitives$Done(
			$author$project$Extra$Type$List$reverse(decls)));
};
var $author$project$Compiler$Parse$Module$chompDecls = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Declaration$declaration,
	function (_v0) {
		var decl = _v0.a;
		return A2(
			$author$project$Compiler$Parse$Primitives$loop,
			$author$project$Compiler$Parse$Module$chompDeclsHelp,
			_List_fromArray(
				[decl]));
	});
var $author$project$Compiler$Reporting$Error$Syntax$Effect = F2(
	function (a, b) {
		return {$: 'Effect', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$FreshLine = F2(
	function (a, b) {
		return {$: 'FreshLine', a: a, b: b};
	});
var $author$project$Compiler$Parse$Module$Header = F3(
	function (a, b, c) {
		return {$: 'Header', a: a, b: b, c: c};
	});
var $author$project$Compiler$Parse$Module$Manager = F2(
	function (a, b) {
		return {$: 'Manager', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ModuleExposing = F3(
	function (a, b, c) {
		return {$: 'ModuleExposing', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ModuleName = F2(
	function (a, b) {
		return {$: 'ModuleName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ModuleProblem = F2(
	function (a, b) {
		return {$: 'ModuleProblem', a: a, b: b};
	});
var $author$project$Compiler$Parse$Module$NoEffects = function (a) {
	return {$: 'NoEffects', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$PortModuleExposing = F3(
	function (a, b, c) {
		return {$: 'PortModuleExposing', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortModuleName = F2(
	function (a, b) {
		return {$: 'PortModuleName', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem = F2(
	function (a, b) {
		return {$: 'PortModuleProblem', a: a, b: b};
	});
var $author$project$Compiler$Parse$Module$Ports = function (a) {
	return {$: 'Ports', a: a};
};
var $author$project$Compiler$AST$Source$CCmd = function (a) {
	return {$: 'CCmd', a: a};
};
var $author$project$Compiler$AST$Source$CSub = function (a) {
	return {$: 'CSub', a: a};
};
var $author$project$Compiler$AST$Source$Fx = F2(
	function (a, b) {
		return {$: 'Fx', a: a, b: b};
	});
var $author$project$Compiler$Parse$Keyword$k7 = F8(
	function (w1, w2, w3, w4, w5, w6, w7, toError) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var pos7 = pos + 7;
				if ((_Utils_cmp(pos7, end) < 1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos),
					w1) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1),
					w2) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2),
					w3) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3),
					w4) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4),
					w5) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 5),
					w6) && (_Utils_eq(
					A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 6),
					w7) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos7, end)))))))))) {
					var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos7, end, indent, row, col + 7);
					return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
				}
			});
	});
var $author$project$Compiler$Parse$Keyword$command_ = function (tx) {
	return A8($author$project$Compiler$Parse$Keyword$k7, 99, 111, 109, 109, 97, 110, 100, tx);
};
var $author$project$Compiler$Parse$Module$spaces_em = A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect);
var $author$project$Compiler$Parse$Module$chompCommand = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Keyword$command_($author$project$Compiler$Reporting$Error$Syntax$Effect),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Module$spaces_em,
			function (_v1) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$Effect),
					function (_v2) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Module$spaces_em,
							function (_v3) {
								return $author$project$Compiler$Parse$Primitives$addLocation(
									$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$Effect));
							});
					});
			});
	});
var $author$project$Compiler$Parse$Keyword$subscription_ = function (toError) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			var pos12 = pos + 12;
			if ((_Utils_cmp(pos12, end) < 1) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) === 115) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 1) === 117) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2) === 98) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3) === 115) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4) === 99) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 5) === 114) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 6) === 105) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 7) === 112) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 8) === 116) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 9) === 105) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 10) === 111) && ((A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 11) === 110) && (!A3($author$project$Compiler$Parse$Variable$getInnerWidth, src, pos12, end))))))))))))))) {
				var s = A6($author$project$Compiler$Parse$Primitives$State, src, pos12, end, indent, row, col + 12);
				return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, s);
			} else {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toError);
			}
		});
};
var $author$project$Compiler$Parse$Module$chompSubscription = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Keyword$subscription_($author$project$Compiler$Reporting$Error$Syntax$Effect),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Module$spaces_em,
			function (_v1) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Reporting$Error$Syntax$Effect),
					function (_v2) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Module$spaces_em,
							function (_v3) {
								return $author$project$Compiler$Parse$Primitives$addLocation(
									$author$project$Compiler$Parse$Variable$upper($author$project$Compiler$Reporting$Error$Syntax$Effect));
							});
					});
			});
	});
var $author$project$Compiler$Parse$Module$chompManager = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	A2($author$project$Compiler$Parse$Primitives$word1, 123, $author$project$Compiler$Reporting$Error$Syntax$Effect),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Module$spaces_em,
			function (_v1) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOf,
					$author$project$Compiler$Reporting$Error$Syntax$Effect,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Module$chompCommand,
							function (cmd) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Module$spaces_em,
									function (_v2) {
										return A2(
											$author$project$Compiler$Parse$Primitives$oneOf,
											$author$project$Compiler$Reporting$Error$Syntax$Effect,
											_List_fromArray(
												[
													A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$Effect),
													function (_v3) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															$author$project$Compiler$Parse$Module$spaces_em,
															function (_v4) {
																return $author$project$Compiler$Parse$Primitives$return(
																	$author$project$Compiler$AST$Source$CCmd(cmd));
															});
													}),
													A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$Effect),
													function (_v5) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															$author$project$Compiler$Parse$Module$spaces_em,
															function (_v6) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Module$chompSubscription,
																	function (sub) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			$author$project$Compiler$Parse$Module$spaces_em,
																			function (_v7) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$Effect),
																					function (_v8) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							$author$project$Compiler$Parse$Module$spaces_em,
																							function (_v9) {
																								return $author$project$Compiler$Parse$Primitives$return(
																									A2($author$project$Compiler$AST$Source$Fx, cmd, sub));
																							});
																					});
																			});
																	});
															});
													})
												]));
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Module$chompSubscription,
							function (sub) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Module$spaces_em,
									function (_v10) {
										return A2(
											$author$project$Compiler$Parse$Primitives$oneOf,
											$author$project$Compiler$Reporting$Error$Syntax$Effect,
											_List_fromArray(
												[
													A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$Effect),
													function (_v11) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															$author$project$Compiler$Parse$Module$spaces_em,
															function (_v12) {
																return $author$project$Compiler$Parse$Primitives$return(
																	$author$project$Compiler$AST$Source$CSub(sub));
															});
													}),
													A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Reporting$Error$Syntax$Effect),
													function (_v13) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															$author$project$Compiler$Parse$Module$spaces_em,
															function (_v14) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Module$chompCommand,
																	function (cmd) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			$author$project$Compiler$Parse$Module$spaces_em,
																			function (_v15) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Reporting$Error$Syntax$Effect),
																					function (_v16) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							$author$project$Compiler$Parse$Module$spaces_em,
																							function (_v17) {
																								return $author$project$Compiler$Parse$Primitives$return(
																									A2($author$project$Compiler$AST$Source$Fx, cmd, sub));
																							});
																					});
																			});
																	});
															});
													})
												]));
									});
							})
						]));
			});
	});
var $author$project$Compiler$Parse$Module$chompModuleDocCommentSpace = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Primitives$addLocation(
		$author$project$Compiler$Parse$Module$freshLine($author$project$Compiler$Reporting$Error$Syntax$FreshLine)),
	function (_v0) {
		var region = _v0.a;
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Space$docComment, $author$project$Compiler$Reporting$Error$Syntax$ImportStart, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace),
					function (docComment) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Reporting$Error$Syntax$ModuleSpace),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Reporting$Error$Syntax$FreshLine),
									function (_v2) {
										return $author$project$Compiler$Parse$Primitives$return(
											$author$project$Extra$Type$Either$Right(docComment));
									});
							});
					})
				]),
			$author$project$Extra$Type$Either$Left(region));
	});
var $author$project$Compiler$Parse$Keyword$effect_ = function (tx) {
	return A7($author$project$Compiler$Parse$Keyword$k6, 101, 102, 102, 101, 99, 116, tx);
};
var $author$project$Compiler$Parse$Keyword$module_ = function (tx) {
	return A7($author$project$Compiler$Parse$Keyword$k6, 109, 111, 100, 117, 108, 101, tx);
};
var $author$project$Compiler$Parse$Keyword$where_ = function (tx) {
	return A6($author$project$Compiler$Parse$Keyword$k5, 119, 104, 101, 114, 101, tx);
};
var $author$project$Compiler$Parse$Module$chompHeader = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Parse$Module$freshLine($author$project$Compiler$Reporting$Error$Syntax$FreshLine),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Parse$Primitives$getPosition,
			function (start) {
				return A2(
					$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Keyword$module_($author$project$Compiler$Reporting$Error$Syntax$ModuleProblem),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Parse$Primitives$getPosition,
									function (effectEnd) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$ModuleProblem),
											function (_v2) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													$author$project$Compiler$Parse$Primitives$addLocation(
														$author$project$Compiler$Parse$Variable$moduleName($author$project$Compiler$Reporting$Error$Syntax$ModuleName)),
													function (name) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$ModuleProblem),
															function (_v3) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Keyword$exposing_($author$project$Compiler$Reporting$Error$Syntax$ModuleProblem),
																	function (_v4) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$ModuleProblem),
																			function (_v5) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					$author$project$Compiler$Parse$Primitives$addLocation(
																						A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$ModuleExposing, $author$project$Compiler$Parse$Module$exposing_)),
																					function (exports) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							$author$project$Compiler$Parse$Module$chompModuleDocCommentSpace,
																							function (_v6) {
																								return $author$project$Compiler$Parse$Primitives$return(
																									$elm$core$Maybe$Just(
																										A3(
																											$author$project$Compiler$Parse$Module$Header,
																											name,
																											$author$project$Compiler$Parse$Module$NoEffects(
																												A2($author$project$Compiler$Reporting$Annotation$Region, start, effectEnd)),
																											exports)));
																							});
																					});
																			});
																	});
															});
													});
											});
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Keyword$port_($author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
							function (_v7) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
									function (_v8) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Keyword$module_($author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
											function (_v9) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													$author$project$Compiler$Parse$Primitives$getPosition,
													function (effectEnd) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
															function (_v10) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Primitives$addLocation(
																		$author$project$Compiler$Parse$Variable$moduleName($author$project$Compiler$Reporting$Error$Syntax$PortModuleName)),
																	function (name) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
																			function (_v11) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					$author$project$Compiler$Parse$Keyword$exposing_($author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
																					function (_v12) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$PortModuleProblem),
																							function (_v13) {
																								return A2(
																									$author$project$Compiler$Parse$Primitives$bind,
																									$author$project$Compiler$Parse$Primitives$addLocation(
																										A2($author$project$Compiler$Parse$Primitives$specialize, $author$project$Compiler$Reporting$Error$Syntax$PortModuleExposing, $author$project$Compiler$Parse$Module$exposing_)),
																									function (exports) {
																										return A2(
																											$author$project$Compiler$Parse$Primitives$bind,
																											$author$project$Compiler$Parse$Module$chompModuleDocCommentSpace,
																											function (_v14) {
																												return $author$project$Compiler$Parse$Primitives$return(
																													$elm$core$Maybe$Just(
																														A3(
																															$author$project$Compiler$Parse$Module$Header,
																															name,
																															$author$project$Compiler$Parse$Module$Ports(
																																A2($author$project$Compiler$Reporting$Annotation$Region, start, effectEnd)),
																															exports)));
																											});
																									});
																							});
																					});
																			});
																	});
															});
													});
											});
									});
							}),
							A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Keyword$effect_($author$project$Compiler$Reporting$Error$Syntax$Effect),
							function (_v15) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect),
									function (_v16) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Keyword$module_($author$project$Compiler$Reporting$Error$Syntax$Effect),
											function (_v17) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													$author$project$Compiler$Parse$Primitives$getPosition,
													function (effectEnd) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect),
															function (_v18) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Parse$Primitives$addLocation(
																		$author$project$Compiler$Parse$Variable$moduleName($author$project$Compiler$Reporting$Error$Syntax$ModuleName)),
																	function (name) {
																		return A2(
																			$author$project$Compiler$Parse$Primitives$bind,
																			A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect),
																			function (_v19) {
																				return A2(
																					$author$project$Compiler$Parse$Primitives$bind,
																					$author$project$Compiler$Parse$Keyword$where_($author$project$Compiler$Reporting$Error$Syntax$Effect),
																					function (_v20) {
																						return A2(
																							$author$project$Compiler$Parse$Primitives$bind,
																							A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect),
																							function (_v21) {
																								return A2(
																									$author$project$Compiler$Parse$Primitives$bind,
																									$author$project$Compiler$Parse$Module$chompManager,
																									function (manager) {
																										return A2(
																											$author$project$Compiler$Parse$Primitives$bind,
																											A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect),
																											function (_v22) {
																												return A2(
																													$author$project$Compiler$Parse$Primitives$bind,
																													$author$project$Compiler$Parse$Keyword$exposing_($author$project$Compiler$Reporting$Error$Syntax$Effect),
																													function (_v23) {
																														return A2(
																															$author$project$Compiler$Parse$Primitives$bind,
																															A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, $author$project$Compiler$Reporting$Error$Syntax$ModuleSpace, $author$project$Compiler$Reporting$Error$Syntax$Effect),
																															function (_v24) {
																																return A2(
																																	$author$project$Compiler$Parse$Primitives$bind,
																																	$author$project$Compiler$Parse$Primitives$addLocation(
																																		A2(
																																			$author$project$Compiler$Parse$Primitives$specialize,
																																			$elm$core$Basics$always($author$project$Compiler$Reporting$Error$Syntax$Effect),
																																			$author$project$Compiler$Parse$Module$exposing_)),
																																	function (exports) {
																																		return A2(
																																			$author$project$Compiler$Parse$Primitives$bind,
																																			$author$project$Compiler$Parse$Module$chompModuleDocCommentSpace,
																																			function (_v25) {
																																				return $author$project$Compiler$Parse$Primitives$return(
																																					$elm$core$Maybe$Just(
																																						A3(
																																							$author$project$Compiler$Parse$Module$Header,
																																							name,
																																							A2(
																																								$author$project$Compiler$Parse$Module$Manager,
																																								A2($author$project$Compiler$Reporting$Annotation$Region, start, effectEnd),
																																								manager),
																																							exports)));
																																			});
																																	});
																															});
																													});
																											});
																									});
																							});
																					});
																			});
																	});
															});
													});
											});
									});
							})
						]),
					$elm$core$Maybe$Nothing);
			});
	});
var $author$project$Compiler$Parse$Module$chompImports = function (is) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Module$chompImport,
				function (i) {
					return $author$project$Compiler$Parse$Module$chompImports(
						A2($elm$core$List$cons, i, is));
				})
			]),
		$author$project$Extra$Type$List$reverse(is));
};
var $author$project$Compiler$AST$Source$Infix = F4(
	function (a, b, c, d) {
		return {$: 'Infix', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Reporting$Error$Syntax$Infix = F2(
	function (a, b) {
		return {$: 'Infix', a: a, b: b};
	});
var $author$project$Compiler$Parse$Keyword$infix_ = function (tx) {
	return A6($author$project$Compiler$Parse$Keyword$k5, 105, 110, 102, 105, 120, tx);
};
var $author$project$Compiler$Parse$Keyword$left_ = function (tx) {
	return A5($author$project$Compiler$Parse$Keyword$k4, 108, 101, 102, 116, tx);
};
var $author$project$Compiler$Parse$Keyword$non_ = function (tx) {
	return A4($author$project$Compiler$Parse$Keyword$k3, 110, 111, 110, tx);
};
var $author$project$Compiler$Parse$Number$precedence = function (toExpectation) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			if (_Utils_cmp(pos, end) > -1) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				return $author$project$Compiler$Parse$Number$isDecimalDigit(word) ? A2(
					$author$project$Compiler$Parse$Primitives$Cok,
					$author$project$Compiler$AST$Utils$Binop$Precedence(word - 48),
					A6($author$project$Compiler$Parse$Primitives$State, src, pos + 1, end, indent, row, col + 1)) : A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, toExpectation);
			}
		});
};
var $author$project$Compiler$Parse$Keyword$right_ = function (tx) {
	return A6($author$project$Compiler$Parse$Keyword$k5, 114, 105, 103, 104, 116, tx);
};
var $author$project$Compiler$Parse$Declaration$infix_ = function () {
	var err_ = function (_v14) {
		return $author$project$Compiler$Reporting$Error$Syntax$Infix;
	};
	var err = $author$project$Compiler$Reporting$Error$Syntax$Infix;
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Primitives$getPosition,
		function (start) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Keyword$infix_(err),
				function (_v0) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
						function (_v1) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2(
									$author$project$Compiler$Parse$Primitives$oneOf,
									err,
									_List_fromArray(
										[
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Keyword$left_(err),
											function (_v2) {
												return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$AST$Utils$Binop$Left);
											}),
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Keyword$right_(err),
											function (_v3) {
												return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$AST$Utils$Binop$Right);
											}),
											A2(
											$author$project$Compiler$Parse$Primitives$bind,
											$author$project$Compiler$Parse$Keyword$non_(err),
											function (_v4) {
												return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$AST$Utils$Binop$Non);
											})
										])),
								function (associativity) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
										function (_v5) {
											return A2(
												$author$project$Compiler$Parse$Primitives$bind,
												$author$project$Compiler$Parse$Number$precedence(err),
												function (precedence) {
													return A2(
														$author$project$Compiler$Parse$Primitives$bind,
														A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
														function (_v6) {
															return A2(
																$author$project$Compiler$Parse$Primitives$bind,
																A2($author$project$Compiler$Parse$Primitives$word1, 40, err),
																function (_v7) {
																	return A2(
																		$author$project$Compiler$Parse$Primitives$bind,
																		A2($author$project$Compiler$Parse$Symbol$operator, err, err_),
																		function (op) {
																			return A2(
																				$author$project$Compiler$Parse$Primitives$bind,
																				A2($author$project$Compiler$Parse$Primitives$word1, 41, err),
																				function (_v8) {
																					return A2(
																						$author$project$Compiler$Parse$Primitives$bind,
																						A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
																						function (_v9) {
																							return A2(
																								$author$project$Compiler$Parse$Primitives$bind,
																								A2($author$project$Compiler$Parse$Primitives$word1, 61, err),
																								function (_v10) {
																									return A2(
																										$author$project$Compiler$Parse$Primitives$bind,
																										A2($author$project$Compiler$Parse$Space$chompAndCheckIndent, err_, err),
																										function (_v11) {
																											return A2(
																												$author$project$Compiler$Parse$Primitives$bind,
																												$author$project$Compiler$Parse$Variable$lower(err),
																												function (name) {
																													return A2(
																														$author$project$Compiler$Parse$Primitives$bind,
																														$author$project$Compiler$Parse$Primitives$getPosition,
																														function (end) {
																															return A2(
																																$author$project$Compiler$Parse$Primitives$bind,
																																$author$project$Compiler$Parse$Space$chomp(err_),
																																function (_v12) {
																																	return A2(
																																		$author$project$Compiler$Parse$Primitives$bind,
																																		$author$project$Compiler$Parse$Space$checkFreshLine(err),
																																		function (_v13) {
																																			return $author$project$Compiler$Parse$Primitives$return(
																																				A3(
																																					$author$project$Compiler$Reporting$Annotation$at,
																																					start,
																																					end,
																																					A4($author$project$Compiler$AST$Source$Infix, op, associativity, precedence, name)));
																																		});
																																});
																														});
																												});
																										});
																								});
																						});
																				});
																		});
																});
														});
												});
										});
								});
						});
				});
		});
}();
var $author$project$Compiler$Parse$Module$chompInfixes = function (infixes) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Declaration$infix_,
				function (binop) {
					return $author$project$Compiler$Parse$Module$chompInfixes(
						A2($elm$core$List$cons, binop, infixes));
				})
			]),
		infixes);
};
var $author$project$Compiler$Elm$Compiler$Imports$closed = $author$project$Compiler$AST$Source$Explicit(_List_Nil);
var $author$project$Compiler$Elm$Compiler$Imports$import_ = F3(
	function (_v0, maybeAlias, exposing_) {
		var name = _v0.b;
		return A3(
			$author$project$Compiler$AST$Source$Import,
			A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, name),
			maybeAlias,
			exposing_);
	});
var $author$project$Compiler$Elm$Compiler$Imports$operator = function (op) {
	return $author$project$Compiler$AST$Source$Explicit(
		_List_fromArray(
			[
				A2($author$project$Compiler$AST$Source$Operator, $author$project$Compiler$Reporting$Annotation$zero, op)
			]));
};
var $author$project$Compiler$Data$Name$result = 'Result';
var $author$project$Compiler$Elm$ModuleName$result = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$result);
var $author$project$Compiler$Data$Name$tuple = 'Tuple';
var $author$project$Compiler$Elm$ModuleName$tuple = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$tuple);
var $author$project$Compiler$Elm$Compiler$Imports$typeClosed = function (name) {
	return $author$project$Compiler$AST$Source$Explicit(
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$AST$Source$Upper,
				A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, name),
				$author$project$Compiler$AST$Source$Private)
			]));
};
var $author$project$Compiler$Elm$Compiler$Imports$typeOpen = function (name) {
	return $author$project$Compiler$AST$Source$Explicit(
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$AST$Source$Upper,
				A2($author$project$Compiler$Reporting$Annotation$At, $author$project$Compiler$Reporting$Annotation$zero, name),
				$author$project$Compiler$AST$Source$Public($author$project$Compiler$Reporting$Annotation$zero))
			]));
};
var $author$project$Compiler$Elm$Compiler$Imports$defaults = _List_fromArray(
	[
		A3($author$project$Compiler$Elm$Compiler$Imports$import_, $author$project$Compiler$Elm$ModuleName$basics, $elm$core$Maybe$Nothing, $author$project$Compiler$AST$Source$Open),
		A3($author$project$Compiler$Elm$Compiler$Imports$import_, $author$project$Compiler$Elm$ModuleName$debug, $elm$core$Maybe$Nothing, $author$project$Compiler$Elm$Compiler$Imports$closed),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$list,
		$elm$core$Maybe$Nothing,
		$author$project$Compiler$Elm$Compiler$Imports$operator('::')),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$maybe,
		$elm$core$Maybe$Nothing,
		$author$project$Compiler$Elm$Compiler$Imports$typeOpen($author$project$Compiler$Data$Name$maybe)),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$result,
		$elm$core$Maybe$Nothing,
		$author$project$Compiler$Elm$Compiler$Imports$typeOpen($author$project$Compiler$Data$Name$result)),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$string,
		$elm$core$Maybe$Nothing,
		$author$project$Compiler$Elm$Compiler$Imports$typeClosed($author$project$Compiler$Data$Name$string)),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$char,
		$elm$core$Maybe$Nothing,
		$author$project$Compiler$Elm$Compiler$Imports$typeClosed($author$project$Compiler$Data$Name$char)),
		A3($author$project$Compiler$Elm$Compiler$Imports$import_, $author$project$Compiler$Elm$ModuleName$tuple, $elm$core$Maybe$Nothing, $author$project$Compiler$Elm$Compiler$Imports$closed),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$platform,
		$elm$core$Maybe$Nothing,
		$author$project$Compiler$Elm$Compiler$Imports$typeClosed($author$project$Compiler$Data$Name$program)),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$cmd,
		$elm$core$Maybe$Just($author$project$Compiler$Data$Name$cmd),
		$author$project$Compiler$Elm$Compiler$Imports$typeClosed($author$project$Compiler$Data$Name$cmd)),
		A3(
		$author$project$Compiler$Elm$Compiler$Imports$import_,
		$author$project$Compiler$Elm$ModuleName$sub,
		$elm$core$Maybe$Just($author$project$Compiler$Data$Name$sub),
		$author$project$Compiler$Elm$Compiler$Imports$typeClosed($author$project$Compiler$Data$Name$sub))
	]);
var $author$project$Compiler$Parse$Module$isCore = function (projectType) {
	if (projectType.$ === 'Package') {
		var pkg = projectType.a;
		return _Utils_eq(pkg, $author$project$Compiler$Elm$Package$core);
	} else {
		return false;
	}
};
var $author$project$Compiler$Parse$Module$chompModule = function (projectType) {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Parse$Module$chompHeader,
		function (header) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Parse$Module$chompImports(
					$author$project$Compiler$Parse$Module$isCore(projectType) ? _List_Nil : $author$project$Compiler$Elm$Compiler$Imports$defaults),
				function (imports) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Parse$Module$isKernel(projectType) ? $author$project$Compiler$Parse$Module$chompInfixes(_List_Nil) : $author$project$Compiler$Parse$Primitives$return(_List_Nil),
						function (infixes) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2(
									$author$project$Compiler$Parse$Primitives$specialize,
									F3(
										function (decl, _v0, _v1) {
											return $author$project$Compiler$Reporting$Error$Syntax$Declarations(decl);
										}),
									$author$project$Compiler$Parse$Module$chompDecls),
								function (decls) {
									return $author$project$Compiler$Parse$Primitives$return(
										A4($author$project$Compiler$Parse$Module$Module, header, imports, infixes, decls));
								});
						});
				});
		});
};
var $author$project$Compiler$Parse$Module$fromByteString = F2(
	function (projectType, source) {
		var _v0 = A3(
			$author$project$Compiler$Parse$Primitives$fromByteString,
			$author$project$Compiler$Parse$Module$chompModule(projectType),
			$author$project$Compiler$Reporting$Error$Syntax$ModuleBadEnd,
			source);
		if (_v0.$ === 'Right') {
			var modul = _v0.a;
			return A2($author$project$Compiler$Parse$Module$checkModule, projectType, modul);
		} else {
			var err = _v0.a;
			return $author$project$Extra$Type$Either$Left(
				$author$project$Compiler$Reporting$Error$Syntax$ParseError(err));
		}
	});
var $author$project$Builder$Build$lensMVResultMap = {
	getter: function (_v0) {
		var _v1 = _v0.d;
		var x = _v1.f;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var _v3 = _v2.d;
			var bi = _v3.a;
			var ci = _v3.b;
			var di = _v3.c;
			var ei = _v3.d;
			var fi = _v3.e;
			var gi = _v3.g;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				A7($author$project$Builder$Build$LocalState, bi, ci, di, ei, fi, x, gi),
				e,
				f,
				g,
				h);
		})
};
var $author$project$Extra$System$MVar$MVar = function (a) {
	return {$: 'MVar', a: a};
};
var $author$project$Extra$System$MVar$newEmptyMVar = function (_v0) {
	var nextId = _v0.a;
	var map = _v0.b;
	var name = _v0.c;
	return _Utils_Tuple2(
		$author$project$Extra$System$MVar$MVar(nextId),
		_Utils_Tuple3(nextId + 1, map, name));
};
var $author$project$Extra$System$IO$put = F2(
	function (s, _v0) {
		return _Utils_Tuple2(
			$author$project$Extra$System$IO$Pure(_Utils_Tuple0),
			s);
	});
var $author$project$Extra$System$MVar$newEmpty = function (_v0) {
	var getter = _v0.getter;
	var setter = _v0.setter;
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Extra$System$IO$get,
		function (gs) {
			var _v1 = $author$project$Extra$System$MVar$newEmptyMVar(
				getter(gs));
			var mvar = _v1.a;
			var state = _v1.b;
			return A2(
				$author$project$Extra$System$IO$fmap,
				function (_v2) {
					return mvar;
				},
				$author$project$Extra$System$IO$put(
					A2(setter, state, gs)));
		});
};
var $author$project$Extra$System$MVar$new = F2(
	function (lens, a) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$MVar$newEmpty(lens),
			function (mvar) {
				return A2(
					$author$project$Extra$System$IO$fmap,
					function (_v0) {
						return mvar;
					},
					A3($author$project$Extra$System$MVar$write, lens, mvar, a));
			});
	});
var $author$project$Builder$File$bytesToString = function (bytes) {
	return A2(
		$elm$bytes$Bytes$Decode$decode,
		$elm$bytes$Bytes$Decode$string(
			$elm$bytes$Bytes$width(bytes)),
		bytes);
};
var $author$project$Builder$File$readUtf8 = function (path) {
	return A2(
		$author$project$Extra$System$IO$fmap,
		A2(
			$elm$core$Basics$composeR,
			$elm$core$Maybe$andThen($author$project$Builder$File$bytesToString),
			$elm$core$Maybe$withDefault('')),
		$author$project$Extra$System$File$readFile(path));
};
var $author$project$Compiler$Elm$Package$toChars = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return author + ('/' + project);
};
var $author$project$Compiler$Reporting$Error$Import$Error = F4(
	function (a, b, c, d) {
		return {$: 'Error', a: a, b: b, c: c, d: d};
	});
var $elm$core$Set$diff = F2(
	function (_v0, _v1) {
		var dict1 = _v0.a;
		var dict2 = _v1.a;
		return $elm$core$Set$Set_elm_builtin(
			A2($elm$core$Dict$diff, dict1, dict2));
	});
var $author$project$Extra$Type$Set$difference = $elm$core$Set$diff;
var $author$project$Compiler$Data$NonEmptyList$fmap = F2(
	function (func, _v0) {
		var x = _v0.a;
		var xs = _v0.b;
		return A2(
			$author$project$Compiler$Data$NonEmptyList$CList,
			func(x),
			A2($author$project$Extra$Type$List$map, func, xs));
	});
var $author$project$Compiler$AST$Source$getImportName = function (_v0) {
	var _v1 = _v0.a;
	var name = _v1.b;
	return name;
};
var $author$project$Extra$Type$Set$unions = A2($author$project$Extra$Type$List$foldl, $author$project$Extra$Type$Set$union, $author$project$Extra$Type$Set$empty);
var $author$project$Builder$Build$toImportErrors = F4(
	function (_v0, results, imports, problems) {
		var locals = _v0.e;
		var foreigns = _v0.f;
		var regionDict = $author$project$Extra$Type$Map$fromList(
			A2(
				$author$project$Extra$Type$List$map,
				function (_v2) {
					var _v3 = _v2.a;
					var region = _v3.a;
					var name = _v3.b;
					return _Utils_Tuple2(name, region);
				},
				imports));
		var knownModules = $author$project$Extra$Type$Set$unions(
			_List_fromArray(
				[
					$author$project$Extra$Type$Map$keysSet(foreigns),
					$author$project$Extra$Type$Map$keysSet(locals),
					$author$project$Extra$Type$Map$keysSet(results)
				]));
		var unimportedModules = A2(
			$author$project$Extra$Type$Set$difference,
			knownModules,
			$author$project$Extra$Type$Set$fromList(
				A2($author$project$Extra$Type$List$map, $author$project$Compiler$AST$Source$getImportName, imports)));
		var toError = function (_v1) {
			var name = _v1.a;
			var problem = _v1.b;
			return A4(
				$author$project$Compiler$Reporting$Error$Import$Error,
				A2($author$project$Extra$Type$Map$ex, regionDict, name),
				name,
				unimportedModules,
				problem);
		};
		return A2($author$project$Compiler$Data$NonEmptyList$fmap, toError, problems);
	});
var $author$project$Builder$Build$checkModule = F6(
	function (env, foreigns, resultsMVar, name, status, _v0) {
		var root = env.a;
		var projectType = env.b;
		switch (status.$) {
			case 'SCached':
				var local = status.a;
				var path = local.a;
				var time = local.b;
				var deps = local.c;
				var hasMain = local.d;
				var lastChange = local.e;
				var lastCompile = local.f;
				return A2(
					$author$project$Extra$System$IO$bind,
					A2($author$project$Extra$System$MVar$read, $author$project$Builder$Build$lensMVResultMap, resultsMVar),
					function (results) {
						return A2(
							$author$project$Extra$System$IO$bind,
							A4($author$project$Builder$Build$checkDeps, root, results, deps, lastCompile),
							function (depsStatus) {
								switch (depsStatus.$) {
									case 'DepsChange':
										var ifaces = depsStatus.a;
										return A2(
											$author$project$Extra$System$IO$bind,
											$author$project$Builder$File$readUtf8(path),
											function (source) {
												var _v3 = A2($author$project$Compiler$Parse$Module$fromByteString, projectType, source);
												if (_v3.$ === 'Right') {
													var modul = _v3.a;
													return A5($author$project$Builder$Build$compile, env, local, source, ifaces, modul);
												} else {
													var err = _v3.a;
													return $author$project$Extra$System$IO$return(
														$author$project$Builder$Build$RProblem(
															A5(
																$author$project$Compiler$Reporting$Error$Module,
																name,
																path,
																time,
																source,
																$author$project$Compiler$Reporting$Error$BadSyntax(err))));
												}
											});
									case 'DepsSame':
										return A2(
											$author$project$Extra$System$IO$bind,
											A2($author$project$Extra$System$MVar$new, $author$project$Builder$Build$lensMVCachedInterface, $author$project$Builder$Build$Unneeded),
											function (mvar) {
												return $author$project$Extra$System$IO$return(
													A3($author$project$Builder$Build$RCached, hasMain, lastChange, mvar));
											});
									case 'DepsBlock':
										return $author$project$Extra$System$IO$return($author$project$Builder$Build$RBlocked);
									default:
										var problems = depsStatus.a;
										return A2(
											$author$project$Extra$System$IO$bind,
											$author$project$Builder$File$readUtf8(path),
											function (source) {
												return $author$project$Extra$System$IO$return(
													$author$project$Builder$Build$RProblem(
														A5(
															$author$project$Compiler$Reporting$Error$Module,
															name,
															path,
															time,
															source,
															function () {
																var _v4 = A2($author$project$Compiler$Parse$Module$fromByteString, projectType, source);
																if (_v4.$ === 'Right') {
																	var _v5 = _v4.a;
																	var imports = _v5.c;
																	return $author$project$Compiler$Reporting$Error$BadImports(
																		A4($author$project$Builder$Build$toImportErrors, env, results, imports, problems));
																} else {
																	var err = _v4.a;
																	return $author$project$Compiler$Reporting$Error$BadSyntax(err);
																}
															}())));
											});
								}
							});
					});
			case 'SChanged':
				var local = status.a;
				var path = local.a;
				var time = local.b;
				var deps = local.c;
				var lastCompile = local.f;
				var source = status.b;
				var modul = status.c;
				var imports = modul.c;
				return A2(
					$author$project$Extra$System$IO$bind,
					A2($author$project$Extra$System$MVar$read, $author$project$Builder$Build$lensMVResultMap, resultsMVar),
					function (results) {
						return A2(
							$author$project$Extra$System$IO$bind,
							A4($author$project$Builder$Build$checkDeps, root, results, deps, lastCompile),
							function (depsStatus) {
								switch (depsStatus.$) {
									case 'DepsChange':
										var ifaces = depsStatus.a;
										return A5($author$project$Builder$Build$compile, env, local, source, ifaces, modul);
									case 'DepsSame':
										var same = depsStatus.a;
										var cached = depsStatus.b;
										return A2(
											$author$project$Extra$System$IO$bind,
											A3($author$project$Builder$Build$loadInterfaces, root, same, cached),
											function (maybeLoaded) {
												if (maybeLoaded.$ === 'Nothing') {
													return $author$project$Extra$System$IO$return($author$project$Builder$Build$RBlocked);
												} else {
													var ifaces = maybeLoaded.a;
													return A5($author$project$Builder$Build$compile, env, local, source, ifaces, modul);
												}
											});
									case 'DepsBlock':
										return $author$project$Extra$System$IO$return($author$project$Builder$Build$RBlocked);
									default:
										var problems = depsStatus.a;
										return $author$project$Extra$System$IO$return(
											$author$project$Builder$Build$RProblem(
												A5(
													$author$project$Compiler$Reporting$Error$Module,
													name,
													path,
													time,
													source,
													$author$project$Compiler$Reporting$Error$BadImports(
														A4($author$project$Builder$Build$toImportErrors, env, results, imports, problems)))));
								}
							});
					});
			case 'SBadImport':
				var importProblem = status.a;
				return $author$project$Extra$System$IO$return(
					$author$project$Builder$Build$RNotFound(importProblem));
			case 'SBadSyntax':
				var path = status.a;
				var time = status.b;
				var source = status.c;
				var err = status.d;
				return $author$project$Extra$System$IO$return(
					$author$project$Builder$Build$RProblem(
						A5(
							$author$project$Compiler$Reporting$Error$Module,
							name,
							path,
							time,
							source,
							$author$project$Compiler$Reporting$Error$BadSyntax(err))));
			case 'SForeign':
				var home = status.a;
				var _v8 = A2(
					$author$project$Extra$Type$Map$ex,
					foreigns,
					$author$project$Compiler$Elm$ModuleName$toComparable(
						A2($author$project$Compiler$Elm$ModuleName$Canonical, home, name)));
				if (_v8.$ === 'Public') {
					var iface = _v8.a;
					return $author$project$Extra$System$IO$return(
						$author$project$Builder$Build$RForeign(iface));
				} else {
					return _Debug_todo(
						'Builder.Build',
						{
							start: {line: 494, column: 28},
							end: {line: 494, column: 38}
						})(
						'mistakenly seeing private interface for ' + ($author$project$Compiler$Elm$Package$toChars(home) + (' ' + $author$project$Compiler$Elm$ModuleName$toChars(name))));
				}
			default:
				return $author$project$Extra$System$IO$return($author$project$Builder$Build$RKernel);
		}
	});
var $author$project$Compiler$Reporting$Error$Import$Ambiguous = F2(
	function (a, b) {
		return {$: 'Ambiguous', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Import$AmbiguousForeign = F3(
	function (a, b, c) {
		return {$: 'AmbiguousForeign', a: a, b: b, c: c};
	});
var $author$project$Compiler$Reporting$Error$Import$AmbiguousLocal = F3(
	function (a, b, c) {
		return {$: 'AmbiguousLocal', a: a, b: b, c: c};
	});
var $author$project$Builder$Build$DocsNeed = function (a) {
	return {$: 'DocsNeed', a: a};
};
var $author$project$Compiler$Reporting$Error$Syntax$ModuleNameMismatch = F2(
	function (a, b) {
		return {$: 'ModuleNameMismatch', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Syntax$ModuleNameUnspecified = function (a) {
	return {$: 'ModuleNameUnspecified', a: a};
};
var $author$project$Compiler$Reporting$Error$Import$NotFound = {$: 'NotFound'};
var $author$project$Builder$Build$SBadImport = function (a) {
	return {$: 'SBadImport', a: a};
};
var $author$project$Builder$Build$SBadSyntax = F4(
	function (a, b, c, d) {
		return {$: 'SBadSyntax', a: a, b: b, c: c, d: d};
	});
var $author$project$Builder$Build$SCached = function (a) {
	return {$: 'SCached', a: a};
};
var $author$project$Builder$Build$SChanged = F3(
	function (a, b, c) {
		return {$: 'SChanged', a: a, b: b, c: c};
	});
var $author$project$Builder$Build$SForeign = function (a) {
	return {$: 'SForeign', a: a};
};
var $author$project$Builder$Build$SKernel = {$: 'SKernel'};
var $author$project$Extra$System$File$addExtension = F2(
	function (path, extension) {
		var _v0 = $author$project$Extra$System$File$splitLastName(path);
		var parent = _v0.a;
		var name = _v0.b;
		return A2($author$project$Extra$System$File$addName, parent, name + ('.' + extension));
	});
var $author$project$Builder$Build$addRelative = F2(
	function (_v0, segments) {
		var srcDir = _v0.a;
		return A2(
			$author$project$Extra$System$File$addExtension,
			A2($author$project$Extra$System$File$addNames, srcDir, segments),
			'elm');
	});
var $author$project$Builder$File$exists = function (path) {
	return $author$project$Extra$System$File$doesFileExist(path);
};
var $author$project$Extra$Type$List$filterM = F3(
	function (pPure, pLiftA2, predicate) {
		return A2(
			$author$project$Extra$Type$List$foldr,
			function (x) {
				return A2(
					pLiftA2,
					function (flag) {
						return flag ? function (l) {
							return A2($elm$core$List$cons, x, l);
						} : $elm$core$Basics$identity;
					},
					predicate(x));
			},
			pPure(_List_Nil));
	});
var $author$project$Extra$System$MVar$Waiting = function (a) {
	return {$: 'Waiting', a: a};
};
var $author$project$Extra$System$MVar$wait = F3(
	function (lens, mvar, f) {
		return A2(
			$author$project$Extra$System$MVar$modify,
			lens,
			A2(
				$author$project$Extra$System$MVar$setEntry,
				mvar,
				$author$project$Extra$System$MVar$Waiting(f)));
	});
var $author$project$Extra$System$MVar$newWaiting = F2(
	function (lens, f) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$MVar$newEmpty(lens),
			function (mvar) {
				return A2(
					$author$project$Extra$System$IO$fmap,
					function (_v0) {
						return mvar;
					},
					A3($author$project$Extra$System$MVar$wait, lens, mvar, f));
			});
	});
var $author$project$Builder$Build$fork = $author$project$Extra$System$MVar$newWaiting;
var $author$project$Extra$Type$Map$fromKeys = F2(
	function (f, l) {
		return A3(
			$author$project$Extra$Type$List$foldl,
			F2(
				function (acc, k) {
					return A3(
						$author$project$Extra$Type$Map$insert,
						k,
						f(k),
						acc);
				}),
			$author$project$Extra$Type$Map$empty,
			l);
	});
var $author$project$Builder$File$Time = function (a) {
	return {$: 'Time', a: a};
};
var $author$project$Extra$System$File$getModificationTime = function (path) {
	return A3(
		$author$project$Extra$System$File$walkFileSystem,
		false,
		path,
		F2(
			function (maybeNode, _v0) {
				return _Utils_Tuple2(
					$elm$core$Maybe$Nothing,
					function () {
						_v1$2:
						while (true) {
							if ((maybeNode.$ === 'Just') && (maybeNode.a.c.$ === 'Just')) {
								switch (maybeNode.a.c.a.b.$) {
									case 'FileEntry':
										var _v2 = maybeNode.a;
										var _v3 = _v2.c.a;
										var time = _v3.a;
										return time;
									case 'MountedFileEntry':
										var _v4 = maybeNode.a;
										var _v5 = _v4.c.a;
										var time = _v5.a;
										var _v6 = _v5.b;
										return time;
									default:
										break _v1$2;
								}
							} else {
								break _v1$2;
							}
						}
						return $elm$time$Time$millisToPosix(0);
					}());
			}));
};
var $author$project$Builder$File$getTime = function (path) {
	return A2(
		$author$project$Extra$System$IO$fmap,
		$author$project$Builder$File$Time,
		$author$project$Extra$System$File$getModificationTime(path));
};
var $author$project$Extra$System$File$makeRelativeHelper = F2(
	function (baseNames, pathNames) {
		makeRelativeHelper:
		while (true) {
			var _v0 = _Utils_Tuple2(baseNames, pathNames);
			if (_v0.a.b && _v0.b.b) {
				var _v1 = _v0.a;
				var baseName = _v1.a;
				var baseRest = _v1.b;
				var _v2 = _v0.b;
				var pathName = _v2.a;
				var pathRest = _v2.b;
				if (_Utils_eq(baseName, pathName)) {
					var $temp$baseNames = baseRest,
						$temp$pathNames = pathRest;
					baseNames = $temp$baseNames;
					pathNames = $temp$pathNames;
					continue makeRelativeHelper;
				} else {
					return pathNames;
				}
			} else {
				return pathNames;
			}
		}
	});
var $author$project$Extra$System$File$makeRelative = F2(
	function (base, path) {
		var _v0 = _Utils_Tuple2(base, path);
		if ((_v0.a.$ === 'Absolute') && (_v0.b.$ === 'Absolute')) {
			var baseNames = _v0.a.a;
			var pathNames = _v0.b.a;
			return $author$project$Extra$System$File$Relative(
				$author$project$Extra$Type$List$reverse(
					A2(
						$author$project$Extra$System$File$makeRelativeHelper,
						$author$project$Extra$Type$List$reverse(baseNames),
						$author$project$Extra$Type$List$reverse(pathNames))));
		} else {
			return path;
		}
	});
var $author$project$Builder$Build$isEquivalent = F3(
	function (root, path, oldPath) {
		var startsWith = F2(
			function (prefix, testPath) {
				var _v0 = _Utils_Tuple2(prefix, testPath);
				if (!_v0.a.b) {
					return true;
				} else {
					if (!_v0.b.b) {
						return false;
					} else {
						var _v1 = _v0.a;
						var prefixHead = _v1.a;
						var prefixTail = _v1.b;
						var _v2 = _v0.b;
						var testHead = _v2.a;
						var testTail = _v2.b;
						return _Utils_eq(prefixHead, testHead) && A2(startsWith, prefixTail, testTail);
					}
				}
			});
		return A2(
			startsWith,
			$author$project$Extra$System$File$getNames(
				A2($author$project$Extra$System$File$makeRelative, root, path)),
			$author$project$Extra$System$File$getNames(oldPath));
	});
var $author$project$Builder$Build$isMain = function (_v0) {
	var _v1 = _v0.b;
	var _v2 = _v1.a;
	var name = _v2.b;
	return _Utils_eq(name, $author$project$Compiler$Data$Name$l_main);
};
var $author$project$Builder$Build$lensMVStatus = {
	getter: function (_v0) {
		var _v1 = _v0.d;
		var x = _v1.a;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var _v3 = _v2.d;
			var bi = _v3.b;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				A7($author$project$Builder$Build$LocalState, x, bi, ci, di, ei, fi, gi),
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Build$lensMVStatusMap = {
	getter: function (_v0) {
		var _v1 = _v0.d;
		var x = _v1.b;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var _v3 = _v2.d;
			var bi = _v3.a;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				A7($author$project$Builder$Build$LocalState, bi, x, ci, di, ei, fi, gi),
				e,
				f,
				g,
				h);
		})
};
var $author$project$Extra$Class$Foldable$mapM_ = F5(
	function (pFoldr, pReturn, pBind, f, t) {
		return A3(
			pFoldr,
			F2(
				function (x, k) {
					return A2(
						pBind,
						f(x),
						function (_v0) {
							return k;
						});
				}),
			pReturn(_Utils_Tuple0),
			t);
	});
var $author$project$Extra$Type$Map$mapM_ = F4(
	function (pReturn, pBind, f, m) {
		return A5($author$project$Extra$Class$Foldable$mapM_, $author$project$Extra$Type$Map$foldr, pReturn, pBind, f, m);
	});
var $author$project$Builder$Build$needsDocs = function (_v0) {
	var b = _v0.a;
	return b;
};
var $author$project$Compiler$Elm$ModuleName$toFileNames = function (name) {
	return A2($elm$core$String$split, '.', name);
};
var $author$project$Builder$Build$crawlDeps = F4(
	function (env, mvar, deps, blockedValue) {
		var crawlNew = F2(
			function (name, _v14) {
				return A2(
					$author$project$Builder$Build$fork,
					$author$project$Builder$Build$lensMVStatus,
					A4(
						$author$project$Builder$Build$crawlModule,
						env,
						mvar,
						$author$project$Builder$Build$DocsNeed(false),
						name));
			});
		return A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Extra$System$MVar$read, $author$project$Builder$Build$lensMVStatusMap, mvar),
			function (statusDict) {
				var depsDict = A2(
					$author$project$Extra$Type$Map$fromKeys,
					function (_v13) {
						return _Utils_Tuple0;
					},
					deps);
				var newsDict = A2($author$project$Extra$Type$Map$difference, depsDict, statusDict);
				return A2(
					$author$project$Extra$System$IO$bind,
					A4($author$project$Extra$Type$Map$traverseWithKey, $author$project$Extra$System$IO$pure, $author$project$Extra$System$IO$liftA2, crawlNew, newsDict),
					function (statuses) {
						return A2(
							$author$project$Extra$System$IO$bind,
							A3(
								$author$project$Extra$System$MVar$write,
								$author$project$Builder$Build$lensMVStatusMap,
								mvar,
								A2($author$project$Extra$Type$Map$union, statuses, statusDict)),
							function (_v11) {
								return A2(
									$author$project$Extra$System$IO$bind,
									A4(
										$author$project$Extra$Type$Map$mapM_,
										$author$project$Extra$System$IO$return,
										$author$project$Extra$System$IO$bind,
										$author$project$Extra$System$MVar$read($author$project$Builder$Build$lensMVStatus),
										statuses),
									function (_v12) {
										return $author$project$Extra$System$IO$return(blockedValue);
									});
							});
					});
			});
	});
var $author$project$Builder$Build$crawlFile = F6(
	function (env, mvar, expectedName, path, time, lastChange) {
		var root = env.a;
		var projectType = env.b;
		var buildID = env.d;
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$File$readUtf8(
				A2($author$project$Extra$System$File$combine, root, path)),
			function (source) {
				var _v9 = A2($author$project$Compiler$Parse$Module$fromByteString, projectType, source);
				if (_v9.$ === 'Left') {
					var err = _v9.a;
					return $author$project$Extra$System$IO$return(
						A4($author$project$Builder$Build$SBadSyntax, path, time, source, err));
				} else {
					var modul = _v9.a;
					var maybeActualName = modul.a;
					var imports = modul.c;
					var values = modul.d;
					if (maybeActualName.$ === 'Nothing') {
						return $author$project$Extra$System$IO$return(
							A4(
								$author$project$Builder$Build$SBadSyntax,
								path,
								time,
								source,
								$author$project$Compiler$Reporting$Error$Syntax$ModuleNameUnspecified(expectedName)));
					} else {
						var name = maybeActualName.a;
						var actualName = name.b;
						if (_Utils_eq(expectedName, actualName)) {
							var deps = A2($author$project$Extra$Type$List$map, $author$project$Compiler$AST$Source$getImportName, imports);
							var local = A6(
								$author$project$Builder$Elm$Details$Local,
								path,
								time,
								deps,
								A2($author$project$Extra$Type$List$any, $author$project$Builder$Build$isMain, values),
								lastChange,
								buildID);
							return A4(
								$author$project$Builder$Build$crawlDeps,
								env,
								mvar,
								deps,
								A3($author$project$Builder$Build$SChanged, local, source, modul));
						} else {
							return $author$project$Extra$System$IO$return(
								A4(
									$author$project$Builder$Build$SBadSyntax,
									path,
									time,
									source,
									A2($author$project$Compiler$Reporting$Error$Syntax$ModuleNameMismatch, expectedName, name)));
						}
					}
				}
			});
	});
var $author$project$Builder$Build$crawlModule = F5(
	function (env, mvar, docsNeed, name, _v0) {
		var root = env.a;
		var projectType = env.b;
		var srcDirs = env.c;
		var buildID = env.d;
		var locals = env.e;
		var foreigns = env.f;
		var fileNames = $author$project$Compiler$Elm$ModuleName$toFileNames(name);
		return A2(
			$author$project$Extra$System$IO$bind,
			A4(
				$author$project$Extra$Type$List$filterM,
				$author$project$Extra$System$IO$pure,
				$author$project$Extra$System$IO$liftA2,
				$author$project$Builder$File$exists,
				A2(
					$author$project$Extra$Type$List$map,
					function (d) {
						return A2($author$project$Builder$Build$addRelative, d, fileNames);
					},
					srcDirs)),
			function (paths) {
				if (paths.b) {
					if (!paths.b.b) {
						var path = paths.a;
						var _v2 = A2($author$project$Extra$Type$Map$lookup, name, foreigns);
						if (_v2.$ === 'Just') {
							var _v3 = _v2.a;
							var dep = _v3.a;
							return $author$project$Extra$System$IO$return(
								$author$project$Builder$Build$SBadImport(
									A2($author$project$Compiler$Reporting$Error$Import$Ambiguous, path, dep)));
						} else {
							return A2(
								$author$project$Extra$System$IO$bind,
								$author$project$Builder$File$getTime(path),
								function (newTime) {
									var _v4 = A2($author$project$Extra$Type$Map$lookup, name, locals);
									if (_v4.$ === 'Nothing') {
										return A6($author$project$Builder$Build$crawlFile, env, mvar, name, path, newTime, buildID);
									} else {
										var local = _v4.a;
										var oldPath = local.a;
										var oldTime = local.b;
										var deps = local.c;
										var lastChange = local.e;
										return ((!_Utils_eq(oldTime, newTime)) || ($author$project$Builder$Build$needsDocs(docsNeed) || (!A3($author$project$Builder$Build$isEquivalent, root, path, oldPath)))) ? A6($author$project$Builder$Build$crawlFile, env, mvar, name, path, newTime, lastChange) : A4(
											$author$project$Builder$Build$crawlDeps,
											env,
											mvar,
											deps,
											$author$project$Builder$Build$SCached(local));
									}
								});
						}
					} else {
						var p1 = paths.a;
						var _v5 = paths.b;
						var p2 = _v5.a;
						var ps = _v5.b;
						return $author$project$Extra$System$IO$return(
							$author$project$Builder$Build$SBadImport(
								A3(
									$author$project$Compiler$Reporting$Error$Import$AmbiguousLocal,
									A2($author$project$Extra$System$File$makeRelative, root, p1),
									A2($author$project$Extra$System$File$makeRelative, root, p2),
									A2(
										$author$project$Extra$Type$List$map,
										$author$project$Extra$System$File$makeRelative(root),
										ps))));
					}
				} else {
					var _v6 = A2($author$project$Extra$Type$Map$lookup, name, foreigns);
					if (_v6.$ === 'Just') {
						var _v7 = _v6.a;
						var dep = _v7.a;
						var deps = _v7.b;
						if (!deps.b) {
							return $author$project$Extra$System$IO$return(
								$author$project$Builder$Build$SForeign(dep));
						} else {
							var d = deps.a;
							var ds = deps.b;
							return $author$project$Extra$System$IO$return(
								$author$project$Builder$Build$SBadImport(
									A3($author$project$Compiler$Reporting$Error$Import$AmbiguousForeign, dep, d, ds)));
						}
					} else {
						return ($author$project$Compiler$Data$Name$isKernel(name) && $author$project$Compiler$Parse$Module$isKernel(projectType)) ? A2(
							$author$project$Extra$System$IO$bind,
							$author$project$Builder$File$exists(
								A2(
									$author$project$Extra$System$File$addExtension,
									A2(
										$author$project$Extra$System$File$addNames,
										$author$project$Extra$System$File$fromString('src'),
										$author$project$Compiler$Elm$ModuleName$toFileNames(name)),
									'js')),
							function (exists) {
								return $author$project$Extra$System$IO$return(
									exists ? $author$project$Builder$Build$SKernel : $author$project$Builder$Build$SBadImport($author$project$Compiler$Reporting$Error$Import$NotFound));
							}) : $author$project$Extra$System$IO$return(
							$author$project$Builder$Build$SBadImport($author$project$Compiler$Reporting$Error$Import$NotFound));
					}
				}
			});
	});
var $author$project$Builder$Build$Fresh = F3(
	function (a, b, c) {
		return {$: 'Fresh', a: a, b: b, c: c};
	});
var $author$project$Builder$Build$ReplArtifacts = F4(
	function (a, b, c, d) {
		return {$: 'ReplArtifacts', a: a, b: b, c: c, d: d};
	});
var $author$project$Builder$Reporting$Exit$ReplBadCache = {$: 'ReplBadCache'};
var $author$project$Builder$Reporting$Exit$ReplBadLocalDeps = F3(
	function (a, b, c) {
		return {$: 'ReplBadLocalDeps', a: a, b: b, c: c};
	});
var $author$project$Builder$Reporting$Exit$ReplBlocked = {$: 'ReplBlocked'};
var $author$project$Builder$Build$addErrors = F2(
	function (result, errors) {
		switch (result.$) {
			case 'RNew':
				return errors;
			case 'RSame':
				return errors;
			case 'RCached':
				return errors;
			case 'RNotFound':
				return errors;
			case 'RProblem':
				var e = result.a;
				return A2($elm$core$List$cons, e, errors);
			case 'RBlocked':
				return errors;
			case 'RForeign':
				return errors;
			default:
				return errors;
		}
	});
var $author$project$Builder$Build$Cached = F3(
	function (a, b, c) {
		return {$: 'Cached', a: a, b: b, c: c};
	});
var $author$project$Builder$Build$badInside = function (name) {
	return 'Error from `' + (name + '` should have been reported already.');
};
var $author$project$Builder$Build$addInside = F3(
	function (name, result, modules) {
		switch (result.$) {
			case 'RNew':
				var iface = result.b;
				var objs = result.c;
				return A2(
					$elm$core$List$cons,
					A3($author$project$Builder$Build$Fresh, name, iface, objs),
					modules);
			case 'RSame':
				var iface = result.b;
				var objs = result.c;
				return A2(
					$elm$core$List$cons,
					A3($author$project$Builder$Build$Fresh, name, iface, objs),
					modules);
			case 'RCached':
				var main = result.a;
				var mvar = result.c;
				return A2(
					$elm$core$List$cons,
					A3($author$project$Builder$Build$Cached, name, main, mvar),
					modules);
			case 'RNotFound':
				return _Debug_todo(
					'Builder.Build',
					{
						start: {line: 1192, column: 28},
						end: {line: 1192, column: 38}
					})(
					$author$project$Builder$Build$badInside(name));
			case 'RProblem':
				return _Debug_todo(
					'Builder.Build',
					{
						start: {line: 1193, column: 28},
						end: {line: 1193, column: 38}
					})(
					$author$project$Builder$Build$badInside(name));
			case 'RBlocked':
				return _Debug_todo(
					'Builder.Build',
					{
						start: {line: 1194, column: 28},
						end: {line: 1194, column: 38}
					})(
					$author$project$Builder$Build$badInside(name));
			case 'RForeign':
				return modules;
			default:
				return modules;
		}
	});
var $author$project$Compiler$AST$Canonical$getName = function (_v0) {
	var name = _v0.a;
	return name;
};
var $author$project$Builder$Build$finalizeReplArtifacts = F6(
	function (env, source, modul, depsStatus, resultMVars, results) {
		var root = env.a;
		var projectType = env.b;
		var imports = modul.c;
		var pkg = $author$project$Builder$Build$projectTypeToPkg(projectType);
		var compileInput = function (ifaces) {
			var _v3 = A3($author$project$Compiler$Compile$compile, pkg, ifaces, modul);
			if (_v3.$ === 'Right') {
				var _v4 = _v3.a;
				var canonical = _v4.a;
				var annotations = _v4.b;
				var objects = _v4.c;
				var ms = A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Builder$Build$addInside, _List_Nil, results);
				var m = A3(
					$author$project$Builder$Build$Fresh,
					$author$project$Compiler$AST$Source$getName(modul),
					A3($author$project$Compiler$Elm$Interface$fromModule, pkg, canonical, annotations),
					objects);
				var h = $author$project$Compiler$AST$Canonical$getName(canonical);
				return $author$project$Extra$System$IO$return(
					$author$project$Extra$Type$Either$Right(
						A4(
							$author$project$Builder$Build$ReplArtifacts,
							h,
							A2($elm$core$List$cons, m, ms),
							$author$project$Compiler$Reporting$Render$Type$Localizer$fromModule(modul),
							annotations)));
			} else {
				var errors = _v3.a;
				return $author$project$Extra$System$IO$return(
					$author$project$Extra$Type$Either$Left(
						A2($author$project$Builder$Reporting$Exit$ReplBadInput, source, errors)));
			}
		};
		switch (depsStatus.$) {
			case 'DepsChange':
				var ifaces = depsStatus.a;
				return compileInput(ifaces);
			case 'DepsSame':
				var same = depsStatus.a;
				var cached = depsStatus.b;
				return A2(
					$author$project$Extra$System$IO$bind,
					A3($author$project$Builder$Build$loadInterfaces, root, same, cached),
					function (maybeLoaded) {
						if (maybeLoaded.$ === 'Just') {
							var ifaces = maybeLoaded.a;
							return compileInput(ifaces);
						} else {
							return $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$ReplBadCache));
						}
					});
			case 'DepsBlock':
				var _v2 = A3($author$project$Extra$Type$Map$foldr, $author$project$Builder$Build$addErrors, _List_Nil, results);
				if (!_v2.b) {
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$ReplBlocked));
				} else {
					var e = _v2.a;
					var es = _v2.b;
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(
							A3($author$project$Builder$Reporting$Exit$ReplBadLocalDeps, root, e, es)));
				}
			default:
				var problems = depsStatus.a;
				return $author$project$Extra$System$IO$return(
					$author$project$Extra$Type$Either$Left(
						A2(
							$author$project$Builder$Reporting$Exit$ReplBadInput,
							source,
							$author$project$Compiler$Reporting$Error$BadImports(
								A4($author$project$Builder$Build$toImportErrors, env, resultMVars, imports, problems)))));
		}
	});
var $author$project$Builder$Build$forkWithKey = F3(
	function (lens, func, dict) {
		return A4(
			$author$project$Extra$Type$Map$traverseWithKey,
			$author$project$Extra$System$IO$pure,
			$author$project$Extra$System$IO$liftA2,
			F2(
				function (k, v) {
					return A2(
						$author$project$Builder$Build$fork,
						lens,
						A2(func, k, v));
				}),
			dict);
	});
var $author$project$Compiler$Elm$Interface$Private = F3(
	function (a, b, c) {
		return {$: 'Private', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Interface$Public = function (a) {
	return {$: 'Public', a: a};
};
var $author$project$Compiler$Elm$Interface$bDependencyInterface = $author$project$Extra$Data$Binary$finish(
	A6(
		$author$project$Extra$Data$Binary$var3,
		1,
		$author$project$Compiler$Elm$Interface$Private,
		$author$project$Compiler$Elm$Package$bName,
		A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$AST$Canonical$bUnion),
		A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Compiler$AST$Canonical$bAlias),
		A4(
			$author$project$Extra$Data$Binary$var1,
			0,
			$author$project$Compiler$Elm$Interface$Public,
			$author$project$Compiler$Elm$Interface$bInterface,
			A2(
				$author$project$Extra$Data$Binary$custom,
				'binary encoding of DependencyInterface was corrupted',
				F3(
					function (p0, p1, dependencyInterface) {
						if (dependencyInterface.$ === 'Public') {
							var a = dependencyInterface.a;
							return p0(a);
						} else {
							var a = dependencyInterface.a;
							var b = dependencyInterface.b;
							var c = dependencyInterface.c;
							return A3(p1, a, b, c);
						}
					})))));
var $author$project$Builder$Elm$Details$bInterfaces = A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Elm$ModuleName$bComparable, $author$project$Compiler$Elm$Interface$bDependencyInterface);
var $author$project$Builder$Elm$Details$fork = $author$project$Extra$System$MVar$newWaiting;
var $author$project$Builder$Stuff$interfaces = function (root) {
	return A2(
		$author$project$Extra$System$File$addName,
		$author$project$Builder$Stuff$stuff(root),
		'i.dat');
};
var $author$project$Builder$Elm$Details$loadInterfaces = F2(
	function (root, _v0) {
		var extras = _v0.f;
		if (extras.$ === 'ArtifactsFresh') {
			var i = extras.a;
			return A2(
				$author$project$Extra$System$MVar$new,
				$author$project$Builder$Elm$Details$lensMVInterfaces,
				$elm$core$Maybe$Just(i));
		} else {
			return A2(
				$author$project$Builder$Elm$Details$fork,
				$author$project$Builder$Elm$Details$lensMVInterfaces,
				function (_v2) {
					return A2(
						$author$project$Builder$File$readBinary,
						$author$project$Builder$Elm$Details$bInterfaces,
						$author$project$Builder$Stuff$interfaces(root));
				});
		}
	});
var $author$project$Compiler$Parse$Module$Application = {$: 'Application'};
var $author$project$Builder$Build$Env = F6(
	function (a, b, c, d, e, f) {
		return {$: 'Env', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Compiler$Parse$Module$Package = function (a) {
	return {$: 'Package', a: a};
};
var $author$project$Builder$Elm$Outline$RelativeSrcDir = function (a) {
	return {$: 'RelativeSrcDir', a: a};
};
var $author$project$Builder$Build$AbsoluteSrcDir = function (a) {
	return {$: 'AbsoluteSrcDir', a: a};
};
var $author$project$Builder$Build$toAbsoluteSrcDir = F2(
	function (root, srcDir) {
		return A2(
			$author$project$Extra$System$IO$fmap,
			$author$project$Builder$Build$AbsoluteSrcDir,
			$author$project$Extra$System$IO$return(
				function () {
					if (srcDir.$ === 'AbsoluteSrcDir') {
						var dir = srcDir.a;
						return dir;
					} else {
						var dir = srcDir.a;
						return A2($author$project$Extra$System$File$combine, root, dir);
					}
				}()));
	});
var $author$project$Compiler$Data$NonEmptyList$toList = function (_v0) {
	var x = _v0.a;
	var xs = _v0.b;
	return A2($elm$core$List$cons, x, xs);
};
var $author$project$Builder$Build$makeEnv = F2(
	function (root, _v0) {
		var validOutline = _v0.b;
		var buildID = _v0.c;
		var locals = _v0.d;
		var foreigns = _v0.e;
		if (validOutline.$ === 'ValidApp') {
			var givenSrcDirs = validOutline.a;
			return A2(
				$author$project$Extra$System$IO$bind,
				A4(
					$author$project$Extra$Type$List$traverse,
					$author$project$Extra$System$IO$pure,
					$author$project$Extra$System$IO$liftA2,
					$author$project$Builder$Build$toAbsoluteSrcDir(root),
					$author$project$Compiler$Data$NonEmptyList$toList(givenSrcDirs)),
				function (srcDirs) {
					return $author$project$Extra$System$IO$return(
						A6($author$project$Builder$Build$Env, root, $author$project$Compiler$Parse$Module$Application, srcDirs, buildID, locals, foreigns));
				});
		} else {
			var pkg = validOutline.a;
			return A2(
				$author$project$Extra$System$IO$bind,
				A2(
					$author$project$Builder$Build$toAbsoluteSrcDir,
					root,
					$author$project$Builder$Elm$Outline$RelativeSrcDir(
						$author$project$Extra$System$File$fromString('src'))),
				function (srcDir) {
					return $author$project$Extra$System$IO$return(
						A6(
							$author$project$Builder$Build$Env,
							root,
							$author$project$Compiler$Parse$Module$Package(pkg),
							_List_fromArray(
								[srcDir]),
							buildID,
							locals,
							foreigns));
				});
		}
	});
var $author$project$Builder$Elm$Details$Details = F6(
	function (a, b, c, d, e, f) {
		return {$: 'Details', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Builder$Build$addNewLocal = F3(
	function (name, result, locals) {
		switch (result.$) {
			case 'RNew':
				var local = result.a;
				return A3($author$project$Extra$Type$Map$insert, name, local, locals);
			case 'RSame':
				var local = result.a;
				return A3($author$project$Extra$Type$Map$insert, name, local, locals);
			case 'RCached':
				return locals;
			case 'RNotFound':
				return locals;
			case 'RProblem':
				return locals;
			case 'RBlocked':
				return locals;
			case 'RForeign':
				return locals;
			default:
				return locals;
		}
	});
var $author$project$Builder$Elm$Details$ArtifactsCached = {$: 'ArtifactsCached'};
var $author$project$Builder$Elm$Details$Foreign = F2(
	function (a, b) {
		return {$: 'Foreign', a: a, b: b};
	});
var $author$project$Builder$Elm$Details$bForeign = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Builder$Elm$Details$Foreign,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Elm$Package$bName,
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Elm$Package$bName));
var $author$project$Extra$Data$Binary$T6 = F6(
	function (a, b, c, d, e, f) {
		return {$: 'T6', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Extra$Data$Binary$bPath = A3($author$project$Extra$Data$Binary$bin1, $author$project$Extra$System$File$fromString, $author$project$Extra$System$File$toString, $author$project$Extra$Data$Binary$bString);
var $author$project$Compiler$Elm$ModuleName$bRaw = $author$project$Compiler$Data$Name$bName;
var $cmditch$elm_bigint$BigInt$BigIntNotNormalised = F2(
	function (a, b) {
		return {$: 'BigIntNotNormalised', a: a, b: b};
	});
var $cmditch$elm_bigint$BigInt$MagnitudeNotNormalised = function (a) {
	return {$: 'MagnitudeNotNormalised', a: a};
};
var $elm$core$Basics$abs = function (n) {
	return (n < 0) ? (-n) : n;
};
var $cmditch$elm_bigint$BigInt$Magnitude = function (a) {
	return {$: 'Magnitude', a: a};
};
var $elm_community$list_extra$List$Extra$last = function (items) {
	last:
	while (true) {
		if (!items.b) {
			return $elm$core$Maybe$Nothing;
		} else {
			if (!items.b.b) {
				var x = items.a;
				return $elm$core$Maybe$Just(x);
			} else {
				var rest = items.b;
				var $temp$items = rest;
				items = $temp$items;
				continue last;
			}
		}
	}
};
var $cmditch$elm_bigint$BigInt$isNegativeMagnitude = function (digits) {
	var _v0 = $elm_community$list_extra$List$Extra$last(digits);
	if (_v0.$ === 'Nothing') {
		return false;
	} else {
		var x = _v0.a;
		return x < 0;
	}
};
var $cmditch$elm_bigint$BigInt$Neg = function (a) {
	return {$: 'Neg', a: a};
};
var $cmditch$elm_bigint$BigInt$Pos = function (a) {
	return {$: 'Pos', a: a};
};
var $cmditch$elm_bigint$BigInt$Zer = {$: 'Zer'};
var $cmditch$elm_bigint$BigInt$mkBigInt = F2(
	function (s, mag) {
		var digits = mag.a;
		if ($elm$core$List$isEmpty(digits)) {
			return $cmditch$elm_bigint$BigInt$Zer;
		} else {
			switch (s.$) {
				case 'Zero':
					return $cmditch$elm_bigint$BigInt$Zer;
				case 'Positive':
					return $cmditch$elm_bigint$BigInt$Pos(mag);
				default:
					return $cmditch$elm_bigint$BigInt$Neg(mag);
			}
		}
	});
var $cmditch$elm_bigint$BigInt$mkBigIntNotNormalised = F2(
	function (s, digits) {
		return A2(
			$cmditch$elm_bigint$BigInt$BigIntNotNormalised,
			s,
			$cmditch$elm_bigint$BigInt$MagnitudeNotNormalised(digits));
	});
var $elm_community$list_extra$List$Extra$dropWhileRight = function (p) {
	return A2(
		$elm$core$List$foldr,
		F2(
			function (x, xs) {
				return (p(x) && $elm$core$List$isEmpty(xs)) ? _List_Nil : A2($elm$core$List$cons, x, xs);
			}),
		_List_Nil);
};
var $cmditch$elm_bigint$BigInt$dropZeroes = $elm_community$list_extra$List$Extra$dropWhileRight(
	$elm$core$Basics$eq(0));
var $cmditch$elm_bigint$Constants$maxDigitMagnitude = 7;
var $elm$core$Basics$pow = _Basics_pow;
var $cmditch$elm_bigint$Constants$maxDigitValue = (-1) + A2($elm$core$Basics$pow, 10, $cmditch$elm_bigint$Constants$maxDigitMagnitude);
var $cmditch$elm_bigint$BigInt$baseDigit = $cmditch$elm_bigint$Constants$maxDigitValue + 1;
var $elm$core$Tuple$mapFirst = F2(
	function (func, _v0) {
		var x = _v0.a;
		var y = _v0.b;
		return _Utils_Tuple2(
			func(x),
			y);
	});
var $cmditch$elm_bigint$BigInt$normaliseDigit = function (x) {
	return (x < 0) ? A2(
		$elm$core$Tuple$mapFirst,
		$elm$core$Basics$add(-1),
		$cmditch$elm_bigint$BigInt$normaliseDigit(x + $cmditch$elm_bigint$BigInt$baseDigit)) : _Utils_Tuple2((x / $cmditch$elm_bigint$BigInt$baseDigit) | 0, x % $cmditch$elm_bigint$BigInt$baseDigit);
};
var $cmditch$elm_bigint$BigInt$normaliseDigitList = F2(
	function (carry, xs) {
		normaliseDigitList:
		while (true) {
			if (!xs.b) {
				if (_Utils_cmp(carry, $cmditch$elm_bigint$BigInt$baseDigit) > 0) {
					var $temp$carry = 0,
						$temp$xs = _List_fromArray(
						[carry]);
					carry = $temp$carry;
					xs = $temp$xs;
					continue normaliseDigitList;
				} else {
					return _List_fromArray(
						[carry]);
				}
			} else {
				var x = xs.a;
				var xs_ = xs.b;
				var _v1 = $cmditch$elm_bigint$BigInt$normaliseDigit(x + carry);
				var newCarry = _v1.a;
				var x_ = _v1.b;
				return A2(
					$elm$core$List$cons,
					x_,
					A2($cmditch$elm_bigint$BigInt$normaliseDigitList, newCarry, xs_));
			}
		}
	});
var $cmditch$elm_bigint$BigInt$normaliseMagnitude = function (_v0) {
	var xs = _v0.a;
	return $cmditch$elm_bigint$BigInt$Magnitude(
		$cmditch$elm_bigint$BigInt$dropZeroes(
			A2($cmditch$elm_bigint$BigInt$normaliseDigitList, 0, xs)));
};
var $cmditch$elm_bigint$BigInt$reverseMagnitude = $elm$core$List$map($elm$core$Basics$negate);
var $cmditch$elm_bigint$BigInt$Negative = {$: 'Negative'};
var $cmditch$elm_bigint$BigInt$Positive = {$: 'Positive'};
var $cmditch$elm_bigint$BigInt$Zero = {$: 'Zero'};
var $cmditch$elm_bigint$BigInt$signNegate = function (sign_) {
	switch (sign_.$) {
		case 'Positive':
			return $cmditch$elm_bigint$BigInt$Negative;
		case 'Negative':
			return $cmditch$elm_bigint$BigInt$Positive;
		default:
			return $cmditch$elm_bigint$BigInt$Zero;
	}
};
var $cmditch$elm_bigint$BigInt$normalise = function (_v0) {
	normalise:
	while (true) {
		var s = _v0.a;
		var digits = _v0.b;
		var _v1 = $cmditch$elm_bigint$BigInt$normaliseMagnitude(digits);
		var normalisedMag = _v1.a;
		if ($cmditch$elm_bigint$BigInt$isNegativeMagnitude(normalisedMag)) {
			var $temp$_v0 = A2(
				$cmditch$elm_bigint$BigInt$mkBigIntNotNormalised,
				$cmditch$elm_bigint$BigInt$signNegate(s),
				$cmditch$elm_bigint$BigInt$reverseMagnitude(normalisedMag));
			_v0 = $temp$_v0;
			continue normalise;
		} else {
			return A2(
				$cmditch$elm_bigint$BigInt$mkBigInt,
				s,
				$cmditch$elm_bigint$BigInt$Magnitude(normalisedMag));
		}
	}
};
var $cmditch$elm_bigint$BigInt$signFromInt = function (x) {
	var _v0 = A2($elm$core$Basics$compare, x, 0);
	switch (_v0.$) {
		case 'LT':
			return $cmditch$elm_bigint$BigInt$Negative;
		case 'GT':
			return $cmditch$elm_bigint$BigInt$Positive;
		default:
			return $cmditch$elm_bigint$BigInt$Zero;
	}
};
var $cmditch$elm_bigint$BigInt$fromInt = function (x) {
	return $cmditch$elm_bigint$BigInt$normalise(
		A2(
			$cmditch$elm_bigint$BigInt$BigIntNotNormalised,
			$cmditch$elm_bigint$BigInt$signFromInt(x),
			$cmditch$elm_bigint$BigInt$MagnitudeNotNormalised(
				_List_fromArray(
					[
						$elm$core$Basics$abs(x)
					]))));
};
var $author$project$Extra$Data$Binary$bigFactor = $cmditch$elm_bigint$BigInt$fromInt(256);
var $author$project$Extra$Data$Binary$bigZero = $cmditch$elm_bigint$BigInt$fromInt(0);
var $cmditch$elm_bigint$BigInt$abs = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return $cmditch$elm_bigint$BigInt$Zer;
		case 'Neg':
			var mag = bigInt.a;
			return $cmditch$elm_bigint$BigInt$Pos(mag);
		default:
			var i = bigInt;
			return i;
	}
};
var $cmditch$elm_bigint$BigInt$MagnitudePair = function (a) {
	return {$: 'MagnitudePair', a: a};
};
var $cmditch$elm_bigint$BigInt$sameSizeRaw = F2(
	function (xs, ys) {
		var _v0 = _Utils_Tuple2(xs, ys);
		if (!_v0.a.b) {
			if (!_v0.b.b) {
				return _List_Nil;
			} else {
				var _v2 = _v0.b;
				var y = _v2.a;
				var ys_ = _v2.b;
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(0, y),
					A2($cmditch$elm_bigint$BigInt$sameSizeRaw, _List_Nil, ys_));
			}
		} else {
			if (!_v0.b.b) {
				var _v1 = _v0.a;
				var x = _v1.a;
				var xs_ = _v1.b;
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(x, 0),
					A2($cmditch$elm_bigint$BigInt$sameSizeRaw, xs_, _List_Nil));
			} else {
				var _v3 = _v0.a;
				var x = _v3.a;
				var xs_ = _v3.b;
				var _v4 = _v0.b;
				var y = _v4.a;
				var ys_ = _v4.b;
				return A2(
					$elm$core$List$cons,
					_Utils_Tuple2(x, y),
					A2($cmditch$elm_bigint$BigInt$sameSizeRaw, xs_, ys_));
			}
		}
	});
var $cmditch$elm_bigint$BigInt$sameSizeNotNormalized = F2(
	function (_v0, _v1) {
		var xs = _v0.a;
		var ys = _v1.a;
		return $cmditch$elm_bigint$BigInt$MagnitudePair(
			A2($cmditch$elm_bigint$BigInt$sameSizeRaw, xs, ys));
	});
var $cmditch$elm_bigint$BigInt$toPositiveSign = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return A2($cmditch$elm_bigint$BigInt$mkBigIntNotNormalised, $cmditch$elm_bigint$BigInt$Zero, _List_Nil);
		case 'Neg':
			var digits = bigInt.a.a;
			return A2(
				$cmditch$elm_bigint$BigInt$mkBigIntNotNormalised,
				$cmditch$elm_bigint$BigInt$Positive,
				$cmditch$elm_bigint$BigInt$reverseMagnitude(digits));
		default:
			var digits = bigInt.a.a;
			return A2($cmditch$elm_bigint$BigInt$mkBigIntNotNormalised, $cmditch$elm_bigint$BigInt$Positive, digits);
	}
};
var $cmditch$elm_bigint$BigInt$add = F2(
	function (a, b) {
		var _v0 = $cmditch$elm_bigint$BigInt$toPositiveSign(b);
		var mb = _v0.b;
		var _v1 = $cmditch$elm_bigint$BigInt$toPositiveSign(a);
		var ma = _v1.b;
		var _v2 = A2($cmditch$elm_bigint$BigInt$sameSizeNotNormalized, ma, mb);
		var pairs = _v2.a;
		var added = A2(
			$elm$core$List$map,
			function (_v3) {
				var a_ = _v3.a;
				var b_ = _v3.b;
				return a_ + b_;
			},
			pairs);
		return $cmditch$elm_bigint$BigInt$normalise(
			A2(
				$cmditch$elm_bigint$BigInt$BigIntNotNormalised,
				$cmditch$elm_bigint$BigInt$Positive,
				$cmditch$elm_bigint$BigInt$MagnitudeNotNormalised(added)));
	});
var $cmditch$elm_bigint$BigInt$compareMagnitude = F4(
	function (x, y, xs, ys) {
		compareMagnitude:
		while (true) {
			var _v0 = _Utils_Tuple2(xs, ys);
			if (!_v0.a.b) {
				if (!_v0.b.b) {
					return A2($elm$core$Basics$compare, x, y);
				} else {
					return $elm$core$Basics$LT;
				}
			} else {
				if (!_v0.b.b) {
					return $elm$core$Basics$GT;
				} else {
					var _v1 = _v0.a;
					var x_ = _v1.a;
					var xss = _v1.b;
					var _v2 = _v0.b;
					var y_ = _v2.a;
					var yss = _v2.b;
					if (_Utils_eq(x_, y_)) {
						var $temp$x = x,
							$temp$y = y,
							$temp$xs = xss,
							$temp$ys = yss;
						x = $temp$x;
						y = $temp$y;
						xs = $temp$xs;
						ys = $temp$ys;
						continue compareMagnitude;
					} else {
						var $temp$x = x_,
							$temp$y = y_,
							$temp$xs = xss,
							$temp$ys = yss;
						x = $temp$x;
						y = $temp$y;
						xs = $temp$xs;
						ys = $temp$ys;
						continue compareMagnitude;
					}
				}
			}
		}
	});
var $cmditch$elm_bigint$BigInt$orderNegate = function (x) {
	switch (x.$) {
		case 'LT':
			return $elm$core$Basics$GT;
		case 'EQ':
			return $elm$core$Basics$EQ;
		default:
			return $elm$core$Basics$LT;
	}
};
var $cmditch$elm_bigint$BigInt$compare = F2(
	function (int1, int2) {
		var _v0 = _Utils_Tuple2(int1, int2);
		switch (_v0.a.$) {
			case 'Pos':
				if (_v0.b.$ === 'Pos') {
					var mag1 = _v0.a.a.a;
					var mag2 = _v0.b.a.a;
					return A4($cmditch$elm_bigint$BigInt$compareMagnitude, 0, 0, mag1, mag2);
				} else {
					return $elm$core$Basics$GT;
				}
			case 'Neg':
				if (_v0.b.$ === 'Neg') {
					var mag1 = _v0.a.a.a;
					var mag2 = _v0.b.a.a;
					return $cmditch$elm_bigint$BigInt$orderNegate(
						A4($cmditch$elm_bigint$BigInt$compareMagnitude, 0, 0, mag1, mag2));
				} else {
					return $elm$core$Basics$LT;
				}
			default:
				switch (_v0.b.$) {
					case 'Pos':
						var _v1 = _v0.a;
						return $elm$core$Basics$LT;
					case 'Zer':
						var _v2 = _v0.a;
						var _v3 = _v0.b;
						return $elm$core$Basics$EQ;
					default:
						var _v4 = _v0.a;
						return $elm$core$Basics$GT;
				}
		}
	});
var $cmditch$elm_bigint$BigInt$gt = F2(
	function (x, y) {
		return _Utils_eq(
			A2($cmditch$elm_bigint$BigInt$compare, x, y),
			$elm$core$Basics$GT);
	});
var $cmditch$elm_bigint$BigInt$lte = F2(
	function (x, y) {
		return !A2($cmditch$elm_bigint$BigInt$gt, x, y);
	});
var $cmditch$elm_bigint$BigInt$magnitude = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return $cmditch$elm_bigint$BigInt$Magnitude(_List_Nil);
		case 'Pos':
			var mag = bigInt.a;
			return mag;
		default:
			var mag = bigInt.a;
			return mag;
	}
};
var $cmditch$elm_bigint$BigInt$mulSingleDigit = F2(
	function (_v0, d) {
		var xs = _v0.a;
		return $cmditch$elm_bigint$BigInt$normaliseMagnitude(
			$cmditch$elm_bigint$BigInt$MagnitudeNotNormalised(
				A2(
					$elm$core$List$map,
					$elm$core$Basics$mul(d),
					xs)));
	});
var $cmditch$elm_bigint$BigInt$mulMagnitudes = F2(
	function (_v0, _v1) {
		var mag1 = _v0.a;
		var mag2 = _v1.a;
		if (!mag1.b) {
			return $cmditch$elm_bigint$BigInt$Magnitude(_List_Nil);
		} else {
			if (!mag1.b.b) {
				var m = mag1.a;
				return A2(
					$cmditch$elm_bigint$BigInt$mulSingleDigit,
					$cmditch$elm_bigint$BigInt$Magnitude(mag2),
					m);
			} else {
				var m = mag1.a;
				var mx = mag1.b;
				var accum = A2(
					$cmditch$elm_bigint$BigInt$mulSingleDigit,
					$cmditch$elm_bigint$BigInt$Magnitude(mag2),
					m);
				var _v3 = A2(
					$cmditch$elm_bigint$BigInt$mulMagnitudes,
					$cmditch$elm_bigint$BigInt$Magnitude(mx),
					$cmditch$elm_bigint$BigInt$Magnitude(mag2));
				var rest = _v3.a;
				var bigInt = A2(
					$cmditch$elm_bigint$BigInt$add,
					A2($cmditch$elm_bigint$BigInt$mkBigInt, $cmditch$elm_bigint$BigInt$Positive, accum),
					A2(
						$cmditch$elm_bigint$BigInt$mkBigInt,
						$cmditch$elm_bigint$BigInt$Positive,
						$cmditch$elm_bigint$BigInt$Magnitude(
							A2($elm$core$List$cons, 0, rest))));
				return $cmditch$elm_bigint$BigInt$magnitude(bigInt);
			}
		}
	});
var $cmditch$elm_bigint$BigInt$sign = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return $cmditch$elm_bigint$BigInt$Zero;
		case 'Pos':
			return $cmditch$elm_bigint$BigInt$Positive;
		default:
			return $cmditch$elm_bigint$BigInt$Negative;
	}
};
var $cmditch$elm_bigint$BigInt$signProduct = F2(
	function (x, y) {
		return (_Utils_eq(x, $cmditch$elm_bigint$BigInt$Zero) || _Utils_eq(y, $cmditch$elm_bigint$BigInt$Zero)) ? $cmditch$elm_bigint$BigInt$Zero : (_Utils_eq(x, y) ? $cmditch$elm_bigint$BigInt$Positive : $cmditch$elm_bigint$BigInt$Negative);
	});
var $cmditch$elm_bigint$BigInt$mul = F2(
	function (int1, int2) {
		return A2(
			$cmditch$elm_bigint$BigInt$mkBigInt,
			A2(
				$cmditch$elm_bigint$BigInt$signProduct,
				$cmditch$elm_bigint$BigInt$sign(int1),
				$cmditch$elm_bigint$BigInt$sign(int2)),
			A2(
				$cmditch$elm_bigint$BigInt$mulMagnitudes,
				$cmditch$elm_bigint$BigInt$magnitude(int1),
				$cmditch$elm_bigint$BigInt$magnitude(int2)));
	});
var $cmditch$elm_bigint$BigInt$negate = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return $cmditch$elm_bigint$BigInt$Zer;
		case 'Pos':
			var mag = bigInt.a;
			return $cmditch$elm_bigint$BigInt$Neg(mag);
		default:
			var mag = bigInt.a;
			return $cmditch$elm_bigint$BigInt$Pos(mag);
	}
};
var $cmditch$elm_bigint$BigInt$sub = F2(
	function (a, b) {
		return A2(
			$cmditch$elm_bigint$BigInt$add,
			a,
			$cmditch$elm_bigint$BigInt$negate(b));
	});
var $cmditch$elm_bigint$BigInt$zero = $cmditch$elm_bigint$BigInt$fromInt(0);
var $cmditch$elm_bigint$BigInt$divmodDigit_ = F4(
	function (to_test, padding, num, den) {
		if (!to_test) {
			return _Utils_Tuple2($cmditch$elm_bigint$BigInt$zero, num);
		} else {
			var x = $cmditch$elm_bigint$BigInt$fromInt(to_test);
			var candidate = A2(
				$cmditch$elm_bigint$BigInt$mul,
				A2($cmditch$elm_bigint$BigInt$mul, x, den),
				padding);
			var _v0 = A2($cmditch$elm_bigint$BigInt$lte, candidate, num) ? _Utils_Tuple2(
				A2($cmditch$elm_bigint$BigInt$mul, x, padding),
				A2($cmditch$elm_bigint$BigInt$sub, num, candidate)) : _Utils_Tuple2($cmditch$elm_bigint$BigInt$zero, num);
			var newdiv = _v0.a;
			var newmod = _v0.b;
			var _v1 = A4($cmditch$elm_bigint$BigInt$divmodDigit_, (to_test / 2) | 0, padding, newmod, den);
			var restdiv = _v1.a;
			var restmod = _v1.b;
			return _Utils_Tuple2(
				A2($cmditch$elm_bigint$BigInt$add, newdiv, restdiv),
				restmod);
		}
	});
var $cmditch$elm_bigint$BigInt$maxDigitBits = $elm$core$Basics$ceiling(
	A2($elm$core$Basics$logBase, 2, $cmditch$elm_bigint$Constants$maxDigitValue));
var $cmditch$elm_bigint$BigInt$divmodDigit = F3(
	function (padding, x, y) {
		return A4(
			$cmditch$elm_bigint$BigInt$divmodDigit_,
			A2($elm$core$Basics$pow, 2, $cmditch$elm_bigint$BigInt$maxDigitBits),
			padding,
			x,
			y);
	});
var $cmditch$elm_bigint$BigInt$one = $cmditch$elm_bigint$BigInt$fromInt(1);
var $cmditch$elm_bigint$BigInt$repeatedly = F3(
	function (f, x, n) {
		return A3(
			$elm$core$List$foldl,
			$elm$core$Basics$always(f),
			x,
			A2($elm$core$List$range, 1, n));
	});
var $cmditch$elm_bigint$BigInt$padDigits = function (n) {
	return A3(
		$cmditch$elm_bigint$BigInt$repeatedly,
		$cmditch$elm_bigint$BigInt$mul(
			$cmditch$elm_bigint$BigInt$fromInt($cmditch$elm_bigint$BigInt$baseDigit)),
		$cmditch$elm_bigint$BigInt$one,
		n);
};
var $cmditch$elm_bigint$BigInt$divMod_ = F3(
	function (n, num, den) {
		if (!n) {
			return A3(
				$cmditch$elm_bigint$BigInt$divmodDigit,
				$cmditch$elm_bigint$BigInt$padDigits(n),
				num,
				den);
		} else {
			var _v0 = A3(
				$cmditch$elm_bigint$BigInt$divmodDigit,
				$cmditch$elm_bigint$BigInt$padDigits(n),
				num,
				den);
			var cdiv = _v0.a;
			var cmod = _v0.b;
			var _v1 = A3($cmditch$elm_bigint$BigInt$divMod_, n - 1, cmod, den);
			var rdiv = _v1.a;
			var rmod = _v1.b;
			return _Utils_Tuple2(
				A2($cmditch$elm_bigint$BigInt$add, cdiv, rdiv),
				rmod);
		}
	});
var $cmditch$elm_bigint$BigInt$toDigits = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return _List_Nil;
		case 'Pos':
			var ds = bigInt.a.a;
			return ds;
		default:
			var ds = bigInt.a.a;
			return ds;
	}
};
var $cmditch$elm_bigint$BigInt$divmod = F2(
	function (num, den) {
		if (_Utils_eq(den, $cmditch$elm_bigint$BigInt$zero)) {
			return $elm$core$Maybe$Nothing;
		} else {
			var cand_l = ($elm$core$List$length(
				$cmditch$elm_bigint$BigInt$toDigits(num)) - $elm$core$List$length(
				$cmditch$elm_bigint$BigInt$toDigits(den))) + 1;
			var _v0 = A3(
				$cmditch$elm_bigint$BigInt$divMod_,
				A2($elm$core$Basics$max, 0, cand_l),
				$cmditch$elm_bigint$BigInt$abs(num),
				$cmditch$elm_bigint$BigInt$abs(den));
			var d = _v0.a;
			var m = _v0.b;
			return $elm$core$Maybe$Just(
				_Utils_Tuple2(
					A2(
						$cmditch$elm_bigint$BigInt$mkBigInt,
						A2(
							$cmditch$elm_bigint$BigInt$signProduct,
							$cmditch$elm_bigint$BigInt$sign(num),
							$cmditch$elm_bigint$BigInt$sign(den)),
						$cmditch$elm_bigint$BigInt$magnitude(d)),
					A2(
						$cmditch$elm_bigint$BigInt$mkBigInt,
						$cmditch$elm_bigint$BigInt$sign(num),
						$cmditch$elm_bigint$BigInt$magnitude(m))));
		}
	});
var $cmditch$elm_bigint$BigInt$div = F2(
	function (num, den) {
		return A2(
			$elm$core$Maybe$withDefault,
			$cmditch$elm_bigint$BigInt$zero,
			A2(
				$elm$core$Maybe$map,
				$elm$core$Tuple$first,
				A2($cmditch$elm_bigint$BigInt$divmod, num, den)));
	});
var $elm$core$String$toInt = _String_toInt;
var $cmditch$elm_bigint$BigInt$fillZeroes = A2(
	$elm$core$Basics$composeL,
	A2(
		$elm$core$String$padLeft,
		$cmditch$elm_bigint$Constants$maxDigitMagnitude,
		_Utils_chr('0')),
	$elm$core$String$fromInt);
var $cmditch$elm_bigint$BigInt$revMagnitudeToString = function (_v0) {
	var digits = _v0.a;
	var _v1 = $elm$core$List$reverse(digits);
	if (!_v1.b) {
		return '0';
	} else {
		var x = _v1.a;
		var xs = _v1.b;
		return $elm$core$String$concat(
			A2(
				$elm$core$List$cons,
				$elm$core$String$fromInt(x),
				A2($elm$core$List$map, $cmditch$elm_bigint$BigInt$fillZeroes, xs)));
	}
};
var $cmditch$elm_bigint$BigInt$toString = function (bigInt) {
	switch (bigInt.$) {
		case 'Zer':
			return '0';
		case 'Pos':
			var mag = bigInt.a;
			return $cmditch$elm_bigint$BigInt$revMagnitudeToString(mag);
		default:
			var mag = bigInt.a;
			return '-' + $cmditch$elm_bigint$BigInt$revMagnitudeToString(mag);
	}
};
var $author$project$Extra$Data$Binary$bigToInt = function (big) {
	return A2(
		$elm$core$Maybe$withDefault,
		0,
		$elm$core$String$toInt(
			$cmditch$elm_bigint$BigInt$toString(big)));
};
var $author$project$Extra$Data$Binary$maybeBigToInt = function (maybeBig) {
	return $author$project$Extra$Data$Binary$bigToInt(
		A2($elm$core$Maybe$withDefault, $author$project$Extra$Data$Binary$bigZero, maybeBig));
};
var $cmditch$elm_bigint$BigInt$modBy = F2(
	function (modulus, x) {
		return A2(
			$elm$core$Maybe$map,
			$elm$core$Tuple$second,
			A2($cmditch$elm_bigint$BigInt$divmod, x, modulus));
	});
var $author$project$Extra$Data$Binary$bigToBytes = F2(
	function (big, bytes) {
		bigToBytes:
		while (true) {
			if (A2($cmditch$elm_bigint$BigInt$gt, big, $author$project$Extra$Data$Binary$bigZero)) {
				var $temp$big = A2($cmditch$elm_bigint$BigInt$div, big, $author$project$Extra$Data$Binary$bigFactor),
					$temp$bytes = A2(
					$elm$core$List$cons,
					$author$project$Extra$Data$Binary$maybeBigToInt(
						A2($cmditch$elm_bigint$BigInt$modBy, $author$project$Extra$Data$Binary$bigFactor, big)),
					bytes);
				big = $temp$big;
				bytes = $temp$bytes;
				continue bigToBytes;
			} else {
				return $author$project$Extra$Type$List$reverse(bytes);
			}
		}
	});
var $author$project$Extra$Data$Binary$bytesToBig = function (bytes) {
	return A3(
		$author$project$Extra$Type$List$foldr,
		F2(
			function (_byte, big) {
				return A2(
					$cmditch$elm_bigint$BigInt$add,
					A2($cmditch$elm_bigint$BigInt$mul, big, $author$project$Extra$Data$Binary$bigFactor),
					$cmditch$elm_bigint$BigInt$fromInt(_byte));
			}),
		$author$project$Extra$Data$Binary$bigZero,
		bytes);
};
var $author$project$Extra$Data$Binary$bBigInt = A5(
	$author$project$Extra$Data$Binary$bin3,
	F3(
		function (_v0, _v1, bytes) {
			return $author$project$Extra$Data$Binary$bytesToBig(bytes);
		}),
	function (big) {
		return A3(
			$author$project$Extra$Data$Binary$T3,
			1,
			1,
			A2($author$project$Extra$Data$Binary$bigToBytes, big, _List_Nil));
	},
	$author$project$Extra$Data$Binary$bWord8,
	$author$project$Extra$Data$Binary$bWord8,
	$author$project$Extra$Data$Binary$bTList($author$project$Extra$Data$Binary$bWord8));
var $author$project$Builder$File$halfTimeFactor = 500000000;
var $author$project$Builder$File$bigTimeFactor = $cmditch$elm_bigint$BigInt$fromInt(2 * $author$project$Builder$File$halfTimeFactor);
var $author$project$Builder$File$zeroTime = $author$project$Builder$File$Time(
	$elm$time$Time$millisToPosix(0));
var $author$project$Builder$File$bigToTime = function (big) {
	var _v0 = A2($cmditch$elm_bigint$BigInt$divmod, big, $author$project$Builder$File$bigTimeFactor);
	if (_v0.$ === 'Just') {
		var _v1 = _v0.a;
		var div = _v1.a;
		var rem = _v1.b;
		return $author$project$Builder$File$Time(
			$elm$time$Time$millisToPosix(
				$author$project$Extra$Data$Binary$bigToInt(div) + ((_Utils_cmp(
					$author$project$Extra$Data$Binary$bigToInt(rem),
					$author$project$Builder$File$halfTimeFactor) < 0) ? 0 : 1)));
	} else {
		return $author$project$Builder$File$zeroTime;
	}
};
var $elm$time$Time$posixToMillis = function (_v0) {
	var millis = _v0.a;
	return millis;
};
var $author$project$Builder$File$timeToBig = function (_v0) {
	var time = _v0.a;
	return A2(
		$cmditch$elm_bigint$BigInt$mul,
		$cmditch$elm_bigint$BigInt$fromInt(
			$elm$time$Time$posixToMillis(time)),
		$author$project$Builder$File$bigTimeFactor);
};
var $author$project$Builder$File$bTime = A3($author$project$Extra$Data$Binary$bin1, $author$project$Builder$File$bigToTime, $author$project$Builder$File$timeToBig, $author$project$Extra$Data$Binary$bBigInt);
var $author$project$Extra$Data$Binary$Get$liftM6 = F7(
	function (fun, ga, gb, gc, gd, ge, gf) {
		return A2(
			$author$project$Extra$Data$Binary$Get$bind,
			ga,
			function (a) {
				return A2(
					$author$project$Extra$Data$Binary$Get$bind,
					gb,
					function (b) {
						return A2(
							$author$project$Extra$Data$Binary$Get$bind,
							gc,
							function (c) {
								return A2(
									$author$project$Extra$Data$Binary$Get$bind,
									gd,
									function (d) {
										return A2(
											$author$project$Extra$Data$Binary$Get$bind,
											ge,
											function (e) {
												return A2(
													$author$project$Extra$Data$Binary$Get$bind,
													gf,
													function (f) {
														return $author$project$Extra$Data$Binary$Get$pure(
															A6(fun, a, b, c, d, e, f));
													});
											});
									});
							});
					});
			});
	});
var $author$project$Extra$Data$Binary$Put$put6 = function (fa) {
	return function (fb) {
		return function (fc) {
			return function (fd) {
				return function (fe) {
					return function (ff) {
						return function (a) {
							return function (b) {
								return function (c) {
									return function (d) {
										return function (e) {
											return function (f) {
												return $author$project$Extra$Data$Binary$Put$join(
													_List_fromArray(
														[
															fa(a),
															fb(b),
															fc(c),
															fd(d),
															fe(e),
															ff(f)
														]));
											};
										};
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var $author$project$Extra$Data$Binary$bin6 = F8(
	function (ctor, dtor, binA, binB, binC, binD, binE, binF) {
		return {
			get: A7($author$project$Extra$Data$Binary$Get$liftM6, ctor, binA.get, binB.get, binC.get, binD.get, binE.get, binF.get),
			put: function (g) {
				var _v0 = dtor(g);
				var a = _v0.a;
				var b = _v0.b;
				var c = _v0.c;
				var d = _v0.d;
				var e = _v0.e;
				var f = _v0.f;
				return $author$project$Extra$Data$Binary$Put$put6(binA.put)(binB.put)(binC.put)(binD.put)(binE.put)(binF.put)(a)(b)(c)(d)(e)(f);
			}
		};
	});
var $author$project$Builder$Elm$Details$bLocal = A8(
	$author$project$Extra$Data$Binary$bin6,
	$author$project$Builder$Elm$Details$Local,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		var e = _v0.e;
		var f = _v0.f;
		return A6($author$project$Extra$Data$Binary$T6, a, b, c, d, e, f);
	},
	$author$project$Extra$Data$Binary$bPath,
	$author$project$Builder$File$bTime,
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Elm$ModuleName$bRaw),
	$author$project$Extra$Data$Binary$bBool,
	$author$project$Extra$Data$Binary$bWord64,
	$author$project$Extra$Data$Binary$bWord64);
var $author$project$Builder$Elm$Details$ValidApp = function (a) {
	return {$: 'ValidApp', a: a};
};
var $author$project$Builder$Elm$Details$ValidPkg = F3(
	function (a, b, c) {
		return {$: 'ValidPkg', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Package$bComparable = A2($author$project$Extra$Data$Binary$bTuple, $author$project$Compiler$Data$Utf8$bUnder256, $author$project$Compiler$Data$Utf8$bUnder256);
var $author$project$Builder$Elm$Outline$AbsoluteSrcDir = function (a) {
	return {$: 'AbsoluteSrcDir', a: a};
};
var $author$project$Builder$Elm$Outline$bSrcDir = $author$project$Extra$Data$Binary$finish(
	A4(
		$author$project$Extra$Data$Binary$var1,
		1,
		$author$project$Builder$Elm$Outline$RelativeSrcDir,
		$author$project$Extra$Data$Binary$bPath,
		A4(
			$author$project$Extra$Data$Binary$var1,
			0,
			$author$project$Builder$Elm$Outline$AbsoluteSrcDir,
			$author$project$Extra$Data$Binary$bPath,
			A2(
				$author$project$Extra$Data$Binary$custom,
				'binary encoding of SrcDir was corrupted',
				F3(
					function (p0, p1, srcDir) {
						if (srcDir.$ === 'AbsoluteSrcDir') {
							var a = srcDir.a;
							return p0(a);
						} else {
							var a = srcDir.a;
							return p1(a);
						}
					})))));
var $author$project$Compiler$Data$NonEmptyList$bTList = function (binA) {
	return A4(
		$author$project$Extra$Data$Binary$bin2,
		$author$project$Compiler$Data$NonEmptyList$CList,
		function (_v0) {
			var x = _v0.a;
			var xs = _v0.b;
			return A2($author$project$Extra$Data$Binary$T2, x, xs);
		},
		binA,
		$author$project$Extra$Data$Binary$bTList(binA));
};
var $author$project$Compiler$Elm$Version$bVersion = {
	get: A2(
		$author$project$Extra$Data$Binary$Get$bind,
		$author$project$Extra$Data$Binary$bWord8.get,
		function (word) {
			return (word === 255) ? A4($author$project$Extra$Data$Binary$Get$liftM3, $author$project$Compiler$Elm$Version$Version, $author$project$Extra$Data$Binary$bWord16.get, $author$project$Extra$Data$Binary$bWord16.get, $author$project$Extra$Data$Binary$bWord16.get) : A3(
				$author$project$Extra$Data$Binary$Get$liftM2,
				$author$project$Compiler$Elm$Version$Version(word),
				$author$project$Extra$Data$Binary$bWord8.get,
				$author$project$Extra$Data$Binary$bWord8.get);
		}),
	put: function (_v0) {
		var major = _v0.a;
		var minor = _v0.b;
		var patch = _v0.c;
		return ((major < 255) && ((minor < 256) && (patch < 256))) ? A6($author$project$Extra$Data$Binary$Put$put3, $author$project$Extra$Data$Binary$bWord8.put, $author$project$Extra$Data$Binary$bWord8.put, $author$project$Extra$Data$Binary$bWord8.put, major, minor, patch) : A8($author$project$Extra$Data$Binary$Put$put4, $author$project$Extra$Data$Binary$bWord8.put, $author$project$Extra$Data$Binary$bWord16.put, $author$project$Extra$Data$Binary$bWord16.put, $author$project$Extra$Data$Binary$bWord16.put, 255, major, minor, patch);
	}
};
var $author$project$Builder$Elm$Details$bValidOutline = $author$project$Extra$Data$Binary$finish(
	A6(
		$author$project$Extra$Data$Binary$var3,
		1,
		$author$project$Builder$Elm$Details$ValidPkg,
		$author$project$Compiler$Elm$Package$bName,
		$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Elm$ModuleName$bRaw),
		A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Elm$Package$bComparable, $author$project$Compiler$Elm$Version$bVersion),
		A4(
			$author$project$Extra$Data$Binary$var1,
			0,
			$author$project$Builder$Elm$Details$ValidApp,
			$author$project$Compiler$Data$NonEmptyList$bTList($author$project$Builder$Elm$Outline$bSrcDir),
			A2(
				$author$project$Extra$Data$Binary$custom,
				'binary encoding of ValidOutline was corrupted',
				F3(
					function (p0, p1, validOutline) {
						if (validOutline.$ === 'ValidApp') {
							var a = validOutline.a;
							return p0(a);
						} else {
							var a = validOutline.a;
							var b = validOutline.b;
							var c = validOutline.c;
							return A3(p1, a, b, c);
						}
					})))));
var $author$project$Builder$Elm$Details$bDetails = A7(
	$author$project$Extra$Data$Binary$bin5,
	F5(
		function (a, b, c, d, e) {
			return A6($author$project$Builder$Elm$Details$Details, a, b, c, d, e, $author$project$Builder$Elm$Details$ArtifactsCached);
		}),
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		var c = _v0.c;
		var d = _v0.d;
		var e = _v0.e;
		return A5($author$project$Extra$Data$Binary$T5, a, b, c, d, e);
	},
	$author$project$Builder$File$bTime,
	$author$project$Builder$Elm$Details$bValidOutline,
	$author$project$Extra$Data$Binary$bWord64,
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Elm$ModuleName$bRaw, $author$project$Builder$Elm$Details$bLocal),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Elm$ModuleName$bRaw, $author$project$Builder$Elm$Details$bForeign));
var $author$project$Builder$Stuff$details = function (root) {
	return A2(
		$author$project$Extra$System$File$addName,
		$author$project$Builder$Stuff$stuff(root),
		'd.dat');
};
var $author$project$Builder$Build$writeDetails = F3(
	function (root, _v0, results) {
		var time = _v0.a;
		var outline = _v0.b;
		var buildID = _v0.c;
		var locals = _v0.d;
		var foreigns = _v0.e;
		var extras = _v0.f;
		return A3(
			$author$project$Builder$File$writeBinary,
			$author$project$Builder$Elm$Details$bDetails,
			$author$project$Builder$Stuff$details(root),
			A6(
				$author$project$Builder$Elm$Details$Details,
				time,
				outline,
				buildID,
				A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Builder$Build$addNewLocal, locals, results),
				foreigns,
				extras));
	});
var $author$project$Builder$Build$fromRepl = F3(
	function (root, details, source) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Builder$Build$makeEnv, root, details),
			function (env) {
				var projectType = env.b;
				var _v0 = A2($author$project$Compiler$Parse$Module$fromByteString, projectType, source);
				if (_v0.$ === 'Left') {
					var syntaxError = _v0.a;
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(
							A2(
								$author$project$Builder$Reporting$Exit$ReplBadInput,
								source,
								$author$project$Compiler$Reporting$Error$BadSyntax(syntaxError))));
				} else {
					var modul = _v0.a;
					var imports = modul.c;
					return A2(
						$author$project$Extra$System$IO$bind,
						A2($author$project$Builder$Elm$Details$loadInterfaces, root, details),
						function (dmvar) {
							var deps = A2($author$project$Extra$Type$List$map, $author$project$Compiler$AST$Source$getImportName, imports);
							return A2(
								$author$project$Extra$System$IO$bind,
								A2($author$project$Extra$System$MVar$new, $author$project$Builder$Build$lensMVStatusMap, $author$project$Extra$Type$Map$empty),
								function (mvar) {
									return A2(
										$author$project$Extra$System$IO$bind,
										A4($author$project$Builder$Build$crawlDeps, env, mvar, deps, _Utils_Tuple0),
										function (_v1) {
											return A2(
												$author$project$Extra$System$IO$bind,
												A2(
													$author$project$Extra$System$IO$andThen,
													A3(
														$author$project$Extra$Type$Map$traverse,
														$author$project$Extra$System$IO$pure,
														$author$project$Extra$System$IO$liftA2,
														$author$project$Extra$System$MVar$read($author$project$Builder$Build$lensMVStatus)),
													A2($author$project$Extra$System$MVar$read, $author$project$Builder$Build$lensMVStatusMap, mvar)),
												function (statuses) {
													return A2(
														$author$project$Extra$System$IO$bind,
														A2($author$project$Builder$Build$checkMidpoint, dmvar, statuses),
														function (midpoint) {
															if (midpoint.$ === 'Left') {
																var problem = midpoint.a;
																return $author$project$Extra$System$IO$return(
																	$author$project$Extra$Type$Either$Left(
																		$author$project$Builder$Reporting$Exit$ReplProjectProblem(problem)));
															} else {
																var foreigns = midpoint.a;
																return A2(
																	$author$project$Extra$System$IO$bind,
																	$author$project$Extra$System$MVar$newEmpty($author$project$Builder$Build$lensMVResultMap),
																	function (rmvar) {
																		return A2(
																			$author$project$Extra$System$IO$bind,
																			A3(
																				$author$project$Builder$Build$forkWithKey,
																				$author$project$Builder$Build$lensMVResult,
																				A3($author$project$Builder$Build$checkModule, env, foreigns, rmvar),
																				statuses),
																			function (resultMVars) {
																				return A2(
																					$author$project$Extra$System$IO$bind,
																					A3($author$project$Extra$System$MVar$write, $author$project$Builder$Build$lensMVResultMap, rmvar, resultMVars),
																					function (_v3) {
																						return A2(
																							$author$project$Extra$System$IO$bind,
																							A4(
																								$author$project$Extra$Type$Map$traverse,
																								$author$project$Extra$System$IO$pure,
																								$author$project$Extra$System$IO$liftA2,
																								$author$project$Extra$System$MVar$read($author$project$Builder$Build$lensMVResult),
																								resultMVars),
																							function (results) {
																								return A2(
																									$author$project$Extra$System$IO$bind,
																									A3($author$project$Builder$Build$writeDetails, root, details, results),
																									function (_v4) {
																										return A2(
																											$author$project$Extra$System$IO$bind,
																											A4($author$project$Builder$Build$checkDeps, root, resultMVars, deps, 0),
																											function (depsStatus) {
																												return A6($author$project$Builder$Build$finalizeReplArtifacts, env, source, modul, depsStatus, resultMVars, results);
																											});
																									});
																							});
																					});
																			});
																	});
															}
														});
												});
										});
								});
						});
				}
			});
	});
var $author$project$Terminal$Repl$openedModule = function (mode) {
	switch (mode.$) {
		case 'Normal':
			return $elm$core$Maybe$Nothing;
		case 'Module':
			var moduleName = mode.a;
			return $elm$core$Maybe$Just(moduleName);
		case 'Breakpoint':
			var moduleName = mode.a;
			return $elm$core$Maybe$Just(moduleName);
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Compiler$Data$Name$replModule = 'Elm_Repl';
var $author$project$Terminal$Repl$generatedModule = function (mode) {
	return A2(
		$elm$core$Maybe$withDefault,
		$author$project$Compiler$Data$Name$replModule,
		$author$project$Terminal$Repl$openedModule(mode));
};
var $author$project$Terminal$Repl$InterpretHtml = F2(
	function (a, b) {
		return {$: 'InterpretHtml', a: a, b: b};
	});
var $author$project$Terminal$Repl$InterpretValue = function (a) {
	return {$: 'InterpretValue', a: a};
};
var $author$project$Terminal$Repl$inputForKind = F2(
	function (kind, moduleName) {
		if (kind.$ === 'ValueKind') {
			return $author$project$Terminal$Repl$InterpretValue;
		} else {
			return $author$project$Terminal$Repl$InterpretHtml(moduleName);
		}
	});
var $author$project$Terminal$Repl$lensCont = {
	getter: function (_v0) {
		var x = _v0.g.a;
		return x;
	},
	setter: F2(
		function (x, _v1) {
			var a = _v1.a;
			var b = _v1.b;
			var c = _v1.c;
			var d = _v1.d;
			var e = _v1.e;
			var f = _v1.f;
			var h = _v1.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				d,
				e,
				f,
				$author$project$Terminal$Repl$LocalState(x),
				h);
		})
};
var $author$project$Terminal$Repl$interpret = F2(
	function (interpreter, input) {
		return $author$project$Extra$System$IO$liftCont(
			function (cont) {
				return $author$project$Extra$System$IO$sequence(
					_List_fromArray(
						[
							A2(
							$author$project$Extra$System$IO$putLens,
							$author$project$Terminal$Repl$lensCont,
							$elm$core$Maybe$Just(cont)),
							interpreter(input)
						]));
			});
	});
var $author$project$Builder$Reporting$Exit$DetailsBadOutline = function (a) {
	return {$: 'DetailsBadOutline', a: a};
};
var $author$project$Builder$Reporting$Exit$DetailsCannotGetRegistry = function (a) {
	return {$: 'DetailsCannotGetRegistry', a: a};
};
var $author$project$Builder$Elm$Details$Env = F5(
	function (a, b, c, d, e) {
		return {$: 'Env', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Builder$Deps$Solver$Env = F4(
	function (a, b, c, d) {
		return {$: 'Env', a: a, b: b, c: c, d: d};
	});
var $author$project$Builder$Deps$Solver$Offline = {$: 'Offline'};
var $author$project$Builder$Deps$Solver$Online = function (a) {
	return {$: 'Online', a: a};
};
var $author$project$Builder$Deps$Registry$KnownVersions = F2(
	function (a, b) {
		return {$: 'KnownVersions', a: a, b: b};
	});
var $author$project$Builder$Deps$Registry$Registry = F2(
	function (a, b) {
		return {$: 'Registry', a: a, b: b};
	});
var $author$project$Compiler$Elm$Version$one = A3($author$project$Compiler$Elm$Version$Version, 1, 0, 0);
var $author$project$Builder$Deps$Solver$addSpecialVersions = function (_v0) {
	var count = _v0.a;
	var registry = _v0.b;
	return A2(
		$author$project$Builder$Deps$Registry$Registry,
		count + 1,
		A3(
			$author$project$Extra$Type$Map$insert,
			_Utils_Tuple2('elm', 'breakpoint'),
			A2($author$project$Builder$Deps$Registry$KnownVersions, $author$project$Compiler$Elm$Version$one, _List_Nil),
			registry));
};
var $author$project$Builder$Deps$Registry$addEntry = F2(
	function (_v0, count) {
		var vs = _v0.b;
		return (count + 1) + $author$project$Extra$Type$List$length(vs);
	});
var $author$project$Compiler$Json$Decode$Decoder = function (a) {
	return {$: 'Decoder', a: a};
};
var $author$project$Compiler$Json$Decode$Derr = function (a) {
	return {$: 'Derr', a: a};
};
var $author$project$Compiler$Json$Decode$bind = F2(
	function (_v0, callback) {
		var decodeA = _v0.a;
		return $author$project$Compiler$Json$Decode$Decoder(
			function (ast) {
				var _v1 = decodeA(ast);
				if (_v1.$ === 'Dok') {
					var a = _v1.a;
					var _v2 = callback(a);
					var decodeB = _v2.a;
					return decodeB(ast);
				} else {
					var p = _v1.a;
					return $author$project$Compiler$Json$Decode$Derr(p);
				}
			});
	});
var $author$project$Compiler$Json$Decode$andThen = $author$project$Extra$Class$Monad$andThen($author$project$Compiler$Json$Decode$bind);
var $author$project$Builder$Deps$Registry$bail = F2(
	function (_v0, _v1) {
		return _Utils_Tuple0;
	});
var $author$project$Compiler$Json$Decode$Dok = function (a) {
	return {$: 'Dok', a: a};
};
var $author$project$Compiler$Json$Decode$Expecting = F2(
	function (a, b) {
		return {$: 'Expecting', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$Failure = F2(
	function (a, b) {
		return {$: 'Failure', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$TString = {$: 'TString'};
var $author$project$Compiler$Parse$Primitives$fromSnippet = F3(
	function (_v0, toBadEnd, _v1) {
		var parser = _v0.a;
		var fptr = _v1.a;
		var offset = _v1.b;
		var length = _v1.c;
		var row = _v1.d;
		var col = _v1.e;
		var toOk_ = $author$project$Compiler$Parse$Primitives$toOk(toBadEnd);
		var pos = offset;
		var end = pos + length;
		var result = parser(
			A6($author$project$Compiler$Parse$Primitives$State, fptr, pos, end, 0, row, col));
		switch (result.$) {
			case 'Cok':
				var a = result.a;
				var s = result.b;
				return A2(toOk_, a, s);
			case 'Eok':
				var a = result.a;
				var s = result.b;
				return A2(toOk_, a, s);
			case 'Cerr':
				var r = result.a;
				var c = result.b;
				var t = result.c;
				return A3($author$project$Compiler$Parse$Primitives$toErr, r, c, t);
			default:
				var r = result.a;
				var c = result.b;
				var t = result.c;
				return A3($author$project$Compiler$Parse$Primitives$toErr, r, c, t);
		}
	});
var $author$project$Compiler$Json$Decode$customString = F2(
	function (parser, toBadEnd) {
		return $author$project$Compiler$Json$Decode$Decoder(
			function (_v0) {
				var region = _v0.a;
				var ast = _v0.b;
				if (ast.$ === 'String') {
					var snippet = ast.a;
					var _v2 = A3($author$project$Compiler$Parse$Primitives$fromSnippet, parser, toBadEnd, snippet);
					if (_v2.$ === 'Right') {
						var a = _v2.a;
						return $author$project$Compiler$Json$Decode$Dok(a);
					} else {
						var x = _v2.a;
						return $author$project$Compiler$Json$Decode$Derr(
							A2($author$project$Compiler$Json$Decode$Failure, region, x));
					}
				} else {
					return $author$project$Compiler$Json$Decode$Derr(
						A2($author$project$Compiler$Json$Decode$Expecting, region, $author$project$Compiler$Json$Decode$TString));
				}
			});
	});
var $author$project$Compiler$Elm$Version$isDigit = function (word) {
	return (48 <= word) && (word <= 57);
};
var $author$project$Compiler$Elm$Version$chompWord16 = F4(
	function (src, pos, end, total) {
		chompWord16:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(total, pos);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if ($author$project$Compiler$Elm$Version$isDigit(word)) {
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end,
						$temp$total = ((10 * total) + word) - 48;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					total = $temp$total;
					continue chompWord16;
				} else {
					return _Utils_Tuple2(total, pos);
				}
			}
		}
	});
var $author$project$Compiler$Elm$Version$numberParser = $author$project$Compiler$Parse$Primitives$Parser(
	function (_v0) {
		var src = _v0.a;
		var pos = _v0.b;
		var end = _v0.c;
		var indent = _v0.d;
		var row = _v0.e;
		var col = _v0.f;
		if (_Utils_cmp(pos, end) > -1) {
			return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $elm$core$Tuple$pair);
		} else {
			var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
			if (word === 48) {
				var newState = A6($author$project$Compiler$Parse$Primitives$State, src, pos + 1, end, indent, row, col + 1);
				return A2($author$project$Compiler$Parse$Primitives$Cok, 0, newState);
			} else {
				if ($author$project$Compiler$Elm$Version$isDigit(word)) {
					var _v1 = A4($author$project$Compiler$Elm$Version$chompWord16, src, pos + 1, end, word - 48);
					var total = _v1.a;
					var newPos = _v1.b;
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, col + (newPos - pos));
					return A2($author$project$Compiler$Parse$Primitives$Cok, total, newState);
				} else {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $elm$core$Tuple$pair);
				}
			}
		}
	});
var $author$project$Compiler$Elm$Version$parser = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Elm$Version$numberParser,
	function (major) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Primitives$word1, 46, $elm$core$Tuple$pair),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Elm$Version$numberParser,
					function (minor) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 46, $elm$core$Tuple$pair),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									$author$project$Compiler$Elm$Version$numberParser,
									function (patch) {
										return $author$project$Compiler$Parse$Primitives$return(
											A3($author$project$Compiler$Elm$Version$Version, major, minor, patch));
									});
							});
					});
			});
	});
var $author$project$Compiler$Elm$Version$decoder = A2($author$project$Compiler$Json$Decode$customString, $author$project$Compiler$Elm$Version$parser, $elm$core$Tuple$pair);
var $author$project$Compiler$Json$Decode$fmap = F2(
	function (func, _v0) {
		var decodeA = _v0.a;
		return $author$project$Compiler$Json$Decode$Decoder(
			function (ast) {
				var _v1 = decodeA(ast);
				if (_v1.$ === 'Dok') {
					var a = _v1.a;
					return $author$project$Compiler$Json$Decode$Dok(
						func(a));
				} else {
					var p = _v1.a;
					return $author$project$Compiler$Json$Decode$Derr(p);
				}
			});
	});
var $author$project$Compiler$Json$Decode$TObject = {$: 'TObject'};
var $author$project$Compiler$Json$Decode$Field = F2(
	function (a, b) {
		return {$: 'Field', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$snippetToRegion = function (_v0) {
	var len = _v0.c;
	var row = _v0.d;
	var col = _v0.e;
	return A2(
		$author$project$Compiler$Reporting$Annotation$Region,
		A2($author$project$Compiler$Reporting$Annotation$Position, row, col),
		A2($author$project$Compiler$Reporting$Annotation$Position, row, col + len));
};
var $author$project$Compiler$Json$Decode$pairsHelp = F4(
	function (keyDecoder, valueDecoder, kvs, revs) {
		pairsHelp:
		while (true) {
			var keyParser = keyDecoder.a;
			var toBadEnd = keyDecoder.b;
			var decodeA = valueDecoder.a;
			if (!kvs.b) {
				return $author$project$Compiler$Json$Decode$Dok(
					$author$project$Extra$Type$List$reverse(revs));
			} else {
				var _v1 = kvs.a;
				var snippet = _v1.a;
				var ast = _v1.b;
				var kvs_ = kvs.b;
				var _v2 = A3($author$project$Compiler$Parse$Primitives$fromSnippet, keyParser, toBadEnd, snippet);
				if (_v2.$ === 'Left') {
					var x = _v2.a;
					return $author$project$Compiler$Json$Decode$Derr(
						A2(
							$author$project$Compiler$Json$Decode$Failure,
							$author$project$Compiler$Json$Decode$snippetToRegion(snippet),
							x));
				} else {
					var key = _v2.a;
					var _v3 = decodeA(ast);
					if (_v3.$ === 'Dok') {
						var value = _v3.a;
						var $temp$keyDecoder = keyDecoder,
							$temp$valueDecoder = valueDecoder,
							$temp$kvs = kvs_,
							$temp$revs = A2(
							$elm$core$List$cons,
							_Utils_Tuple2(key, value),
							revs);
						keyDecoder = $temp$keyDecoder;
						valueDecoder = $temp$valueDecoder;
						kvs = $temp$kvs;
						revs = $temp$revs;
						continue pairsHelp;
					} else {
						var prob = _v3.a;
						var _v4 = snippet;
						var fptr = _v4.a;
						var off = _v4.b;
						var len = _v4.c;
						return $author$project$Compiler$Json$Decode$Derr(
							A2(
								$author$project$Compiler$Json$Decode$Field,
								A3($elm$core$String$slice, off, off + len, fptr),
								prob));
					}
				}
			}
		}
	});
var $author$project$Compiler$Json$Decode$pairs = F2(
	function (keyDecoder, valueDecoder) {
		return $author$project$Compiler$Json$Decode$Decoder(
			function (_v0) {
				var region = _v0.a;
				var ast = _v0.b;
				if (ast.$ === 'Object') {
					var kvs = ast.a;
					return A4($author$project$Compiler$Json$Decode$pairsHelp, keyDecoder, valueDecoder, kvs, _List_Nil);
				} else {
					return $author$project$Compiler$Json$Decode$Derr(
						A2($author$project$Compiler$Json$Decode$Expecting, region, $author$project$Compiler$Json$Decode$TObject));
				}
			});
	});
var $author$project$Compiler$Json$Decode$dict = F2(
	function (keyDecoder, valueDecoder) {
		return A2(
			$author$project$Compiler$Json$Decode$fmap,
			$author$project$Extra$Type$Map$fromList,
			A2($author$project$Compiler$Json$Decode$pairs, keyDecoder, valueDecoder));
	});
var $author$project$Compiler$Json$Decode$failure = function (x) {
	return $author$project$Compiler$Json$Decode$Decoder(
		function (_v0) {
			var region = _v0.a;
			return $author$project$Compiler$Json$Decode$Derr(
				A2($author$project$Compiler$Json$Decode$Failure, region, x));
		});
};
var $author$project$Compiler$Json$Decode$KeyDecoder = F2(
	function (a, b) {
		return {$: 'KeyDecoder', a: a, b: b};
	});
var $author$project$Compiler$Elm$Package$isAlphaOrDigit = function (word) {
	return ((97 <= word) && (word <= 122)) || (((65 <= word) && (word <= 90)) || ((48 <= word) && (word <= 57)));
};
var $author$project$Compiler$Elm$Package$isLower = function (word) {
	return (97 <= word) && (word <= 122);
};
var $author$project$Compiler$Elm$Package$isLowerOrDigit = function (word) {
	return ((97 <= word) && (word <= 122)) || ((48 <= word) && (word <= 57));
};
var $author$project$Compiler$Elm$Package$chompName = F5(
	function (isGoodChar, src, pos, end, prevWasDash) {
		chompName:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(!prevWasDash, pos);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if (isGoodChar(word)) {
					var $temp$isGoodChar = isGoodChar,
						$temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end,
						$temp$prevWasDash = false;
					isGoodChar = $temp$isGoodChar;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					prevWasDash = $temp$prevWasDash;
					continue chompName;
				} else {
					if (word === 45) {
						if (prevWasDash) {
							return _Utils_Tuple2(false, pos);
						} else {
							var $temp$isGoodChar = isGoodChar,
								$temp$src = src,
								$temp$pos = pos + 1,
								$temp$end = end,
								$temp$prevWasDash = true;
							isGoodChar = $temp$isGoodChar;
							src = $temp$src;
							pos = $temp$pos;
							end = $temp$end;
							prevWasDash = $temp$prevWasDash;
							continue chompName;
						}
					} else {
						return _Utils_Tuple2(true, pos);
					}
				}
			}
		}
	});
var $author$project$Compiler$Elm$Package$parseName = F2(
	function (isGoodStart, isGoodInner) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				if (_Utils_cmp(pos, end) > -1) {
					return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $elm$core$Tuple$pair);
				} else {
					var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
					if (!isGoodStart(word)) {
						return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $elm$core$Tuple$pair);
					} else {
						var _v1 = A5($author$project$Compiler$Elm$Package$chompName, isGoodInner, src, pos + 1, end, false);
						var isGood = _v1.a;
						var newPos = _v1.b;
						var len = newPos - pos;
						var newCol = col + len;
						if (isGood && (len < 256)) {
							var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
							return A2(
								$author$project$Compiler$Parse$Primitives$Cok,
								A3($author$project$Compiler$Data$Utf8$fromPtr, src, pos, newPos),
								newState);
						} else {
							return A3($author$project$Compiler$Parse$Primitives$Cerr, row, newCol, $elm$core$Tuple$pair);
						}
					}
				}
			});
	});
var $author$project$Compiler$Elm$Package$parser = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	A2($author$project$Compiler$Elm$Package$parseName, $author$project$Compiler$Elm$Package$isAlphaOrDigit, $author$project$Compiler$Elm$Package$isAlphaOrDigit),
	function (author) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Primitives$word1, 47, $elm$core$Tuple$pair),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Elm$Package$parseName, $author$project$Compiler$Elm$Package$isLower, $author$project$Compiler$Elm$Package$isLowerOrDigit),
					function (project) {
						return $author$project$Compiler$Parse$Primitives$return(
							A2($author$project$Compiler$Elm$Package$Name, author, project));
					});
			});
	});
var $author$project$Compiler$Elm$Package$keyDecoder = function (toError) {
	var keyParser = A2(
		$author$project$Compiler$Parse$Primitives$fmap,
		$author$project$Compiler$Elm$Package$toComparable,
		A2(
			$author$project$Compiler$Parse$Primitives$specialize,
			F3(
				function (_v0, _v1, _v2) {
					var r = _v0.a;
					var c = _v0.b;
					return A2(toError, r, c);
				}),
			$author$project$Compiler$Elm$Package$parser));
	return A2($author$project$Compiler$Json$Decode$KeyDecoder, keyParser, toError);
};
var $author$project$Compiler$Json$Decode$TArray = {$: 'TArray'};
var $author$project$Compiler$Json$Decode$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$listHelp = F4(
	function (decoder, i, asts, revs) {
		listHelp:
		while (true) {
			var decodeA = decoder.a;
			if (!asts.b) {
				return $author$project$Compiler$Json$Decode$Dok(
					$author$project$Extra$Type$List$reverse(revs));
			} else {
				var ast = asts.a;
				var asts_ = asts.b;
				var _v1 = decodeA(ast);
				if (_v1.$ === 'Dok') {
					var value = _v1.a;
					var $temp$decoder = decoder,
						$temp$i = i + 1,
						$temp$asts = asts_,
						$temp$revs = A2($elm$core$List$cons, value, revs);
					decoder = $temp$decoder;
					i = $temp$i;
					asts = $temp$asts;
					revs = $temp$revs;
					continue listHelp;
				} else {
					var prob = _v1.a;
					return $author$project$Compiler$Json$Decode$Derr(
						A2($author$project$Compiler$Json$Decode$Index, i, prob));
				}
			}
		}
	});
var $author$project$Compiler$Json$Decode$list = function (decoder) {
	return $author$project$Compiler$Json$Decode$Decoder(
		function (_v0) {
			var region = _v0.a;
			var ast = _v0.b;
			if (ast.$ === 'Array') {
				var asts = ast.a;
				return A4($author$project$Compiler$Json$Decode$listHelp, decoder, 0, asts, _List_Nil);
			} else {
				return $author$project$Compiler$Json$Decode$Derr(
					A2($author$project$Compiler$Json$Decode$Expecting, region, $author$project$Compiler$Json$Decode$TArray));
			}
		});
};
var $author$project$Compiler$Json$Decode$OneOf = F2(
	function (a, b) {
		return {$: 'OneOf', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$mapErrorHelp = F2(
	function (func, problem) {
		switch (problem.$) {
			case 'Field':
				var k = problem.a;
				var p = problem.b;
				return A2(
					$author$project$Compiler$Json$Decode$Field,
					k,
					A2($author$project$Compiler$Json$Decode$mapErrorHelp, func, p));
			case 'Index':
				var i = problem.a;
				var p = problem.b;
				return A2(
					$author$project$Compiler$Json$Decode$Index,
					i,
					A2($author$project$Compiler$Json$Decode$mapErrorHelp, func, p));
			case 'OneOf':
				var p = problem.a;
				var ps = problem.b;
				return A2(
					$author$project$Compiler$Json$Decode$OneOf,
					A2($author$project$Compiler$Json$Decode$mapErrorHelp, func, p),
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$Json$Decode$mapErrorHelp(func),
						ps));
			case 'Failure':
				var r = problem.a;
				var x = problem.b;
				return A2(
					$author$project$Compiler$Json$Decode$Failure,
					r,
					func(x));
			default:
				var r = problem.a;
				var e = problem.b;
				return A2($author$project$Compiler$Json$Decode$Expecting, r, e);
		}
	});
var $author$project$Compiler$Json$Decode$mapError = F2(
	function (func, _v0) {
		var decodeA = _v0.a;
		return $author$project$Compiler$Json$Decode$Decoder(
			function (ast) {
				var _v1 = decodeA(ast);
				if (_v1.$ === 'Dok') {
					var a = _v1.a;
					return $author$project$Compiler$Json$Decode$Dok(a);
				} else {
					var prob = _v1.a;
					return $author$project$Compiler$Json$Decode$Derr(
						A2($author$project$Compiler$Json$Decode$mapErrorHelp, func, prob));
				}
			});
	});
var $author$project$Compiler$Json$Decode$return = function (a) {
	return $author$project$Compiler$Json$Decode$Decoder(
		function (_v0) {
			return $author$project$Compiler$Json$Decode$Dok(a);
		});
};
var $author$project$Compiler$Elm$Version$toComparable = function (_v0) {
	var major = _v0.a;
	var minor = _v0.b;
	var patch = _v0.c;
	return _Utils_Tuple3(major, minor, patch);
};
var $author$project$Builder$Deps$Registry$allPkgsDecoder = function () {
	var versionsDecoder = $author$project$Compiler$Json$Decode$list(
		A2(
			$author$project$Compiler$Json$Decode$mapError,
			function (_v1) {
				return _Utils_Tuple0;
			},
			$author$project$Compiler$Elm$Version$decoder));
	var toKnownVersions = function (versions) {
		var _v0 = A2(
			$author$project$Extra$Type$List$sortBy,
			F2(
				function (a, b) {
					return A2(
						$elm$core$Basics$compare,
						$author$project$Compiler$Elm$Version$toComparable(b),
						$author$project$Compiler$Elm$Version$toComparable(a));
				}),
			versions);
		if (_v0.b) {
			var v = _v0.a;
			var vs = _v0.b;
			return $author$project$Compiler$Json$Decode$return(
				A2($author$project$Builder$Deps$Registry$KnownVersions, v, vs));
		} else {
			return $author$project$Compiler$Json$Decode$failure(_Utils_Tuple0);
		}
	};
	var keyDecoder = $author$project$Compiler$Elm$Package$keyDecoder($author$project$Builder$Deps$Registry$bail);
	return A2(
		$author$project$Compiler$Json$Decode$dict,
		keyDecoder,
		A2($author$project$Compiler$Json$Decode$andThen, toKnownVersions, versionsDecoder));
}();
var $author$project$Builder$Deps$Registry$bKnownVersions = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Builder$Deps$Registry$KnownVersions,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Compiler$Elm$Version$bVersion,
	$author$project$Extra$Data$Binary$bTList($author$project$Compiler$Elm$Version$bVersion));
var $author$project$Builder$Deps$Registry$bRegistry = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Builder$Deps$Registry$Registry,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Extra$Data$Binary$bWord64,
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Elm$Package$bComparable, $author$project$Builder$Deps$Registry$bKnownVersions));
var $author$project$Builder$Reporting$Exit$RP_Data = F2(
	function (a, b) {
		return {$: 'RP_Data', a: a, b: b};
	});
var $author$project$Builder$Reporting$Exit$RP_Http = function (a) {
	return {$: 'RP_Http', a: a};
};
var $author$project$Compiler$Json$Decode$BadEnd = F2(
	function (a, b) {
		return {$: 'BadEnd', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$DecodeProblem = F2(
	function (a, b) {
		return {$: 'DecodeProblem', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$ParseProblem = F2(
	function (a, b) {
		return {$: 'ParseProblem', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$Array = function (a) {
	return {$: 'Array', a: a};
};
var $author$project$Compiler$Json$Decode$ArrayEnd = F2(
	function (a, b) {
		return {$: 'ArrayEnd', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$FALSE = {$: 'FALSE'};
var $author$project$Compiler$Json$Decode$NULL = {$: 'NULL'};
var $author$project$Compiler$Json$Decode$Object = function (a) {
	return {$: 'Object', a: a};
};
var $author$project$Compiler$Json$Decode$ObjectColon = F2(
	function (a, b) {
		return {$: 'ObjectColon', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$ObjectEnd = F2(
	function (a, b) {
		return {$: 'ObjectEnd', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$ObjectField = F2(
	function (a, b) {
		return {$: 'ObjectField', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$Start = F2(
	function (a, b) {
		return {$: 'Start', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$String = function (a) {
	return {$: 'String', a: a};
};
var $author$project$Compiler$Json$Decode$TRUE = {$: 'TRUE'};
var $author$project$Compiler$Json$Decode$Int = {$: 'Int'};
var $author$project$Compiler$Json$Decode$NoFloats = F2(
	function (a, b) {
		return {$: 'NoFloats', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$NoLeadingZeros = F2(
	function (a, b) {
		return {$: 'NoLeadingZeros', a: a, b: b};
	});
var $author$project$Compiler$Json$Decode$BadIntEnd = {$: 'BadIntEnd'};
var $author$project$Compiler$Json$Decode$GoodInt = {$: 'GoodInt'};
var $author$project$Compiler$Json$Decode$isDecimalDigit = function (word) {
	return (word <= 57) && (word >= 48);
};
var $author$project$Compiler$Json$Decode$chompInt = F4(
	function (src, pos, end, n) {
		chompInt:
		while (true) {
			if (_Utils_cmp(pos, end) < 0) {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				if ($author$project$Compiler$Json$Decode$isDecimalDigit(word)) {
					var m = ((10 * n) + word) - 48;
					var $temp$src = src,
						$temp$pos = pos + 1,
						$temp$end = end,
						$temp$n = m;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					n = $temp$n;
					continue chompInt;
				} else {
					if ((word === 46) || ((word === 101) || (word === 69))) {
						return _Utils_Tuple3($author$project$Compiler$Json$Decode$BadIntEnd, n, pos);
					} else {
						return _Utils_Tuple3($author$project$Compiler$Json$Decode$GoodInt, n, pos);
					}
				}
			} else {
				return _Utils_Tuple3($author$project$Compiler$Json$Decode$GoodInt, n, pos);
			}
		}
	});
var $author$project$Compiler$Json$Decode$pInt = $author$project$Compiler$Parse$Primitives$Parser(
	function (_v0) {
		var src = _v0.a;
		var pos = _v0.b;
		var end = _v0.c;
		var indent = _v0.d;
		var row = _v0.e;
		var col = _v0.f;
		if (_Utils_cmp(pos, end) > -1) {
			return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $author$project$Compiler$Json$Decode$Start);
		} else {
			var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
			if (!$author$project$Compiler$Json$Decode$isDecimalDigit(word)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, $author$project$Compiler$Json$Decode$Start);
			} else {
				if (word === 48) {
					var pos1 = pos + 1;
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, pos1, end, indent, row, col + 1);
					if (_Utils_cmp(pos1, end) < 0) {
						var word1 = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1);
						return $author$project$Compiler$Json$Decode$isDecimalDigit(word1) ? A3($author$project$Compiler$Parse$Primitives$Cerr, row, col + 1, $author$project$Compiler$Json$Decode$NoLeadingZeros) : ((word1 === 46) ? A3($author$project$Compiler$Parse$Primitives$Cerr, row, col + 1, $author$project$Compiler$Json$Decode$NoFloats) : A2($author$project$Compiler$Parse$Primitives$Cok, $author$project$Compiler$Json$Decode$Int, newState));
					} else {
						return A2($author$project$Compiler$Parse$Primitives$Cok, $author$project$Compiler$Json$Decode$Int, newState);
					}
				} else {
					var _v1 = A4($author$project$Compiler$Json$Decode$chompInt, src, pos + 1, end, word - 48);
					var status = _v1.a;
					var newPos = _v1.c;
					var len = newPos - pos;
					if (status.$ === 'GoodInt') {
						var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, col + len);
						return A2($author$project$Compiler$Parse$Primitives$Cok, $author$project$Compiler$Json$Decode$Int, newState);
					} else {
						return A3($author$project$Compiler$Parse$Primitives$Cerr, row, col + len, $author$project$Compiler$Json$Decode$NoFloats);
					}
				}
			}
		}
	});
var $author$project$Compiler$Parse$Primitives$Snippet = F5(
	function (a, b, c, d, e) {
		return {$: 'Snippet', a: a, b: b, c: c, d: d, e: e};
	});
var $author$project$Compiler$Json$Decode$StringProblem = F3(
	function (a, b, c) {
		return {$: 'StringProblem', a: a, b: b, c: c};
	});
var $author$project$Compiler$Json$Decode$BadString = function (a) {
	return {$: 'BadString', a: a};
};
var $author$project$Compiler$Json$Decode$BadStringControlChar = {$: 'BadStringControlChar'};
var $author$project$Compiler$Json$Decode$BadStringEnd = {$: 'BadStringEnd'};
var $author$project$Compiler$Json$Decode$BadStringEscapeChar = {$: 'BadStringEscapeChar'};
var $author$project$Compiler$Json$Decode$BadStringEscapeHex = {$: 'BadStringEscapeHex'};
var $author$project$Compiler$Json$Decode$GoodString = {$: 'GoodString'};
var $author$project$Compiler$Json$Decode$isHex = function (word) {
	return ((48 <= word) && (word <= 57)) || (((97 <= word) && (word <= 102)) || ((65 <= word) && (word <= 70)));
};
var $author$project$Compiler$Json$Decode$pStringHelp = F5(
	function (src, pos, end, row, col) {
		pStringHelp:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple2(
					_Utils_Tuple2(
						$author$project$Compiler$Json$Decode$BadString($author$project$Compiler$Json$Decode$BadStringEnd),
						pos),
					_Utils_Tuple2(row, col));
			} else {
				var _v0 = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				switch (_v0) {
					case 34:
						return _Utils_Tuple2(
							_Utils_Tuple2($author$project$Compiler$Json$Decode$GoodString, pos + 1),
							_Utils_Tuple2(row, col + 1));
					case 10:
						return _Utils_Tuple2(
							_Utils_Tuple2(
								$author$project$Compiler$Json$Decode$BadString($author$project$Compiler$Json$Decode$BadStringEnd),
								pos),
							_Utils_Tuple2(row, col));
					case 92:
						var pos1 = pos + 1;
						if (_Utils_cmp(pos1, end) > -1) {
							return _Utils_Tuple2(
								_Utils_Tuple2(
									$author$project$Compiler$Json$Decode$BadString($author$project$Compiler$Json$Decode$BadStringEnd),
									pos1),
								_Utils_Tuple2(row + 1, col));
						} else {
							var _v1 = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1);
							switch (_v1) {
								case 34:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 92:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 47:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 98:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 102:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 110:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 114:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 116:
									var $temp$src = src,
										$temp$pos = pos + 2,
										$temp$end = end,
										$temp$row = row,
										$temp$col = col + 2;
									src = $temp$src;
									pos = $temp$pos;
									end = $temp$end;
									row = $temp$row;
									col = $temp$col;
									continue pStringHelp;
								case 117:
									var pos6 = pos + 6;
									if ((_Utils_cmp(pos6, end) < 1) && ($author$project$Compiler$Json$Decode$isHex(
										A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 2)) && ($author$project$Compiler$Json$Decode$isHex(
										A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 3)) && ($author$project$Compiler$Json$Decode$isHex(
										A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 4)) && $author$project$Compiler$Json$Decode$isHex(
										A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos + 5)))))) {
										var $temp$src = src,
											$temp$pos = pos6,
											$temp$end = end,
											$temp$row = row,
											$temp$col = col + 6;
										src = $temp$src;
										pos = $temp$pos;
										end = $temp$end;
										row = $temp$row;
										col = $temp$col;
										continue pStringHelp;
									} else {
										return _Utils_Tuple2(
											_Utils_Tuple2(
												$author$project$Compiler$Json$Decode$BadString($author$project$Compiler$Json$Decode$BadStringEscapeHex),
												pos),
											_Utils_Tuple2(row, col));
									}
								default:
									return _Utils_Tuple2(
										_Utils_Tuple2(
											$author$project$Compiler$Json$Decode$BadString($author$project$Compiler$Json$Decode$BadStringEscapeChar),
											pos),
										_Utils_Tuple2(row, col));
							}
						}
					default:
						var word = _v0;
						if (word < 32) {
							return _Utils_Tuple2(
								_Utils_Tuple2(
									$author$project$Compiler$Json$Decode$BadString($author$project$Compiler$Json$Decode$BadStringControlChar),
									pos),
								_Utils_Tuple2(row, col));
						} else {
							var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
							var $temp$src = src,
								$temp$pos = newPos,
								$temp$end = end,
								$temp$row = row,
								$temp$col = col + 1;
							src = $temp$src;
							pos = $temp$pos;
							end = $temp$end;
							row = $temp$row;
							col = $temp$col;
							continue pStringHelp;
						}
				}
			}
		}
	});
var $author$project$Compiler$Json$Decode$pString = function (start) {
	return $author$project$Compiler$Parse$Primitives$Parser(
		function (_v0) {
			var src = _v0.a;
			var pos = _v0.b;
			var end = _v0.c;
			var indent = _v0.d;
			var row = _v0.e;
			var col = _v0.f;
			if ((_Utils_cmp(pos, end) < 0) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos) === 34)) {
				var pos1 = pos + 1;
				var col1 = col + 1;
				var _v1 = A5($author$project$Compiler$Json$Decode$pStringHelp, src, pos1, end, row, col1);
				var _v2 = _v1.a;
				var status = _v2.a;
				var newPos = _v2.b;
				var _v3 = _v1.b;
				var newRow = _v3.a;
				var newCol = _v3.b;
				if (status.$ === 'GoodString') {
					var off = pos1;
					var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol);
					var len = (newPos - pos1) - 1;
					var snp = A5($author$project$Compiler$Parse$Primitives$Snippet, src, off, len, row, col1);
					return A2($author$project$Compiler$Parse$Primitives$Cok, snp, newState);
				} else {
					var problem = status.a;
					return A3(
						$author$project$Compiler$Parse$Primitives$Cerr,
						newRow,
						newCol,
						$author$project$Compiler$Json$Decode$StringProblem(problem));
				}
			} else {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, col, start);
			}
		});
};
var $author$project$Compiler$Json$Decode$eatSpaces = F5(
	function (src, pos, end, row, col) {
		eatSpaces:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple3(pos, row, col);
			} else {
				var _v0 = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				switch (_v0) {
					case 32:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row,
							$temp$col = col + 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					case 9:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row,
							$temp$col = col + 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					case 10:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row + 1,
							$temp$col = 1;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					case 13:
						var $temp$src = src,
							$temp$pos = pos + 1,
							$temp$end = end,
							$temp$row = row,
							$temp$col = col;
						src = $temp$src;
						pos = $temp$pos;
						end = $temp$end;
						row = $temp$row;
						col = $temp$col;
						continue eatSpaces;
					default:
						return _Utils_Tuple3(pos, row, col);
				}
			}
		}
	});
var $author$project$Compiler$Json$Decode$spaces = $author$project$Compiler$Parse$Primitives$Parser(
	function (state) {
		var src = state.a;
		var pos = state.b;
		var end = state.c;
		var indent = state.d;
		var row = state.e;
		var col = state.f;
		var _v0 = A5($author$project$Compiler$Json$Decode$eatSpaces, src, pos, end, row, col);
		var newPos = _v0.a;
		var newRow = _v0.b;
		var newCol = _v0.c;
		if (_Utils_eq(pos, newPos)) {
			return A2($author$project$Compiler$Parse$Primitives$Eok, _Utils_Tuple0, state);
		} else {
			var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol);
			return A2($author$project$Compiler$Parse$Primitives$Cok, _Utils_Tuple0, newState);
		}
	});
var $author$project$Compiler$Json$Decode$pArrayHelp = function (_v11) {
	var len = _v11.a;
	var revEntries = _v11.b;
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Json$Decode$ArrayEnd,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Json$Decode$ArrayEnd),
				function (_v12) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Json$Decode$spaces,
						function (_v13) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Json$Decode$cyclic$pValue(),
								function (entry) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Json$Decode$spaces,
										function (_v14) {
											return $author$project$Compiler$Parse$Primitives$return(
												$author$project$Compiler$Parse$Primitives$Loop(
													_Utils_Tuple2(
														len + 1,
														A2($elm$core$List$cons, entry, revEntries))));
										});
								});
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 93, $author$project$Compiler$Json$Decode$ArrayEnd),
				function (_v15) {
					return $author$project$Compiler$Parse$Primitives$return(
						$author$project$Compiler$Parse$Primitives$Done(
							$author$project$Compiler$Json$Decode$Array(
								$author$project$Extra$Type$List$reverse(revEntries))));
				})
			]));
};
var $author$project$Compiler$Json$Decode$pObjectHelp = function (revEntries) {
	return A2(
		$author$project$Compiler$Parse$Primitives$oneOf,
		$author$project$Compiler$Json$Decode$ObjectEnd,
		_List_fromArray(
			[
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 44, $author$project$Compiler$Json$Decode$ObjectEnd),
				function (_v0) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						$author$project$Compiler$Json$Decode$spaces,
						function (_v1) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Json$Decode$cyclic$pField(),
								function (entry) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Json$Decode$spaces,
										function (_v2) {
											return $author$project$Compiler$Parse$Primitives$return(
												$author$project$Compiler$Parse$Primitives$Loop(
													A2($elm$core$List$cons, entry, revEntries)));
										});
								});
						});
				}),
				A2(
				$author$project$Compiler$Parse$Primitives$bind,
				A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Json$Decode$ObjectEnd),
				function (_v3) {
					return $author$project$Compiler$Parse$Primitives$return(
						$author$project$Compiler$Parse$Primitives$Done(
							$author$project$Compiler$Json$Decode$Object(
								$author$project$Extra$Type$List$reverse(revEntries))));
				})
			]));
};
function $author$project$Compiler$Json$Decode$cyclic$pValue() {
	return $author$project$Compiler$Parse$Primitives$addLocation(
		A2(
			$author$project$Compiler$Parse$Primitives$oneOf,
			$author$project$Compiler$Json$Decode$Start,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$fmap,
					$author$project$Compiler$Json$Decode$String,
					$author$project$Compiler$Json$Decode$pString($author$project$Compiler$Json$Decode$Start)),
					$author$project$Compiler$Json$Decode$cyclic$pObject(),
					$author$project$Compiler$Json$Decode$cyclic$pArray(),
					$author$project$Compiler$Json$Decode$pInt,
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A5($author$project$Compiler$Parse$Keyword$k4, 116, 114, 117, 101, $author$project$Compiler$Json$Decode$Start),
					function (_v20) {
						return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$Json$Decode$TRUE);
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A6($author$project$Compiler$Parse$Keyword$k5, 102, 97, 108, 115, 101, $author$project$Compiler$Json$Decode$Start),
					function (_v21) {
						return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$Json$Decode$FALSE);
					}),
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A5($author$project$Compiler$Parse$Keyword$k4, 110, 117, 108, 108, $author$project$Compiler$Json$Decode$Start),
					function (_v22) {
						return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$Json$Decode$NULL);
					})
				])));
}
function $author$project$Compiler$Json$Decode$cyclic$pArray() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$Primitives$word1, 91, $author$project$Compiler$Json$Decode$Start),
		function (_v16) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Json$Decode$spaces,
				function (_v17) {
					return A2(
						$author$project$Compiler$Parse$Primitives$oneOf,
						$author$project$Compiler$Json$Decode$Start,
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Json$Decode$cyclic$pValue(),
								function (entry) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Json$Decode$spaces,
										function (_v18) {
											return A2(
												$author$project$Compiler$Parse$Primitives$loop,
												$author$project$Compiler$Json$Decode$pArrayHelp,
												_Utils_Tuple2(
													1,
													_List_fromArray(
														[entry])));
										});
								}),
								A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Primitives$word1, 93, $author$project$Compiler$Json$Decode$ArrayEnd),
								function (_v19) {
									return $author$project$Compiler$Parse$Primitives$return(
										$author$project$Compiler$Json$Decode$Array(_List_Nil));
								})
							]));
				});
		});
}
function $author$project$Compiler$Json$Decode$cyclic$pField() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		$author$project$Compiler$Json$Decode$pString($author$project$Compiler$Json$Decode$ObjectField),
		function (key) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Json$Decode$spaces,
				function (_v8) {
					return A2(
						$author$project$Compiler$Parse$Primitives$bind,
						A2($author$project$Compiler$Parse$Primitives$word1, 58, $author$project$Compiler$Json$Decode$ObjectColon),
						function (_v9) {
							return A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Json$Decode$spaces,
								function (_v10) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Json$Decode$cyclic$pValue(),
										function (value) {
											return $author$project$Compiler$Parse$Primitives$return(
												_Utils_Tuple2(key, value));
										});
								});
						});
				});
		});
}
function $author$project$Compiler$Json$Decode$cyclic$pObject() {
	return A2(
		$author$project$Compiler$Parse$Primitives$bind,
		A2($author$project$Compiler$Parse$Primitives$word1, 123, $author$project$Compiler$Json$Decode$Start),
		function (_v4) {
			return A2(
				$author$project$Compiler$Parse$Primitives$bind,
				$author$project$Compiler$Json$Decode$spaces,
				function (_v5) {
					return A2(
						$author$project$Compiler$Parse$Primitives$oneOf,
						$author$project$Compiler$Json$Decode$ObjectField,
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Parse$Primitives$bind,
								$author$project$Compiler$Json$Decode$cyclic$pField(),
								function (entry) {
									return A2(
										$author$project$Compiler$Parse$Primitives$bind,
										$author$project$Compiler$Json$Decode$spaces,
										function (_v6) {
											return A2(
												$author$project$Compiler$Parse$Primitives$loop,
												$author$project$Compiler$Json$Decode$pObjectHelp,
												_List_fromArray(
													[entry]));
										});
								}),
								A2(
								$author$project$Compiler$Parse$Primitives$bind,
								A2($author$project$Compiler$Parse$Primitives$word1, 125, $author$project$Compiler$Json$Decode$ObjectEnd),
								function (_v7) {
									return $author$project$Compiler$Parse$Primitives$return(
										$author$project$Compiler$Json$Decode$Object(_List_Nil));
								})
							]));
				});
		});
}
try {
	var $author$project$Compiler$Json$Decode$pValue = $author$project$Compiler$Json$Decode$cyclic$pValue();
	$author$project$Compiler$Json$Decode$cyclic$pValue = function () {
		return $author$project$Compiler$Json$Decode$pValue;
	};
	var $author$project$Compiler$Json$Decode$pArray = $author$project$Compiler$Json$Decode$cyclic$pArray();
	$author$project$Compiler$Json$Decode$cyclic$pArray = function () {
		return $author$project$Compiler$Json$Decode$pArray;
	};
	var $author$project$Compiler$Json$Decode$pField = $author$project$Compiler$Json$Decode$cyclic$pField();
	$author$project$Compiler$Json$Decode$cyclic$pField = function () {
		return $author$project$Compiler$Json$Decode$pField;
	};
	var $author$project$Compiler$Json$Decode$pObject = $author$project$Compiler$Json$Decode$cyclic$pObject();
	$author$project$Compiler$Json$Decode$cyclic$pObject = function () {
		return $author$project$Compiler$Json$Decode$pObject;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Json.Decode` are causing infinite recursion:\n\n  \n      pValue\n       \n      pArray\n       \n      pArrayHelp\n       \n      pField\n       \n      pObject\n       \n      pObjectHelp\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$Json$Decode$pFile = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Json$Decode$spaces,
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			$author$project$Compiler$Json$Decode$pValue,
			function (value) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Json$Decode$spaces,
					function (_v1) {
						return $author$project$Compiler$Parse$Primitives$return(value);
					});
			});
	});
var $author$project$Compiler$Json$Decode$fromByteString = F2(
	function (_v0, src) {
		var decode = _v0.a;
		var _v1 = A3($author$project$Compiler$Parse$Primitives$fromByteString, $author$project$Compiler$Json$Decode$pFile, $author$project$Compiler$Json$Decode$BadEnd, src);
		if (_v1.$ === 'Right') {
			var ast = _v1.a;
			var _v2 = decode(ast);
			if (_v2.$ === 'Dok') {
				var a = _v2.a;
				return $author$project$Extra$Type$Either$Right(a);
			} else {
				var p = _v2.a;
				return $author$project$Extra$Type$Either$Left(
					A2($author$project$Compiler$Json$Decode$DecodeProblem, src, p));
			}
		} else {
			var problem = _v1.a;
			return $author$project$Extra$Type$Either$Left(
				A2($author$project$Compiler$Json$Decode$ParseProblem, src, problem));
		}
	});
var $author$project$Builder$Http$userAgent = 'elm/' + $author$project$Compiler$Elm$Version$toChars($author$project$Compiler$Elm$Version$compiler);
var $elm$http$Http$Header = F2(
	function (a, b) {
		return {$: 'Header', a: a, b: b};
	});
var $elm$http$Http$header = $elm$http$Http$Header;
var $author$project$Extra$System$Http$userAgent = function (agent) {
	return A2($elm$http$Http$header, 'User-Agent', agent);
};
var $author$project$Builder$Http$addDefaultHeaders = function (headers) {
	return A2(
		$elm$core$List$cons,
		$author$project$Extra$System$Http$userAgent($author$project$Builder$Http$userAgent),
		headers);
};
var $author$project$Extra$System$Exception$handle = F2(
	function (onError, ia) {
		return A2(
			$author$project$Extra$System$IO$bind,
			ia,
			function (result) {
				if (result.$ === 'Right') {
					var a = result.a;
					return $author$project$Extra$System$IO$return(a);
				} else {
					var e1 = result.a;
					return onError(e1);
				}
			});
	});
var $author$project$Builder$Http$BadHttp = F2(
	function (a, b) {
		return {$: 'BadHttp', a: a, b: b};
	});
var $author$project$Builder$Http$handleHttpException = F3(
	function (url, onError, httpException) {
		return $author$project$Extra$System$IO$return(
			$author$project$Extra$Type$Either$Left(
				onError(
					A2($author$project$Builder$Http$BadHttp, url, httpException))));
	});
var $author$project$Builder$Http$fetch = F6(
	function (methodVerb, manager, url, headers, onError, onSuccess) {
		return A2(
			$author$project$Extra$System$Exception$handle,
			A2($author$project$Builder$Http$handleHttpException, url, onError),
			A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Extra$System$Http$parseUrlThrow(url),
				function (req0) {
					var req1 = _Utils_update(
						req0,
						{
							headers: $author$project$Builder$Http$addDefaultHeaders(headers),
							method: methodVerb
						});
					return A3(
						$author$project$Extra$System$Http$withStringResponse,
						req1,
						manager,
						function (response) {
							if (response.$ === 'Left') {
								var err = response.a;
								return $author$project$Extra$System$IO$return(
									$author$project$Extra$Type$Either$Left(err));
							} else {
								var string = response.a;
								return A2(
									$author$project$Extra$System$IO$fmap,
									$author$project$Extra$Type$Either$Right,
									onSuccess(string));
							}
						});
				}));
	});
var $author$project$Extra$System$Http$methodPost = 'POST';
var $author$project$Builder$Http$post = $author$project$Builder$Http$fetch($author$project$Extra$System$Http$methodPost);
var $author$project$Builder$Deps$Website$domain = 'https://package.elm-lang.org';
var $author$project$Extra$System$Http$specialChars = $author$project$Extra$Type$Map$fromList(
	_List_fromArray(
		[
			_Utils_Tuple2(
			_Utils_chr(' '),
			'%20'),
			_Utils_Tuple2(
			_Utils_chr('!'),
			'%21'),
			_Utils_Tuple2(
			_Utils_chr('#'),
			'%23'),
			_Utils_Tuple2(
			_Utils_chr('$'),
			'%24'),
			_Utils_Tuple2(
			_Utils_chr('%'),
			'%25'),
			_Utils_Tuple2(
			_Utils_chr('&'),
			'%26'),
			_Utils_Tuple2(
			_Utils_chr('\''),
			'%27'),
			_Utils_Tuple2(
			_Utils_chr('('),
			'%28'),
			_Utils_Tuple2(
			_Utils_chr(')'),
			'%29'),
			_Utils_Tuple2(
			_Utils_chr('*'),
			'%2A'),
			_Utils_Tuple2(
			_Utils_chr('+'),
			'%2B'),
			_Utils_Tuple2(
			_Utils_chr(','),
			'%2C'),
			_Utils_Tuple2(
			_Utils_chr('/'),
			'%2F'),
			_Utils_Tuple2(
			_Utils_chr(':'),
			'%3A'),
			_Utils_Tuple2(
			_Utils_chr(';'),
			'%3B'),
			_Utils_Tuple2(
			_Utils_chr('='),
			'%3D'),
			_Utils_Tuple2(
			_Utils_chr('?'),
			'%3F'),
			_Utils_Tuple2(
			_Utils_chr('@'),
			'%40'),
			_Utils_Tuple2(
			_Utils_chr('['),
			'%5B'),
			_Utils_Tuple2(
			_Utils_chr(']'),
			'%5D')
		]));
var $author$project$Extra$System$Http$urlEncodeChar = function (_char) {
	var _v0 = A2($author$project$Extra$Type$Map$lookup, _char, $author$project$Extra$System$Http$specialChars);
	if (_v0.$ === 'Just') {
		var replacement = _v0.a;
		return replacement;
	} else {
		return $elm$core$String$fromChar(_char);
	}
};
var $author$project$Extra$System$Http$urlEncode = function (string) {
	return A2(
		$elm$core$String$join,
		'',
		A2(
			$author$project$Extra$Type$List$map,
			$author$project$Extra$System$Http$urlEncodeChar,
			$elm$core$String$toList(string)));
};
var $author$project$Extra$System$Http$urlEncodeVars = function (vars) {
	return A2(
		$elm$core$String$join,
		'&',
		A2(
			$author$project$Extra$Type$List$map,
			function (_v0) {
				var key = _v0.a;
				var value = _v0.b;
				return $author$project$Extra$System$Http$urlEncode(key) + ('=' + $author$project$Extra$System$Http$urlEncode(value));
			},
			vars));
};
var $author$project$Builder$Http$toUrl = F2(
	function (url, params) {
		if (!params.b) {
			return url;
		} else {
			return url + ('?' + $author$project$Extra$System$Http$urlEncodeVars(params));
		}
	});
var $author$project$Builder$Deps$Website$route = F2(
	function (path, params) {
		return A2(
			$author$project$Builder$Http$toUrl,
			_Utils_ap($author$project$Builder$Deps$Website$domain, path),
			params);
	});
var $author$project$Builder$Deps$Registry$post = F4(
	function (manager, path, decoder, callback) {
		var url = A2($author$project$Builder$Deps$Website$route, path, _List_Nil);
		return A5(
			$author$project$Builder$Http$post,
			manager,
			url,
			_List_Nil,
			$author$project$Builder$Reporting$Exit$RP_Http,
			function (body) {
				var _v0 = A2($author$project$Compiler$Json$Decode$fromByteString, decoder, body);
				if (_v0.$ === 'Right') {
					var a = _v0.a;
					return A2(
						$author$project$Extra$System$IO$fmap,
						$author$project$Extra$Type$Either$Right,
						callback(a));
				} else {
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(
							A2($author$project$Builder$Reporting$Exit$RP_Data, url, body)));
				}
			});
	});
var $author$project$Builder$Stuff$registry = function (_v0) {
	var dir = _v0.a;
	return A2($author$project$Extra$System$File$addName, dir, 'registry.dat');
};
var $author$project$Builder$Deps$Registry$fetch = F2(
	function (manager, cache) {
		return A4(
			$author$project$Builder$Deps$Registry$post,
			manager,
			'/all-packages',
			$author$project$Builder$Deps$Registry$allPkgsDecoder,
			function (versions) {
				var size = A3($author$project$Extra$Type$Map$foldr, $author$project$Builder$Deps$Registry$addEntry, 0, versions);
				var registry = A2($author$project$Builder$Deps$Registry$Registry, size, versions);
				var path = $author$project$Builder$Stuff$registry(cache);
				return A2(
					$author$project$Extra$System$IO$bind,
					A3($author$project$Builder$File$writeBinary, $author$project$Builder$Deps$Registry$bRegistry, path, registry),
					function (_v0) {
						return $author$project$Extra$System$IO$return(registry);
					});
			});
	});
var $author$project$Builder$Http$getManager = A2(
	$author$project$Extra$System$IO$bind,
	$author$project$Extra$System$IO$getLens($author$project$Builder$Http$lensPrefix),
	$author$project$Extra$System$Http$newManager);
var $author$project$Builder$Stuff$PackageCache = function (a) {
	return {$: 'PackageCache', a: a};
};
var $author$project$Extra$System$File$getAppUserDataDirectory = function (app) {
	return $author$project$Extra$System$IO$return(
		$author$project$Extra$System$File$Absolute(
			_List_fromArray(
				['.' + app])));
};
var $author$project$Builder$Stuff$getElmHome = $author$project$Extra$System$File$getAppUserDataDirectory('elm');
var $author$project$Builder$Stuff$getCacheDir = function (projectName) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Builder$Stuff$getElmHome,
		function (home) {
			var root = A2(
				$author$project$Extra$System$File$addNames,
				home,
				_List_fromArray(
					[$author$project$Builder$Stuff$compilerVersion, projectName]));
			return A2(
				$author$project$Extra$System$IO$bind,
				A2($author$project$Extra$System$File$createDirectoryIfMissing, true, root),
				function (_v0) {
					return $author$project$Extra$System$IO$return(root);
				});
		});
};
var $author$project$Builder$Stuff$getPackageCache = A2(
	$author$project$Extra$System$IO$fmap,
	$author$project$Builder$Stuff$PackageCache,
	$author$project$Builder$Stuff$getCacheDir('packages'));
var $author$project$Builder$Deps$Registry$read = function (cache) {
	return A2(
		$author$project$Builder$File$readBinary,
		$author$project$Builder$Deps$Registry$bRegistry,
		$author$project$Builder$Stuff$registry(cache));
};
var $author$project$Builder$Deps$Registry$addNew = F2(
	function (_v0, versions) {
		var name = _v0.a;
		var version = _v0.b;
		var add = function (maybeKnowns) {
			if (maybeKnowns.$ === 'Just') {
				var _v2 = maybeKnowns.a;
				var v = _v2.a;
				var vs = _v2.b;
				return A2(
					$author$project$Builder$Deps$Registry$KnownVersions,
					version,
					A2($elm$core$List$cons, v, vs));
			} else {
				return A2($author$project$Builder$Deps$Registry$KnownVersions, version, _List_Nil);
			}
		};
		return A3(
			$author$project$Extra$Type$Map$alter,
			A2($elm$core$Basics$composeL, $elm$core$Maybe$Just, add),
			$author$project$Compiler$Elm$Package$toComparable(name),
			versions);
	});
var $author$project$Builder$Deps$Registry$newPkgParser = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	A2(
		$author$project$Compiler$Parse$Primitives$specialize,
		F3(
			function (_v0, _v1, _v2) {
				return _Utils_Tuple0;
			}),
		$author$project$Compiler$Elm$Package$parser),
	function (pkg) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Primitives$word1, 64, $author$project$Builder$Deps$Registry$bail),
			function (_v3) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2(
						$author$project$Compiler$Parse$Primitives$specialize,
						F3(
							function (_v4, _v5, _v6) {
								return _Utils_Tuple0;
							}),
						$author$project$Compiler$Elm$Version$parser),
					function (vsn) {
						return $author$project$Compiler$Parse$Primitives$return(
							_Utils_Tuple2(pkg, vsn));
					});
			});
	});
var $author$project$Builder$Deps$Registry$newPkgDecoder = A2($author$project$Compiler$Json$Decode$customString, $author$project$Builder$Deps$Registry$newPkgParser, $author$project$Builder$Deps$Registry$bail);
var $author$project$Builder$Deps$Registry$update = F3(
	function (manager, cache, oldRegistry) {
		var size = oldRegistry.a;
		var packages = oldRegistry.b;
		return A4(
			$author$project$Builder$Deps$Registry$post,
			manager,
			'/all-packages/since/' + $elm$core$String$fromInt(size),
			$author$project$Compiler$Json$Decode$list($author$project$Builder$Deps$Registry$newPkgDecoder),
			function (news) {
				if (!news.b) {
					return $author$project$Extra$System$IO$return(oldRegistry);
				} else {
					var newSize = size + $author$project$Extra$Type$List$length(news);
					var newPkgs = A3($author$project$Extra$Type$List$foldr, $author$project$Builder$Deps$Registry$addNew, packages, news);
					var newRegistry = A2($author$project$Builder$Deps$Registry$Registry, newSize, newPkgs);
					return A2(
						$author$project$Extra$System$IO$bind,
						A3(
							$author$project$Builder$File$writeBinary,
							$author$project$Builder$Deps$Registry$bRegistry,
							$author$project$Builder$Stuff$registry(cache),
							newRegistry),
						function (_v1) {
							return $author$project$Extra$System$IO$return(newRegistry);
						});
				}
			});
	});
var $author$project$Builder$Deps$Solver$initEnv = A2(
	$author$project$Extra$System$IO$bind,
	$author$project$Builder$Http$getManager,
	function (manager) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$Stuff$getPackageCache,
			function (cache) {
				return A2(
					$author$project$Extra$System$IO$bind,
					$author$project$Builder$Deps$Registry$read(cache),
					function (maybeRegistry) {
						if (maybeRegistry.$ === 'Nothing') {
							return A2(
								$author$project$Extra$System$IO$bind,
								A2($author$project$Builder$Deps$Registry$fetch, manager, cache),
								function (eitherRegistry) {
									if (eitherRegistry.$ === 'Right') {
										var latestRegistry = eitherRegistry.a;
										return $author$project$Extra$System$IO$return(
											$author$project$Extra$Type$Either$Right(
												A4(
													$author$project$Builder$Deps$Solver$Env,
													cache,
													manager,
													$author$project$Builder$Deps$Solver$Online(manager),
													$author$project$Builder$Deps$Solver$addSpecialVersions(latestRegistry))));
									} else {
										var problem = eitherRegistry.a;
										return $author$project$Extra$System$IO$return(
											$author$project$Extra$Type$Either$Left(problem));
									}
								});
						} else {
							var cachedRegistry = maybeRegistry.a;
							return A2(
								$author$project$Extra$System$IO$bind,
								A3($author$project$Builder$Deps$Registry$update, manager, cache, cachedRegistry),
								function (eitherRegistry) {
									if (eitherRegistry.$ === 'Right') {
										var latestRegistry = eitherRegistry.a;
										return $author$project$Extra$System$IO$return(
											$author$project$Extra$Type$Either$Right(
												A4(
													$author$project$Builder$Deps$Solver$Env,
													cache,
													manager,
													$author$project$Builder$Deps$Solver$Online(manager),
													$author$project$Builder$Deps$Solver$addSpecialVersions(latestRegistry))));
									} else {
										return $author$project$Extra$System$IO$return(
											$author$project$Extra$Type$Either$Right(
												A4(
													$author$project$Builder$Deps$Solver$Env,
													cache,
													manager,
													$author$project$Builder$Deps$Solver$Offline,
													$author$project$Builder$Deps$Solver$addSpecialVersions(cachedRegistry))));
									}
								});
						}
					});
			});
	});
var $author$project$Builder$Reporting$Exit$OutlineHasBadStructure = function (a) {
	return {$: 'OutlineHasBadStructure', a: a};
};
var $author$project$Builder$Reporting$Exit$OutlineHasDuplicateSrcDirs = F3(
	function (a, b, c) {
		return {$: 'OutlineHasDuplicateSrcDirs', a: a, b: b, c: c};
	});
var $author$project$Builder$Reporting$Exit$OutlineHasMissingSrcDirs = F2(
	function (a, b) {
		return {$: 'OutlineHasMissingSrcDirs', a: a, b: b};
	});
var $author$project$Builder$Reporting$Exit$OutlineNoAppCore = {$: 'OutlineNoAppCore'};
var $author$project$Builder$Reporting$Exit$OutlineNoAppJson = {$: 'OutlineNoAppJson'};
var $author$project$Builder$Reporting$Exit$OutlineNoPkgCore = {$: 'OutlineNoPkgCore'};
var $author$project$Builder$Elm$Outline$App = function (a) {
	return {$: 'App', a: a};
};
var $author$project$Builder$Reporting$Exit$OP_BadType = {$: 'OP_BadType'};
var $author$project$Builder$Elm$Outline$Pkg = function (a) {
	return {$: 'Pkg', a: a};
};
var $author$project$Builder$Elm$Outline$AppOutline = F6(
	function (a, b, c, d, e, f) {
		return {$: 'AppOutline', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Compiler$Json$Decode$andMap = F2(
	function (_v0, _v1) {
		var decodeArg = _v0.a;
		var decodeFunc = _v1.a;
		return $author$project$Compiler$Json$Decode$Decoder(
			function (ast) {
				var _v2 = decodeFunc(ast);
				if (_v2.$ === 'Dok') {
					var func = _v2.a;
					var _v3 = decodeArg(ast);
					if (_v3.$ === 'Dok') {
						var arg = _v3.a;
						return $author$project$Compiler$Json$Decode$Dok(
							func(arg));
					} else {
						var p = _v3.a;
						return $author$project$Compiler$Json$Decode$Derr(p);
					}
				} else {
					var p = _v2.a;
					return $author$project$Compiler$Json$Decode$Derr(p);
				}
			});
	});
var $author$project$Builder$Reporting$Exit$OP_BadDependencyName = F2(
	function (a, b) {
		return {$: 'OP_BadDependencyName', a: a, b: b};
	});
var $author$project$Builder$Elm$Outline$depsDecoder = function (valueDecoder) {
	return A2(
		$author$project$Compiler$Json$Decode$dict,
		$author$project$Compiler$Elm$Package$keyDecoder($author$project$Builder$Reporting$Exit$OP_BadDependencyName),
		valueDecoder);
};
var $author$project$Builder$Reporting$Exit$OP_NoSrcDirs = {$: 'OP_NoSrcDirs'};
var $author$project$Compiler$Json$Decode$nonEmptyList = F2(
	function (decoder, x) {
		return A2(
			$author$project$Compiler$Json$Decode$bind,
			$author$project$Compiler$Json$Decode$list(decoder),
			function (values) {
				if (values.b) {
					var v = values.a;
					var vs = values.b;
					return $author$project$Compiler$Json$Decode$return(
						A2($author$project$Compiler$Data$NonEmptyList$CList, v, vs));
				} else {
					return $author$project$Compiler$Json$Decode$failure(x);
				}
			});
	});
var $author$project$Compiler$Data$Utf8$fromSnippet = function (_v0) {
	var fptr = _v0.a;
	var off = _v0.b;
	var len = _v0.c;
	return A3($elm$core$String$slice, off, off + len, fptr);
};
var $author$project$Compiler$Json$String$fromSnippet = $author$project$Compiler$Data$Utf8$fromSnippet;
var $author$project$Compiler$Json$Decode$string = $author$project$Compiler$Json$Decode$Decoder(
	function (_v0) {
		var region = _v0.a;
		var ast = _v0.b;
		if (ast.$ === 'String') {
			var snippet = ast.a;
			return $author$project$Compiler$Json$Decode$Dok(
				$author$project$Compiler$Json$String$fromSnippet(snippet));
		} else {
			return $author$project$Compiler$Json$Decode$Derr(
				A2($author$project$Compiler$Json$Decode$Expecting, region, $author$project$Compiler$Json$Decode$TString));
		}
	});
var $author$project$Compiler$Json$String$toChars = $elm$core$Basics$identity;
var $author$project$Extra$System$File$isRelative = function (path) {
	if (path.$ === 'Absolute') {
		return false;
	} else {
		return true;
	}
};
var $author$project$Builder$Elm$Outline$toSrcDir = function (path) {
	return $author$project$Extra$System$File$isRelative(path) ? $author$project$Builder$Elm$Outline$RelativeSrcDir(path) : $author$project$Builder$Elm$Outline$AbsoluteSrcDir(path);
};
var $author$project$Builder$Elm$Outline$dirsDecoder = A2(
	$author$project$Compiler$Json$Decode$fmap,
	$author$project$Compiler$Data$NonEmptyList$fmap(
		A2(
			$elm$core$Basics$composeL,
			A2($elm$core$Basics$composeL, $author$project$Builder$Elm$Outline$toSrcDir, $author$project$Extra$System$File$fromString),
			$author$project$Compiler$Json$String$toChars)),
	A2($author$project$Compiler$Json$Decode$nonEmptyList, $author$project$Compiler$Json$Decode$string, $author$project$Builder$Reporting$Exit$OP_NoSrcDirs));
var $author$project$Compiler$Json$Decode$TObjectWith = function (a) {
	return {$: 'TObjectWith', a: a};
};
var $author$project$Compiler$Json$Decode$findField = F2(
	function (key, pairs_) {
		findField:
		while (true) {
			if (!pairs_.b) {
				return $elm$core$Maybe$Nothing;
			} else {
				var _v1 = pairs_.a;
				var _v2 = _v1.a;
				var src = _v2.a;
				var off = _v2.b;
				var len = _v2.c;
				var value = _v1.b;
				var remainingPairs = pairs_.b;
				if (_Utils_eq(
					key,
					A3($elm$core$String$slice, off, off + len, src))) {
					return $elm$core$Maybe$Just(value);
				} else {
					var $temp$key = key,
						$temp$pairs_ = remainingPairs;
					key = $temp$key;
					pairs_ = $temp$pairs_;
					continue findField;
				}
			}
		}
	});
var $author$project$Compiler$Json$Decode$field = F2(
	function (key, _v0) {
		var decodeA = _v0.a;
		return $author$project$Compiler$Json$Decode$Decoder(
			function (_v1) {
				var region = _v1.a;
				var ast = _v1.b;
				if (ast.$ === 'Object') {
					var kvs = ast.a;
					var _v3 = A2($author$project$Compiler$Json$Decode$findField, key, kvs);
					if (_v3.$ === 'Just') {
						var value = _v3.a;
						var _v4 = decodeA(value);
						if (_v4.$ === 'Derr') {
							var prob = _v4.a;
							return $author$project$Compiler$Json$Decode$Derr(
								A2($author$project$Compiler$Json$Decode$Field, key, prob));
						} else {
							var x = _v4;
							return x;
						}
					} else {
						return $author$project$Compiler$Json$Decode$Derr(
							A2(
								$author$project$Compiler$Json$Decode$Expecting,
								region,
								$author$project$Compiler$Json$Decode$TObjectWith(key)));
					}
				} else {
					return $author$project$Compiler$Json$Decode$Derr(
						A2($author$project$Compiler$Json$Decode$Expecting, region, $author$project$Compiler$Json$Decode$TObject));
				}
			});
	});
var $author$project$Compiler$Json$Decode$pure = $author$project$Compiler$Json$Decode$return;
var $author$project$Builder$Reporting$Exit$OP_BadVersion = F2(
	function (a, b) {
		return {$: 'OP_BadVersion', a: a, b: b};
	});
var $author$project$Builder$Elm$Outline$versionDecoder = A2(
	$author$project$Compiler$Json$Decode$mapError,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Builder$Reporting$Exit$OP_BadVersion, a, b);
	},
	$author$project$Compiler$Elm$Version$decoder);
var $author$project$Builder$Elm$Outline$appDecoder = A2(
	$author$project$Compiler$Json$Decode$andMap,
	A2(
		$author$project$Compiler$Json$Decode$field,
		'test-dependencies',
		A2(
			$author$project$Compiler$Json$Decode$field,
			'indirect',
			$author$project$Builder$Elm$Outline$depsDecoder($author$project$Builder$Elm$Outline$versionDecoder))),
	A2(
		$author$project$Compiler$Json$Decode$andMap,
		A2(
			$author$project$Compiler$Json$Decode$field,
			'test-dependencies',
			A2(
				$author$project$Compiler$Json$Decode$field,
				'direct',
				$author$project$Builder$Elm$Outline$depsDecoder($author$project$Builder$Elm$Outline$versionDecoder))),
		A2(
			$author$project$Compiler$Json$Decode$andMap,
			A2(
				$author$project$Compiler$Json$Decode$field,
				'dependencies',
				A2(
					$author$project$Compiler$Json$Decode$field,
					'indirect',
					$author$project$Builder$Elm$Outline$depsDecoder($author$project$Builder$Elm$Outline$versionDecoder))),
			A2(
				$author$project$Compiler$Json$Decode$andMap,
				A2(
					$author$project$Compiler$Json$Decode$field,
					'dependencies',
					A2(
						$author$project$Compiler$Json$Decode$field,
						'direct',
						$author$project$Builder$Elm$Outline$depsDecoder($author$project$Builder$Elm$Outline$versionDecoder))),
				A2(
					$author$project$Compiler$Json$Decode$andMap,
					A2($author$project$Compiler$Json$Decode$field, 'source-directories', $author$project$Builder$Elm$Outline$dirsDecoder),
					A2(
						$author$project$Compiler$Json$Decode$andMap,
						A2($author$project$Compiler$Json$Decode$field, 'elm-version', $author$project$Builder$Elm$Outline$versionDecoder),
						$author$project$Compiler$Json$Decode$pure($author$project$Builder$Elm$Outline$AppOutline)))))));
var $author$project$Compiler$Json$String$fromChars = $elm$core$Basics$identity;
var $author$project$Builder$Reporting$Exit$OP_BadLicense = function (a) {
	return {$: 'OP_BadLicense', a: a};
};
var $author$project$Builder$Elm$Outline$PkgOutline = F8(
	function (a, b, c, d, e, f, g, h) {
		return {$: 'PkgOutline', a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h};
	});
var $author$project$Builder$Reporting$Exit$OP_BadConstraint = function (a) {
	return {$: 'OP_BadConstraint', a: a};
};
var $author$project$Compiler$Elm$Constraint$BadFormat = F2(
	function (a, b) {
		return {$: 'BadFormat', a: a, b: b};
	});
var $author$project$Compiler$Elm$Constraint$InvalidRange = F2(
	function (a, b) {
		return {$: 'InvalidRange', a: a, b: b};
	});
var $author$project$Compiler$Elm$Constraint$Range = F4(
	function (a, b, c, d) {
		return {$: 'Range', a: a, b: b, c: c, d: d};
	});
var $author$project$Compiler$Elm$Constraint$Less = {$: 'Less'};
var $author$project$Compiler$Elm$Constraint$LessOrEqual = {$: 'LessOrEqual'};
var $author$project$Compiler$Elm$Constraint$parseOp = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	A2($author$project$Compiler$Parse$Primitives$word1, 60, $author$project$Compiler$Elm$Constraint$BadFormat),
	function (_v0) {
		return A2(
			$author$project$Compiler$Parse$Primitives$oneOfWithFallback,
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Parse$Primitives$bind,
					A2($author$project$Compiler$Parse$Primitives$word1, 61, $author$project$Compiler$Elm$Constraint$BadFormat),
					function (_v1) {
						return $author$project$Compiler$Parse$Primitives$return($author$project$Compiler$Elm$Constraint$LessOrEqual);
					})
				]),
			$author$project$Compiler$Elm$Constraint$Less);
	});
var $author$project$Compiler$Elm$Constraint$parseVersion = A2(
	$author$project$Compiler$Parse$Primitives$specialize,
	F3(
		function (_v0, _v1, _v2) {
			var r = _v0.a;
			var c = _v0.b;
			return A2($author$project$Compiler$Elm$Constraint$BadFormat, r, c);
		}),
	$author$project$Compiler$Elm$Version$parser);
var $author$project$Compiler$Elm$Constraint$parser = A2(
	$author$project$Compiler$Parse$Primitives$bind,
	$author$project$Compiler$Elm$Constraint$parseVersion,
	function (lower) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A2($author$project$Compiler$Parse$Primitives$word1, 32, $author$project$Compiler$Elm$Constraint$BadFormat),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Elm$Constraint$parseOp,
					function (loOp) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							A2($author$project$Compiler$Parse$Primitives$word1, 32, $author$project$Compiler$Elm$Constraint$BadFormat),
							function (_v1) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2($author$project$Compiler$Parse$Primitives$word1, 118, $author$project$Compiler$Elm$Constraint$BadFormat),
									function (_v2) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A2($author$project$Compiler$Parse$Primitives$word1, 32, $author$project$Compiler$Elm$Constraint$BadFormat),
											function (_v3) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													$author$project$Compiler$Elm$Constraint$parseOp,
													function (hiOp) {
														return A2(
															$author$project$Compiler$Parse$Primitives$bind,
															A2($author$project$Compiler$Parse$Primitives$word1, 32, $author$project$Compiler$Elm$Constraint$BadFormat),
															function (_v4) {
																return A2(
																	$author$project$Compiler$Parse$Primitives$bind,
																	$author$project$Compiler$Elm$Constraint$parseVersion,
																	function (higher) {
																		return $author$project$Compiler$Parse$Primitives$Parser(
																			function (state) {
																				var row = state.e;
																				var col = state.f;
																				return (_Utils_cmp(
																					$author$project$Compiler$Elm$Version$toComparable(lower),
																					$author$project$Compiler$Elm$Version$toComparable(higher)) < 0) ? A2(
																					$author$project$Compiler$Parse$Primitives$Eok,
																					A4($author$project$Compiler$Elm$Constraint$Range, lower, loOp, hiOp, higher),
																					state) : A3(
																					$author$project$Compiler$Parse$Primitives$Eerr,
																					row,
																					col,
																					F2(
																						function (_v5, _v6) {
																							return A2($author$project$Compiler$Elm$Constraint$InvalidRange, lower, higher);
																						}));
																			});
																	});
															});
													});
											});
									});
							});
					});
			});
	});
var $author$project$Compiler$Elm$Constraint$decoder = A2($author$project$Compiler$Json$Decode$customString, $author$project$Compiler$Elm$Constraint$parser, $author$project$Compiler$Elm$Constraint$BadFormat);
var $author$project$Builder$Elm$Outline$constraintDecoder = A2($author$project$Compiler$Json$Decode$mapError, $author$project$Builder$Reporting$Exit$OP_BadConstraint, $author$project$Compiler$Elm$Constraint$decoder);
var $author$project$Compiler$Elm$Licenses$License = function (a) {
	return {$: 'License', a: a};
};
var $author$project$Compiler$Elm$Licenses$osiApprovedSpdxLicenses = $author$project$Extra$Type$Map$fromList(
	_List_fromArray(
		[
			_Utils_Tuple2('0BSD', 'BSD Zero Clause License'),
			_Utils_Tuple2('AAL', 'Attribution Assurance License'),
			_Utils_Tuple2('AFL-1.1', 'Academic Free License v1.1'),
			_Utils_Tuple2('AFL-1.2', 'Academic Free License v1.2'),
			_Utils_Tuple2('AFL-2.0', 'Academic Free License v2.0'),
			_Utils_Tuple2('AFL-2.1', 'Academic Free License v2.1'),
			_Utils_Tuple2('AFL-3.0', 'Academic Free License v3.0'),
			_Utils_Tuple2('AGPL-3.0', 'GNU Affero General Public License v3.0'),
			_Utils_Tuple2('Apache-1.1', 'Apache License 1.1'),
			_Utils_Tuple2('Apache-2.0', 'Apache License 2.0'),
			_Utils_Tuple2('APL-1.0', 'Adaptive Public License 1.0'),
			_Utils_Tuple2('APSL-1.0', 'Apple Public Source License 1.0'),
			_Utils_Tuple2('APSL-1.1', 'Apple Public Source License 1.1'),
			_Utils_Tuple2('APSL-1.2', 'Apple Public Source License 1.2'),
			_Utils_Tuple2('APSL-2.0', 'Apple Public Source License 2.0'),
			_Utils_Tuple2('Artistic-1.0', 'Artistic License 1.0'),
			_Utils_Tuple2('Artistic-1.0-cl8', 'Artistic License 1.0 w/clause 8'),
			_Utils_Tuple2('Artistic-1.0-Perl', 'Artistic License 1.0 (Perl)'),
			_Utils_Tuple2('Artistic-2.0', 'Artistic License 2.0'),
			_Utils_Tuple2('BSD-2-Clause', 'BSD 2-clause \"Simplified\" License'),
			_Utils_Tuple2('BSD-3-Clause', 'BSD 3-clause \"New\" or \"Revised\" License'),
			_Utils_Tuple2('BSL-1.0', 'Boost Software License 1.0'),
			_Utils_Tuple2('CATOSL-1.1', 'Computer Associates Trusted Open Source License 1.1'),
			_Utils_Tuple2('CDDL-1.0', 'Common Development and Distribution License 1.0'),
			_Utils_Tuple2('CECILL-2.1', 'CeCILL Free Software License Agreement v2.1'),
			_Utils_Tuple2('CNRI-Python', 'CNRI Python License'),
			_Utils_Tuple2('CPAL-1.0', 'Common Public Attribution License 1.0'),
			_Utils_Tuple2('CPL-1.0', 'Common Public License 1.0'),
			_Utils_Tuple2('CUA-OPL-1.0', 'CUA Office Public License v1.0'),
			_Utils_Tuple2('ECL-1.0', 'Educational Community License v1.0'),
			_Utils_Tuple2('ECL-2.0', 'Educational Community License v2.0'),
			_Utils_Tuple2('EFL-1.0', 'Eiffel Forum License v1.0'),
			_Utils_Tuple2('EFL-2.0', 'Eiffel Forum License v2.0'),
			_Utils_Tuple2('Entessa', 'Entessa Public License v1.0'),
			_Utils_Tuple2('EPL-1.0', 'Eclipse Public License 1.0'),
			_Utils_Tuple2('EUDatagrid', 'EU DataGrid Software License'),
			_Utils_Tuple2('EUPL-1.1', 'European Union Public License 1.1'),
			_Utils_Tuple2('Fair', 'Fair License'),
			_Utils_Tuple2('Frameworx-1.0', 'Frameworx Open License 1.0'),
			_Utils_Tuple2('GPL-2.0', 'GNU General Public License v2.0 only'),
			_Utils_Tuple2('GPL-3.0', 'GNU General Public License v3.0 only'),
			_Utils_Tuple2('HPND', 'Historic Permission Notice and Disclaimer'),
			_Utils_Tuple2('Intel', 'Intel Open Source License'),
			_Utils_Tuple2('IPA', 'IPA Font License'),
			_Utils_Tuple2('IPL-1.0', 'IBM Public License v1.0'),
			_Utils_Tuple2('ISC', 'ISC License'),
			_Utils_Tuple2('LGPL-2.0', 'GNU Library General Public License v2 only'),
			_Utils_Tuple2('LGPL-2.1', 'GNU Lesser General Public License v2.1 only'),
			_Utils_Tuple2('LGPL-3.0', 'GNU Lesser General Public License v3.0 only'),
			_Utils_Tuple2('LiLiQ-P-1.1', 'Licence Libre du Qubec  Permissive version 1.1'),
			_Utils_Tuple2('LiLiQ-R-1.1', 'Licence Libre du Qubec  Rciprocit version 1.1'),
			_Utils_Tuple2('LiLiQ-Rplus-1.1', 'Licence Libre du Qubec  Rciprocit forte version 1.1'),
			_Utils_Tuple2('LPL-1.0', 'Lucent Public License Version 1.0'),
			_Utils_Tuple2('LPL-1.02', 'Lucent Public License v1.02'),
			_Utils_Tuple2('LPPL-1.3c', 'LaTeX Project Public License v1.3c'),
			_Utils_Tuple2('MirOS', 'MirOS Licence'),
			_Utils_Tuple2('MIT', 'MIT License'),
			_Utils_Tuple2('Motosoto', 'Motosoto License'),
			_Utils_Tuple2('MPL-1.0', 'Mozilla Public License 1.0'),
			_Utils_Tuple2('MPL-1.1', 'Mozilla Public License 1.1'),
			_Utils_Tuple2('MPL-2.0', 'Mozilla Public License 2.0'),
			_Utils_Tuple2('MPL-2.0-no-copyleft-exception', 'Mozilla Public License 2.0 (no copyleft exception)'),
			_Utils_Tuple2('MS-PL', 'Microsoft Public License'),
			_Utils_Tuple2('MS-RL', 'Microsoft Reciprocal License'),
			_Utils_Tuple2('Multics', 'Multics License'),
			_Utils_Tuple2('NASA-1.3', 'NASA Open Source Agreement 1.3'),
			_Utils_Tuple2('Naumen', 'Naumen Public License'),
			_Utils_Tuple2('NCSA', 'University of Illinois/NCSA Open Source License'),
			_Utils_Tuple2('NGPL', 'Nethack General Public License'),
			_Utils_Tuple2('Nokia', 'Nokia Open Source License'),
			_Utils_Tuple2('NPOSL-3.0', 'Non-Profit Open Software License 3.0'),
			_Utils_Tuple2('NTP', 'NTP License'),
			_Utils_Tuple2('OCLC-2.0', 'OCLC Research Public License 2.0'),
			_Utils_Tuple2('OFL-1.1', 'SIL Open Font License 1.1'),
			_Utils_Tuple2('OGTSL', 'Open Group Test Suite License'),
			_Utils_Tuple2('OSET-PL-2.1', 'OSET Public License version 2.1'),
			_Utils_Tuple2('OSL-1.0', 'Open Software License 1.0'),
			_Utils_Tuple2('OSL-2.0', 'Open Software License 2.0'),
			_Utils_Tuple2('OSL-2.1', 'Open Software License 2.1'),
			_Utils_Tuple2('OSL-3.0', 'Open Software License 3.0'),
			_Utils_Tuple2('PHP-3.0', 'PHP License v3.0'),
			_Utils_Tuple2('PostgreSQL', 'PostgreSQL License'),
			_Utils_Tuple2('Python-2.0', 'Python License 2.0'),
			_Utils_Tuple2('QPL-1.0', 'Q Public License 1.0'),
			_Utils_Tuple2('RPL-1.1', 'Reciprocal Public License 1.1'),
			_Utils_Tuple2('RPL-1.5', 'Reciprocal Public License 1.5'),
			_Utils_Tuple2('RPSL-1.0', 'RealNetworks Public Source License v1.0'),
			_Utils_Tuple2('RSCPL', 'Ricoh Source Code Public License'),
			_Utils_Tuple2('SimPL-2.0', 'Simple Public License 2.0'),
			_Utils_Tuple2('SISSL', 'Sun Industry Standards Source License v1.1'),
			_Utils_Tuple2('Sleepycat', 'Sleepycat License'),
			_Utils_Tuple2('SPL-1.0', 'Sun Public License v1.0'),
			_Utils_Tuple2('UPL-1.0', 'Universal Permissive License v1.0'),
			_Utils_Tuple2('VSL-1.0', 'Vovida Software License v1.0'),
			_Utils_Tuple2('W3C', 'W3C Software Notice and License (2002-12-31)'),
			_Utils_Tuple2('Watcom-1.0', 'Sybase Open Watcom Public License 1.0'),
			_Utils_Tuple2('Xnet', 'X.Net License'),
			_Utils_Tuple2('Zlib', 'zlib License'),
			_Utils_Tuple2('ZPL-2.0', 'Zope Public License 2.0')
		]));
var $dasch$levenshtein$Table$Table = F2(
	function (a, b) {
		return {$: 'Table', a: a, b: b};
	});
var $elm$core$Array$repeat = F2(
	function (n, e) {
		return A2(
			$elm$core$Array$initialize,
			n,
			function (_v0) {
				return e;
			});
	});
var $dasch$levenshtein$Table$empty = function (_v0) {
	var sizeA = _v0.a;
	var sizeB = _v0.b;
	var dimension = sizeB + 1;
	var arraySize = ((sizeA + 1) * dimension) - 1;
	return A2(
		$dasch$levenshtein$Table$Table,
		dimension,
		A2($elm$core$Array$repeat, arraySize, -1));
};
var $elm$core$Bitwise$shiftRightZfBy = _Bitwise_shiftRightZfBy;
var $elm$core$Array$bitMask = 4294967295 >>> (32 - $elm$core$Array$shiftStep);
var $elm$core$Elm$JsArray$unsafeGet = _JsArray_unsafeGet;
var $elm$core$Array$getHelp = F3(
	function (shift, index, tree) {
		getHelp:
		while (true) {
			var pos = $elm$core$Array$bitMask & (index >>> shift);
			var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
			if (_v0.$ === 'SubTree') {
				var subTree = _v0.a;
				var $temp$shift = shift - $elm$core$Array$shiftStep,
					$temp$index = index,
					$temp$tree = subTree;
				shift = $temp$shift;
				index = $temp$index;
				tree = $temp$tree;
				continue getHelp;
			} else {
				var values = _v0.a;
				return A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, values);
			}
		}
	});
var $elm$core$Bitwise$shiftLeftBy = _Bitwise_shiftLeftBy;
var $elm$core$Array$tailIndex = function (len) {
	return (len >>> 5) << 5;
};
var $elm$core$Array$get = F2(
	function (index, _v0) {
		var len = _v0.a;
		var startShift = _v0.b;
		var tree = _v0.c;
		var tail = _v0.d;
		return ((index < 0) || (_Utils_cmp(index, len) > -1)) ? $elm$core$Maybe$Nothing : ((_Utils_cmp(
			index,
			$elm$core$Array$tailIndex(len)) > -1) ? $elm$core$Maybe$Just(
			A2($elm$core$Elm$JsArray$unsafeGet, $elm$core$Array$bitMask & index, tail)) : $elm$core$Maybe$Just(
			A3($elm$core$Array$getHelp, startShift, index, tree)));
	});
var $elm$core$Elm$JsArray$unsafeSet = _JsArray_unsafeSet;
var $elm$core$Array$setHelp = F4(
	function (shift, index, value, tree) {
		var pos = $elm$core$Array$bitMask & (index >>> shift);
		var _v0 = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
		if (_v0.$ === 'SubTree') {
			var subTree = _v0.a;
			var newSub = A4($elm$core$Array$setHelp, shift - $elm$core$Array$shiftStep, index, value, subTree);
			return A3(
				$elm$core$Elm$JsArray$unsafeSet,
				pos,
				$elm$core$Array$SubTree(newSub),
				tree);
		} else {
			var values = _v0.a;
			var newLeaf = A3($elm$core$Elm$JsArray$unsafeSet, $elm$core$Array$bitMask & index, value, values);
			return A3(
				$elm$core$Elm$JsArray$unsafeSet,
				pos,
				$elm$core$Array$Leaf(newLeaf),
				tree);
		}
	});
var $elm$core$Array$set = F3(
	function (index, value, array) {
		var len = array.a;
		var startShift = array.b;
		var tree = array.c;
		var tail = array.d;
		return ((index < 0) || (_Utils_cmp(index, len) > -1)) ? array : ((_Utils_cmp(
			index,
			$elm$core$Array$tailIndex(len)) > -1) ? A4(
			$elm$core$Array$Array_elm_builtin,
			len,
			startShift,
			tree,
			A3($elm$core$Elm$JsArray$unsafeSet, $elm$core$Array$bitMask & index, value, tail)) : A4(
			$elm$core$Array$Array_elm_builtin,
			len,
			startShift,
			A4($elm$core$Array$setHelp, startShift, index, value, tree),
			tail));
	});
var $dasch$levenshtein$Table$fetch = F3(
	function (key, builder, table) {
		var iKey = key.a;
		var jKey = key.b;
		var dimension = table.a;
		var distanceStore = table.b;
		var index = (iKey * dimension) + jKey;
		var _v0 = A2($elm$core$Array$get, index, distanceStore);
		if (_v0.$ === 'Just') {
			var editDistance = _v0.a;
			if (_Utils_eq(editDistance, -1)) {
				var _v1 = A2(builder, table, key);
				var _v2 = _v1.a;
				var newStore = _v2.b;
				var actualEditDistance = _v1.b;
				return _Utils_Tuple2(
					A2(
						$dasch$levenshtein$Table$Table,
						dimension,
						A3($elm$core$Array$set, index, actualEditDistance, newStore)),
					actualEditDistance);
			} else {
				return _Utils_Tuple2(table, editDistance);
			}
		} else {
			return _Utils_Tuple2(table, -1);
		}
	});
var $elm$core$Array$length = function (_v0) {
	var len = _v0.a;
	return len;
};
var $dasch$levenshtein$Levenshtein$distanceHelper = F2(
	function (arr1, arr2) {
		var indecesForLastChars = _Utils_Tuple2(
			$elm$core$Array$length(arr1),
			$elm$core$Array$length(arr2));
		var calculateEditDistanceForChars = F2(
			function (table, _v0) {
				var i = _v0.a;
				var j = _v0.b;
				var _v1 = _Utils_Tuple2(
					A2($elm$core$Array$get, i - 1, arr1),
					A2($elm$core$Array$get, j - 1, arr2));
				if ((_v1.a.$ === 'Just') && (_v1.b.$ === 'Just')) {
					var chr1 = _v1.a.a;
					var chr2 = _v1.b.a;
					var _v2 = A3(
						$dasch$levenshtein$Table$fetch,
						_Utils_Tuple2(i - 1, j),
						calculateEditDistanceForChars,
						table);
					var table1 = _v2.a;
					var dist1 = _v2.b;
					var _v3 = A3(
						$dasch$levenshtein$Table$fetch,
						_Utils_Tuple2(i, j - 1),
						calculateEditDistanceForChars,
						table1);
					var table2 = _v3.a;
					var dist2 = _v3.b;
					var _v4 = A3(
						$dasch$levenshtein$Table$fetch,
						_Utils_Tuple2(i - 1, j - 1),
						calculateEditDistanceForChars,
						table2);
					var table3 = _v4.a;
					var dist3 = _v4.b;
					return _Utils_Tuple2(
						table3,
						(_Utils_cmp(dist3, dist1) < 0) ? ((_Utils_cmp(dist3, dist2) < 0) ? ((!_Utils_eq(chr1, chr2)) ? (dist3 + 1) : dist3) : (dist2 + 1)) : ((_Utils_cmp(dist1, dist2) > 0) ? (dist2 + 1) : (dist1 + 1)));
				} else {
					return _Utils_Tuple2(
						table,
						A2($elm$core$Basics$max, i, j));
				}
			});
		return A2(
			calculateEditDistanceForChars,
			$dasch$levenshtein$Table$empty(indecesForLastChars),
			indecesForLastChars).b;
	});
var $elm$core$Array$fromListHelp = F3(
	function (list, nodeList, nodeListSize) {
		fromListHelp:
		while (true) {
			var _v0 = A2($elm$core$Elm$JsArray$initializeFromList, $elm$core$Array$branchFactor, list);
			var jsArray = _v0.a;
			var remainingItems = _v0.b;
			if (_Utils_cmp(
				$elm$core$Elm$JsArray$length(jsArray),
				$elm$core$Array$branchFactor) < 0) {
				return A2(
					$elm$core$Array$builderToArray,
					true,
					{nodeList: nodeList, nodeListSize: nodeListSize, tail: jsArray});
			} else {
				var $temp$list = remainingItems,
					$temp$nodeList = A2(
					$elm$core$List$cons,
					$elm$core$Array$Leaf(jsArray),
					nodeList),
					$temp$nodeListSize = nodeListSize + 1;
				list = $temp$list;
				nodeList = $temp$nodeList;
				nodeListSize = $temp$nodeListSize;
				continue fromListHelp;
			}
		}
	});
var $elm$core$Array$fromList = function (list) {
	if (!list.b) {
		return $elm$core$Array$empty;
	} else {
		return A3($elm$core$Array$fromListHelp, list, _List_Nil, 0);
	}
};
var $dasch$levenshtein$Levenshtein$distance = F2(
	function (str1, str2) {
		return _Utils_eq(str1, str2) ? 0 : A2(
			$dasch$levenshtein$Levenshtein$distanceHelper,
			$elm$core$Array$fromList(
				$elm$core$String$toList(str1)),
			$elm$core$Array$fromList(
				$elm$core$String$toList(str2)));
	});
var $author$project$Compiler$Reporting$Suggest$distance = F2(
	function (x, y) {
		return A2($dasch$levenshtein$Levenshtein$distance, x, y);
	});
var $elm$core$String$toLower = _String_toLower;
var $author$project$Compiler$Reporting$Suggest$sort = F3(
	function (target, toString, values) {
		return A2(
			$author$project$Extra$Type$List$sortOn,
			A2(
				$elm$core$Basics$composeL,
				A2(
					$elm$core$Basics$composeL,
					$author$project$Compiler$Reporting$Suggest$distance(
						$elm$core$String$toLower(target)),
					$elm$core$String$toLower),
				toString),
			values);
	});
var $author$project$Compiler$Elm$Licenses$check = function (givenCode) {
	if (A2($author$project$Extra$Type$Map$member, givenCode, $author$project$Compiler$Elm$Licenses$osiApprovedSpdxLicenses)) {
		return $author$project$Extra$Type$Either$Right(
			$author$project$Compiler$Elm$Licenses$License(givenCode));
	} else {
		var pairs = _Utils_ap(
			A2(
				$author$project$Extra$Type$List$map,
				function (code) {
					return _Utils_Tuple2(
						code,
						$author$project$Compiler$Json$String$toChars(code));
				},
				$author$project$Extra$Type$Map$keys($author$project$Compiler$Elm$Licenses$osiApprovedSpdxLicenses)),
			$author$project$Extra$Type$Map$toList($author$project$Compiler$Elm$Licenses$osiApprovedSpdxLicenses));
		return $author$project$Extra$Type$Either$Left(
			A2(
				$author$project$Extra$Type$List$map,
				$elm$core$Tuple$first,
				A2(
					$author$project$Extra$Type$List$take,
					4,
					A3($author$project$Compiler$Reporting$Suggest$sort, givenCode, $elm$core$Tuple$second, pairs))));
	}
};
var $author$project$Compiler$Elm$Licenses$decoder = function (toError) {
	return A2(
		$author$project$Compiler$Json$Decode$bind,
		$author$project$Compiler$Json$Decode$string,
		function (str) {
			var _v0 = $author$project$Compiler$Elm$Licenses$check(str);
			if (_v0.$ === 'Right') {
				var license = _v0.a;
				return $author$project$Compiler$Json$Decode$return(license);
			} else {
				var suggestions = _v0.a;
				return $author$project$Compiler$Json$Decode$failure(
					toError(suggestions));
			}
		});
};
var $author$project$Builder$Elm$Outline$ExposedDict = function (a) {
	return {$: 'ExposedDict', a: a};
};
var $author$project$Builder$Elm$Outline$ExposedList = function (a) {
	return {$: 'ExposedList', a: a};
};
var $author$project$Builder$Reporting$Exit$OP_BadModuleHeaderTooLong = {$: 'OP_BadModuleHeaderTooLong'};
var $author$project$Compiler$Json$String$fromPtr = $author$project$Compiler$Data$Utf8$fromPtr;
var $author$project$Builder$Elm$Outline$boundParser = F2(
	function (bound, tooLong) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var len = end - pos;
				var newCol = col + len;
				return (_Utils_cmp(len, bound) < 0) ? A2(
					$author$project$Compiler$Parse$Primitives$Cok,
					A3($author$project$Compiler$Json$String$fromPtr, src, pos, end),
					A6($author$project$Compiler$Parse$Primitives$State, src, end, end, indent, row, newCol)) : A3(
					$author$project$Compiler$Parse$Primitives$Cerr,
					row,
					newCol,
					F2(
						function (_v1, _v2) {
							return tooLong;
						}));
			});
	});
var $author$project$Builder$Elm$Outline$headerKeyDecoder = A2(
	$author$project$Compiler$Json$Decode$KeyDecoder,
	A2($author$project$Builder$Elm$Outline$boundParser, 20, $author$project$Builder$Reporting$Exit$OP_BadModuleHeaderTooLong),
	F2(
		function (_v0, _v1) {
			return $author$project$Builder$Reporting$Exit$OP_BadModuleHeaderTooLong;
		}));
var $author$project$Builder$Reporting$Exit$OP_BadModuleName = F2(
	function (a, b) {
		return {$: 'OP_BadModuleName', a: a, b: b};
	});
var $author$project$Compiler$Elm$ModuleName$chompInner = F4(
	function (src, pos, end, col) {
		chompInner:
		while (true) {
			if (_Utils_cmp(pos, end) > -1) {
				return _Utils_Tuple3(true, pos, col);
			} else {
				var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
				var width = $author$project$Compiler$Parse$Variable$getInnerWidthHelp(word);
				if (!width) {
					return (word === 46) ? A4($author$project$Compiler$Elm$ModuleName$chompStart, src, pos + 1, end, col + 1) : _Utils_Tuple3(true, pos, col);
				} else {
					var $temp$src = src,
						$temp$pos = pos + width,
						$temp$end = end,
						$temp$col = col + 1;
					src = $temp$src;
					pos = $temp$pos;
					end = $temp$end;
					col = $temp$col;
					continue chompInner;
				}
			}
		}
	});
var $author$project$Compiler$Elm$ModuleName$chompStart = F4(
	function (src, pos, end, col) {
		var width = A3($author$project$Compiler$Parse$Variable$getUpperWidth, src, pos, end);
		return (!width) ? _Utils_Tuple3(false, pos, col) : A4($author$project$Compiler$Elm$ModuleName$chompInner, src, pos + width, end, col + 1);
	});
var $author$project$Compiler$Elm$ModuleName$parser = $author$project$Compiler$Parse$Primitives$Parser(
	function (_v0) {
		var src = _v0.a;
		var pos = _v0.b;
		var end = _v0.c;
		var indent = _v0.d;
		var row = _v0.e;
		var col = _v0.f;
		var _v1 = A4($author$project$Compiler$Elm$ModuleName$chompStart, src, pos, end, col);
		var isGood = _v1.a;
		var newPos = _v1.b;
		var newCol = _v1.c;
		if (isGood && ((newPos - pos) < 256)) {
			var newState = A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, row, newCol);
			return A2(
				$author$project$Compiler$Parse$Primitives$Cok,
				A3($author$project$Compiler$Data$Utf8$fromPtr, src, pos, newPos),
				newState);
		} else {
			if (_Utils_eq(col, newCol)) {
				return A3($author$project$Compiler$Parse$Primitives$Eerr, row, newCol, $elm$core$Tuple$pair);
			} else {
				return A3($author$project$Compiler$Parse$Primitives$Cerr, row, newCol, $elm$core$Tuple$pair);
			}
		}
	});
var $author$project$Compiler$Elm$ModuleName$decoder = A2($author$project$Compiler$Json$Decode$customString, $author$project$Compiler$Elm$ModuleName$parser, $elm$core$Tuple$pair);
var $author$project$Builder$Elm$Outline$moduleDecoder = A2(
	$author$project$Compiler$Json$Decode$mapError,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Builder$Reporting$Exit$OP_BadModuleName, a, b);
	},
	$author$project$Compiler$Elm$ModuleName$decoder);
var $author$project$Compiler$Json$Decode$oneOfError = F3(
	function (problems, prob, ps) {
		oneOfError:
		while (true) {
			if (!ps.b) {
				return A2($author$project$Compiler$Json$Decode$OneOf, prob, problems);
			} else {
				var p = ps.a;
				var ps_ = ps.b;
				var $temp$problems = A2($elm$core$List$cons, prob, problems),
					$temp$prob = p,
					$temp$ps = ps_;
				problems = $temp$problems;
				prob = $temp$prob;
				ps = $temp$ps;
				continue oneOfError;
			}
		}
	});
var $author$project$Compiler$Json$Decode$oneOfHelp = F4(
	function (ast, decoders, p, ps) {
		oneOfHelp:
		while (true) {
			if (decoders.b) {
				var decodeA = decoders.a.a;
				var decoders_ = decoders.b;
				var _v1 = decodeA(ast);
				if (_v1.$ === 'Derr') {
					var p_ = _v1.a;
					var $temp$ast = ast,
						$temp$decoders = decoders_,
						$temp$p = p_,
						$temp$ps = A2($elm$core$List$cons, p, ps);
					ast = $temp$ast;
					decoders = $temp$decoders;
					p = $temp$p;
					ps = $temp$ps;
					continue oneOfHelp;
				} else {
					var x = _v1;
					return x;
				}
			} else {
				return $author$project$Compiler$Json$Decode$Derr(
					A3($author$project$Compiler$Json$Decode$oneOfError, _List_Nil, p, ps));
			}
		}
	});
var $author$project$Compiler$Json$Decode$oneOf = function (decoders) {
	return $author$project$Compiler$Json$Decode$Decoder(
		function (ast) {
			if (decoders.b) {
				var decodeA = decoders.a.a;
				var decoders_ = decoders.b;
				var _v1 = decodeA(ast);
				if (_v1.$ === 'Derr') {
					var e = _v1.a;
					return A4($author$project$Compiler$Json$Decode$oneOfHelp, ast, decoders_, e, _List_Nil);
				} else {
					var x = _v1;
					return x;
				}
			} else {
				return _Debug_todo(
					'Compiler.Json.Decode',
					{
						start: {line: 311, column: 9},
						end: {line: 311, column: 19}
					})('Ran into (Json.Decode.oneOf [])');
			}
		});
};
var $author$project$Builder$Elm$Outline$exposedDecoder = $author$project$Compiler$Json$Decode$oneOf(
	_List_fromArray(
		[
			A2(
			$author$project$Compiler$Json$Decode$fmap,
			$author$project$Builder$Elm$Outline$ExposedList,
			$author$project$Compiler$Json$Decode$list($author$project$Builder$Elm$Outline$moduleDecoder)),
			A2(
			$author$project$Compiler$Json$Decode$fmap,
			$author$project$Builder$Elm$Outline$ExposedDict,
			A2(
				$author$project$Compiler$Json$Decode$pairs,
				$author$project$Builder$Elm$Outline$headerKeyDecoder,
				$author$project$Compiler$Json$Decode$list($author$project$Builder$Elm$Outline$moduleDecoder)))
		]));
var $author$project$Builder$Reporting$Exit$OP_BadPkgName = F2(
	function (a, b) {
		return {$: 'OP_BadPkgName', a: a, b: b};
	});
var $author$project$Compiler$Elm$Package$decoder = A2($author$project$Compiler$Json$Decode$customString, $author$project$Compiler$Elm$Package$parser, $elm$core$Tuple$pair);
var $author$project$Builder$Elm$Outline$nameDecoder = A2(
	$author$project$Compiler$Json$Decode$mapError,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Builder$Reporting$Exit$OP_BadPkgName, a, b);
	},
	$author$project$Compiler$Elm$Package$decoder);
var $author$project$Builder$Reporting$Exit$OP_BadSummaryTooLong = {$: 'OP_BadSummaryTooLong'};
var $author$project$Builder$Elm$Outline$summaryDecoder = A2(
	$author$project$Compiler$Json$Decode$customString,
	A2($author$project$Builder$Elm$Outline$boundParser, 80, $author$project$Builder$Reporting$Exit$OP_BadSummaryTooLong),
	F2(
		function (_v0, _v1) {
			return $author$project$Builder$Reporting$Exit$OP_BadSummaryTooLong;
		}));
var $author$project$Builder$Elm$Outline$pkgDecoder = A2(
	$author$project$Compiler$Json$Decode$andMap,
	A2($author$project$Compiler$Json$Decode$field, 'elm-version', $author$project$Builder$Elm$Outline$constraintDecoder),
	A2(
		$author$project$Compiler$Json$Decode$andMap,
		A2(
			$author$project$Compiler$Json$Decode$field,
			'test-dependencies',
			$author$project$Builder$Elm$Outline$depsDecoder($author$project$Builder$Elm$Outline$constraintDecoder)),
		A2(
			$author$project$Compiler$Json$Decode$andMap,
			A2(
				$author$project$Compiler$Json$Decode$field,
				'dependencies',
				$author$project$Builder$Elm$Outline$depsDecoder($author$project$Builder$Elm$Outline$constraintDecoder)),
			A2(
				$author$project$Compiler$Json$Decode$andMap,
				A2($author$project$Compiler$Json$Decode$field, 'exposed-modules', $author$project$Builder$Elm$Outline$exposedDecoder),
				A2(
					$author$project$Compiler$Json$Decode$andMap,
					A2($author$project$Compiler$Json$Decode$field, 'version', $author$project$Builder$Elm$Outline$versionDecoder),
					A2(
						$author$project$Compiler$Json$Decode$andMap,
						A2(
							$author$project$Compiler$Json$Decode$field,
							'license',
							$author$project$Compiler$Elm$Licenses$decoder($author$project$Builder$Reporting$Exit$OP_BadLicense)),
						A2(
							$author$project$Compiler$Json$Decode$andMap,
							A2($author$project$Compiler$Json$Decode$field, 'summary', $author$project$Builder$Elm$Outline$summaryDecoder),
							A2(
								$author$project$Compiler$Json$Decode$andMap,
								A2($author$project$Compiler$Json$Decode$field, 'name', $author$project$Builder$Elm$Outline$nameDecoder),
								$author$project$Compiler$Json$Decode$pure($author$project$Builder$Elm$Outline$PkgOutline)))))))));
var $author$project$Builder$Elm$Outline$decoder = function () {
	var _package = $author$project$Compiler$Json$String$fromChars('package');
	var application = $author$project$Compiler$Json$String$fromChars('application');
	return A2(
		$author$project$Compiler$Json$Decode$bind,
		A2($author$project$Compiler$Json$Decode$field, 'type', $author$project$Compiler$Json$Decode$string),
		function (tipe) {
			return _Utils_eq(tipe, application) ? A2($author$project$Compiler$Json$Decode$fmap, $author$project$Builder$Elm$Outline$App, $author$project$Builder$Elm$Outline$appDecoder) : (_Utils_eq(tipe, _package) ? A2($author$project$Compiler$Json$Decode$fmap, $author$project$Builder$Elm$Outline$Pkg, $author$project$Builder$Elm$Outline$pkgDecoder) : $author$project$Compiler$Json$Decode$failure($author$project$Builder$Reporting$Exit$OP_BadType));
		});
}();
var $author$project$Extra$Type$Map$fromListWith = F2(
	function (f, l) {
		return A3(
			$author$project$Extra$Type$List$foldl,
			F2(
				function (m, _v0) {
					var k = _v0.a;
					var a = _v0.b;
					return A4($author$project$Extra$Type$Map$insertWith, f, k, a, m);
				}),
			$author$project$Extra$Type$Map$empty,
			l);
	});
var $author$project$Builder$Elm$Outline$isDup = function (paths) {
	if (paths.$ === 'One') {
		return $elm$core$Maybe$Nothing;
	} else {
		var a = paths.a;
		var b = paths.b;
		return $elm$core$Maybe$Just(
			A2($author$project$Compiler$Data$OneOrMore$getFirstTwo, a, b));
	}
};
var $author$project$Extra$Type$Map$mapMaybe = F2(
	function (f, m) {
		return A2(
			$author$project$Extra$Type$Map$mapMaybeWithKey,
			function (_v0) {
				return f;
			},
			m);
	});
var $author$project$Builder$Elm$Outline$toAbsolute = F2(
	function (root, srcDir) {
		if (srcDir.$ === 'AbsoluteSrcDir') {
			var dir = srcDir.a;
			return dir;
		} else {
			var dir = srcDir.a;
			return A2($author$project$Extra$System$File$combine, root, dir);
		}
	});
var $author$project$Builder$Elm$Outline$toGiven = function (srcDir) {
	if (srcDir.$ === 'AbsoluteSrcDir') {
		var dir = srcDir.a;
		return dir;
	} else {
		var dir = srcDir.a;
		return dir;
	}
};
var $author$project$Builder$Elm$Outline$toPair = F2(
	function (root, srcDir) {
		return $author$project$Extra$System$IO$return(
			_Utils_Tuple2(
				$author$project$Extra$System$File$toString(
					A2($author$project$Builder$Elm$Outline$toAbsolute, root, srcDir)),
				$author$project$Compiler$Data$OneOrMore$one(
					$author$project$Builder$Elm$Outline$toGiven(srcDir))));
	});
var $author$project$Builder$Elm$Outline$detectDuplicates = F2(
	function (root, srcDirs) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A4(
				$author$project$Extra$Type$List$traverse,
				$author$project$Extra$System$IO$pure,
				$author$project$Extra$System$IO$liftA2,
				$author$project$Builder$Elm$Outline$toPair(root),
				srcDirs),
			function (pairs) {
				return $author$project$Extra$System$IO$return(
					$author$project$Extra$Type$Map$lookupMin(
						A2(
							$author$project$Extra$Type$Map$mapMaybe,
							$author$project$Builder$Elm$Outline$isDup,
							A2($author$project$Extra$Type$Map$fromListWith, $author$project$Compiler$Data$OneOrMore$more, pairs))));
			});
	});
var $author$project$Extra$System$File$doesDirectoryExist = function (filePath) {
	return A3(
		$author$project$Extra$System$File$walkFileSystem,
		false,
		filePath,
		F2(
			function (maybeNode, _v0) {
				return _Utils_Tuple2(
					$elm$core$Maybe$Nothing,
					function () {
						if (((maybeNode.$ === 'Just') && (maybeNode.a.c.$ === 'Just')) && (maybeNode.a.c.a.b.$ === 'DirectoryEntry')) {
							var _v2 = maybeNode.a;
							var _v3 = _v2.c.a;
							return true;
						} else {
							return false;
						}
					}());
			}));
};
var $author$project$Builder$Elm$Outline$isSrcDirMissing = F2(
	function (root, srcDir) {
		return A2(
			$author$project$Extra$System$IO$fmap,
			$elm$core$Basics$not,
			$author$project$Extra$System$File$doesDirectoryExist(
				A2($author$project$Builder$Elm$Outline$toAbsolute, root, srcDir)));
	});
var $author$project$Builder$Elm$Outline$read = function (root) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Builder$File$readUtf8(
			A2($author$project$Extra$System$File$addName, root, 'elm.json')),
		function (bytes) {
			var _v0 = A2($author$project$Compiler$Json$Decode$fromByteString, $author$project$Builder$Elm$Outline$decoder, bytes);
			if (_v0.$ === 'Left') {
				var err = _v0.a;
				return $author$project$Extra$System$IO$return(
					$author$project$Extra$Type$Either$Left(
						$author$project$Builder$Reporting$Exit$OutlineHasBadStructure(err)));
			} else {
				var outline = _v0.a;
				if (outline.$ === 'Pkg') {
					var _v2 = outline.a;
					var pkg = _v2.a;
					var deps = _v2.f;
					return $author$project$Extra$System$IO$return(
						((!A2(
							$author$project$Extra$Type$Map$member,
							$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$core),
							deps)) && (!_Utils_eq(pkg, $author$project$Compiler$Elm$Package$core))) ? $author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$OutlineNoPkgCore) : $author$project$Extra$Type$Either$Right(outline));
				} else {
					var _v3 = outline.a;
					var srcDirs = _v3.b;
					var direct = _v3.c;
					var indirect = _v3.d;
					return (!A2(
						$author$project$Extra$Type$Map$member,
						$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$core),
						direct)) ? $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$OutlineNoAppCore)) : (((!A2(
						$author$project$Extra$Type$Map$member,
						$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$json),
						direct)) && (!A2(
						$author$project$Extra$Type$Map$member,
						$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$json),
						indirect))) ? $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$OutlineNoAppJson)) : A2(
						$author$project$Extra$System$IO$bind,
						A4(
							$author$project$Extra$Type$List$filterM,
							$author$project$Extra$System$IO$pure,
							$author$project$Extra$System$IO$liftA2,
							$author$project$Builder$Elm$Outline$isSrcDirMissing(root),
							$author$project$Compiler$Data$NonEmptyList$toList(srcDirs)),
						function (badDirs) {
							var _v4 = A2($author$project$Extra$Type$List$map, $author$project$Builder$Elm$Outline$toGiven, badDirs);
							if (_v4.b) {
								var d = _v4.a;
								var ds = _v4.b;
								return $author$project$Extra$System$IO$return(
									$author$project$Extra$Type$Either$Left(
										A2($author$project$Builder$Reporting$Exit$OutlineHasMissingSrcDirs, d, ds)));
							} else {
								return A2(
									$author$project$Extra$System$IO$bind,
									A2(
										$author$project$Builder$Elm$Outline$detectDuplicates,
										root,
										$author$project$Compiler$Data$NonEmptyList$toList(srcDirs)),
									function (maybeDups) {
										if (maybeDups.$ === 'Nothing') {
											return $author$project$Extra$System$IO$return(
												$author$project$Extra$Type$Either$Right(outline));
										} else {
											var _v6 = maybeDups.a;
											var canonicalDir = _v6.a;
											var _v7 = _v6.b;
											var dir1 = _v7.a;
											var dir2 = _v7.b;
											return $author$project$Extra$System$IO$return(
												$author$project$Extra$Type$Either$Left(
													A3($author$project$Builder$Reporting$Exit$OutlineHasDuplicateSrcDirs, canonicalDir, dir1, dir2)));
										}
									});
							}
						}));
				}
			}
		});
};
var $author$project$Builder$Elm$Details$initEnv = function (root) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Builder$Deps$Solver$initEnv,
		function (maybeEnv) {
			return A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Builder$Elm$Outline$read(root),
				function (eitherOutline) {
					if (eitherOutline.$ === 'Left') {
						var problem = eitherOutline.a;
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Left(
								$author$project$Builder$Reporting$Exit$DetailsBadOutline(problem)));
					} else {
						var outline = eitherOutline.a;
						if (maybeEnv.$ === 'Left') {
							var problem = maybeEnv.a;
							return $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Left(
									$author$project$Builder$Reporting$Exit$DetailsCannotGetRegistry(problem)));
						} else {
							var _v2 = maybeEnv.a;
							var cache = _v2.a;
							var manager = _v2.b;
							var connection = _v2.c;
							var registry = _v2.d;
							return $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Right(
									_Utils_Tuple2(
										A5($author$project$Builder$Elm$Details$Env, root, cache, manager, connection, registry),
										outline)));
						}
					}
				});
		});
};
var $author$project$Builder$Reporting$Task$run = function (_v0) {
	var task = _v0.a;
	return A2(
		task,
		A2($elm$core$Basics$composeL, $author$project$Extra$System$IO$return, $author$project$Extra$Type$Either$Right),
		A2($elm$core$Basics$composeL, $author$project$Extra$System$IO$return, $author$project$Extra$Type$Either$Left));
};
var $author$project$Builder$Reporting$Exit$DetailsBadElmInAppOutline = function (a) {
	return {$: 'DetailsBadElmInAppOutline', a: a};
};
var $author$project$Builder$Reporting$Exit$DetailsHandEditedDependencies = {$: 'DetailsHandEditedDependencies'};
var $author$project$Builder$Reporting$Task$pure = function (a) {
	return $author$project$Builder$Reporting$Task$Task(
		F2(
			function (ok, _v0) {
				return ok(a);
			}));
};
var $author$project$Builder$Reporting$Task$return = $author$project$Builder$Reporting$Task$pure;
var $author$project$Builder$Reporting$Task$throw = function (x) {
	return $author$project$Builder$Reporting$Task$Task(
		F2(
			function (_v0, err) {
				return err(x);
			}));
};
var $author$project$Builder$Elm$Details$allowEqualDups = F3(
	function (_v0, v1, v2) {
		return _Utils_eq(v1, v2) ? $author$project$Builder$Reporting$Task$return(v1) : $author$project$Builder$Reporting$Task$throw($author$project$Builder$Reporting$Exit$DetailsHandEditedDependencies);
	});
var $author$project$Builder$Elm$Details$noDups = F3(
	function (_v0, _v1, _v2) {
		return $author$project$Builder$Reporting$Task$throw($author$project$Builder$Reporting$Exit$DetailsHandEditedDependencies);
	});
var $author$project$Builder$Reporting$Task$andMap = F2(
	function (_v0, _v1) {
		var taskArg = _v0.a;
		var taskFunc = _v1.a;
		return $author$project$Builder$Reporting$Task$Task(
			F2(
				function (ok, err) {
					var okFunc = function (func) {
						var okArg = function (arg) {
							return ok(
								func(arg));
						};
						return A2(taskArg, okArg, err);
					};
					return A2(taskFunc, okFunc, err);
				}));
	});
var $author$project$Builder$Reporting$Task$liftA2 = A2($author$project$Extra$Class$Applicative$liftA2, $author$project$Builder$Reporting$Task$fmap, $author$project$Builder$Reporting$Task$andMap);
var $author$project$Extra$Type$Map$preserveMissing = F3(
	function (pPure, _v0, a) {
		return pPure(
			$elm$core$Maybe$Just(a));
	});
var $author$project$Extra$Type$Map$zipWithAMatched = F5(
	function (pFmap, f, k, a, b) {
		return A2(
			pFmap,
			$elm$core$Maybe$Just,
			A3(f, k, a, b));
	});
var $author$project$Builder$Elm$Details$union = F3(
	function (tieBreaker, deps1, deps2) {
		return A7(
			$author$project$Extra$Type$Map$mergeA,
			$author$project$Builder$Reporting$Task$pure,
			$author$project$Builder$Reporting$Task$liftA2,
			$author$project$Extra$Type$Map$preserveMissing($author$project$Builder$Reporting$Task$pure),
			$author$project$Extra$Type$Map$preserveMissing($author$project$Builder$Reporting$Task$pure),
			A2($author$project$Extra$Type$Map$zipWithAMatched, $author$project$Builder$Reporting$Task$fmap, tieBreaker),
			deps1,
			deps2);
	});
var $author$project$Builder$Elm$Details$checkAppDeps = function (_v0) {
	var direct = _v0.c;
	var indirect = _v0.d;
	var testDirect = _v0.e;
	var testIndirect = _v0.f;
	return A2(
		$author$project$Builder$Reporting$Task$bind,
		A3($author$project$Builder$Elm$Details$union, $author$project$Builder$Elm$Details$allowEqualDups, indirect, testDirect),
		function (x) {
			return A2(
				$author$project$Builder$Reporting$Task$bind,
				A3($author$project$Builder$Elm$Details$union, $author$project$Builder$Elm$Details$noDups, direct, testIndirect),
				function (y) {
					return A3($author$project$Builder$Elm$Details$union, $author$project$Builder$Elm$Details$noDups, x, y);
				});
		});
};
var $author$project$Compiler$Elm$Constraint$exactly = function (version) {
	return A4($author$project$Compiler$Elm$Constraint$Range, version, $author$project$Compiler$Elm$Constraint$LessOrEqual, $author$project$Compiler$Elm$Constraint$LessOrEqual, version);
};
var $author$project$Builder$Reporting$Exit$DetailsNoOfflineSolution = {$: 'DetailsNoOfflineSolution'};
var $author$project$Builder$Reporting$Exit$DetailsNoSolution = {$: 'DetailsNoSolution'};
var $author$project$Builder$Reporting$Exit$DetailsSolverProblem = function (a) {
	return {$: 'DetailsSolverProblem', a: a};
};
var $author$project$Builder$Reporting$Task$io = function (work) {
	return $author$project$Builder$Reporting$Task$Task(
		F2(
			function (ok, _v0) {
				return A2($author$project$Extra$System$IO$bind, work, ok);
			}));
};
var $author$project$Builder$Deps$Solver$Err = function (a) {
	return {$: 'Err', a: a};
};
var $author$project$Builder$Deps$Solver$Ok = function (a) {
	return {$: 'Ok', a: a};
};
var $author$project$Builder$Deps$Solver$State = F4(
	function (a, b, c, d) {
		return {$: 'State', a: a, b: b, c: c, d: d};
	});
var $author$project$Builder$Deps$Solver$Details = F2(
	function (a, b) {
		return {$: 'Details', a: a, b: b};
	});
var $author$project$Builder$Deps$Solver$addDeps = F3(
	function (_v0, name, vsn) {
		var constraints = _v0.d;
		var _v1 = A2(
			$author$project$Extra$Type$Map$lookup,
			_Utils_Tuple2(
				name,
				$author$project$Compiler$Elm$Version$toComparable(vsn)),
			constraints);
		if (_v1.$ === 'Just') {
			var _v2 = _v1.a;
			var deps = _v2.b;
			return A2($author$project$Builder$Deps$Solver$Details, vsn, deps);
		} else {
			return _Debug_todo(
				'Builder.Deps.Solver',
				{
					start: {line: 114, column: 34},
					end: {line: 114, column: 44}
				})('compiler bug manifesting in Deps.Solver.addDeps');
		}
	});
var $author$project$Builder$Deps$Solver$NoOfflineSolution = {$: 'NoOfflineSolution'};
var $author$project$Builder$Deps$Solver$NoSolution = {$: 'NoSolution'};
var $author$project$Builder$Deps$Solver$noSolution = function (connection) {
	if (connection.$ === 'Online') {
		return $author$project$Builder$Deps$Solver$NoSolution;
	} else {
		return $author$project$Builder$Deps$Solver$NoOfflineSolution;
	}
};
var $author$project$Builder$Deps$Solver$Goals = F2(
	function (a, b) {
		return {$: 'Goals', a: a, b: b};
	});
var $author$project$Builder$Deps$Solver$Solver = function (a) {
	return {$: 'Solver', a: a};
};
var $author$project$Builder$Deps$Solver$backtrack = $author$project$Builder$Deps$Solver$Solver(
	F4(
		function (state, _v0, back, _v1) {
			return back(state);
		}));
var $author$project$Compiler$Elm$Constraint$intersect = F2(
	function (_v0, _v1) {
		var lo = _v0.a;
		var lop = _v0.b;
		var hop = _v0.c;
		var hi = _v0.d;
		var lo_ = _v1.a;
		var lop_ = _v1.b;
		var hop_ = _v1.c;
		var hi_ = _v1.d;
		var _v2 = function () {
			var _v3 = A2(
				$elm$core$Basics$compare,
				$author$project$Compiler$Elm$Version$toComparable(lo),
				$author$project$Compiler$Elm$Version$toComparable(lo_));
			switch (_v3.$) {
				case 'LT':
					return _Utils_Tuple2(lo_, lop_);
				case 'EQ':
					return _Utils_Tuple2(
						lo,
						A2(
							$author$project$Extra$Type$List$elem,
							$author$project$Compiler$Elm$Constraint$Less,
							_List_fromArray(
								[lop, lop_])) ? $author$project$Compiler$Elm$Constraint$Less : $author$project$Compiler$Elm$Constraint$LessOrEqual);
				default:
					return _Utils_Tuple2(lo, lop);
			}
		}();
		var newLo = _v2.a;
		var newLop = _v2.b;
		var _v4 = function () {
			var _v5 = A2(
				$elm$core$Basics$compare,
				$author$project$Compiler$Elm$Version$toComparable(hi),
				$author$project$Compiler$Elm$Version$toComparable(hi_));
			switch (_v5.$) {
				case 'LT':
					return _Utils_Tuple2(hi, hop);
				case 'EQ':
					return _Utils_Tuple2(
						hi,
						A2(
							$author$project$Extra$Type$List$elem,
							$author$project$Compiler$Elm$Constraint$Less,
							_List_fromArray(
								[hop, hop_])) ? $author$project$Compiler$Elm$Constraint$Less : $author$project$Compiler$Elm$Constraint$LessOrEqual);
				default:
					return _Utils_Tuple2(hi_, hop_);
			}
		}();
		var newHi = _v4.a;
		var newHop = _v4.b;
		return (_Utils_cmp(
			$author$project$Compiler$Elm$Version$toComparable(newLo),
			$author$project$Compiler$Elm$Version$toComparable(newHi)) < 1) ? $elm$core$Maybe$Just(
			A4($author$project$Compiler$Elm$Constraint$Range, newLo, newLop, newHop, newHi)) : $elm$core$Maybe$Nothing;
	});
var $author$project$Builder$Deps$Solver$return = function (a) {
	return $author$project$Builder$Deps$Solver$Solver(
		F4(
			function (state, ok, back, _v0) {
				return A3(ok, state, a, back);
			}));
};
var $author$project$Compiler$Elm$Constraint$isLess = function (op) {
	if (op.$ === 'Less') {
		return $elm$core$Basics$lt;
	} else {
		return $elm$core$Basics$le;
	}
};
var $author$project$Compiler$Elm$Constraint$satisfies = F2(
	function (constraint, version) {
		var lower = constraint.a;
		var lowerOp = constraint.b;
		var upperOp = constraint.c;
		var upper = constraint.d;
		return A3(
			$author$project$Compiler$Elm$Constraint$isLess,
			lowerOp,
			$author$project$Compiler$Elm$Version$toComparable(lower),
			$author$project$Compiler$Elm$Version$toComparable(version)) && A3(
			$author$project$Compiler$Elm$Constraint$isLess,
			upperOp,
			$author$project$Compiler$Elm$Version$toComparable(version),
			$author$project$Compiler$Elm$Version$toComparable(upper));
	});
var $author$project$Builder$Deps$Solver$addConstraint = F3(
	function (solved, unsolved, _v0) {
		var name = _v0.a;
		var newConstraint = _v0.b;
		var _v1 = A2($author$project$Extra$Type$Map$lookup, name, solved);
		if (_v1.$ === 'Just') {
			var version = _v1.a;
			return A2($author$project$Compiler$Elm$Constraint$satisfies, newConstraint, version) ? $author$project$Builder$Deps$Solver$return(unsolved) : $author$project$Builder$Deps$Solver$backtrack;
		} else {
			var _v2 = A2($author$project$Extra$Type$Map$lookup, name, unsolved);
			if (_v2.$ === 'Nothing') {
				return $author$project$Builder$Deps$Solver$return(
					A3($author$project$Extra$Type$Map$insert, name, newConstraint, unsolved));
			} else {
				var oldConstraint = _v2.a;
				var _v3 = A2($author$project$Compiler$Elm$Constraint$intersect, oldConstraint, newConstraint);
				if (_v3.$ === 'Nothing') {
					return $author$project$Builder$Deps$Solver$backtrack;
				} else {
					var mergedConstraint = _v3.a;
					return _Utils_eq(oldConstraint, mergedConstraint) ? $author$project$Builder$Deps$Solver$return(unsolved) : $author$project$Builder$Deps$Solver$return(
						A3($author$project$Extra$Type$Map$insert, name, mergedConstraint, unsolved));
				}
			}
		}
	});
var $author$project$Builder$Deps$Solver$bind = F2(
	function (_v0, callback) {
		var solverA = _v0.a;
		return $author$project$Builder$Deps$Solver$Solver(
			F4(
				function (state, ok, back, err) {
					var okA = F3(
						function (stateA, a, backA) {
							var _v1 = callback(a);
							var solverB = _v1.a;
							return A4(solverB, stateA, ok, backA, err);
						});
					return A4(solverA, state, okA, back, err);
				}));
	});
var $author$project$Builder$Reporting$Exit$SolverBadCacheData = F2(
	function (a, b) {
		return {$: 'SolverBadCacheData', a: a, b: b};
	});
var $author$project$Builder$Reporting$Exit$SolverBadHttp = F3(
	function (a, b, c) {
		return {$: 'SolverBadHttp', a: a, b: b, c: c};
	});
var $author$project$Builder$Reporting$Exit$SolverBadHttpData = F3(
	function (a, b, c) {
		return {$: 'SolverBadHttpData', a: a, b: b, c: c};
	});
var $author$project$Builder$Deps$Solver$Constraints = F2(
	function (a, b) {
		return {$: 'Constraints', a: a, b: b};
	});
var $author$project$Builder$Deps$Solver$constraintsDecoder = A2(
	$author$project$Compiler$Json$Decode$bind,
	A2(
		$author$project$Compiler$Json$Decode$mapError,
		$elm$core$Basics$always(_Utils_Tuple0),
		$author$project$Builder$Elm$Outline$decoder),
	function (outline) {
		if (outline.$ === 'Pkg') {
			var _v1 = outline.a;
			var deps = _v1.f;
			var elmConstraint = _v1.h;
			return $author$project$Compiler$Json$Decode$return(
				A2($author$project$Builder$Deps$Solver$Constraints, elmConstraint, deps));
		} else {
			return $author$project$Compiler$Json$Decode$failure(_Utils_Tuple0);
		}
	});
var $author$project$Builder$Http$get = $author$project$Builder$Http$fetch($author$project$Extra$System$Http$methodGet);
var $author$project$Compiler$Elm$Package$toUrl = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return author + ('/' + project);
};
var $author$project$Builder$Deps$Website$metadata = F3(
	function (name, version, file) {
		return $author$project$Builder$Deps$Website$domain + ('/packages/' + ($author$project$Compiler$Elm$Package$toUrl(name) + ('/' + ($author$project$Compiler$Elm$Version$toChars(version) + ('/' + file)))));
	});
var $author$project$Compiler$Elm$Package$toFilePath = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return A2(
		$author$project$Extra$System$File$addName,
		$author$project$Extra$System$File$fromString(author),
		project);
};
var $author$project$Builder$Stuff$package = F3(
	function (_v0, name, version) {
		var dir = _v0.a;
		return A2(
			$author$project$Extra$System$File$addName,
			A2(
				$author$project$Extra$System$File$combine,
				dir,
				$author$project$Compiler$Elm$Package$toFilePath(name)),
			$author$project$Compiler$Elm$Version$toChars(version));
	});
var $author$project$Extra$Type$Map$delete = $elm$core$Dict$remove;
var $author$project$Extra$System$File$removeFile = function (filePath) {
	return A3(
		$author$project$Extra$System$File$walkFileSystem,
		false,
		filePath,
		F2(
			function (maybeNode, _v0) {
				if (((maybeNode.$ === 'Just') && (maybeNode.a.c.$ === 'Just')) && (maybeNode.a.c.a.b.$ === 'FileEntry')) {
					var _v2 = maybeNode.a;
					var directory = _v2.a;
					var fileName = _v2.b;
					var _v3 = _v2.c.a;
					return _Utils_Tuple2(
						$elm$core$Maybe$Just(
							A2($author$project$Extra$Type$Map$delete, fileName, directory)),
						_Utils_Tuple0);
				} else {
					return _Utils_Tuple2($elm$core$Maybe$Nothing, _Utils_Tuple0);
				}
			}));
};
var $author$project$Builder$File$remove = function (path) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Extra$System$File$doesFileExist(path),
		function (exists_) {
			return exists_ ? $author$project$Extra$System$File$removeFile(path) : $author$project$Extra$System$IO$return(_Utils_Tuple0);
		});
};
var $author$project$Builder$File$writeUtf8 = F2(
	function (filePath, contents) {
		return A2(
			$author$project$Extra$System$File$writeFile,
			filePath,
			$elm$bytes$Bytes$Encode$encode(
				$elm$bytes$Bytes$Encode$string(contents)));
	});
var $author$project$Builder$Deps$Solver$getConstraints = F2(
	function (pkg, vsn) {
		return $author$project$Builder$Deps$Solver$Solver(
			F4(
				function (state, ok, back, err) {
					var cache = state.a;
					var connection = state.b;
					var registry = state.c;
					var cDict = state.d;
					var key = _Utils_Tuple2(
						$author$project$Compiler$Elm$Package$toComparable(pkg),
						$author$project$Compiler$Elm$Version$toComparable(vsn));
					var _v0 = A2($author$project$Extra$Type$Map$lookup, key, cDict);
					if (_v0.$ === 'Just') {
						var cs = _v0.a;
						return A3(ok, state, cs, back);
					} else {
						var toNewState = function (cs) {
							return A4(
								$author$project$Builder$Deps$Solver$State,
								cache,
								connection,
								registry,
								A3($author$project$Extra$Type$Map$insert, key, cs, cDict));
						};
						var home = A3($author$project$Builder$Stuff$package, cache, pkg, vsn);
						var path = A2($author$project$Extra$System$File$addName, home, 'elm.json');
						return A2(
							$author$project$Extra$System$IO$bind,
							$author$project$Builder$File$exists(path),
							function (outlineExists) {
								if (outlineExists) {
									return A2(
										$author$project$Extra$System$IO$bind,
										$author$project$Builder$File$readUtf8(path),
										function (bytes) {
											var _v1 = A2($author$project$Compiler$Json$Decode$fromByteString, $author$project$Builder$Deps$Solver$constraintsDecoder, bytes);
											if (_v1.$ === 'Right') {
												var cs = _v1.a;
												if (connection.$ === 'Online') {
													return A3(
														ok,
														toNewState(cs),
														cs,
														back);
												} else {
													return A2(
														$author$project$Extra$System$IO$bind,
														$author$project$Extra$System$File$doesDirectoryExist(
															A2(
																$author$project$Extra$System$File$addName,
																A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
																'src')),
														function (srcExists) {
															return srcExists ? A3(
																ok,
																toNewState(cs),
																cs,
																back) : back(state);
														});
												}
											} else {
												return A2(
													$author$project$Extra$System$IO$bind,
													$author$project$Builder$File$remove(path),
													function (_v3) {
														return err(
															A2($author$project$Builder$Reporting$Exit$SolverBadCacheData, pkg, vsn));
													});
											}
										});
								} else {
									if (connection.$ === 'Offline') {
										return back(state);
									} else {
										var manager = connection.a;
										var url = A3($author$project$Builder$Deps$Website$metadata, pkg, vsn, 'elm.json');
										return A2(
											$author$project$Extra$System$IO$bind,
											A5(
												$author$project$Builder$Http$get,
												manager,
												url,
												_List_Nil,
												$elm$core$Basics$identity,
												A2($elm$core$Basics$composeL, $author$project$Extra$System$IO$return, $author$project$Extra$Type$Either$Right)),
											function (result) {
												if (result.$ === 'Left') {
													var httpProblem = result.a;
													return err(
														A3($author$project$Builder$Reporting$Exit$SolverBadHttp, pkg, vsn, httpProblem));
												} else {
													var body = result.a;
													var _v6 = A2($author$project$Compiler$Json$Decode$fromByteString, $author$project$Builder$Deps$Solver$constraintsDecoder, body);
													if (_v6.$ === 'Right') {
														var cs = _v6.a;
														return A2(
															$author$project$Extra$System$IO$bind,
															A2($author$project$Extra$System$File$createDirectoryIfMissing, true, home),
															function (_v7) {
																return A2(
																	$author$project$Extra$System$IO$bind,
																	A2($author$project$Builder$File$writeUtf8, path, body),
																	function (_v8) {
																		return A3(
																			ok,
																			toNewState(cs),
																			cs,
																			back);
																	});
															});
													} else {
														return err(
															A3($author$project$Builder$Reporting$Exit$SolverBadHttpData, pkg, vsn, url));
													}
												}
											});
									}
								}
							});
					}
				}));
	});
var $author$project$Compiler$Elm$Constraint$goodElm = function (constraint) {
	return A2($author$project$Compiler$Elm$Constraint$satisfies, constraint, $author$project$Compiler$Elm$Version$compiler);
};
var $author$project$Builder$Deps$Solver$addVersion = F3(
	function (_v0, name, version) {
		var pending = _v0.a;
		var solved = _v0.b;
		return A2(
			$author$project$Builder$Deps$Solver$bind,
			A2(
				$author$project$Builder$Deps$Solver$getConstraints,
				$author$project$Compiler$Elm$Package$fromComparable(name),
				version),
			function (_v1) {
				var elm = _v1.a;
				var deps = _v1.b;
				return $author$project$Compiler$Elm$Constraint$goodElm(elm) ? A2(
					$author$project$Builder$Deps$Solver$bind,
					A5(
						$author$project$Extra$Type$List$foldlM,
						$author$project$Builder$Deps$Solver$return,
						$author$project$Builder$Deps$Solver$bind,
						$author$project$Builder$Deps$Solver$addConstraint(solved),
						pending,
						$author$project$Extra$Type$Map$toList(deps)),
					function (newPending) {
						return $author$project$Builder$Deps$Solver$return(
							A2(
								$author$project$Builder$Deps$Solver$Goals,
								newPending,
								A3($author$project$Extra$Type$Map$insert, name, version, solved)));
					}) : $author$project$Builder$Deps$Solver$backtrack;
			});
	});
var $author$project$Builder$Deps$Registry$getVersions = F2(
	function (name, _v0) {
		var versions = _v0.b;
		return A2($author$project$Extra$Type$Map$lookup, name, versions);
	});
var $author$project$Builder$Deps$Solver$getRelevantVersions = F2(
	function (name, constraint) {
		return $author$project$Builder$Deps$Solver$Solver(
			F4(
				function (state, ok, back, _v0) {
					var registry = state.c;
					var _v1 = A2($author$project$Builder$Deps$Registry$getVersions, name, registry);
					if (_v1.$ === 'Just') {
						var _v2 = _v1.a;
						var newest = _v2.a;
						var previous = _v2.b;
						var _v3 = A2(
							$author$project$Extra$Type$List$filter,
							$author$project$Compiler$Elm$Constraint$satisfies(constraint),
							A2($elm$core$List$cons, newest, previous));
						if (!_v3.b) {
							return back(state);
						} else {
							var v = _v3.a;
							var vs = _v3.b;
							return A3(
								ok,
								state,
								_Utils_Tuple2(v, vs),
								back);
						}
					} else {
						return back(state);
					}
				}));
	});
var $author$project$Extra$Type$Map$minViewWithKey = function (m) {
	return A2(
		$elm$core$Maybe$map,
		function (_v0) {
			var k = _v0.a;
			var a = _v0.b;
			return _Utils_Tuple2(
				_Utils_Tuple2(k, a),
				A2($elm$core$Dict$remove, k, m));
		},
		$author$project$Extra$Type$Map$lookupMin(m));
};
var $author$project$Builder$Deps$Solver$oneOf = F2(
	function (solver, solvers) {
		var solverHead = solver.a;
		if (!solvers.b) {
			return solver;
		} else {
			var s = solvers.a;
			var ss = solvers.b;
			return $author$project$Builder$Deps$Solver$Solver(
				F4(
					function (state0, ok, back, err) {
						var tryTail = function (state1) {
							var _v1 = A2($author$project$Builder$Deps$Solver$oneOf, s, ss);
							var solverTail = _v1.a;
							return A4(solverTail, state1, ok, back, err);
						};
						return A4(solverHead, state0, ok, tryTail, err);
					}));
		}
	});
var $author$project$Builder$Deps$Solver$exploreGoals = function (_v0) {
	var pending = _v0.a;
	var solved = _v0.b;
	var _v1 = $author$project$Extra$Type$Map$minViewWithKey(pending);
	if (_v1.$ === 'Nothing') {
		return $author$project$Builder$Deps$Solver$return(solved);
	} else {
		var _v2 = _v1.a;
		var _v3 = _v2.a;
		var name = _v3.a;
		var constraint = _v3.b;
		var otherPending = _v2.b;
		var goals1 = A2($author$project$Builder$Deps$Solver$Goals, otherPending, solved);
		var addVsn = A2($author$project$Builder$Deps$Solver$addVersion, goals1, name);
		return A2(
			$author$project$Builder$Deps$Solver$bind,
			A2($author$project$Builder$Deps$Solver$getRelevantVersions, name, constraint),
			function (_v4) {
				var v = _v4.a;
				var vs = _v4.b;
				return A2(
					$author$project$Builder$Deps$Solver$bind,
					A2(
						$author$project$Builder$Deps$Solver$oneOf,
						addVsn(v),
						A2($author$project$Extra$Type$List$map, addVsn, vs)),
					function (goals2) {
						return $author$project$Builder$Deps$Solver$exploreGoals(goals2);
					});
			});
	}
};
var $author$project$Builder$Deps$Solver$try = function (constraints) {
	return $author$project$Builder$Deps$Solver$exploreGoals(
		A2($author$project$Builder$Deps$Solver$Goals, constraints, $author$project$Extra$Type$Map$empty));
};
var $author$project$Builder$Deps$Solver$verify = F4(
	function (cache, connection, registry, constraints) {
		var _v0 = $author$project$Builder$Deps$Solver$try(constraints);
		var solver = _v0.a;
		return A4(
			solver,
			A4($author$project$Builder$Deps$Solver$State, cache, connection, registry, $author$project$Extra$Type$Map$empty),
			F3(
				function (s, a, _v1) {
					return $author$project$Extra$System$IO$return(
						$author$project$Builder$Deps$Solver$Ok(
							A2(
								$author$project$Extra$Type$Map$mapWithKey,
								$author$project$Builder$Deps$Solver$addDeps(s),
								a)));
				}),
			function (_v2) {
				return $author$project$Extra$System$IO$return(
					$author$project$Builder$Deps$Solver$noSolution(connection));
			},
			function (e) {
				return $author$project$Extra$System$IO$return(
					$author$project$Builder$Deps$Solver$Err(e));
			});
	});
var $author$project$Builder$Elm$Details$verifyConstraints = F2(
	function (_v0, constraints) {
		var cache = _v0.b;
		var connection = _v0.d;
		var registry = _v0.e;
		return A2(
			$author$project$Builder$Reporting$Task$bind,
			$author$project$Builder$Reporting$Task$io(
				A4($author$project$Builder$Deps$Solver$verify, cache, connection, registry, constraints)),
			function (result) {
				switch (result.$) {
					case 'Ok':
						var details = result.a;
						return $author$project$Builder$Reporting$Task$return(details);
					case 'NoSolution':
						return $author$project$Builder$Reporting$Task$throw($author$project$Builder$Reporting$Exit$DetailsNoSolution);
					case 'NoOfflineSolution':
						return $author$project$Builder$Reporting$Task$throw($author$project$Builder$Reporting$Exit$DetailsNoOfflineSolution);
					default:
						var exit = result.a;
						return $author$project$Builder$Reporting$Task$throw(
							$author$project$Builder$Reporting$Exit$DetailsSolverProblem(exit));
				}
			});
	});
var $author$project$Builder$Elm$Details$ArtifactsFresh = F2(
	function (a, b) {
		return {$: 'ArtifactsFresh', a: a, b: b};
	});
var $author$project$Builder$Reporting$Exit$DetailsBadDeps = F2(
	function (a, b) {
		return {$: 'DetailsBadDeps', a: a, b: b};
	});
var $author$project$Extra$Type$Map$mapKeys = F2(
	function (f, m) {
		return A3(
			$author$project$Extra$Type$Map$foldlWithKey,
			F3(
				function (acc, k, a) {
					return A3(
						$author$project$Extra$Type$Map$insert,
						f(k),
						a,
						acc);
				}),
			$author$project$Extra$Type$Map$empty,
			m);
	});
var $author$project$Compiler$Elm$Interface$extractAlias = function (iAlias) {
	if (iAlias.$ === 'PublicAlias') {
		var alias = iAlias.a;
		return alias;
	} else {
		var alias = iAlias.a;
		return alias;
	}
};
var $author$project$Compiler$Elm$Interface$extractUnion = function (iUnion) {
	switch (iUnion.$) {
		case 'OpenUnion':
			var union = iUnion.a;
			return union;
		case 'ClosedUnion':
			var union = iUnion.a;
			return union;
		default:
			var union = iUnion.a;
			return union;
	}
};
var $author$project$Compiler$Elm$Interface$private = function (_v0) {
	var pkg = _v0.a;
	var unions = _v0.c;
	var aliases = _v0.d;
	return A3(
		$author$project$Compiler$Elm$Interface$Private,
		pkg,
		A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Elm$Interface$extractUnion, unions),
		A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Elm$Interface$extractAlias, aliases));
};
var $author$project$Compiler$Elm$Interface$privatize = function (di) {
	if (di.$ === 'Public') {
		var i = di.a;
		return $author$project$Compiler$Elm$Interface$private(i);
	} else {
		return di;
	}
};
var $author$project$Builder$Elm$Details$addInterfaces = F4(
	function (directDeps, pkg, _v0, dependencyInterfaces) {
		var ifaces = _v0.a;
		return A2(
			$author$project$Extra$Type$Map$union,
			dependencyInterfaces,
			A2(
				$author$project$Extra$Type$Map$mapKeys,
				A2(
					$elm$core$Basics$composeL,
					$author$project$Compiler$Elm$ModuleName$toComparable,
					$author$project$Compiler$Elm$ModuleName$Canonical(
						$author$project$Compiler$Elm$Package$fromComparable(pkg))),
				A2($author$project$Extra$Type$Map$member, pkg, directDeps) ? ifaces : A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Elm$Interface$privatize, ifaces)));
	});
var $author$project$Compiler$AST$Optimized$GlobalGraph = F2(
	function (a, b) {
		return {$: 'GlobalGraph', a: a, b: b};
	});
var $author$project$Compiler$AST$Optimized$addGlobalGraph = F2(
	function (_v0, _v1) {
		var nodes1 = _v0.a;
		var fields1 = _v0.b;
		var nodes2 = _v1.a;
		var fields2 = _v1.b;
		return A2(
			$author$project$Compiler$AST$Optimized$GlobalGraph,
			A2($author$project$Extra$Type$Map$union, nodes1, nodes2),
			A2($author$project$Extra$Type$Map$union, fields1, fields2));
	});
var $author$project$Builder$Elm$Details$addObjects = F2(
	function (_v0, graph) {
		var objs = _v0.b;
		return A2($author$project$Compiler$AST$Optimized$addGlobalGraph, objs, graph);
	});
var $author$project$Compiler$AST$Optimized$bGlobalGraph = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Compiler$AST$Optimized$GlobalGraph,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$AST$Optimized$bGlobalComparable, $author$project$Compiler$AST$Optimized$bNode),
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Data$Name$bName, $author$project$Extra$Data$Binary$bWord64));
var $author$project$Compiler$Data$OneOrMore$destructRight = F2(
	function (oneOrMore, xs) {
		destructRight:
		while (true) {
			if (oneOrMore.$ === 'One') {
				var x = oneOrMore.a;
				return A2($elm$core$List$cons, x, xs);
			} else {
				var a = oneOrMore.a;
				var b = oneOrMore.b;
				var $temp$oneOrMore = a,
					$temp$xs = A2($author$project$Compiler$Data$OneOrMore$destructRight, b, xs);
				oneOrMore = $temp$oneOrMore;
				xs = $temp$xs;
				continue destructRight;
			}
		}
	});
var $author$project$Compiler$Data$OneOrMore$destructLeft = F3(
	function (func, oneOrMore, xs) {
		destructLeft:
		while (true) {
			if (oneOrMore.$ === 'One') {
				var x = oneOrMore.a;
				return A2(func, x, xs);
			} else {
				var a = oneOrMore.a;
				var b = oneOrMore.b;
				var $temp$func = func,
					$temp$oneOrMore = a,
					$temp$xs = A2($author$project$Compiler$Data$OneOrMore$destructRight, b, xs);
				func = $temp$func;
				oneOrMore = $temp$oneOrMore;
				xs = $temp$xs;
				continue destructLeft;
			}
		}
	});
var $author$project$Compiler$Data$OneOrMore$destruct = F2(
	function (func, oneOrMore) {
		return A3($author$project$Compiler$Data$OneOrMore$destructLeft, func, oneOrMore, _List_Nil);
	});
var $author$project$Compiler$AST$Optimized$empty = A2($author$project$Compiler$AST$Optimized$GlobalGraph, $author$project$Extra$Type$Map$empty, $author$project$Extra$Type$Map$empty);
var $author$project$Builder$Elm$Details$gatherForeigns = F3(
	function (pkg, _v0, foreigns) {
		var ifaces = _v0.a;
		var isPublic = function (di) {
			if (di.$ === 'Public') {
				return $elm$core$Maybe$Just(
					$author$project$Compiler$Data$OneOrMore$one(
						$author$project$Compiler$Elm$Package$fromComparable(pkg)));
			} else {
				return $elm$core$Maybe$Nothing;
			}
		};
		return A3(
			$author$project$Extra$Type$Map$unionWith,
			$author$project$Compiler$Data$OneOrMore$more,
			foreigns,
			A2($author$project$Extra$Type$Map$mapMaybe, isPublic, ifaces));
	});
var $author$project$Extra$Type$Either$lefts = function (eithers) {
	return A3(
		$author$project$Extra$Type$List$foldr,
		F2(
			function (either, acc) {
				if (either.$ === 'Left') {
					var x = either.a;
					return A2($elm$core$List$cons, x, acc);
				} else {
					return acc;
				}
			}),
		_List_Nil,
		eithers);
};
var $author$project$Builder$Elm$Details$lensMVDep = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.a;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var bi = _v3.b;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, x, bi, ci, di, ei, fi, gi, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Elm$Details$lensMVDepMap = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.b;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, x, ci, di, ei, fi, gi, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Stuff$objects = function (root) {
	return A2(
		$author$project$Extra$System$File$addName,
		$author$project$Builder$Stuff$stuff(root),
		'o.dat');
};
var $author$project$Extra$Type$Map$sequenceA = F2(
	function (pPure, pLiftA2) {
		return $author$project$Extra$Class$Traversable$sequenceA(
			A2($author$project$Extra$Type$Map$traverse, pPure, pLiftA2));
	});
var $author$project$Builder$Reporting$Exit$BD_BadDownload = F3(
	function (a, b, c) {
		return {$: 'BD_BadDownload', a: a, b: b, c: c};
	});
var $author$project$Builder$Elm$Details$ArtifactCache = F2(
	function (a, b) {
		return {$: 'ArtifactCache', a: a, b: b};
	});
var $author$project$Builder$Elm$Details$Artifacts = F2(
	function (a, b) {
		return {$: 'Artifacts', a: a, b: b};
	});
var $author$project$Builder$Elm$Details$bArtifacts = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Builder$Elm$Details$Artifacts,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	A2($author$project$Extra$Data$Binary$bMap, $author$project$Compiler$Elm$ModuleName$bRaw, $author$project$Compiler$Elm$Interface$bDependencyInterface),
	$author$project$Compiler$AST$Optimized$bGlobalGraph);
var $author$project$Compiler$Elm$Version$fromComparable = function (_v0) {
	var major = _v0.a;
	var minor = _v0.b;
	var patch = _v0.c;
	return A3($author$project$Compiler$Elm$Version$Version, major, minor, patch);
};
var $author$project$Compiler$Elm$Version$bComparable = A3($author$project$Extra$Data$Binary$iso, $author$project$Compiler$Elm$Version$toComparable, $author$project$Compiler$Elm$Version$fromComparable, $author$project$Compiler$Elm$Version$bVersion);
var $author$project$Builder$Elm$Details$bFingerprintComparable = $author$project$Extra$Data$Binary$bTList(
	A2($author$project$Extra$Data$Binary$bTuple, $author$project$Compiler$Elm$Package$bComparable, $author$project$Compiler$Elm$Version$bComparable));
var $author$project$Builder$Elm$Details$bArtifactCache = A4(
	$author$project$Extra$Data$Binary$bin2,
	$author$project$Builder$Elm$Details$ArtifactCache,
	function (_v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A2($author$project$Extra$Data$Binary$T2, a, b);
	},
	$author$project$Extra$Data$Binary$bSet($author$project$Builder$Elm$Details$bFingerprintComparable),
	$author$project$Builder$Elm$Details$bArtifacts);
var $author$project$Builder$Reporting$Exit$BD_BadBuild = F3(
	function (a, b, c) {
		return {$: 'BD_BadBuild', a: a, b: b, c: c};
	});
var $author$project$Builder$Elm$Details$RForeign = function (a) {
	return {$: 'RForeign', a: a};
};
var $author$project$Builder$Elm$Details$RKernelForeign = {$: 'RKernelForeign'};
var $author$project$Builder$Elm$Details$RKernelLocal = function (a) {
	return {$: 'RKernelLocal', a: a};
};
var $author$project$Builder$Elm$Details$RLocal = F2(
	function (a, b) {
		return {$: 'RLocal', a: a, b: b};
	});
var $author$project$Builder$Elm$Details$getInterface = function (result) {
	switch (result.$) {
		case 'RLocal':
			var iface = result.a;
			return $elm$core$Maybe$Just(iface);
		case 'RForeign':
			var iface = result.a;
			return $elm$core$Maybe$Just(iface);
		case 'RKernelLocal':
			return $elm$core$Maybe$Nothing;
		default:
			return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Builder$Elm$Details$lensMVResult = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.e;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var di = _v3.d;
			var fi = _v3.f;
			var gi = _v3.g;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, bi, ci, di, x, fi, gi, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Elm$Details$lensMVResultMap = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.f;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var gi = _v3.g;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, bi, ci, di, ei, x, gi, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Elm$Details$compile = F4(
	function (pkg, mvar, status, _v0) {
		switch (status.$) {
			case 'SLocal':
				var deps = status.a;
				var modul = status.b;
				return A2(
					$author$project$Extra$System$IO$bind,
					A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVResultMap, mvar),
					function (resultsDict) {
						return A2(
							$author$project$Extra$System$IO$bind,
							A4(
								$author$project$Extra$Type$Map$traverse,
								$author$project$Extra$System$IO$pure,
								$author$project$Extra$System$IO$liftA2,
								$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVResult),
								A2($author$project$Extra$Type$Map$intersection, resultsDict, deps)),
							function (maybeResults) {
								var _v2 = A3($author$project$Extra$Type$Map$sequenceA, $elm$core$Maybe$Just, $elm$core$Maybe$map2, maybeResults);
								if (_v2.$ === 'Nothing') {
									return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
								} else {
									var results = _v2.a;
									var _v3 = A3(
										$author$project$Compiler$Compile$compile,
										pkg,
										A2($author$project$Extra$Type$Map$mapMaybe, $author$project$Builder$Elm$Details$getInterface, results),
										modul);
									if (_v3.$ === 'Left') {
										return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
									} else {
										var _v4 = _v3.a;
										var canonical = _v4.a;
										var annotations = _v4.b;
										var objects = _v4.c;
										var ifaces = A3($author$project$Compiler$Elm$Interface$fromModule, pkg, canonical, annotations);
										return $author$project$Extra$System$IO$return(
											$elm$core$Maybe$Just(
												A2($author$project$Builder$Elm$Details$RLocal, ifaces, objects)));
									}
								}
							});
					});
			case 'SForeign':
				var iface = status.a;
				return $author$project$Extra$System$IO$return(
					$elm$core$Maybe$Just(
						$author$project$Builder$Elm$Details$RForeign(iface)));
			case 'SKernelLocal':
				var chunks = status.a;
				return $author$project$Extra$System$IO$return(
					$elm$core$Maybe$Just(
						$author$project$Builder$Elm$Details$RKernelLocal(chunks)));
			default:
				return $author$project$Extra$System$IO$return(
					$elm$core$Maybe$Just($author$project$Builder$Elm$Details$RKernelForeign));
		}
	});
var $author$project$Builder$Elm$Details$SForeign = function (a) {
	return {$: 'SForeign', a: a};
};
var $author$project$Builder$Elm$Details$SKernelForeign = {$: 'SKernelForeign'};
var $author$project$Builder$Elm$Details$SKernelLocal = function (a) {
	return {$: 'SKernelLocal', a: a};
};
var $author$project$Builder$Elm$Details$SLocal = F2(
	function (a, b) {
		return {$: 'SLocal', a: a, b: b};
	});
var $author$project$Compiler$Elm$Kernel$Content = F2(
	function (a, b) {
		return {$: 'Content', a: a, b: b};
	});
var $author$project$Compiler$Elm$Kernel$ignoreError = F3(
	function (_v0, _v1, _v2) {
		return _Utils_Tuple0;
	});
var $author$project$Compiler$Elm$Kernel$lookupEnum = F3(
	function (word, _var, allEnums) {
		var enums = A3($author$project$Extra$Type$Map$findWithDefault, $author$project$Extra$Type$Map$empty, word, allEnums);
		var _v0 = A2($author$project$Extra$Type$Map$lookup, _var, enums);
		if (_v0.$ === 'Just') {
			var n = _v0.a;
			return _Utils_Tuple2(n, allEnums);
		} else {
			var n = $author$project$Extra$Type$Map$size(enums);
			return _Utils_Tuple2(
				n,
				A3(
					$author$project$Extra$Type$Map$insert,
					word,
					A3($author$project$Extra$Type$Map$insert, _var, n, enums),
					allEnums));
		}
	});
var $author$project$Compiler$Elm$Kernel$lookupField = F2(
	function (name, fields) {
		var _v0 = A2($author$project$Extra$Type$Map$lookup, name, fields);
		if (_v0.$ === 'Just') {
			var n = _v0.a;
			return _Utils_Tuple2(n, fields);
		} else {
			var n = $author$project$Extra$Type$Map$size(fields);
			return _Utils_Tuple2(
				n,
				A3($author$project$Extra$Type$Map$insert, name, n, fields));
		}
	});
var $author$project$Compiler$Elm$Kernel$toByteString = F3(
	function (src, pos, end) {
		return A3($elm$core$String$slice, pos, end, src);
	});
var $author$project$Compiler$Elm$Kernel$chompChunks = function (vs) {
	return function (es) {
		return function (fs) {
			return function (src) {
				return function (pos) {
					return function (end) {
						return function (row) {
							return function (col) {
								return function (lastPos) {
									return function (revChunks) {
										chompChunks:
										while (true) {
											if (_Utils_cmp(pos, end) > -1) {
												var js = A3($author$project$Compiler$Elm$Kernel$toByteString, src, lastPos, end);
												return _Utils_Tuple2(
													_Utils_Tuple2(
														$author$project$Extra$Type$List$reverse(
															A2(
																$elm$core$List$cons,
																$author$project$Compiler$Elm$Kernel$JS(js),
																revChunks)),
														pos),
													_Utils_Tuple2(row, col));
											} else {
												var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos);
												if (word === 95) {
													var pos3 = pos + 3;
													var pos1 = pos + 1;
													if ((_Utils_cmp(pos3, end) < 1) && (A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, pos1) === 95)) {
														var js = A3($author$project$Compiler$Elm$Kernel$toByteString, src, lastPos, pos);
														return A9(
															$author$project$Compiler$Elm$Kernel$chompTag,
															vs,
															es,
															fs,
															src,
															pos3,
															end,
															row,
															col + 3,
															A2(
																$elm$core$List$cons,
																$author$project$Compiler$Elm$Kernel$JS(js),
																revChunks));
													} else {
														var $temp$vs = vs,
															$temp$es = es,
															$temp$fs = fs,
															$temp$src = src,
															$temp$pos = pos1,
															$temp$end = end,
															$temp$row = row,
															$temp$col = col + 1,
															$temp$lastPos = lastPos,
															$temp$revChunks = revChunks;
														vs = $temp$vs;
														es = $temp$es;
														fs = $temp$fs;
														src = $temp$src;
														pos = $temp$pos;
														end = $temp$end;
														row = $temp$row;
														col = $temp$col;
														lastPos = $temp$lastPos;
														revChunks = $temp$revChunks;
														continue chompChunks;
													}
												} else {
													if (word === 10) {
														var $temp$vs = vs,
															$temp$es = es,
															$temp$fs = fs,
															$temp$src = src,
															$temp$pos = pos + 1,
															$temp$end = end,
															$temp$row = row + 1,
															$temp$col = 1,
															$temp$lastPos = lastPos,
															$temp$revChunks = revChunks;
														vs = $temp$vs;
														es = $temp$es;
														fs = $temp$fs;
														src = $temp$src;
														pos = $temp$pos;
														end = $temp$end;
														row = $temp$row;
														col = $temp$col;
														lastPos = $temp$lastPos;
														revChunks = $temp$revChunks;
														continue chompChunks;
													} else {
														var newPos = pos + $author$project$Compiler$Parse$Primitives$getCharWidth(word);
														var $temp$vs = vs,
															$temp$es = es,
															$temp$fs = fs,
															$temp$src = src,
															$temp$pos = newPos,
															$temp$end = end,
															$temp$row = row,
															$temp$col = col + 1,
															$temp$lastPos = lastPos,
															$temp$revChunks = revChunks;
														vs = $temp$vs;
														es = $temp$es;
														fs = $temp$fs;
														src = $temp$src;
														pos = $temp$pos;
														end = $temp$end;
														row = $temp$row;
														col = $temp$col;
														lastPos = $temp$lastPos;
														revChunks = $temp$revChunks;
														continue chompChunks;
													}
												}
											}
										}
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var $author$project$Compiler$Elm$Kernel$chompTag = F9(
	function (vs, es, fs, src, pos, end, row, col, revChunks) {
		var tagPos = pos - 1;
		var word = A2($author$project$Compiler$Parse$Primitives$unsafeIndex, src, tagPos);
		var _v0 = A4($author$project$Compiler$Parse$Variable$chompInnerChars, src, pos, end, col);
		var newPos = _v0.a;
		var newCol = _v0.b;
		if (word === 36) {
			var name = A3($author$project$Compiler$Data$Name$fromPtr, src, pos, newPos);
			return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(es)(fs)(src)(newPos)(end)(row)(newCol)(newPos)(
				A2(
					$elm$core$List$cons,
					$author$project$Compiler$Elm$Kernel$ElmField(name),
					revChunks));
		} else {
			var name = A3($author$project$Compiler$Data$Name$fromPtr, src, tagPos, newPos);
			if ((48 <= word) && (word <= 57)) {
				var _v1 = A3($author$project$Compiler$Elm$Kernel$lookupEnum, word - 48, name, es);
				var _enum = _v1.a;
				var newEnums = _v1.b;
				return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(newEnums)(fs)(src)(newPos)(end)(row)(newCol)(newPos)(
					A2(
						$elm$core$List$cons,
						$author$project$Compiler$Elm$Kernel$JsEnum(_enum),
						revChunks));
			} else {
				if ((97 <= word) && (word <= 122)) {
					var _v2 = A2($author$project$Compiler$Elm$Kernel$lookupField, name, fs);
					var field = _v2.a;
					var newFields = _v2.b;
					return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(es)(newFields)(src)(newPos)(end)(row)(newCol)(newPos)(
						A2(
							$elm$core$List$cons,
							$author$project$Compiler$Elm$Kernel$JsField(field),
							revChunks));
				} else {
					if (name === 'DEBUG') {
						return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(es)(fs)(src)(newPos)(end)(row)(newCol)(newPos)(
							A2($elm$core$List$cons, $author$project$Compiler$Elm$Kernel$Debug, revChunks));
					} else {
						if (name === 'PROD') {
							return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(es)(fs)(src)(newPos)(end)(row)(newCol)(newPos)(
								A2($elm$core$List$cons, $author$project$Compiler$Elm$Kernel$Prod, revChunks));
						} else {
							if (name === 'ASYNC') {
								return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(es)(fs)(src)(newPos)(end)(row)(newCol)(newPos)(
									A2($elm$core$List$cons, $author$project$Compiler$Elm$Kernel$Async, revChunks));
							} else {
								var _v3 = A2($author$project$Extra$Type$Map$lookup, name, vs);
								if (_v3.$ === 'Just') {
									var chunk = _v3.a;
									return $author$project$Compiler$Elm$Kernel$chompChunks(vs)(es)(fs)(src)(newPos)(end)(row)(newCol)(newPos)(
										A2($elm$core$List$cons, chunk, revChunks));
								} else {
									return _Utils_Tuple2(
										_Utils_Tuple2(revChunks, pos),
										_Utils_Tuple2(row, col));
								}
							}
						}
					}
				}
			}
		}
	});
var $author$project$Compiler$Elm$Kernel$toError = F2(
	function (_v0, _v1) {
		return _Utils_Tuple0;
	});
var $author$project$Compiler$Elm$Kernel$parseChunks = F3(
	function (vtable, enums, fields) {
		return $author$project$Compiler$Parse$Primitives$Parser(
			function (_v0) {
				var src = _v0.a;
				var pos = _v0.b;
				var end = _v0.c;
				var indent = _v0.d;
				var row = _v0.e;
				var col = _v0.f;
				var _v1 = $author$project$Compiler$Elm$Kernel$chompChunks(vtable)(enums)(fields)(src)(pos)(end)(row)(col)(pos)(_List_Nil);
				var _v2 = _v1.a;
				var chunks = _v2.a;
				var newPos = _v2.b;
				var _v3 = _v1.b;
				var newRow = _v3.a;
				var newCol = _v3.b;
				return _Utils_eq(newPos, end) ? A2(
					$author$project$Compiler$Parse$Primitives$Cok,
					chunks,
					A6($author$project$Compiler$Parse$Primitives$State, src, newPos, end, indent, newRow, newCol)) : A3($author$project$Compiler$Parse$Primitives$Cerr, row, col, $author$project$Compiler$Elm$Kernel$toError);
			});
	});
var $author$project$Compiler$Data$Name$sepBy = F3(
	function (sep, name1, name2) {
		return _Utils_ap(
			name1,
			A2(
				$elm$core$String$cons,
				$elm$core$Char$fromCode(sep),
				name2));
	});
var $author$project$Compiler$Elm$Kernel$toName = function (exposed) {
	switch (exposed.$) {
		case 'Lower':
			var _v1 = exposed.a;
			var name = _v1.b;
			return name;
		case 'Upper':
			if (exposed.b.$ === 'Private') {
				var _v2 = exposed.a;
				var name = _v2.b;
				var _v3 = exposed.b;
				return name;
			} else {
				return _Debug_todo(
					'Compiler.Elm.Kernel',
					{
						start: {line: 325, column: 7},
						end: {line: 325, column: 17}
					})('cannot have Maybe(..) syntax in kernel code header');
			}
		default:
			return _Debug_todo(
				'Compiler.Elm.Kernel',
				{
					start: {line: 328, column: 7},
					end: {line: 328, column: 17}
				})('cannot use binops in kernel code');
	}
};
var $author$project$Compiler$Elm$Kernel$toNames = function (exposing_) {
	if (exposing_.$ === 'Open') {
		return _Debug_todo(
			'Compiler.Elm.Kernel',
			{
				start: {line: 309, column: 7},
				end: {line: 309, column: 17}
			})('cannot have `exposing (..)` in kernel code.');
	} else {
		var exposedList = exposing_.a;
		return A2($author$project$Extra$Type$List$map, $author$project$Compiler$Elm$Kernel$toName, exposedList);
	}
};
var $elm$core$String$contains = _String_contains;
var $author$project$Compiler$Data$Utf8$contains = F2(
	function (word, str) {
		return A2(
			$elm$core$String$contains,
			$elm$core$String$fromChar(
				$elm$core$Char$fromCode(word)),
			str);
	});
var $author$project$Compiler$Data$Name$hasDot = function (name) {
	return A2($author$project$Compiler$Data$Utf8$contains, 46, name);
};
var $author$project$Compiler$Elm$Kernel$toPrefix = F2(
	function (home, maybeAlias) {
		if (maybeAlias.$ === 'Just') {
			var alias = maybeAlias.a;
			return alias;
		} else {
			return $author$project$Compiler$Data$Name$hasDot(home) ? _Debug_todo(
				'Compiler.Elm.Kernel',
				{
					start: {line: 300, column: 9},
					end: {line: 300, column: 19}
				})('kernel imports with dots need an alias: ' + home) : home;
		}
	});
var $author$project$Compiler$Elm$Kernel$addImport = F4(
	function (pkg, foreigns, vtable, _v0) {
		var _v1 = _v0.a;
		var importName = _v1.b;
		var maybeAlias = _v0.b;
		var exposing_ = _v0.c;
		if ($author$project$Compiler$Data$Name$isKernel(importName)) {
			if (maybeAlias.$ === 'Just') {
				return _Debug_todo(
					'Compiler.Elm.Kernel',
					{
						start: {line: 272, column: 9},
						end: {line: 272, column: 19}
					})('cannot use `as` with kernel import of: ' + importName);
			} else {
				var home = $author$project$Compiler$Data$Name$getKernel(importName);
				var add = F2(
					function (table, name) {
						return A3(
							$author$project$Extra$Type$Map$insert,
							A3($author$project$Compiler$Data$Name$sepBy, 95, home, name),
							A2($author$project$Compiler$Elm$Kernel$JsVar, home, name),
							table);
					});
				return A3(
					$author$project$Extra$Type$List$foldl,
					add,
					vtable,
					$author$project$Compiler$Elm$Kernel$toNames(exposing_));
			}
		} else {
			var prefix = A2($author$project$Compiler$Elm$Kernel$toPrefix, importName, maybeAlias);
			var home = A2(
				$author$project$Compiler$Elm$ModuleName$Canonical,
				A3($author$project$Extra$Type$Map$findWithDefault, pkg, importName, foreigns),
				importName);
			var add = F2(
				function (table, name) {
					return A3(
						$author$project$Extra$Type$Map$insert,
						A3($author$project$Compiler$Data$Name$sepBy, 95, prefix, name),
						A2($author$project$Compiler$Elm$Kernel$ElmVar, home, name),
						table);
				});
			return A3(
				$author$project$Extra$Type$List$foldl,
				add,
				vtable,
				$author$project$Compiler$Elm$Kernel$toNames(exposing_));
		}
	});
var $author$project$Compiler$Elm$Kernel$toVarTable = F3(
	function (pkg, foreigns, imports) {
		return A3(
			$author$project$Extra$Type$List$foldl,
			A2($author$project$Compiler$Elm$Kernel$addImport, pkg, foreigns),
			$author$project$Extra$Type$Map$empty,
			imports);
	});
var $author$project$Compiler$Elm$Kernel$parser = F2(
	function (pkg, foreigns) {
		return A2(
			$author$project$Compiler$Parse$Primitives$bind,
			A3($author$project$Compiler$Parse$Primitives$word2, 47, 42, $author$project$Compiler$Elm$Kernel$toError),
			function (_v0) {
				return A2(
					$author$project$Compiler$Parse$Primitives$bind,
					$author$project$Compiler$Parse$Space$chomp($author$project$Compiler$Elm$Kernel$ignoreError),
					function (_v1) {
						return A2(
							$author$project$Compiler$Parse$Primitives$bind,
							$author$project$Compiler$Parse$Space$checkFreshLine($author$project$Compiler$Elm$Kernel$toError),
							function (_v2) {
								return A2(
									$author$project$Compiler$Parse$Primitives$bind,
									A2(
										$author$project$Compiler$Parse$Primitives$specialize,
										$author$project$Compiler$Elm$Kernel$ignoreError,
										$author$project$Compiler$Parse$Module$chompImports(_List_Nil)),
									function (imports) {
										return A2(
											$author$project$Compiler$Parse$Primitives$bind,
											A3($author$project$Compiler$Parse$Primitives$word2, 42, 47, $author$project$Compiler$Elm$Kernel$toError),
											function (_v3) {
												return A2(
													$author$project$Compiler$Parse$Primitives$bind,
													A3(
														$author$project$Compiler$Elm$Kernel$parseChunks,
														A3($author$project$Compiler$Elm$Kernel$toVarTable, pkg, foreigns, imports),
														$author$project$Extra$Type$Map$empty,
														$author$project$Extra$Type$Map$empty),
													function (chunks) {
														return $author$project$Compiler$Parse$Primitives$return(
															A2($author$project$Compiler$Elm$Kernel$Content, imports, chunks));
													});
											});
									});
							});
					});
			});
	});
var $author$project$Compiler$Elm$Kernel$fromByteString = F3(
	function (pkg, foreigns, bytes) {
		var _v0 = A3(
			$author$project$Compiler$Parse$Primitives$fromByteString,
			A2($author$project$Compiler$Elm$Kernel$parser, pkg, foreigns),
			$author$project$Compiler$Elm$Kernel$toError,
			bytes);
		if (_v0.$ === 'Right') {
			var content = _v0.a;
			return $elm$core$Maybe$Just(content);
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Builder$Elm$Details$getDepHome = function (fi) {
	if (fi.$ === 'ForeignSpecific') {
		var _v1 = fi.a;
		var pkg = _v1.a;
		return $elm$core$Maybe$Just(pkg);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Builder$Elm$Details$lensMVStatus = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.c;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var bi = _v3.b;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, bi, x, di, ei, fi, gi, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Elm$Details$lensMVStatusMap = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.d;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var hi = _v3.h;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, bi, ci, x, ei, fi, gi, hi),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Elm$Details$crawlFile = F6(
	function (foreignDeps, mvar, pkg, src, expectedName, path) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$File$readUtf8(path),
			function (bytes) {
				var _v9 = A2(
					$author$project$Compiler$Parse$Module$fromByteString,
					$author$project$Compiler$Parse$Module$Package(pkg),
					bytes);
				if ((_v9.$ === 'Right') && (_v9.a.a.$ === 'Just')) {
					var modul = _v9.a;
					var _v10 = modul.a.a;
					var actualName = _v10.b;
					var imports = modul.c;
					return _Utils_eq(expectedName, actualName) ? A2(
						$author$project$Extra$System$IO$bind,
						A5($author$project$Builder$Elm$Details$crawlImports, foreignDeps, mvar, pkg, src, imports),
						function (deps) {
							return $author$project$Extra$System$IO$return(
								$elm$core$Maybe$Just(
									A2($author$project$Builder$Elm$Details$SLocal, deps, modul)));
						}) : $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
				} else {
					return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
				}
			});
	});
var $author$project$Builder$Elm$Details$crawlImports = F5(
	function (foreignDeps, mvar, pkg, src, imports) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVStatusMap, mvar),
			function (statusDict) {
				var deps = $author$project$Extra$Type$Map$fromList(
					A2(
						$author$project$Extra$Type$List$map,
						function (i) {
							return _Utils_Tuple2(
								$author$project$Compiler$AST$Source$getImportName(i),
								_Utils_Tuple0);
						},
						imports));
				var news = A2($author$project$Extra$Type$Map$difference, deps, statusDict);
				return A2(
					$author$project$Extra$System$IO$bind,
					A4(
						$author$project$Extra$Type$Map$traverseWithKey,
						$author$project$Extra$System$IO$pure,
						$author$project$Extra$System$IO$liftA2,
						F2(
							function (k, _v6) {
								return A2(
									$author$project$Builder$Elm$Details$fork,
									$author$project$Builder$Elm$Details$lensMVStatus,
									A5($author$project$Builder$Elm$Details$crawlModule, foreignDeps, mvar, pkg, src, k));
							}),
						news),
					function (mvars) {
						return A2(
							$author$project$Extra$System$IO$bind,
							A3(
								$author$project$Extra$System$MVar$write,
								$author$project$Builder$Elm$Details$lensMVStatusMap,
								mvar,
								A2($author$project$Extra$Type$Map$union, mvars, statusDict)),
							function (_v7) {
								return A2(
									$author$project$Extra$System$IO$bind,
									A4(
										$author$project$Extra$Type$Map$mapM_,
										$author$project$Extra$System$IO$return,
										$author$project$Extra$System$IO$bind,
										$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVStatus),
										mvars),
									function (_v8) {
										return $author$project$Extra$System$IO$return(deps);
									});
							});
					});
			});
	});
var $author$project$Builder$Elm$Details$crawlKernel = F5(
	function (foreignDeps, mvar, pkg, src, name) {
		var path = A2(
			$author$project$Extra$System$File$addExtension,
			A2(
				$author$project$Extra$System$File$addNames,
				src,
				$author$project$Compiler$Elm$ModuleName$toFileNames(name)),
			'js');
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$File$exists(path),
			function (exists) {
				return exists ? A2(
					$author$project$Extra$System$IO$bind,
					$author$project$Builder$File$readUtf8(path),
					function (bytes) {
						var _v3 = A3(
							$author$project$Compiler$Elm$Kernel$fromByteString,
							pkg,
							A2($author$project$Extra$Type$Map$mapMaybe, $author$project$Builder$Elm$Details$getDepHome, foreignDeps),
							bytes);
						if (_v3.$ === 'Nothing') {
							return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
						} else {
							var _v4 = _v3.a;
							var imports = _v4.a;
							var chunks = _v4.b;
							return A2(
								$author$project$Extra$System$IO$bind,
								A5($author$project$Builder$Elm$Details$crawlImports, foreignDeps, mvar, pkg, src, imports),
								function (_v5) {
									return $author$project$Extra$System$IO$return(
										$elm$core$Maybe$Just(
											$author$project$Builder$Elm$Details$SKernelLocal(chunks)));
								});
						}
					}) : $author$project$Extra$System$IO$return(
					$elm$core$Maybe$Just($author$project$Builder$Elm$Details$SKernelForeign));
			});
	});
var $author$project$Builder$Elm$Details$crawlModule = F6(
	function (foreignDeps, mvar, pkg, src, name, _v0) {
		var path = A2(
			$author$project$Extra$System$File$addExtension,
			A2(
				$author$project$Extra$System$File$addNames,
				src,
				$author$project$Compiler$Elm$ModuleName$toFileNames(name)),
			'elm');
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$File$exists(path),
			function (exists) {
				var _v1 = A2($author$project$Extra$Type$Map$lookup, name, foreignDeps);
				if (_v1.$ === 'Just') {
					if (_v1.a.$ === 'ForeignAmbiguous') {
						var _v2 = _v1.a;
						return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
					} else {
						var iface = _v1.a.a;
						return exists ? $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing) : $author$project$Extra$System$IO$return(
							$elm$core$Maybe$Just(
								$author$project$Builder$Elm$Details$SForeign(iface)));
					}
				} else {
					return exists ? A6($author$project$Builder$Elm$Details$crawlFile, foreignDeps, mvar, pkg, src, name, path) : (($author$project$Compiler$Elm$Package$isKernel(pkg) && $author$project$Compiler$Data$Name$isKernel(name)) ? A5($author$project$Builder$Elm$Details$crawlKernel, foreignDeps, mvar, pkg, src, name) : $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing));
				}
			});
	});
var $author$project$Builder$Elm$Outline$flattenExposed = function (exposed) {
	if (exposed.$ === 'ExposedList') {
		var names = exposed.a;
		return names;
	} else {
		var sections = exposed.a;
		return A2($author$project$Extra$Type$List$concatMap, $elm$core$Tuple$second, sections);
	}
};
var $author$project$Builder$Elm$Details$ForeignAmbiguous = {$: 'ForeignAmbiguous'};
var $author$project$Builder$Elm$Details$ForeignSpecific = function (a) {
	return {$: 'ForeignSpecific', a: a};
};
var $author$project$Builder$Elm$Details$gatherForeignInterfaces = function (directArtifacts) {
	var isPublic = function (di) {
		if (di.$ === 'Public') {
			var iface = di.a;
			return $elm$core$Maybe$Just(
				$author$project$Compiler$Data$OneOrMore$one(iface));
		} else {
			return $elm$core$Maybe$Nothing;
		}
	};
	var gather = F3(
		function (_v1, _v2, buckets) {
			var ifaces = _v2.a;
			return A3(
				$author$project$Extra$Type$Map$unionWith,
				$author$project$Compiler$Data$OneOrMore$more,
				buckets,
				A2($author$project$Extra$Type$Map$mapMaybe, isPublic, ifaces));
		});
	var finalize = F2(
		function (i, is) {
			if (!is.b) {
				return $author$project$Builder$Elm$Details$ForeignSpecific(i);
			} else {
				return $author$project$Builder$Elm$Details$ForeignAmbiguous;
			}
		});
	return A2(
		$author$project$Extra$Type$Map$map,
		$author$project$Compiler$Data$OneOrMore$destruct(finalize),
		A3($author$project$Extra$Type$Map$foldrWithKey, gather, $author$project$Extra$Type$Map$empty, directArtifacts));
};
var $author$project$Extra$Type$Map$mapMaybeMissing = F4(
	function (pPure, f, k, a) {
		return pPure(
			A2(f, k, a));
	});
var $author$project$Compiler$Elm$Interface$public = $author$project$Compiler$Elm$Interface$Public;
var $author$project$Builder$Elm$Details$toLocalInterface = F2(
	function (func, result) {
		switch (result.$) {
			case 'RLocal':
				var iface = result.a;
				return $elm$core$Maybe$Just(
					func(iface));
			case 'RForeign':
				return $elm$core$Maybe$Nothing;
			case 'RKernelLocal':
				return $elm$core$Maybe$Nothing;
			default:
				return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Extra$Type$Map$zipWithMaybeMatched = F5(
	function (pPure, f, k, a, b) {
		return pPure(
			A3(f, k, a, b));
	});
var $author$project$Builder$Elm$Details$gatherInterfaces = F2(
	function (exposed, artifacts) {
		var onRight = A2(
			$author$project$Extra$Type$Map$mapMaybeMissing,
			$elm$core$Basics$identity,
			F2(
				function (_v4, iface) {
					return A2($author$project$Builder$Elm$Details$toLocalInterface, $author$project$Compiler$Elm$Interface$private, iface);
				}));
		var onLeft = A2(
			$author$project$Extra$Type$Map$mapMissing,
			$elm$core$Basics$identity,
			F2(
				function (_v2, _v3) {
					return _Debug_todo(
						'Builder.Elm.Details',
						{
							start: {line: 582, column: 49},
							end: {line: 582, column: 59}
						})('compiler bug manifesting in Elm.Details.gatherInterfaces');
				}));
		var onBoth = A2(
			$author$project$Extra$Type$Map$zipWithMaybeMatched,
			$elm$core$Basics$identity,
			F3(
				function (_v0, _v1, iface) {
					return A2($author$project$Builder$Elm$Details$toLocalInterface, $author$project$Compiler$Elm$Interface$public, iface);
				}));
		return A7($author$project$Extra$Type$Map$mergeA, $elm$core$Basics$identity, $elm$core$Basics$identity, onLeft, onRight, onBoth, exposed, artifacts);
	});
var $author$project$Compiler$AST$Optimized$addKernelDep = F2(
	function (chunk, deps) {
		switch (chunk.$) {
			case 'JS':
				return deps;
			case 'ElmVar':
				var home = chunk.a;
				var name = chunk.b;
				return A2(
					$author$project$Extra$Type$Set$insert,
					$author$project$Compiler$AST$Optimized$toGlobalComparable(
						A2($author$project$Compiler$AST$Optimized$Global, home, name)),
					deps);
			case 'JsVar':
				var shortName = chunk.a;
				return A2(
					$author$project$Extra$Type$Set$insert,
					$author$project$Compiler$AST$Optimized$toGlobalComparable(
						$author$project$Compiler$AST$Optimized$toKernelGlobal(shortName)),
					deps);
			case 'ElmField':
				return deps;
			case 'JsField':
				return deps;
			case 'JsEnum':
				return deps;
			case 'Debug':
				return deps;
			case 'Prod':
				return deps;
			default:
				return deps;
		}
	});
var $author$project$Compiler$Elm$Kernel$addField = F2(
	function (chunk, fields) {
		switch (chunk.$) {
			case 'JS':
				return fields;
			case 'ElmVar':
				return fields;
			case 'JsVar':
				return fields;
			case 'ElmField':
				var f = chunk.a;
				return A4($author$project$Extra$Type$Map$insertWith, $elm$core$Basics$add, f, 1, fields);
			case 'JsField':
				return fields;
			case 'JsEnum':
				return fields;
			case 'Debug':
				return fields;
			case 'Prod':
				return fields;
			default:
				return fields;
		}
	});
var $author$project$Compiler$Elm$Kernel$countFields = function (chunks) {
	return A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$Elm$Kernel$addField, $author$project$Extra$Type$Map$empty, chunks);
};
var $author$project$Compiler$AST$Optimized$addKernel = F3(
	function (shortName, chunks, _v0) {
		var nodes = _v0.a;
		var fields = _v0.b;
		var node = A2(
			$author$project$Compiler$AST$Optimized$Kernel,
			chunks,
			A3($author$project$Extra$Type$List$foldr, $author$project$Compiler$AST$Optimized$addKernelDep, $author$project$Extra$Type$Set$empty, chunks));
		var global = $author$project$Compiler$AST$Optimized$toKernelGlobal(shortName);
		return A2(
			$author$project$Compiler$AST$Optimized$GlobalGraph,
			A3(
				$author$project$Extra$Type$Map$insert,
				$author$project$Compiler$AST$Optimized$toGlobalComparable(global),
				node,
				nodes),
			A2(
				$author$project$Extra$Type$Map$union,
				$author$project$Compiler$Elm$Kernel$countFields(chunks),
				fields));
	});
var $author$project$Compiler$AST$Optimized$addLocalGraph = F2(
	function (_v0, _v1) {
		var nodes1 = _v0.b;
		var fields1 = _v0.c;
		var nodes2 = _v1.a;
		var fields2 = _v1.b;
		return A2(
			$author$project$Compiler$AST$Optimized$GlobalGraph,
			A2($author$project$Extra$Type$Map$union, nodes1, nodes2),
			A2($author$project$Extra$Type$Map$union, fields1, fields2));
	});
var $author$project$Builder$Elm$Details$addLocalGraph = F3(
	function (name, status, graph) {
		switch (status.$) {
			case 'RLocal':
				var objs = status.b;
				return A2($author$project$Compiler$AST$Optimized$addLocalGraph, objs, graph);
			case 'RForeign':
				return graph;
			case 'RKernelLocal':
				var cs = status.a;
				return A3(
					$author$project$Compiler$AST$Optimized$addKernel,
					$author$project$Compiler$Data$Name$getKernel(name),
					cs,
					graph);
			default:
				return graph;
		}
	});
var $author$project$Builder$Elm$Details$gatherObjects = function (results) {
	return A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Builder$Elm$Details$addLocalGraph, $author$project$Compiler$AST$Optimized$empty, results);
};
var $author$project$Builder$Elm$Details$DocsNeeded = {$: 'DocsNeeded'};
var $author$project$Builder$Elm$Details$DocsNotNeeded = {$: 'DocsNotNeeded'};
var $author$project$Builder$Elm$Details$getDocsStatus = F3(
	function (cache, pkg, vsn) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$File$exists(
				A2(
					$author$project$Extra$System$File$addName,
					A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
					'docs.json')),
			function (exists) {
				return exists ? $author$project$Extra$System$IO$return($author$project$Builder$Elm$Details$DocsNotNeeded) : $author$project$Extra$System$IO$return($author$project$Builder$Elm$Details$DocsNeeded);
			});
	});
var $author$project$Builder$Elm$Details$toComparable = function (f) {
	return A2(
		$author$project$Extra$Type$List$map,
		function (_v0) {
			var a = _v0.a;
			var b = _v0.b;
			return _Utils_Tuple2(
				a,
				$author$project$Compiler$Elm$Version$toComparable(b));
		},
		$author$project$Extra$Type$Map$toList(f));
};
var $author$project$Builder$Elm$Details$writeDocs = F5(
	function (_v0, _v1, _v2, status, _v3) {
		if (status.$ === 'DocsNeeded') {
			return $author$project$Extra$System$IO$return(_Utils_Tuple0);
		} else {
			return $author$project$Extra$System$IO$return(_Utils_Tuple0);
		}
	});
var $author$project$Builder$Elm$Details$build = F6(
	function (cache, depsMVar, pkg, _v0, f, fs) {
		var vsn = _v0.a;
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$Elm$Outline$read(
				A3($author$project$Builder$Stuff$package, cache, pkg, vsn)),
			function (eitherOutline) {
				if (eitherOutline.$ === 'Left') {
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(
							$elm$core$Maybe$Just(
								A3($author$project$Builder$Reporting$Exit$BD_BadBuild, pkg, vsn, f))));
				} else {
					if (eitherOutline.a.$ === 'App') {
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Left(
								$elm$core$Maybe$Just(
									A3($author$project$Builder$Reporting$Exit$BD_BadBuild, pkg, vsn, f))));
					} else {
						var _v2 = eitherOutline.a.a;
						var exposed = _v2.e;
						var deps = _v2.f;
						return A2(
							$author$project$Extra$System$IO$bind,
							A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVDepMap, depsMVar),
							function (allDeps) {
								return A2(
									$author$project$Extra$System$IO$bind,
									A4(
										$author$project$Extra$Type$Map$traverse,
										$author$project$Extra$System$IO$pure,
										$author$project$Extra$System$IO$liftA2,
										$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVDep),
										A2($author$project$Extra$Type$Map$intersection, allDeps, deps)),
									function (directDeps) {
										var _v3 = A3($author$project$Extra$Type$Map$sequenceA, $author$project$Extra$Type$Either$pure, $author$project$Extra$Type$Either$liftA2, directDeps);
										if (_v3.$ === 'Left') {
											return $author$project$Extra$System$IO$return(
												$author$project$Extra$Type$Either$Left($elm$core$Maybe$Nothing));
										} else {
											var directArtifacts = _v3.a;
											var src = A2(
												$author$project$Extra$System$File$addName,
												A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
												'src');
											var foreignDeps = $author$project$Builder$Elm$Details$gatherForeignInterfaces(directArtifacts);
											var exposedDict = A2(
												$author$project$Extra$Type$Map$fromKeys,
												function (_v12) {
													return _Utils_Tuple0;
												},
												$author$project$Builder$Elm$Outline$flattenExposed(exposed));
											return A2(
												$author$project$Extra$System$IO$bind,
												A3($author$project$Builder$Elm$Details$getDocsStatus, cache, pkg, vsn),
												function (docsStatus) {
													return A2(
														$author$project$Extra$System$IO$bind,
														$author$project$Extra$System$MVar$newEmpty($author$project$Builder$Elm$Details$lensMVStatusMap),
														function (mvar) {
															return A2(
																$author$project$Extra$System$IO$bind,
																A4(
																	$author$project$Extra$Type$Map$traverseWithKey,
																	$author$project$Extra$System$IO$pure,
																	$author$project$Extra$System$IO$liftA2,
																	F2(
																		function (k, _v4) {
																			return A2(
																				$author$project$Builder$Elm$Details$fork,
																				$author$project$Builder$Elm$Details$lensMVStatus,
																				A5($author$project$Builder$Elm$Details$crawlModule, foreignDeps, mvar, pkg, src, k));
																		}),
																	exposedDict),
																function (mvars) {
																	return A2(
																		$author$project$Extra$System$IO$bind,
																		A3($author$project$Extra$System$MVar$write, $author$project$Builder$Elm$Details$lensMVStatusMap, mvar, mvars),
																		function (_v5) {
																			return A2(
																				$author$project$Extra$System$IO$bind,
																				A4(
																					$author$project$Extra$Type$Map$mapM_,
																					$author$project$Extra$System$IO$return,
																					$author$project$Extra$System$IO$bind,
																					$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVStatus),
																					mvars),
																				function (_v6) {
																					return A2(
																						$author$project$Extra$System$IO$bind,
																						A2(
																							$author$project$Extra$System$IO$andThen,
																							A3(
																								$author$project$Extra$Type$Map$traverse,
																								$author$project$Extra$System$IO$pure,
																								$author$project$Extra$System$IO$liftA2,
																								$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVStatus)),
																							A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVStatusMap, mvar)),
																						function (maybeStatuses) {
																							var _v7 = A3($author$project$Extra$Type$Map$sequenceA, $elm$core$Maybe$Just, $elm$core$Maybe$map2, maybeStatuses);
																							if (_v7.$ === 'Nothing') {
																								return $author$project$Extra$System$IO$return(
																									$author$project$Extra$Type$Either$Left(
																										$elm$core$Maybe$Just(
																											A3($author$project$Builder$Reporting$Exit$BD_BadBuild, pkg, vsn, f))));
																							} else {
																								var statuses = _v7.a;
																								return A2(
																									$author$project$Extra$System$IO$bind,
																									$author$project$Extra$System$MVar$newEmpty($author$project$Builder$Elm$Details$lensMVResultMap),
																									function (rmvar) {
																										return A2(
																											$author$project$Extra$System$IO$bind,
																											A4(
																												$author$project$Extra$Type$Map$traverse,
																												$author$project$Extra$System$IO$pure,
																												$author$project$Extra$System$IO$liftA2,
																												function (v) {
																													return A2(
																														$author$project$Builder$Elm$Details$fork,
																														$author$project$Builder$Elm$Details$lensMVResult,
																														A3($author$project$Builder$Elm$Details$compile, pkg, rmvar, v));
																												},
																												statuses),
																											function (rmvars) {
																												return A2(
																													$author$project$Extra$System$IO$bind,
																													A3($author$project$Extra$System$MVar$write, $author$project$Builder$Elm$Details$lensMVResultMap, rmvar, rmvars),
																													function (_v8) {
																														return A2(
																															$author$project$Extra$System$IO$bind,
																															A4(
																																$author$project$Extra$Type$Map$traverse,
																																$author$project$Extra$System$IO$pure,
																																$author$project$Extra$System$IO$liftA2,
																																$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVResult),
																																rmvars),
																															function (maybeResults) {
																																var _v9 = A3($author$project$Extra$Type$Map$sequenceA, $elm$core$Maybe$Just, $elm$core$Maybe$map2, maybeResults);
																																if (_v9.$ === 'Nothing') {
																																	return $author$project$Extra$System$IO$return(
																																		$author$project$Extra$Type$Either$Left(
																																			$elm$core$Maybe$Just(
																																				A3($author$project$Builder$Reporting$Exit$BD_BadBuild, pkg, vsn, f))));
																																} else {
																																	var results = _v9.a;
																																	var path = A2(
																																		$author$project$Extra$System$File$addName,
																																		A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
																																		'artifacts.dat');
																																	var objects = $author$project$Builder$Elm$Details$gatherObjects(results);
																																	var ifaces = A2($author$project$Builder$Elm$Details$gatherInterfaces, exposedDict, results);
																																	var fingerprints = A2(
																																		$author$project$Extra$Type$Set$insert,
																																		$author$project$Builder$Elm$Details$toComparable(f),
																																		fs);
																																	var artifacts = A2($author$project$Builder$Elm$Details$Artifacts, ifaces, objects);
																																	return A2(
																																		$author$project$Extra$System$IO$bind,
																																		A5($author$project$Builder$Elm$Details$writeDocs, cache, pkg, vsn, docsStatus, results),
																																		function (_v10) {
																																			return A2(
																																				$author$project$Extra$System$IO$bind,
																																				A3(
																																					$author$project$Builder$File$writeBinary,
																																					$author$project$Builder$Elm$Details$bArtifactCache,
																																					path,
																																					A2($author$project$Builder$Elm$Details$ArtifactCache, fingerprints, artifacts)),
																																				function (_v11) {
																																					return $author$project$Extra$System$IO$return(
																																						$author$project$Extra$Type$Either$Right(artifacts));
																																				});
																																		});
																																}
																															});
																													});
																											});
																									});
																							}
																						});
																				});
																		});
																});
														});
												});
										}
									});
							});
					}
				}
			});
	});
var $author$project$Builder$Reporting$Exit$PP_BadArchiveContent = function (a) {
	return {$: 'PP_BadArchiveContent', a: a};
};
var $author$project$Builder$Reporting$Exit$PP_BadArchiveRequest = function (a) {
	return {$: 'PP_BadArchiveRequest', a: a};
};
var $author$project$Builder$Reporting$Exit$PP_BadEndpointContent = function (a) {
	return {$: 'PP_BadEndpointContent', a: a};
};
var $author$project$Builder$Reporting$Exit$PP_BadEndpointRequest = function (a) {
	return {$: 'PP_BadEndpointRequest', a: a};
};
var $author$project$Builder$Elm$Details$endpointDecoder = A2(
	$author$project$Compiler$Json$Decode$bind,
	A2($author$project$Compiler$Json$Decode$field, 'url', $author$project$Compiler$Json$Decode$string),
	function (url) {
		return A2(
			$author$project$Compiler$Json$Decode$bind,
			A2($author$project$Compiler$Json$Decode$field, 'hash', $author$project$Compiler$Json$Decode$string),
			function (hash) {
				return $author$project$Compiler$Json$Decode$return(
					_Utils_Tuple2(url, hash));
			});
	});
var $agu_z$elm_zip$Zip$Zip = function (a) {
	return {$: 'Zip', a: a};
};
var $elm$bytes$Bytes$Decode$map2 = F3(
	function (func, _v0, _v1) {
		var decodeA = _v0.a;
		var decodeB = _v1.a;
		return $elm$bytes$Bytes$Decode$Decoder(
			F2(
				function (bites, offset) {
					var _v2 = A2(decodeA, bites, offset);
					var aOffset = _v2.a;
					var a = _v2.b;
					var _v3 = A2(decodeB, bites, aOffset);
					var bOffset = _v3.a;
					var b = _v3.b;
					return _Utils_Tuple2(
						bOffset,
						A2(func, a, b));
				}));
	});
var $agu_z$elm_zip$Internal$Decode$after = function (offset) {
	return A2(
		$elm$bytes$Bytes$Decode$map2,
		F2(
			function (_v0, a) {
				return a;
			}),
		$elm$bytes$Bytes$Decode$bytes(offset));
};
var $agu_z$elm_zip$Internal$Decode$CdRecordBounds = F6(
	function (nameLength, extraFieldLength, commentLength, internalAttributes, externalAttributes, startOffset) {
		return {commentLength: commentLength, externalAttributes: externalAttributes, extraFieldLength: extraFieldLength, internalAttributes: internalAttributes, nameLength: nameLength, startOffset: startOffset};
	});
var $agu_z$elm_zip$Internal$Format$Entry = F2(
	function (a, b) {
		return {$: 'Entry', a: a, b: b};
	});
var $agu_z$elm_zip$Internal$Format$EntryMeta = function (madeBy) {
	return function (extractMinVersion) {
		return function (flag) {
			return function (compressionMethod) {
				return function (lastModified) {
					return function (crc32) {
						return function (compressedSize) {
							return function (uncompressedSize) {
								return function (fileName) {
									return function (extraField) {
										return function (comment) {
											return function (internalAttributes) {
												return function (externalAttributes) {
													return {comment: comment, compressedSize: compressedSize, compressionMethod: compressionMethod, crc32: crc32, externalAttributes: externalAttributes, extraField: extraField, extractMinVersion: extractMinVersion, fileName: fileName, flag: flag, internalAttributes: internalAttributes, lastModified: lastModified, madeBy: madeBy, uncompressedSize: uncompressedSize};
												};
											};
										};
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var $agu_z$elm_zip$Internal$Format$Offset = F2(
	function (a, b) {
		return {$: 'Offset', a: a, b: b};
	});
var $elm$bytes$Bytes$Decode$fail = $elm$bytes$Bytes$Decode$Decoder(_Bytes_decodeFailure);
var $agu_z$elm_zip$Internal$Decode$i32 = $elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$LE);
var $agu_z$elm_zip$Internal$Decode$checkSignature = function (expected) {
	var check = function (value) {
		return _Utils_eq(value, expected) ? $elm$bytes$Bytes$Decode$succeed(_Utils_Tuple0) : $elm$bytes$Bytes$Decode$fail;
	};
	return A2(
		$elm$bytes$Bytes$Decode$map2,
		F2(
			function (_v0, b) {
				return b;
			}),
		A2($elm$bytes$Bytes$Decode$andThen, check, $agu_z$elm_zip$Internal$Decode$i32));
};
var $agu_z$elm_zip$Internal$Format$Deflated = {$: 'Deflated'};
var $agu_z$elm_zip$Internal$Format$Stored = {$: 'Stored'};
var $agu_z$elm_zip$Internal$Format$Unsupported = function (a) {
	return {$: 'Unsupported', a: a};
};
var $agu_z$elm_zip$Internal$Decode$i16 = $elm$bytes$Bytes$Decode$unsignedInt16($elm$bytes$Bytes$LE);
var $agu_z$elm_zip$Internal$Decode$compressionMethod = function () {
	var help = function (m) {
		switch (m) {
			case 0:
				return $agu_z$elm_zip$Internal$Format$Stored;
			case 8:
				return $agu_z$elm_zip$Internal$Format$Deflated;
			default:
				var method = m;
				return $agu_z$elm_zip$Internal$Format$Unsupported(method);
		}
	};
	return A2($elm$bytes$Bytes$Decode$map, help, $agu_z$elm_zip$Internal$Decode$i16);
}();
var $elm$bytes$Bytes$Decode$map5 = F6(
	function (func, _v0, _v1, _v2, _v3, _v4) {
		var decodeA = _v0.a;
		var decodeB = _v1.a;
		var decodeC = _v2.a;
		var decodeD = _v3.a;
		var decodeE = _v4.a;
		return $elm$bytes$Bytes$Decode$Decoder(
			F2(
				function (bites, offset) {
					var _v5 = A2(decodeA, bites, offset);
					var aOffset = _v5.a;
					var a = _v5.b;
					var _v6 = A2(decodeB, bites, aOffset);
					var bOffset = _v6.a;
					var b = _v6.b;
					var _v7 = A2(decodeC, bites, bOffset);
					var cOffset = _v7.a;
					var c = _v7.b;
					var _v8 = A2(decodeD, bites, cOffset);
					var dOffset = _v8.a;
					var d = _v8.b;
					var _v9 = A2(decodeE, bites, dOffset);
					var eOffset = _v9.a;
					var e = _v9.b;
					return _Utils_Tuple2(
						eOffset,
						A5(func, a, b, c, d, e));
				}));
	});
var $agu_z$elm_zip$Internal$Decode$with = F2(
	function (a, fn) {
		return A3($elm$bytes$Bytes$Decode$map2, $elm$core$Basics$apL, fn, a);
	});
var $agu_z$elm_zip$Internal$Decode$entryIn = function (bytes) {
	var start = A2(
		$agu_z$elm_zip$Internal$Decode$with,
		$agu_z$elm_zip$Internal$Decode$i32,
		A2(
			$agu_z$elm_zip$Internal$Decode$with,
			$agu_z$elm_zip$Internal$Decode$i32,
			A2(
				$agu_z$elm_zip$Internal$Decode$with,
				$agu_z$elm_zip$Internal$Decode$i32,
				A2(
					$agu_z$elm_zip$Internal$Decode$with,
					$agu_z$elm_zip$Internal$Decode$i32,
					A2(
						$agu_z$elm_zip$Internal$Decode$with,
						$agu_z$elm_zip$Internal$Decode$compressionMethod,
						A2(
							$agu_z$elm_zip$Internal$Decode$with,
							$agu_z$elm_zip$Internal$Decode$i16,
							A2(
								$agu_z$elm_zip$Internal$Decode$with,
								$agu_z$elm_zip$Internal$Decode$i16,
								A2(
									$agu_z$elm_zip$Internal$Decode$with,
									$agu_z$elm_zip$Internal$Decode$i16,
									A2(
										$agu_z$elm_zip$Internal$Decode$checkSignature,
										33639248,
										$elm$bytes$Bytes$Decode$succeed($agu_z$elm_zip$Internal$Format$EntryMeta))))))))));
	var recordBounds = A2(
		$agu_z$elm_zip$Internal$Decode$with,
		$agu_z$elm_zip$Internal$Decode$i32,
		A2(
			$agu_z$elm_zip$Internal$Decode$with,
			$agu_z$elm_zip$Internal$Decode$i32,
			A2(
				$agu_z$elm_zip$Internal$Decode$with,
				A2($agu_z$elm_zip$Internal$Decode$after, 2, $agu_z$elm_zip$Internal$Decode$i16),
				A2(
					$agu_z$elm_zip$Internal$Decode$with,
					$agu_z$elm_zip$Internal$Decode$i16,
					A2(
						$agu_z$elm_zip$Internal$Decode$with,
						$agu_z$elm_zip$Internal$Decode$i16,
						A2(
							$agu_z$elm_zip$Internal$Decode$with,
							$agu_z$elm_zip$Internal$Decode$i16,
							$elm$bytes$Bytes$Decode$succeed($agu_z$elm_zip$Internal$Decode$CdRecordBounds)))))));
	var finish = function (_v0) {
		var makeMeta = _v0.a;
		var bounds = _v0.b;
		return A2(
			$elm$bytes$Bytes$Decode$map,
			$agu_z$elm_zip$Internal$Format$Entry(
				A2($agu_z$elm_zip$Internal$Format$Offset, bytes, bounds.startOffset)),
			A6(
				$elm$bytes$Bytes$Decode$map5,
				makeMeta,
				$elm$bytes$Bytes$Decode$string(bounds.nameLength),
				$elm$bytes$Bytes$Decode$bytes(bounds.extraFieldLength),
				$elm$bytes$Bytes$Decode$string(bounds.commentLength),
				$elm$bytes$Bytes$Decode$succeed(bounds.internalAttributes),
				$elm$bytes$Bytes$Decode$succeed(bounds.externalAttributes)));
	};
	return A2(
		$elm$bytes$Bytes$Decode$andThen,
		finish,
		A3($elm$bytes$Bytes$Decode$map2, $elm$core$Tuple$pair, start, recordBounds));
};
var $agu_z$elm_zip$Internal$Decode$CdBounds = F2(
	function (recordCount, start) {
		return {recordCount: recordCount, start: start};
	});
var $agu_z$elm_zip$Internal$Decode$findCdBounds = function (bytes) {
	var decoder = A2(
		$agu_z$elm_zip$Internal$Decode$with,
		A2($agu_z$elm_zip$Internal$Decode$after, 4, $agu_z$elm_zip$Internal$Decode$i32),
		A2(
			$agu_z$elm_zip$Internal$Decode$with,
			A2($agu_z$elm_zip$Internal$Decode$after, 6, $agu_z$elm_zip$Internal$Decode$i16),
			A2(
				$agu_z$elm_zip$Internal$Decode$checkSignature,
				101010256,
				$elm$bytes$Bytes$Decode$succeed($agu_z$elm_zip$Internal$Decode$CdBounds))));
	var attempt = function (offset) {
		attempt:
		while (true) {
			var _v0 = A2(
				$elm$bytes$Bytes$Decode$decode,
				A2($agu_z$elm_zip$Internal$Decode$after, offset, decoder),
				bytes);
			if (_v0.$ === 'Just') {
				var bounds = _v0.a;
				return $elm$core$Maybe$Just(bounds);
			} else {
				if (offset < 0) {
					return $elm$core$Maybe$Nothing;
				} else {
					var $temp$offset = offset - 1;
					offset = $temp$offset;
					continue attempt;
				}
			}
		}
	};
	return attempt(
		$elm$bytes$Bytes$width(bytes) - 22);
};
var $agu_z$elm_zip$Internal$Decode$listStep = F2(
	function (elementDecoder, _v0) {
		var n = _v0.a;
		var elements = _v0.b;
		return (n <= 0) ? $elm$bytes$Bytes$Decode$succeed(
			$elm$bytes$Bytes$Decode$Done(
				$elm$core$List$reverse(elements))) : A2(
			$elm$bytes$Bytes$Decode$map,
			function (element) {
				return $elm$bytes$Bytes$Decode$Loop(
					_Utils_Tuple2(
						n - 1,
						A2($elm$core$List$cons, element, elements)));
			},
			elementDecoder);
	});
var $agu_z$elm_zip$Internal$Decode$list = F2(
	function (length, aDecoder) {
		return A2(
			$elm$bytes$Bytes$Decode$loop,
			_Utils_Tuple2(length, _List_Nil),
			$agu_z$elm_zip$Internal$Decode$listStep(aDecoder));
	});
var $agu_z$elm_zip$Internal$Decode$readDirectory = function (bytes) {
	var topDecoder = function (bounds) {
		return A2(
			$agu_z$elm_zip$Internal$Decode$after,
			bounds.start,
			A2(
				$agu_z$elm_zip$Internal$Decode$list,
				bounds.recordCount,
				$agu_z$elm_zip$Internal$Decode$entryIn(bytes)));
	};
	return A2(
		$elm$core$Maybe$andThen,
		function (bounds) {
			return A2(
				$elm$bytes$Bytes$Decode$decode,
				topDecoder(bounds),
				bytes);
		},
		$agu_z$elm_zip$Internal$Decode$findCdBounds(bytes));
};
var $agu_z$elm_zip$Zip$fromBytes = function (bytes) {
	return A2(
		$elm$core$Maybe$map,
		$agu_z$elm_zip$Zip$Zip,
		$agu_z$elm_zip$Internal$Decode$readDirectory(bytes));
};
var $author$project$Builder$Http$getArchive = F5(
	function (manager, url, onError, err, onSuccess) {
		return A2(
			$author$project$Extra$System$Exception$handle,
			A2($author$project$Builder$Http$handleHttpException, url, onError),
			A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Extra$System$Http$parseUrlThrow(url),
				function (req0) {
					var req1 = _Utils_update(
						req0,
						{
							headers: $author$project$Builder$Http$addDefaultHeaders(_List_Nil),
							method: $author$project$Extra$System$Http$methodGet
						});
					return A3(
						$author$project$Extra$System$Http$withBytesResponse,
						req1,
						manager,
						function (response) {
							if (response.$ === 'Left') {
								var error = response.a;
								return $author$project$Extra$System$IO$return(
									$author$project$Extra$Type$Either$Left(error));
							} else {
								var bytes = response.a;
								var _v1 = $agu_z$elm_zip$Zip$fromBytes(bytes);
								if (_v1.$ === 'Nothing') {
									return $author$project$Extra$System$IO$return(
										$author$project$Extra$Type$Either$Right(
											$author$project$Extra$Type$Either$Left(err)));
								} else {
									var zip = _v1.a;
									return A2(
										$author$project$Extra$System$IO$fmap,
										$author$project$Extra$Type$Either$Right,
										onSuccess(zip));
								}
							}
						});
				}));
	});
var $agu_z$elm_zip$Zip$entries = function (_v0) {
	var allEntries = _v0.a;
	return allEntries;
};
var $author$project$Extra$Type$List$mapM_ = F4(
	function (pReturn, pBind, f, l) {
		return A5($author$project$Extra$Class$Foldable$mapM_, $author$project$Extra$Type$List$foldr, pReturn, pBind, f, l);
	});
var $agu_z$elm_zip$Zip$Entry$path = function (_v0) {
	var record = _v0.b;
	return record.fileName;
};
var $elm$core$String$isEmpty = function (string) {
	return string === '';
};
var $agu_z$elm_zip$Zip$Entry$DecodeError = {$: 'DecodeError'};
var $agu_z$elm_zip$Zip$Entry$InflateError = {$: 'InflateError'};
var $agu_z$elm_zip$Zip$Entry$UnsupportedCompression = F2(
	function (a, b) {
		return {$: 'UnsupportedCompression', a: a, b: b};
	});
var $elm$core$Result$andThen = F2(
	function (callback, result) {
		if (result.$ === 'Ok') {
			var value = result.a;
			return callback(value);
		} else {
			var msg = result.a;
			return $elm$core$Result$Err(msg);
		}
	});
var $elm$core$Result$fromMaybe = F2(
	function (err, maybe) {
		if (maybe.$ === 'Just') {
			var v = maybe.a;
			return $elm$core$Result$Ok(v);
		} else {
			return $elm$core$Result$Err(err);
		}
	});
var $elm$bytes$Bytes$Encode$Bytes = function (a) {
	return {$: 'Bytes', a: a};
};
var $elm$bytes$Bytes$Encode$bytes = $elm$bytes$Bytes$Encode$Bytes;
var $folkertdev$elm_flate$Inflate$BitReader$decode = F2(
	function (bytes, _v0) {
		var reader = _v0.a;
		var initialState = {bitsAvailable: 0, buffer: bytes, reserve: 0, reserveAvailable: 0, tag: 0};
		var _v1 = reader(initialState);
		if (_v1.$ === 'Ok') {
			var _v2 = _v1.a;
			var value = _v2.a;
			return $elm$core$Result$Ok(value);
		} else {
			var e = _v1.a;
			return $elm$core$Result$Err(e);
		}
	});
var $folkertdev$elm_flate$Experimental$ByteArray$ByteArray = F3(
	function (a, b, c) {
		return {$: 'ByteArray', a: a, b: b, c: c};
	});
var $folkertdev$elm_flate$Experimental$ByteArray$empty = A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, $elm$core$Array$empty, 0, 0);
var $folkertdev$elm_flate$Inflate$BitReader$BitReader = function (a) {
	return {$: 'BitReader', a: a};
};
var $folkertdev$elm_flate$Inflate$BitReader$loopHelp = F3(
	function (accum, callback, state) {
		loopHelp:
		while (true) {
			var _v0 = callback(accum);
			var decoder = _v0.a;
			var _v1 = decoder(state);
			if (_v1.$ === 'Err') {
				var e = _v1.a;
				return $elm$core$Result$Err(e);
			} else {
				if (_v1.a.a.$ === 'Loop') {
					var _v2 = _v1.a;
					var newAccum = _v2.a.a;
					var newState = _v2.b;
					var $temp$accum = newAccum,
						$temp$callback = callback,
						$temp$state = newState;
					accum = $temp$accum;
					callback = $temp$callback;
					state = $temp$state;
					continue loopHelp;
				} else {
					var _v3 = _v1.a;
					var result = _v3.a.a;
					var newState = _v3.b;
					return $elm$core$Result$Ok(
						_Utils_Tuple2(result, newState));
				}
			}
		}
	});
var $folkertdev$elm_flate$Inflate$BitReader$loop = F2(
	function (state, callback) {
		return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
			A2($folkertdev$elm_flate$Inflate$BitReader$loopHelp, state, callback));
	});
var $folkertdev$elm_flate$Inflate$BitReader$map = F2(
	function (f, _v0) {
		var g = _v0.a;
		return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
			function (s) {
				var _v1 = g(s);
				if (_v1.$ === 'Ok') {
					var _v2 = _v1.a;
					var value = _v2.a;
					var newState = _v2.b;
					return $elm$core$Result$Ok(
						_Utils_Tuple2(
							f(value),
							newState));
				} else {
					var e = _v1.a;
					return $elm$core$Result$Err(e);
				}
			});
	});
var $folkertdev$elm_flate$Experimental$ByteArray$toBytes = function (_v0) {
	var array = _v0.a;
	var finalSize = _v0.b;
	var finalBytes = _v0.c;
	var initial = function () {
		var finalInt32 = finalBytes >>> ((4 - finalSize) * 8);
		switch (finalSize) {
			case 4:
				return _List_fromArray(
					[
						A2($elm$bytes$Bytes$Encode$unsignedInt32, $elm$bytes$Bytes$BE, finalBytes)
					]);
			case 1:
				return _List_fromArray(
					[
						$elm$bytes$Bytes$Encode$unsignedInt8(finalInt32)
					]);
			case 2:
				return _List_fromArray(
					[
						A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$BE, finalInt32)
					]);
			case 3:
				return _List_fromArray(
					[
						A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$BE, finalInt32 >> 8),
						$elm$bytes$Bytes$Encode$unsignedInt8(255 & finalInt32)
					]);
			default:
				return _List_Nil;
		}
	}();
	var folder = F2(
		function (element, accum) {
			return A2(
				$elm$core$List$cons,
				A2($elm$bytes$Bytes$Encode$unsignedInt32, $elm$bytes$Bytes$BE, element),
				accum);
		});
	return $elm$bytes$Bytes$Encode$encode(
		$elm$bytes$Bytes$Encode$sequence(
			A3($elm$core$Array$foldr, folder, initial, array)));
};
var $folkertdev$elm_flate$Inflate$BitReader$andThen = F2(
	function (f, _v0) {
		var g = _v0.a;
		return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
			function (s) {
				var _v1 = g(s);
				if (_v1.$ === 'Ok') {
					var _v2 = _v1.a;
					var value = _v2.a;
					var newState = _v2.b;
					var _v3 = f(value);
					var h = _v3.a;
					return h(newState);
				} else {
					var e = _v1.a;
					return $elm$core$Result$Err(e);
				}
			});
	});
var $elm$core$Bitwise$or = _Bitwise_or;
var $elm$core$Elm$JsArray$push = _JsArray_push;
var $elm$core$Elm$JsArray$singleton = _JsArray_singleton;
var $elm$core$Array$insertTailInTree = F4(
	function (shift, index, tail, tree) {
		var pos = $elm$core$Array$bitMask & (index >>> shift);
		if (_Utils_cmp(
			pos,
			$elm$core$Elm$JsArray$length(tree)) > -1) {
			if (shift === 5) {
				return A2(
					$elm$core$Elm$JsArray$push,
					$elm$core$Array$Leaf(tail),
					tree);
			} else {
				var newSub = $elm$core$Array$SubTree(
					A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, $elm$core$Elm$JsArray$empty));
				return A2($elm$core$Elm$JsArray$push, newSub, tree);
			}
		} else {
			var value = A2($elm$core$Elm$JsArray$unsafeGet, pos, tree);
			if (value.$ === 'SubTree') {
				var subTree = value.a;
				var newSub = $elm$core$Array$SubTree(
					A4($elm$core$Array$insertTailInTree, shift - $elm$core$Array$shiftStep, index, tail, subTree));
				return A3($elm$core$Elm$JsArray$unsafeSet, pos, newSub, tree);
			} else {
				var newSub = $elm$core$Array$SubTree(
					A4(
						$elm$core$Array$insertTailInTree,
						shift - $elm$core$Array$shiftStep,
						index,
						tail,
						$elm$core$Elm$JsArray$singleton(value)));
				return A3($elm$core$Elm$JsArray$unsafeSet, pos, newSub, tree);
			}
		}
	});
var $elm$core$Array$unsafeReplaceTail = F2(
	function (newTail, _v0) {
		var len = _v0.a;
		var startShift = _v0.b;
		var tree = _v0.c;
		var tail = _v0.d;
		var originalTailLen = $elm$core$Elm$JsArray$length(tail);
		var newTailLen = $elm$core$Elm$JsArray$length(newTail);
		var newArrayLen = len + (newTailLen - originalTailLen);
		if (_Utils_eq(newTailLen, $elm$core$Array$branchFactor)) {
			var overflow = _Utils_cmp(newArrayLen >>> $elm$core$Array$shiftStep, 1 << startShift) > 0;
			if (overflow) {
				var newShift = startShift + $elm$core$Array$shiftStep;
				var newTree = A4(
					$elm$core$Array$insertTailInTree,
					newShift,
					len,
					newTail,
					$elm$core$Elm$JsArray$singleton(
						$elm$core$Array$SubTree(tree)));
				return A4($elm$core$Array$Array_elm_builtin, newArrayLen, newShift, newTree, $elm$core$Elm$JsArray$empty);
			} else {
				return A4(
					$elm$core$Array$Array_elm_builtin,
					newArrayLen,
					startShift,
					A4($elm$core$Array$insertTailInTree, startShift, len, newTail, tree),
					$elm$core$Elm$JsArray$empty);
			}
		} else {
			return A4($elm$core$Array$Array_elm_builtin, newArrayLen, startShift, tree, newTail);
		}
	});
var $elm$core$Array$push = F2(
	function (a, array) {
		var tail = array.d;
		return A2(
			$elm$core$Array$unsafeReplaceTail,
			A2($elm$core$Elm$JsArray$push, a, tail),
			array);
	});
var $folkertdev$elm_flate$Experimental$ByteArray$push = F2(
	function (value, input) {
		var array = input.a;
		var finalSize = input.b;
		var finalBytes = input.c;
		if (finalSize === 4) {
			return A3(
				$folkertdev$elm_flate$Experimental$ByteArray$ByteArray,
				A2($elm$core$Array$push, finalBytes, array),
				1,
				value << 24);
		} else {
			if (!finalSize) {
				return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, 1, value << 24);
			} else {
				var offset = finalSize;
				var internalIndex = $elm$core$Array$length(array) - 1;
				var _new = ((255 & value) << ((3 - offset) * 8)) | finalBytes;
				var mask = 4278190080 >>> (offset * 8);
				return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize + 1, _new);
			}
		}
	});
var $folkertdev$elm_flate$Experimental$ByteArray$pushMany = F3(
	function (nbytes, value_, input) {
		var array = input.a;
		var finalSize = input.b;
		var finalBytes = input.c;
		var value = (nbytes === 4) ? value_ : (((1 << (nbytes * 8)) - 1) & value_);
		if (!nbytes) {
			return input;
		} else {
			if (finalSize === 4) {
				return A3(
					$folkertdev$elm_flate$Experimental$ByteArray$ByteArray,
					A2($elm$core$Array$push, finalBytes, array),
					nbytes,
					value << ((4 - nbytes) * 8));
			} else {
				if (!finalSize) {
					return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, nbytes, value << ((4 - nbytes) * 8));
				} else {
					var freeSpace = 4 - finalSize;
					if (_Utils_cmp(nbytes, freeSpace) > 0) {
						var bytesLeftOver = (finalSize + nbytes) - 4;
						var forFinal = value >>> (bytesLeftOver * 8);
						var newFinal = finalBytes | forFinal;
						var amount = ((8 - finalSize) - nbytes) * 8;
						var forNextFinal = (((1 << (bytesLeftOver * 8)) - 1) & value) << amount;
						return A3(
							$folkertdev$elm_flate$Experimental$ByteArray$ByteArray,
							A2($elm$core$Array$push, newFinal, array),
							nbytes - freeSpace,
							forNextFinal);
					} else {
						var amount = (4 - (finalSize + nbytes)) * 8;
						var forFinal = value << amount;
						var newFinal = finalBytes | forFinal;
						return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize + nbytes, newFinal);
					}
				}
			}
		}
	});
var $folkertdev$elm_flate$Experimental$ByteArray$appendBytesHelp = function (_v0) {
	var remaining = _v0.a;
	var bytearray = _v0.b;
	var array = bytearray.a;
	var finalSize = bytearray.b;
	var finalBytes = bytearray.c;
	return (remaining >= 4) ? A2(
		$elm$bytes$Bytes$Decode$map,
		function (_new) {
			return $elm$bytes$Bytes$Decode$Loop(
				_Utils_Tuple2(
					remaining - 4,
					A3($folkertdev$elm_flate$Experimental$ByteArray$pushMany, 4, _new, bytearray)));
		},
		$elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$BE)) : ((remaining >= 1) ? A2(
		$elm$bytes$Bytes$Decode$map,
		function (_new) {
			return $elm$bytes$Bytes$Decode$Loop(
				_Utils_Tuple2(
					remaining - 1,
					A2($folkertdev$elm_flate$Experimental$ByteArray$push, _new, bytearray)));
		},
		$elm$bytes$Bytes$Decode$unsignedInt8) : $elm$bytes$Bytes$Decode$succeed(
		$elm$bytes$Bytes$Decode$Done(bytearray)));
};
var $folkertdev$elm_flate$Experimental$ByteArray$appendBytes = F2(
	function (bytes, barray) {
		var array = barray.a;
		var finalSize = barray.b;
		var finalBytes = barray.c;
		var decoder = A2(
			$elm$bytes$Bytes$Decode$loop,
			_Utils_Tuple2(
				$elm$bytes$Bytes$width(bytes),
				barray),
			$folkertdev$elm_flate$Experimental$ByteArray$appendBytesHelp);
		var _v0 = A2($elm$bytes$Bytes$Decode$decode, decoder, bytes);
		if (_v0.$ === 'Just') {
			var v = _v0.a;
			return v;
		} else {
			return barray;
		}
	});
var $folkertdev$elm_flate$Inflate$Internal$buildTree = F3(
	function (lengths, offset, num) {
		var tableDict = function () {
			var updater = function (maybeValue) {
				if (maybeValue.$ === 'Nothing') {
					return $elm$core$Maybe$Just(1);
				} else {
					var v = maybeValue.a;
					return $elm$core$Maybe$Just(v + 1);
				}
			};
			var folder = F3(
				function (key, value, accum) {
					return ((_Utils_cmp(key, offset) > -1) && (_Utils_cmp(key, num + offset) < 0)) ? A3($elm$core$Dict$update, value, updater, accum) : accum;
				});
			return A3($elm$core$Dict$foldl, folder, $elm$core$Dict$empty, lengths);
		}();
		var offsetsDict = A3(
			$elm$core$Dict$foldl,
			F3(
				function (key, value, _v4) {
					var sum = _v4.a;
					var dict = _v4.b;
					return _Utils_Tuple2(
						sum + value,
						A3($elm$core$Dict$insert, key, sum, dict));
				}),
			_Utils_Tuple2(0, $elm$core$Dict$empty),
			tableDict);
		var newTable = function () {
			var helper = F4(
				function (key, value, i, array) {
					helper:
					while (true) {
						if (_Utils_cmp(i, key) > 0) {
							var $temp$key = key,
								$temp$value = value,
								$temp$i = i - 1,
								$temp$array = A2($elm$core$List$cons, 0, array);
							key = $temp$key;
							value = $temp$value;
							i = $temp$i;
							array = $temp$array;
							continue helper;
						} else {
							return A2($elm$core$List$cons, value, array);
						}
					}
				});
			var foldHelp = F3(
				function (key, value, _v3) {
					var i = _v3.a;
					var array = _v3.b;
					return _Utils_Tuple2(
						key - 1,
						A4(helper, key, value, i, array));
				});
			var anotherGo = F2(
				function (i, array) {
					anotherGo:
					while (true) {
						if (i >= 0) {
							var $temp$i = i - 1,
								$temp$array = A2($elm$core$List$cons, 0, array);
							i = $temp$i;
							array = $temp$array;
							continue anotherGo;
						} else {
							return array;
						}
					}
				});
			return function (_v2) {
				var a = _v2.a;
				var b = _v2.b;
				return A2(anotherGo, a, b);
			}(
				A3(
					$elm$core$Dict$foldr,
					foldHelp,
					_Utils_Tuple2(15, _List_Nil),
					tableDict));
		}();
		var go2 = F3(
			function (i, currentTranslation, currentOffsets) {
				go2:
				while (true) {
					if ((i - num) < 0) {
						var _v0 = A2($elm$core$Dict$get, offset + i, lengths);
						if (_v0.$ === 'Nothing') {
							var $temp$i = i + 1,
								$temp$currentTranslation = currentTranslation,
								$temp$currentOffsets = currentOffsets;
							i = $temp$i;
							currentTranslation = $temp$currentTranslation;
							currentOffsets = $temp$currentOffsets;
							continue go2;
						} else {
							var v = _v0.a;
							if (!(!v)) {
								var _v1 = A2($elm$core$Dict$get, v, currentOffsets);
								if (_v1.$ === 'Nothing') {
									return currentTranslation;
								} else {
									var w = _v1.a;
									var $temp$i = i + 1,
										$temp$currentTranslation = A3($elm$core$Array$set, w, i, currentTranslation),
										$temp$currentOffsets = A3($elm$core$Dict$insert, v, w + 1, currentOffsets);
									i = $temp$i;
									currentTranslation = $temp$currentTranslation;
									currentOffsets = $temp$currentOffsets;
									continue go2;
								}
							} else {
								var $temp$i = i + 1,
									$temp$currentTranslation = currentTranslation,
									$temp$currentOffsets = currentOffsets;
								i = $temp$i;
								currentTranslation = $temp$currentTranslation;
								currentOffsets = $temp$currentOffsets;
								continue go2;
							}
						}
					} else {
						return currentTranslation;
					}
				}
			});
		var translation2 = A3(
			go2,
			0,
			A2($elm$core$Array$repeat, num, 0),
			offsetsDict.b);
		return {table: newTable, trans: translation2};
	});
var $folkertdev$elm_flate$Inflate$Internal$clcIndices = _List_fromArray(
	[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var $folkertdev$elm_flate$Inflate$BitSet$BitSet320 = function (a) {
	return function (b) {
		return function (c) {
			return function (d) {
				return function (e) {
					return function (f) {
						return function (g) {
							return function (h) {
								return function (i) {
									return function (j) {
										return {$: 'BitSet320', a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h, i: i, j: j};
									};
								};
							};
						};
					};
				};
			};
		};
	};
};
var $folkertdev$elm_flate$Inflate$BitSet$insert = F2(
	function (n, input) {
		var b1 = input.a;
		var b2 = input.b;
		var b3 = input.c;
		var b4 = input.d;
		var b5 = input.e;
		var b6 = input.f;
		var b7 = input.g;
		var b8 = input.h;
		var b9 = input.i;
		var b10 = input.j;
		if (n >= 320) {
			return input;
		} else {
			var bit = 1 << (n % 32);
			var _v0 = (n / 32) | 0;
			switch (_v0) {
				case 0:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(bit | b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 1:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(bit | b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 2:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(bit | b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 3:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(bit | b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 4:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(bit | b5)(b6)(b7)(b8)(b9)(b10);
				case 5:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(bit | b6)(b7)(b8)(b9)(b10);
				case 6:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(bit | b7)(b8)(b9)(b10);
				case 7:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(b7)(bit | b8)(b9)(b10);
				case 8:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(bit | b9)(b10);
				case 9:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(bit | b10);
				default:
					return input;
			}
		}
	});
var $folkertdev$elm_flate$Inflate$BitSet$member = F2(
	function (n, input) {
		var b1 = input.a;
		var b2 = input.b;
		var b3 = input.c;
		var b4 = input.d;
		var b5 = input.e;
		var b6 = input.f;
		var b7 = input.g;
		var b8 = input.h;
		var b9 = input.i;
		var b10 = input.j;
		if (n >= 320) {
			return false;
		} else {
			var bit = 1 << (n % 32);
			var _v0 = (n / 32) | 0;
			switch (_v0) {
				case 0:
					return (bit & b1) > 0;
				case 1:
					return (bit & b2) > 0;
				case 2:
					return (bit & b3) > 0;
				case 3:
					return (bit & b4) > 0;
				case 4:
					return (bit & b5) > 0;
				case 5:
					return (bit & b6) > 0;
				case 6:
					return (bit & b7) > 0;
				case 7:
					return (bit & b8) > 0;
				case 8:
					return (bit & b9) > 0;
				case 9:
					return (bit & b10) > 0;
				default:
					return false;
			}
		}
	});
var $elm$core$Bitwise$complement = _Bitwise_complement;
var $folkertdev$elm_flate$Inflate$BitSet$remove = F2(
	function (n, input) {
		var b1 = input.a;
		var b2 = input.b;
		var b3 = input.c;
		var b4 = input.d;
		var b5 = input.e;
		var b6 = input.f;
		var b7 = input.g;
		var b8 = input.h;
		var b9 = input.i;
		var b10 = input.j;
		if (n >= 320) {
			return input;
		} else {
			var bit = ~(1 << (n % 32));
			var _v0 = (n / 32) | 0;
			switch (_v0) {
				case 0:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(bit & b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 1:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(bit & b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 2:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(bit & b3)(b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 3:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(bit & b4)(b5)(b6)(b7)(b8)(b9)(b10);
				case 4:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(bit & b5)(b6)(b7)(b8)(b9)(b10);
				case 5:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(bit & b6)(b7)(b8)(b9)(b10);
				case 6:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(bit & b7)(b8)(b9)(b10);
				case 7:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(b7)(bit & b8)(b9)(b10);
				case 8:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(bit & b9)(b10);
				case 9:
					return $folkertdev$elm_flate$Inflate$BitSet$BitSet320(b1)(b2)(b3)(b4)(b5)(b6)(b7)(b8)(b9)(bit & b10);
				default:
					return input;
			}
		}
	});
var $folkertdev$elm_flate$Inflate$Internal$copySegment = F5(
	function (i, value, bitset, lengths, length) {
		var end = i + length;
		var go = F3(
			function (j, currentBitSet, accum) {
				go:
				while (true) {
					if ((j - end) < 0) {
						if (!(!value)) {
							var $temp$j = j + 1,
								$temp$currentBitSet = A2($folkertdev$elm_flate$Inflate$BitSet$insert, j, currentBitSet),
								$temp$accum = A3($elm$core$Dict$insert, j, value, accum);
							j = $temp$j;
							currentBitSet = $temp$currentBitSet;
							accum = $temp$accum;
							continue go;
						} else {
							if (A2($folkertdev$elm_flate$Inflate$BitSet$member, j, currentBitSet)) {
								var $temp$j = j + 1,
									$temp$currentBitSet = A2($folkertdev$elm_flate$Inflate$BitSet$remove, j, currentBitSet),
									$temp$accum = A2($elm$core$Dict$remove, j, accum);
								j = $temp$j;
								currentBitSet = $temp$currentBitSet;
								accum = $temp$accum;
								continue go;
							} else {
								var $temp$j = j + 1,
									$temp$currentBitSet = currentBitSet,
									$temp$accum = accum;
								j = $temp$j;
								currentBitSet = $temp$currentBitSet;
								accum = $temp$accum;
								continue go;
							}
						}
					} else {
						return _Utils_Tuple2(currentBitSet, accum);
					}
				}
			});
		var _v0 = A3(go, i, bitset, lengths);
		var newBitSet = _v0.a;
		var newLengths = _v0.b;
		return _Utils_Tuple3(i + length, newBitSet, newLengths);
	});
var $folkertdev$elm_flate$Inflate$Internal$decodeSymbolInnerLoop = F5(
	function (table, cur, tag, bitsAvailable, sum) {
		decodeSymbolInnerLoop:
		while (true) {
			var newTag = tag >>> 1;
			if (!table.b) {
				return {bitsAvailable: bitsAvailable, cur: cur, sum: sum, tag: tag};
			} else {
				var value = table.a;
				var rest = table.b;
				var newerCur = ((cur << 1) + (tag & 1)) - value;
				var newSum = sum + value;
				if (newerCur >= 0) {
					var $temp$table = rest,
						$temp$cur = newerCur,
						$temp$tag = newTag,
						$temp$bitsAvailable = bitsAvailable - 1,
						$temp$sum = newSum;
					table = $temp$table;
					cur = $temp$cur;
					tag = $temp$tag;
					bitsAvailable = $temp$bitsAvailable;
					sum = $temp$sum;
					continue decodeSymbolInnerLoop;
				} else {
					return {bitsAvailable: bitsAvailable - 1, cur: newerCur, sum: newSum, tag: newTag};
				}
			}
		}
	});
var $folkertdev$elm_flate$Inflate$BitReader$moveFromReserve = F2(
	function (nbits, state) {
		var masked = (nbits === 32) ? (state.reserve << state.bitsAvailable) : ((((1 << nbits) - 1) & state.reserve) << state.bitsAvailable);
		return {bitsAvailable: state.bitsAvailable + nbits, buffer: state.buffer, reserve: state.reserve >>> nbits, reserveAvailable: state.reserveAvailable - nbits, tag: masked | state.tag};
	});
var $folkertdev$elm_flate$Inflate$BitReader$runDecoder = F3(
	function (width, valueDecoder, state) {
		var decoder = A3(
			$elm$bytes$Bytes$Decode$map2,
			$elm$core$Tuple$pair,
			valueDecoder,
			$elm$bytes$Bytes$Decode$bytes(
				$elm$bytes$Bytes$width(state.buffer) - width));
		var _v0 = A2($elm$bytes$Bytes$Decode$decode, decoder, state.buffer);
		if (_v0.$ === 'Just') {
			var value = _v0.a;
			return $elm$core$Result$Ok(value);
		} else {
			return $elm$core$Result$Err('BitReader.runDecoder: Unexpected end of Bytes');
		}
	});
var $folkertdev$elm_flate$Inflate$BitReader$unsignedInt24 = function (endianness) {
	if (endianness.$ === 'LE') {
		return A3(
			$elm$bytes$Bytes$Decode$map2,
			F2(
				function (b2, b1) {
					return (b1 << 16) | b2;
				}),
			$elm$bytes$Bytes$Decode$unsignedInt16(endianness),
			$elm$bytes$Bytes$Decode$unsignedInt8);
	} else {
		return A3(
			$elm$bytes$Bytes$Decode$map2,
			F2(
				function (b1, b2) {
					return (b1 << 16) | b2;
				}),
			$elm$bytes$Bytes$Decode$unsignedInt16(endianness),
			$elm$bytes$Bytes$Decode$unsignedInt8);
	}
};
var $folkertdev$elm_flate$Inflate$BitReader$readMoreBits = function (state) {
	readMoreBits:
	while (true) {
		var freeSpaceOnTag = 32 - state.bitsAvailable;
		if ((_Utils_cmp(freeSpaceOnTag, state.reserveAvailable) < 1) && (state.reserveAvailable > 0)) {
			return $elm$core$Result$Ok(
				A2($folkertdev$elm_flate$Inflate$BitReader$moveFromReserve, freeSpaceOnTag, state));
		} else {
			if (!$elm$bytes$Bytes$width(state.buffer)) {
				return $elm$core$Result$Ok(
					A2($folkertdev$elm_flate$Inflate$BitReader$moveFromReserve, state.reserveAvailable, state));
			} else {
				var state1 = A2($folkertdev$elm_flate$Inflate$BitReader$moveFromReserve, state.reserveAvailable, state);
				var _v0 = function () {
					var _v1 = $elm$bytes$Bytes$width(state.buffer);
					switch (_v1) {
						case 0:
							return _Utils_Tuple3(
								0,
								0,
								$elm$bytes$Bytes$Decode$succeed(0));
						case 1:
							return _Utils_Tuple3(1, 8, $elm$bytes$Bytes$Decode$unsignedInt8);
						case 2:
							return _Utils_Tuple3(
								2,
								16,
								$elm$bytes$Bytes$Decode$unsignedInt16($elm$bytes$Bytes$LE));
						case 3:
							return _Utils_Tuple3(
								3,
								24,
								$folkertdev$elm_flate$Inflate$BitReader$unsignedInt24($elm$bytes$Bytes$LE));
						default:
							return _Utils_Tuple3(
								4,
								32,
								$elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$LE));
					}
				}();
				var width = _v0.a;
				var additionallyAvailable = _v0.b;
				var decoder = _v0.c;
				var _v2 = A3($folkertdev$elm_flate$Inflate$BitReader$runDecoder, width, decoder, state1);
				if (_v2.$ === 'Err') {
					var e = _v2.a;
					return $elm$core$Result$Err(e);
				} else {
					var _v3 = _v2.a;
					var newReserve = _v3.a;
					var newBuffer = _v3.b;
					var $temp$state = {bitsAvailable: state1.bitsAvailable, buffer: newBuffer, reserve: newReserve, reserveAvailable: additionallyAvailable, tag: state1.tag};
					state = $temp$state;
					continue readMoreBits;
				}
			}
		}
	}
};
var $folkertdev$elm_flate$Inflate$Internal$decodeSymbol = F2(
	function (table, tree) {
		return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
			function (state) {
				var _v0 = (state.bitsAvailable < 16) ? $folkertdev$elm_flate$Inflate$BitReader$readMoreBits(state) : $elm$core$Result$Ok(state);
				if (_v0.$ === 'Err') {
					var e = _v0.a;
					return $elm$core$Result$Err(e);
				} else {
					var d = _v0.a;
					var _v1 = A5($folkertdev$elm_flate$Inflate$Internal$decodeSymbolInnerLoop, table, 0, d.tag, d.bitsAvailable, 0);
					var cur = _v1.cur;
					var tag = _v1.tag;
					var bitsAvailable = _v1.bitsAvailable;
					var sum = _v1.sum;
					var _v2 = A2($elm$core$Array$get, sum + cur, tree.trans);
					if (_v2.$ === 'Nothing') {
						return $elm$core$Result$Err('Index into trans tree out of bounds');
					} else {
						var result = _v2.a;
						return $elm$core$Result$Ok(
							_Utils_Tuple2(
								result,
								{bitsAvailable: bitsAvailable, buffer: d.buffer, reserve: d.reserve, reserveAvailable: d.reserveAvailable, tag: tag}));
					}
				}
			});
	});
var $folkertdev$elm_flate$Inflate$BitReader$readBits = F2(
	function (numberOfBits, base) {
		return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
			function (state) {
				if (!numberOfBits) {
					return $elm$core$Result$Ok(
						_Utils_Tuple2(base, state));
				} else {
					var _v0 = (_Utils_cmp(state.bitsAvailable, numberOfBits) < 0) ? $folkertdev$elm_flate$Inflate$BitReader$readMoreBits(state) : $elm$core$Result$Ok(state);
					if (_v0.$ === 'Err') {
						var e = _v0.a;
						return $elm$core$Result$Err(e);
					} else {
						var d = _v0.a;
						var val = d.tag & (65535 >>> (16 - numberOfBits));
						var newTag = d.tag >>> numberOfBits;
						return $elm$core$Result$Ok(
							_Utils_Tuple2(
								val + base,
								{bitsAvailable: d.bitsAvailable - numberOfBits, buffer: d.buffer, reserve: d.reserve, reserveAvailable: d.reserveAvailable, tag: newTag}));
					}
				}
			});
	});
var $folkertdev$elm_flate$Inflate$BitReader$succeed = function (x) {
	return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
		function (s) {
			return $elm$core$Result$Ok(
				_Utils_Tuple2(x, s));
		});
};
var $elm$core$List$tail = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(xs);
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $folkertdev$elm_flate$Inflate$Internal$decodeDynamicTreeLength = F4(
	function (codeTree, hlit, hdist, _v0) {
		var i = _v0.a;
		var bitset = _v0.b;
		var lengths = _v0.c;
		if (_Utils_cmp(i, hlit + hdist) < 0) {
			var table = A2(
				$elm$core$Maybe$withDefault,
				_List_Nil,
				$elm$core$List$tail(codeTree.table));
			return A2(
				$folkertdev$elm_flate$Inflate$BitReader$andThen,
				function (sym) {
					switch (sym) {
						case 16:
							var prev = A2(
								$elm$core$Maybe$withDefault,
								0,
								A2($elm$core$Dict$get, i - 1, lengths));
							return A2(
								$folkertdev$elm_flate$Inflate$BitReader$map,
								A2(
									$elm$core$Basics$composeR,
									A4($folkertdev$elm_flate$Inflate$Internal$copySegment, i, prev, bitset, lengths),
									$elm$bytes$Bytes$Decode$Loop),
								A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 2, 3));
						case 17:
							return A2(
								$folkertdev$elm_flate$Inflate$BitReader$map,
								A2(
									$elm$core$Basics$composeR,
									A4($folkertdev$elm_flate$Inflate$Internal$copySegment, i, 0, bitset, lengths),
									$elm$bytes$Bytes$Decode$Loop),
								A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 3, 3));
						case 18:
							return A2(
								$folkertdev$elm_flate$Inflate$BitReader$map,
								A2(
									$elm$core$Basics$composeR,
									A4($folkertdev$elm_flate$Inflate$Internal$copySegment, i, 0, bitset, lengths),
									$elm$bytes$Bytes$Decode$Loop),
								A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 7, 11));
						case 0:
							return A2($folkertdev$elm_flate$Inflate$BitSet$member, i, bitset) ? $folkertdev$elm_flate$Inflate$BitReader$succeed(
								$elm$bytes$Bytes$Decode$Loop(
									_Utils_Tuple3(
										i + 1,
										bitset,
										A2($elm$core$Dict$remove, i, lengths)))) : $folkertdev$elm_flate$Inflate$BitReader$succeed(
								$elm$bytes$Bytes$Decode$Loop(
									_Utils_Tuple3(i + 1, bitset, lengths)));
						default:
							return $folkertdev$elm_flate$Inflate$BitReader$succeed(
								$elm$bytes$Bytes$Decode$Loop(
									_Utils_Tuple3(
										i + 1,
										A2($folkertdev$elm_flate$Inflate$BitSet$insert, i, bitset),
										A3($elm$core$Dict$insert, i, sym, lengths))));
					}
				},
				A2($folkertdev$elm_flate$Inflate$Internal$decodeSymbol, table, codeTree));
		} else {
			return $folkertdev$elm_flate$Inflate$BitReader$succeed(
				$elm$bytes$Bytes$Decode$Done(lengths));
		}
	});
var $folkertdev$elm_flate$Inflate$BitSet$empty = $folkertdev$elm_flate$Inflate$BitSet$BitSet320(0)(0)(0)(0)(0)(0)(0)(0)(0)(0);
var $folkertdev$elm_flate$Inflate$Internal$decodeTreeLengths = F4(
	function (hlit, hdist, hclen, codeLengths) {
		var clcs = A2($elm$core$List$take, hclen, $folkertdev$elm_flate$Inflate$Internal$clcIndices);
		var initialLengths = function () {
			var go = F3(
				function (xs, ys, accum) {
					go:
					while (true) {
						if (!xs.b) {
							return accum;
						} else {
							var index = xs.a;
							var restIndex = xs.b;
							if (!ys.b) {
								return accum;
							} else {
								var codeLength = ys.a;
								var restCodeLength = ys.b;
								if (!(!codeLength)) {
									var $temp$xs = restIndex,
										$temp$ys = restCodeLength,
										$temp$accum = A3($elm$core$Dict$insert, index, codeLength, accum);
									xs = $temp$xs;
									ys = $temp$ys;
									accum = $temp$accum;
									continue go;
								} else {
									var $temp$xs = restIndex,
										$temp$ys = restCodeLength,
										$temp$accum = accum;
									xs = $temp$xs;
									ys = $temp$ys;
									accum = $temp$accum;
									continue go;
								}
							}
						}
					}
				});
			return A3(go, clcs, codeLengths, $elm$core$Dict$empty);
		}();
		var codeTree = A3($folkertdev$elm_flate$Inflate$Internal$buildTree, initialLengths, 0, 19);
		var initialBitSet = A3(
			$elm$core$Dict$foldl,
			F2(
				function (i, _v0) {
					return $folkertdev$elm_flate$Inflate$BitSet$insert(i);
				}),
			$folkertdev$elm_flate$Inflate$BitSet$empty,
			initialLengths);
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$loop,
			_Utils_Tuple3(0, initialBitSet, initialLengths),
			A3($folkertdev$elm_flate$Inflate$Internal$decodeDynamicTreeLength, codeTree, hlit, hdist));
	});
var $folkertdev$elm_flate$Inflate$BitReader$exactly = F2(
	function (tableCount, decoder) {
		var helper = function (_v0) {
			var n = _v0.a;
			var xs = _v0.b;
			return (n <= 0) ? $folkertdev$elm_flate$Inflate$BitReader$succeed(
				$elm$bytes$Bytes$Decode$Done(
					$elm$core$List$reverse(xs))) : A2(
				$folkertdev$elm_flate$Inflate$BitReader$map,
				function (x) {
					return $elm$bytes$Bytes$Decode$Loop(
						_Utils_Tuple2(
							n - 1,
							A2($elm$core$List$cons, x, xs)));
				},
				decoder);
		};
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$loop,
			_Utils_Tuple2(tableCount, _List_Nil),
			helper);
	});
var $folkertdev$elm_flate$Inflate$Internal$cont = F3(
	function (hlit, hdist, hclen) {
		var buildTrees = function (lengths) {
			return _Utils_Tuple2(
				A3($folkertdev$elm_flate$Inflate$Internal$buildTree, lengths, 0, hlit),
				A3($folkertdev$elm_flate$Inflate$Internal$buildTree, lengths, hlit, hdist));
		};
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$map,
			buildTrees,
			A2(
				$folkertdev$elm_flate$Inflate$BitReader$andThen,
				A3($folkertdev$elm_flate$Inflate$Internal$decodeTreeLengths, hlit, hdist, hclen),
				A2(
					$folkertdev$elm_flate$Inflate$BitReader$exactly,
					hclen,
					A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 3, 0))));
	});
var $folkertdev$elm_flate$Inflate$BitReader$map2 = F3(
	function (f, _v0, _v1) {
		var fa = _v0.a;
		var fb = _v1.a;
		return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
			function (state) {
				var _v2 = fa(state);
				if (_v2.$ === 'Err') {
					var e = _v2.a;
					return $elm$core$Result$Err(e);
				} else {
					var _v3 = _v2.a;
					var a = _v3.a;
					var newState = _v3.b;
					var _v4 = fb(newState);
					if (_v4.$ === 'Err') {
						var e = _v4.a;
						return $elm$core$Result$Err(e);
					} else {
						var _v5 = _v4.a;
						var b = _v5.a;
						var newerState = _v5.b;
						return $elm$core$Result$Ok(
							_Utils_Tuple2(
								A2(f, a, b),
								newerState));
					}
				}
			});
	});
var $folkertdev$elm_flate$Inflate$BitReader$andMap = F2(
	function (a, f) {
		return A3($folkertdev$elm_flate$Inflate$BitReader$map2, $elm$core$Basics$apL, f, a);
	});
var $folkertdev$elm_flate$Inflate$BitReader$map3 = F4(
	function (f, a, b, c) {
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$andMap,
			c,
			A2(
				$folkertdev$elm_flate$Inflate$BitReader$andMap,
				b,
				A2(
					$folkertdev$elm_flate$Inflate$BitReader$andMap,
					a,
					$folkertdev$elm_flate$Inflate$BitReader$succeed(f))));
	});
var $folkertdev$elm_flate$Inflate$Internal$decodeTrees = A2(
	$folkertdev$elm_flate$Inflate$BitReader$andThen,
	$elm$core$Basics$identity,
	A4(
		$folkertdev$elm_flate$Inflate$BitReader$map3,
		$folkertdev$elm_flate$Inflate$Internal$cont,
		A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 5, 257),
		A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 5, 1),
		A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 4, 4)));
var $folkertdev$elm_flate$Inflate$BitReader$error = function (e) {
	return $folkertdev$elm_flate$Inflate$BitReader$BitReader(
		function (s) {
			return $elm$core$Result$Err(e);
		});
};
var $folkertdev$elm_flate$Inflate$BitReader$getBit = A2($folkertdev$elm_flate$Inflate$BitReader$readBits, 1, 0);
var $folkertdev$elm_flate$Experimental$ByteArray$get = F2(
	function (index, _v0) {
		var array = _v0.a;
		var finalSize = _v0.b;
		var finalBytes = _v0.c;
		var offset = index % 4;
		if (_Utils_cmp(
			index,
			($elm$core$Array$length(array) * 4) + finalSize) > -1) {
			return $elm$core$Maybe$Nothing;
		} else {
			if (_Utils_cmp(
				index,
				$elm$core$Array$length(array) * 4) > -1) {
				return $elm$core$Maybe$Just(255 & (finalBytes >>> (8 * (3 - offset))));
			} else {
				var internalIndex = (index / 4) | 0;
				var _v1 = A2($elm$core$Array$get, internalIndex, array);
				if (_v1.$ === 'Nothing') {
					return $elm$core$Maybe$Nothing;
				} else {
					var int32 = _v1.a;
					return $elm$core$Maybe$Just(255 & (int32 >>> (8 * (3 - offset))));
				}
			}
		}
	});
var $folkertdev$elm_flate$Experimental$ByteArray$copyToBackInternal = F5(
	function (startIndex, size, array, finalSize, finalBytes) {
		copyToBackInternal:
		while (true) {
			var offset = startIndex % 4;
			var internalIndex = (startIndex / 4) | 0;
			if (size <= 0) {
				return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize, finalBytes);
			} else {
				if (_Utils_cmp(
					startIndex + 4,
					(($elm$core$Array$length(array) - 1) * 4) + finalSize) > -1) {
					var _v0 = A2(
						$folkertdev$elm_flate$Experimental$ByteArray$get,
						startIndex,
						A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize, finalBytes));
					if (_v0.$ === 'Nothing') {
						return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize, finalBytes);
					} else {
						var value = _v0.a;
						var _v1 = A2(
							$folkertdev$elm_flate$Experimental$ByteArray$push,
							value,
							A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize, finalBytes));
						var newArray = _v1.a;
						var newFinalSize = _v1.b;
						var newFinalBytes = _v1.c;
						var $temp$startIndex = startIndex + 1,
							$temp$size = size - 1,
							$temp$array = newArray,
							$temp$finalSize = newFinalSize,
							$temp$finalBytes = newFinalBytes;
						startIndex = $temp$startIndex;
						size = $temp$size;
						array = $temp$array;
						finalSize = $temp$finalSize;
						finalBytes = $temp$finalBytes;
						continue copyToBackInternal;
					}
				} else {
					var _v2 = A2($elm$core$Array$get, internalIndex, array);
					if (_v2.$ === 'Nothing') {
						return A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize, finalBytes);
					} else {
						var value = _v2.a;
						var written = A2($elm$core$Basics$min, 4 - offset, size);
						var maskedFront = value << (8 * offset);
						var maskedBack = function () {
							if (_Utils_cmp(4 - offset, size) > 0) {
								var bytesWeNeedToRemove = 4 - size;
								var bytesWeHave = (3 - offset) + 1;
								return maskedFront >> (bytesWeNeedToRemove * 8);
							} else {
								return maskedFront >> (offset * 8);
							}
						}();
						var _v3 = A3(
							$folkertdev$elm_flate$Experimental$ByteArray$pushMany,
							written,
							maskedBack,
							A3($folkertdev$elm_flate$Experimental$ByteArray$ByteArray, array, finalSize, finalBytes));
						var x = _v3.a;
						var y = _v3.b;
						var z = _v3.c;
						var $temp$startIndex = startIndex + written,
							$temp$size = size - written,
							$temp$array = x,
							$temp$finalSize = y,
							$temp$finalBytes = z;
						startIndex = $temp$startIndex;
						size = $temp$size;
						array = $temp$array;
						finalSize = $temp$finalSize;
						finalBytes = $temp$finalBytes;
						continue copyToBackInternal;
					}
				}
			}
		}
	});
var $folkertdev$elm_flate$Experimental$ByteArray$copyToBack = F3(
	function (startIndex, size, _v0) {
		var array = _v0.a;
		var finalSize = _v0.b;
		var finalBytes = _v0.c;
		return A5($folkertdev$elm_flate$Experimental$ByteArray$copyToBackInternal, startIndex, size, array, finalSize, finalBytes);
	});
var $folkertdev$elm_flate$Inflate$Internal$HuffmanTable = function (a) {
	return {$: 'HuffmanTable', a: a};
};
var $elm$core$Elm$JsArray$foldl = _JsArray_foldl;
var $elm$core$Array$foldl = F3(
	function (func, baseCase, _v0) {
		var tree = _v0.c;
		var tail = _v0.d;
		var helper = F2(
			function (node, acc) {
				if (node.$ === 'SubTree') {
					var subTree = node.a;
					return A3($elm$core$Elm$JsArray$foldl, helper, acc, subTree);
				} else {
					var values = node.a;
					return A3($elm$core$Elm$JsArray$foldl, func, acc, values);
				}
			});
		return A3(
			$elm$core$Elm$JsArray$foldl,
			func,
			A3($elm$core$Elm$JsArray$foldl, helper, baseCase, tree),
			tail);
	});
var $folkertdev$elm_flate$Inflate$Internal$buildBitsBase = F2(
	function (delta, first) {
		var initializer = function (i) {
			return (_Utils_cmp(i, delta) < 0) ? 0 : (((i - delta) / delta) | 0);
		};
		var folder = F2(
			function (bit, _v0) {
				var sum = _v0.a;
				var accum = _v0.b;
				return _Utils_Tuple2(
					sum + (1 << bit),
					A2(
						$elm$core$Array$push,
						{base: sum, bits: bit},
						accum));
			});
		var bits = A2($elm$core$Array$initialize, 30, initializer);
		var base = A3(
			$elm$core$Array$foldl,
			folder,
			_Utils_Tuple2(first, $elm$core$Array$empty),
			bits).b;
		return $folkertdev$elm_flate$Inflate$Internal$HuffmanTable(base);
	});
var $folkertdev$elm_flate$Inflate$Internal$hardcodedDistanceTable = A2($folkertdev$elm_flate$Inflate$Internal$buildBitsBase, 2, 1);
var $folkertdev$elm_flate$Inflate$Internal$hardcodedLengthTable = function (_v0) {
	var array = _v0.a;
	return $folkertdev$elm_flate$Inflate$Internal$HuffmanTable(
		A3(
			$elm$core$Array$set,
			28,
			{base: 258, bits: 0},
			array));
}(
	A2($folkertdev$elm_flate$Inflate$Internal$buildBitsBase, 4, 3));
var $folkertdev$elm_flate$Inflate$Internal$readHuffmanTable = F2(
	function (index, _v0) {
		var table = _v0.a;
		return A2($elm$core$Array$get, index, table);
	});
var $folkertdev$elm_flate$Inflate$Internal$decodeLength = function (symbol) {
	var _v0 = A2($folkertdev$elm_flate$Inflate$Internal$readHuffmanTable, symbol - 257, $folkertdev$elm_flate$Inflate$Internal$hardcodedLengthTable);
	if (_v0.$ === 'Nothing') {
		return $folkertdev$elm_flate$Inflate$BitReader$error(
			function () {
				var _v1 = $folkertdev$elm_flate$Inflate$Internal$hardcodedDistanceTable;
				var internal = _v1.a;
				return 'index out of bounds in hardcodedLengthTable: requested index ' + ($elm$core$String$fromInt(symbol - 257) + ('but hardcodedLengthTable has length ' + $elm$core$String$fromInt(
					$elm$core$Array$length(internal))));
			}());
	} else {
		var entry = _v0.a;
		return A2($folkertdev$elm_flate$Inflate$BitReader$readBits, entry.bits, entry.base);
	}
};
var $folkertdev$elm_flate$Inflate$Internal$decodeOffset = F2(
	function (outputLength, dt) {
		var table_ = A2(
			$elm$core$Maybe$withDefault,
			_List_Nil,
			$elm$core$List$tail(dt.table));
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$andThen,
			function (distance) {
				var _v0 = A2($folkertdev$elm_flate$Inflate$Internal$readHuffmanTable, distance, $folkertdev$elm_flate$Inflate$Internal$hardcodedDistanceTable);
				if (_v0.$ === 'Nothing') {
					return $folkertdev$elm_flate$Inflate$BitReader$error(
						function () {
							var _v1 = $folkertdev$elm_flate$Inflate$Internal$hardcodedDistanceTable;
							var internal = _v1.a;
							return 'index out of bounds in hardcodedDistanceTable: requested index ' + ($elm$core$String$fromInt(distance) + ('but hardcodedLengthTable has length ' + $elm$core$String$fromInt(
								$elm$core$Array$length(internal))));
						}());
				} else {
					var entry = _v0.a;
					return A2(
						$folkertdev$elm_flate$Inflate$BitReader$map,
						function (v) {
							return outputLength - v;
						},
						A2($folkertdev$elm_flate$Inflate$BitReader$readBits, entry.bits, entry.base));
				}
			},
			A2($folkertdev$elm_flate$Inflate$Internal$decodeSymbol, table_, dt));
	});
var $folkertdev$elm_flate$Inflate$Internal$inflateBlockDataHelp = F2(
	function (trees, _v0) {
		var outputLength = _v0.a;
		var output = _v0.b;
		var table = A2(
			$elm$core$Maybe$withDefault,
			_List_Nil,
			$elm$core$List$tail(trees.literal.table));
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$andThen,
			function (symbol) {
				return (symbol === 256) ? $folkertdev$elm_flate$Inflate$BitReader$succeed(
					$elm$bytes$Bytes$Decode$Done(output)) : ((symbol < 256) ? $folkertdev$elm_flate$Inflate$BitReader$succeed(
					$elm$bytes$Bytes$Decode$Loop(
						_Utils_Tuple2(
							outputLength + 1,
							A2($folkertdev$elm_flate$Experimental$ByteArray$push, symbol, output)))) : A3(
					$folkertdev$elm_flate$Inflate$BitReader$map2,
					F2(
						function (length, offset) {
							return $elm$bytes$Bytes$Decode$Loop(
								_Utils_Tuple2(
									outputLength + length,
									A3($folkertdev$elm_flate$Experimental$ByteArray$copyToBack, offset, length, output)));
						}),
					$folkertdev$elm_flate$Inflate$Internal$decodeLength(symbol),
					A2($folkertdev$elm_flate$Inflate$Internal$decodeOffset, outputLength, trees.distance)));
			},
			A2($folkertdev$elm_flate$Inflate$Internal$decodeSymbol, table, trees.literal));
	});
var $folkertdev$elm_flate$Inflate$Internal$inflateBlockData = F3(
	function (trees, outputLength, output) {
		return A2(
			$folkertdev$elm_flate$Inflate$BitReader$loop,
			_Utils_Tuple2(outputLength, output),
			$folkertdev$elm_flate$Inflate$Internal$inflateBlockDataHelp(trees));
	});
var $folkertdev$elm_flate$Inflate$Internal$uncompressedBlockDecoder = function (bufferWidth) {
	var decodeLengths = A3(
		$elm$bytes$Bytes$Decode$map2,
		$elm$core$Tuple$pair,
		$elm$bytes$Bytes$Decode$unsignedInt16($elm$bytes$Bytes$LE),
		$elm$bytes$Bytes$Decode$unsignedInt16($elm$bytes$Bytes$LE));
	return A2(
		$elm$bytes$Bytes$Decode$andThen,
		function (_v0) {
			var length = _v0.a;
			var invlength = _v0.b;
			if (!_Utils_eq(length, (~invlength) & 65535)) {
				return $elm$bytes$Bytes$Decode$fail;
			} else {
				var remainingSize = (bufferWidth - 4) - length;
				return A3(
					$elm$bytes$Bytes$Decode$map2,
					$elm$core$Tuple$pair,
					$elm$bytes$Bytes$Decode$bytes(length),
					$elm$bytes$Bytes$Decode$bytes(remainingSize));
			}
		},
		decodeLengths);
};
var $folkertdev$elm_flate$Inflate$Internal$inflateUncompressedBlock = $folkertdev$elm_flate$Inflate$BitReader$BitReader(
	function (state) {
		var _v0 = A2(
			$elm$bytes$Bytes$Decode$decode,
			$folkertdev$elm_flate$Inflate$Internal$uncompressedBlockDecoder(
				$elm$bytes$Bytes$width(state.buffer)),
			state.buffer);
		if (_v0.$ === 'Nothing') {
			return $elm$core$Result$Err('inflateUncompressedBlock: ran out of bounds');
		} else {
			var _v1 = _v0.a;
			var block = _v1.a;
			var newBuffer = _v1.b;
			return $elm$core$Result$Ok(
				_Utils_Tuple2(
					block,
					_Utils_update(
						state,
						{buffer: newBuffer})));
		}
	});
var $folkertdev$elm_flate$Experimental$ByteArray$length = function (_v0) {
	var array = _v0.a;
	var finalSize = _v0.b;
	var finalBytes = _v0.c;
	var _v1 = $elm$core$Array$length(array) * 4;
	if (!_v1) {
		return finalSize;
	} else {
		var l = _v1;
		return l + finalSize;
	}
};
var $elm$core$Elm$JsArray$appendN = _JsArray_appendN;
var $elm$core$Elm$JsArray$slice = _JsArray_slice;
var $elm$core$Array$appendHelpBuilder = F2(
	function (tail, builder) {
		var tailLen = $elm$core$Elm$JsArray$length(tail);
		var notAppended = ($elm$core$Array$branchFactor - $elm$core$Elm$JsArray$length(builder.tail)) - tailLen;
		var appended = A3($elm$core$Elm$JsArray$appendN, $elm$core$Array$branchFactor, builder.tail, tail);
		return (notAppended < 0) ? {
			nodeList: A2(
				$elm$core$List$cons,
				$elm$core$Array$Leaf(appended),
				builder.nodeList),
			nodeListSize: builder.nodeListSize + 1,
			tail: A3($elm$core$Elm$JsArray$slice, notAppended, tailLen, tail)
		} : ((!notAppended) ? {
			nodeList: A2(
				$elm$core$List$cons,
				$elm$core$Array$Leaf(appended),
				builder.nodeList),
			nodeListSize: builder.nodeListSize + 1,
			tail: $elm$core$Elm$JsArray$empty
		} : {nodeList: builder.nodeList, nodeListSize: builder.nodeListSize, tail: appended});
	});
var $elm$core$Array$appendHelpTree = F2(
	function (toAppend, array) {
		var len = array.a;
		var tree = array.c;
		var tail = array.d;
		var itemsToAppend = $elm$core$Elm$JsArray$length(toAppend);
		var notAppended = ($elm$core$Array$branchFactor - $elm$core$Elm$JsArray$length(tail)) - itemsToAppend;
		var appended = A3($elm$core$Elm$JsArray$appendN, $elm$core$Array$branchFactor, tail, toAppend);
		var newArray = A2($elm$core$Array$unsafeReplaceTail, appended, array);
		if (notAppended < 0) {
			var nextTail = A3($elm$core$Elm$JsArray$slice, notAppended, itemsToAppend, toAppend);
			return A2($elm$core$Array$unsafeReplaceTail, nextTail, newArray);
		} else {
			return newArray;
		}
	});
var $elm$core$Array$builderFromArray = function (_v0) {
	var len = _v0.a;
	var tree = _v0.c;
	var tail = _v0.d;
	var helper = F2(
		function (node, acc) {
			if (node.$ === 'SubTree') {
				var subTree = node.a;
				return A3($elm$core$Elm$JsArray$foldl, helper, acc, subTree);
			} else {
				return A2($elm$core$List$cons, node, acc);
			}
		});
	return {
		nodeList: A3($elm$core$Elm$JsArray$foldl, helper, _List_Nil, tree),
		nodeListSize: (len / $elm$core$Array$branchFactor) | 0,
		tail: tail
	};
};
var $elm$core$Array$append = F2(
	function (a, _v0) {
		var aTail = a.d;
		var bLen = _v0.a;
		var bTree = _v0.c;
		var bTail = _v0.d;
		if (_Utils_cmp(bLen, $elm$core$Array$branchFactor * 4) < 1) {
			var foldHelper = F2(
				function (node, array) {
					if (node.$ === 'SubTree') {
						var tree = node.a;
						return A3($elm$core$Elm$JsArray$foldl, foldHelper, array, tree);
					} else {
						var leaf = node.a;
						return A2($elm$core$Array$appendHelpTree, leaf, array);
					}
				});
			return A2(
				$elm$core$Array$appendHelpTree,
				bTail,
				A3($elm$core$Elm$JsArray$foldl, foldHelper, a, bTree));
		} else {
			var foldHelper = F2(
				function (node, builder) {
					if (node.$ === 'SubTree') {
						var tree = node.a;
						return A3($elm$core$Elm$JsArray$foldl, foldHelper, builder, tree);
					} else {
						var leaf = node.a;
						return A2($elm$core$Array$appendHelpBuilder, leaf, builder);
					}
				});
			return A2(
				$elm$core$Array$builderToArray,
				true,
				A2(
					$elm$core$Array$appendHelpBuilder,
					bTail,
					A3(
						$elm$core$Elm$JsArray$foldl,
						foldHelper,
						$elm$core$Array$builderFromArray(a),
						bTree)));
		}
	});
var $folkertdev$elm_flate$Inflate$Internal$sdtree = {
	table: _List_fromArray(
		[0, 0, 0, 0, 0, 32, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
	trans: A2(
		$elm$core$Array$append,
		$elm$core$Array$fromList(
			_List_fromArray(
				[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31])),
		A2($elm$core$Array$repeat, 288 - 32, 0))
};
var $folkertdev$elm_flate$Inflate$BitReader$flushHelp = function (state0) {
	var availableSpace = 32 - state0.bitsAvailable;
	var state = A2(
		$folkertdev$elm_flate$Inflate$BitReader$moveFromReserve,
		A2($elm$core$Basics$min, availableSpace, state0.reserveAvailable),
		state0);
	var reserveEncoder = (state.reserveAvailable > 24) ? _List_fromArray(
		[
			A2($elm$bytes$Bytes$Encode$unsignedInt32, $elm$bytes$Bytes$LE, state.reserve)
		]) : ((state.reserveAvailable > 16) ? _List_fromArray(
		[
			A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$LE, state.reserve),
			$elm$bytes$Bytes$Encode$unsignedInt8(state.reserve >> 16)
		]) : ((state.reserveAvailable > 8) ? _List_fromArray(
		[
			A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$LE, state.reserve)
		]) : ((state.reserveAvailable > 1) ? _List_fromArray(
		[
			$elm$bytes$Bytes$Encode$unsignedInt8(state.reserve)
		]) : _List_Nil)));
	var tagEncoder = (state.bitsAvailable > 24) ? _List_fromArray(
		[
			A2($elm$bytes$Bytes$Encode$unsignedInt32, $elm$bytes$Bytes$LE, state.tag)
		]) : ((state.bitsAvailable > 16) ? _List_fromArray(
		[
			A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$LE, state.tag),
			$elm$bytes$Bytes$Encode$unsignedInt8(state.tag >> 16)
		]) : ((state.bitsAvailable > 8) ? _List_fromArray(
		[
			A2($elm$bytes$Bytes$Encode$unsignedInt16, $elm$bytes$Bytes$LE, state.tag)
		]) : ((state.bitsAvailable > 1) ? _List_fromArray(
		[
			$elm$bytes$Bytes$Encode$unsignedInt8(state.tag)
		]) : _List_Nil)));
	return $elm$bytes$Bytes$Encode$encode(
		$elm$bytes$Bytes$Encode$sequence(
			_Utils_ap(
				tagEncoder,
				_Utils_ap(
					reserveEncoder,
					_List_fromArray(
						[
							$elm$bytes$Bytes$Encode$bytes(state.buffer)
						])))));
};
var $folkertdev$elm_flate$Inflate$BitReader$flush = function (state) {
	return {
		bitsAvailable: 0,
		buffer: $folkertdev$elm_flate$Inflate$BitReader$flushHelp(state),
		reserve: 0,
		reserveAvailable: 0,
		tag: 0
	};
};
var $folkertdev$elm_flate$Inflate$BitReader$skipToByteBoundary = $folkertdev$elm_flate$Inflate$BitReader$BitReader(
	function (s) {
		var available = s.bitsAvailable + s.reserveAvailable;
		var untilBoundary = A2($elm$core$Basics$modBy, 8, available);
		var _v0 = A2($folkertdev$elm_flate$Inflate$BitReader$readBits, untilBoundary, 0);
		var step = _v0.a;
		var _v1 = step(s);
		if (_v1.$ === 'Err') {
			var e = _v1.a;
			return $elm$core$Result$Err(e);
		} else {
			var _v2 = _v1.a;
			var newState = _v2.b;
			var _v3 = $folkertdev$elm_flate$Inflate$BitReader$readMoreBits(newState);
			if (_v3.$ === 'Err') {
				var e = _v3.a;
				return $elm$core$Result$Err(e);
			} else {
				var newerState = _v3.a;
				return $elm$core$Result$Ok(
					_Utils_Tuple2(
						_Utils_Tuple0,
						$folkertdev$elm_flate$Inflate$BitReader$flush(newerState)));
			}
		}
	});
var $folkertdev$elm_flate$Inflate$Internal$sltree = {
	table: _List_fromArray(
		[0, 0, 0, 0, 0, 0, 0, 24, 152, 112, 0, 0, 0, 0, 0, 0]),
	trans: $elm$core$Array$fromList(
		_List_fromArray(
			[256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 280, 281, 282, 283, 284, 285, 286, 287, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]))
};
var $folkertdev$elm_flate$Inflate$Internal$uncompressHelp = function (output) {
	var uncompressBlock = function (btype) {
		switch (btype) {
			case 0:
				return A2(
					$folkertdev$elm_flate$Inflate$BitReader$map,
					function (bytes) {
						return A2($folkertdev$elm_flate$Experimental$ByteArray$appendBytes, bytes, output);
					},
					A2(
						$folkertdev$elm_flate$Inflate$BitReader$andThen,
						function (_v1) {
							return $folkertdev$elm_flate$Inflate$Internal$inflateUncompressedBlock;
						},
						$folkertdev$elm_flate$Inflate$BitReader$skipToByteBoundary));
			case 1:
				return A3(
					$folkertdev$elm_flate$Inflate$Internal$inflateBlockData,
					{distance: $folkertdev$elm_flate$Inflate$Internal$sdtree, literal: $folkertdev$elm_flate$Inflate$Internal$sltree},
					$folkertdev$elm_flate$Experimental$ByteArray$length(output),
					output);
			case 2:
				return A2(
					$folkertdev$elm_flate$Inflate$BitReader$andThen,
					function (_v2) {
						var ltree = _v2.a;
						var dtree = _v2.b;
						return A3(
							$folkertdev$elm_flate$Inflate$Internal$inflateBlockData,
							{distance: dtree, literal: ltree},
							$folkertdev$elm_flate$Experimental$ByteArray$length(output),
							output);
					},
					$folkertdev$elm_flate$Inflate$Internal$decodeTrees);
			default:
				return $folkertdev$elm_flate$Inflate$BitReader$error(
					'invalid block type: ' + ($elm$core$String$fromInt(btype) + ' (only 0, 1 and 2 are valid block types)'));
		}
	};
	var readTwoBits = A3(
		$folkertdev$elm_flate$Inflate$BitReader$map2,
		F2(
			function (b1, b2) {
				return b1 + (2 * b2);
			}),
		$folkertdev$elm_flate$Inflate$BitReader$getBit,
		$folkertdev$elm_flate$Inflate$BitReader$getBit);
	var go = F2(
		function (isFinal, blockType) {
			return (!(!isFinal)) ? A2(
				$folkertdev$elm_flate$Inflate$BitReader$map,
				$elm$bytes$Bytes$Decode$Done,
				uncompressBlock(blockType)) : A2(
				$folkertdev$elm_flate$Inflate$BitReader$map,
				$elm$bytes$Bytes$Decode$Loop,
				uncompressBlock(blockType));
		});
	return A2(
		$folkertdev$elm_flate$Inflate$BitReader$andThen,
		$elm$core$Basics$identity,
		A3($folkertdev$elm_flate$Inflate$BitReader$map2, go, $folkertdev$elm_flate$Inflate$BitReader$getBit, readTwoBits));
};
var $folkertdev$elm_flate$Inflate$Internal$uncompress = A2(
	$folkertdev$elm_flate$Inflate$BitReader$map,
	A2($elm$core$Basics$composeR, $folkertdev$elm_flate$Experimental$ByteArray$toBytes, $elm$core$List$singleton),
	A2($folkertdev$elm_flate$Inflate$BitReader$loop, $folkertdev$elm_flate$Experimental$ByteArray$empty, $folkertdev$elm_flate$Inflate$Internal$uncompressHelp));
var $folkertdev$elm_flate$Inflate$Internal$inflate = function (buffer) {
	var _v0 = A2($folkertdev$elm_flate$Inflate$BitReader$decode, buffer, $folkertdev$elm_flate$Inflate$Internal$uncompress);
	if (_v0.$ === 'Err') {
		var e = _v0.a;
		return $elm$core$Result$Err(e);
	} else {
		var values = _v0.a;
		return $elm$core$Result$Ok(
			$elm$bytes$Bytes$Encode$encode(
				$elm$bytes$Bytes$Encode$sequence(
					A2($elm$core$List$map, $elm$bytes$Bytes$Encode$bytes, values))));
	}
};
var $folkertdev$elm_flate$Inflate$Inflate$inflate = function (buffer) {
	var _v0 = $folkertdev$elm_flate$Inflate$Internal$inflate(buffer);
	if (_v0.$ === 'Err') {
		return $elm$core$Maybe$Nothing;
	} else {
		var newBuffer = _v0.a;
		return $elm$core$Maybe$Just(newBuffer);
	}
};
var $folkertdev$elm_flate$Flate$inflate = $folkertdev$elm_flate$Inflate$Inflate$inflate;
var $agu_z$elm_zip$Zip$Entry$IntegrityError = {$: 'IntegrityError'};
var $folkertdev$elm_flate$Checksum$Crc32$tinf_crc32case = function (i) {
	switch (i) {
		case 0:
			return 0;
		case 1:
			return 498536548;
		case 2:
			return 997073096;
		case 3:
			return 651767980;
		case 4:
			return 1994146192;
		case 5:
			return 1802195444;
		case 6:
			return 1303535960;
		case 7:
			return 1342533948;
		case 8:
			return 3988292384;
		case 9:
			return 4027552580;
		case 10:
			return 3604390888;
		case 11:
			return 3412177804;
		case 12:
			return 2607071920;
		case 13:
			return 2262029012;
		case 14:
			return 2685067896;
		default:
			return 3183342108;
	}
};
var $elm$core$Bitwise$xor = _Bitwise_xor;
var $folkertdev$elm_flate$Checksum$Crc32$step = F2(
	function (_byte, crc) {
		var a = (crc ^ _byte) >>> 0;
		var b = ((a >>> 4) ^ $folkertdev$elm_flate$Checksum$Crc32$tinf_crc32case(a & 15)) >>> 0;
		var c = (b >>> 4) ^ $folkertdev$elm_flate$Checksum$Crc32$tinf_crc32case(b & 15);
		return c;
	});
var $folkertdev$elm_flate$Checksum$Crc32$crc32Help = function (_v0) {
	var remaining = _v0.remaining;
	var crc = _v0.crc;
	return (remaining >= 8) ? A3(
		$elm$bytes$Bytes$Decode$map2,
		F2(
			function (word1, word2) {
				var byte8 = 255 & word2;
				var byte7 = 255 & (word2 >>> 8);
				var byte6 = 255 & (word2 >>> 16);
				var byte5 = 255 & (word2 >>> 24);
				var byte4 = 255 & word1;
				var byte3 = 255 & (word1 >>> 8);
				var byte2 = 255 & (word1 >>> 16);
				var byte1 = 255 & (word1 >>> 24);
				return $elm$bytes$Bytes$Decode$Loop(
					{
						crc: A2(
							$folkertdev$elm_flate$Checksum$Crc32$step,
							byte8,
							A2(
								$folkertdev$elm_flate$Checksum$Crc32$step,
								byte7,
								A2(
									$folkertdev$elm_flate$Checksum$Crc32$step,
									byte6,
									A2(
										$folkertdev$elm_flate$Checksum$Crc32$step,
										byte5,
										A2(
											$folkertdev$elm_flate$Checksum$Crc32$step,
											byte4,
											A2(
												$folkertdev$elm_flate$Checksum$Crc32$step,
												byte3,
												A2(
													$folkertdev$elm_flate$Checksum$Crc32$step,
													byte2,
													A2($folkertdev$elm_flate$Checksum$Crc32$step, byte1, crc)))))))),
						remaining: remaining - 8
					});
			}),
		$elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$BE),
		$elm$bytes$Bytes$Decode$unsignedInt32($elm$bytes$Bytes$BE)) : ((remaining > 0) ? A2(
		$elm$bytes$Bytes$Decode$map,
		function (_byte) {
			return $elm$bytes$Bytes$Decode$Loop(
				{
					crc: A2($folkertdev$elm_flate$Checksum$Crc32$step, _byte, crc),
					remaining: remaining - 1
				});
		},
		$elm$bytes$Bytes$Decode$unsignedInt8) : $elm$bytes$Bytes$Decode$succeed(
		$elm$bytes$Bytes$Decode$Done((crc ^ 4294967295) >>> 0)));
};
var $folkertdev$elm_flate$Checksum$Crc32$tinf_crc32 = function (buffer) {
	var length = $elm$bytes$Bytes$width(buffer);
	var initialCrc = 4294967295;
	return (!length) ? 0 : A2(
		$elm$core$Maybe$withDefault,
		0,
		A2(
			$elm$bytes$Bytes$Decode$decode,
			A2(
				$elm$bytes$Bytes$Decode$loop,
				{crc: initialCrc, remaining: length},
				$folkertdev$elm_flate$Checksum$Crc32$crc32Help),
			buffer));
};
var $folkertdev$elm_flate$Checksum$Crc32$crc32 = $folkertdev$elm_flate$Checksum$Crc32$tinf_crc32;
var $folkertdev$elm_flate$Flate$crc32 = $folkertdev$elm_flate$Checksum$Crc32$crc32;
var $agu_z$elm_zip$Zip$Entry$integrity = F2(
	function (sum, bytes) {
		return _Utils_eq(
			sum,
			$folkertdev$elm_flate$Flate$crc32(bytes)) ? $elm$core$Result$Ok(bytes) : $elm$core$Result$Err($agu_z$elm_zip$Zip$Entry$IntegrityError);
	});
var $agu_z$elm_zip$Internal$Decode$readFile = function (_v0) {
	var bytes = _v0.a;
	var meta = _v0.b;
	if (bytes.$ === 'Exactly') {
		var entryBytes = bytes.a;
		return $elm$core$Maybe$Just(entryBytes);
	} else {
		var allBytes = bytes.a;
		var startOffset = bytes.b;
		var entryDataDecoder = A2(
			$elm$bytes$Bytes$Decode$andThen,
			function (offset) {
				return A2(
					$agu_z$elm_zip$Internal$Decode$after,
					offset,
					$elm$bytes$Bytes$Decode$bytes(meta.compressedSize));
			},
			A2(
				$agu_z$elm_zip$Internal$Decode$with,
				$agu_z$elm_zip$Internal$Decode$i16,
				A2(
					$agu_z$elm_zip$Internal$Decode$with,
					A2($agu_z$elm_zip$Internal$Decode$after, 22, $agu_z$elm_zip$Internal$Decode$i16),
					A2(
						$agu_z$elm_zip$Internal$Decode$checkSignature,
						67324752,
						$elm$bytes$Bytes$Decode$succeed($elm$core$Basics$add)))));
		return A2(
			$elm$bytes$Bytes$Decode$decode,
			A2($agu_z$elm_zip$Internal$Decode$after, startOffset, entryDataDecoder),
			allBytes);
	}
};
var $agu_z$elm_zip$Zip$Entry$toBytes = function (entry) {
	var record = entry.b;
	var _v0 = $agu_z$elm_zip$Internal$Decode$readFile(entry);
	if (_v0.$ === 'Just') {
		var rawBytes = _v0.a;
		return A2(
			$elm$core$Result$andThen,
			$agu_z$elm_zip$Zip$Entry$integrity(record.crc32),
			function () {
				var _v1 = record.compressionMethod;
				switch (_v1.$) {
					case 'Stored':
						return $elm$core$Result$Ok(rawBytes);
					case 'Deflated':
						return A2(
							$elm$core$Result$fromMaybe,
							$agu_z$elm_zip$Zip$Entry$InflateError,
							$folkertdev$elm_flate$Flate$inflate(rawBytes));
					default:
						var method = _v1.a;
						return $elm$core$Result$Err(
							A2($agu_z$elm_zip$Zip$Entry$UnsupportedCompression, method, rawBytes));
				}
			}());
	} else {
		return $elm$core$Result$Err($agu_z$elm_zip$Zip$Entry$DecodeError);
	}
};
var $author$project$Builder$File$writeEntry = F3(
	function (destination, root, entry) {
		var path = A2(
			$elm$core$String$dropLeft,
			root,
			$agu_z$elm_zip$Zip$Entry$path(entry));
		if (A2($elm$core$String$startsWith, 'src/', path) || ((path === 'LICENSE') || ((path === 'README.md') || (path === 'elm.json')))) {
			if ((!$elm$core$String$isEmpty(path)) && A2($elm$core$String$endsWith, '/', path)) {
				return A2(
					$author$project$Extra$System$File$createDirectoryIfMissing,
					true,
					A2(
						$author$project$Extra$System$File$combine,
						destination,
						$author$project$Extra$System$File$fromString(path)));
			} else {
				var _v0 = $agu_z$elm_zip$Zip$Entry$toBytes(entry);
				if (_v0.$ === 'Err') {
					return $author$project$Extra$System$IO$return(_Utils_Tuple0);
				} else {
					var bytes = _v0.a;
					return A2(
						$author$project$Extra$System$File$writeFile,
						A2(
							$author$project$Extra$System$File$combine,
							destination,
							$author$project$Extra$System$File$fromString(path)),
						bytes);
				}
			}
		} else {
			return $author$project$Extra$System$IO$return(_Utils_Tuple0);
		}
	});
var $author$project$Builder$File$writePackage = F2(
	function (destination, archive) {
		var _v0 = $agu_z$elm_zip$Zip$entries(archive);
		if (!_v0.b) {
			return $author$project$Extra$System$IO$return(_Utils_Tuple0);
		} else {
			var entry = _v0.a;
			var entries = _v0.b;
			var root = $elm$core$String$length(
				$agu_z$elm_zip$Zip$Entry$path(entry));
			return A4(
				$author$project$Extra$Type$List$mapM_,
				$author$project$Extra$System$IO$return,
				$author$project$Extra$System$IO$bind,
				A2($author$project$Builder$File$writeEntry, destination, root),
				A2($author$project$Extra$Type$List$sortOn, $agu_z$elm_zip$Zip$Entry$path, entries));
		}
	});
var $author$project$Builder$Elm$Details$downloadPackage = F4(
	function (cache, manager, pkg, vsn) {
		var url = A3($author$project$Builder$Deps$Website$metadata, pkg, vsn, 'endpoint.json');
		return A2(
			$author$project$Extra$System$IO$bind,
			A5(
				$author$project$Builder$Http$get,
				manager,
				url,
				_List_Nil,
				$elm$core$Basics$identity,
				A2($elm$core$Basics$composeL, $author$project$Extra$System$IO$return, $author$project$Extra$Type$Either$Right)),
			function (eitherByteString) {
				if (eitherByteString.$ === 'Left') {
					var err = eitherByteString.a;
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(
							$author$project$Builder$Reporting$Exit$PP_BadEndpointRequest(err)));
				} else {
					var byteString = eitherByteString.a;
					var _v1 = A2($author$project$Compiler$Json$Decode$fromByteString, $author$project$Builder$Elm$Details$endpointDecoder, byteString);
					if (_v1.$ === 'Left') {
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Left(
								$author$project$Builder$Reporting$Exit$PP_BadEndpointContent(url)));
					} else {
						var _v2 = _v1.a;
						var endpoint = _v2.a;
						return A5(
							$author$project$Builder$Http$getArchive,
							manager,
							endpoint,
							$author$project$Builder$Reporting$Exit$PP_BadArchiveRequest,
							$author$project$Builder$Reporting$Exit$PP_BadArchiveContent(endpoint),
							function (archive) {
								return A2(
									$author$project$Extra$System$IO$fmap,
									$author$project$Extra$Type$Either$Right,
									A2(
										$author$project$Builder$File$writePackage,
										A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
										archive));
							});
					}
				}
			});
	});
var $author$project$Builder$Elm$Details$verifyDep = F6(
	function (_v0, depsMVar, solution, pkg, details, _v1) {
		var cache = _v0.b;
		var manager = _v0.c;
		var vsn = details.a;
		var directDeps = details.b;
		var fingerprint = A3(
			$author$project$Extra$Type$Map$intersectionWith,
			F2(
				function (_v5, _v6) {
					var v = _v5.a;
					return v;
				}),
			solution,
			directDeps);
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$File$doesDirectoryExist(
				A2(
					$author$project$Extra$System$File$addName,
					A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
					'src')),
			function (exists) {
				return exists ? A2(
					$author$project$Extra$System$IO$bind,
					A2(
						$author$project$Builder$File$readBinary,
						$author$project$Builder$Elm$Details$bArtifactCache,
						A2(
							$author$project$Extra$System$File$addName,
							A3($author$project$Builder$Stuff$package, cache, pkg, vsn),
							'artifacts.dat')),
					function (maybeCache) {
						if (maybeCache.$ === 'Nothing') {
							return A6($author$project$Builder$Elm$Details$build, cache, depsMVar, pkg, details, fingerprint, $author$project$Extra$Type$Set$empty);
						} else {
							var _v3 = maybeCache.a;
							var fingerprints = _v3.a;
							var artifacts = _v3.b;
							return A2(
								$author$project$Extra$Type$Set$member,
								$author$project$Builder$Elm$Details$toComparable(fingerprint),
								fingerprints) ? $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Right(artifacts)) : A6($author$project$Builder$Elm$Details$build, cache, depsMVar, pkg, details, fingerprint, fingerprints);
						}
					}) : A2(
					$author$project$Extra$System$IO$bind,
					A4($author$project$Builder$Elm$Details$downloadPackage, cache, manager, pkg, vsn),
					function (result) {
						if (result.$ === 'Left') {
							var problem = result.a;
							return $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Left(
									$elm$core$Maybe$Just(
										A3($author$project$Builder$Reporting$Exit$BD_BadDownload, pkg, vsn, problem))));
						} else {
							return A6($author$project$Builder$Elm$Details$build, cache, depsMVar, pkg, details, fingerprint, $author$project$Extra$Type$Set$empty);
						}
					});
			});
	});
var $author$project$Builder$Elm$Details$verifyDependencies = F5(
	function (env, time, outline, solution, directDeps) {
		var root = env.a;
		return A2(
			$author$project$Builder$Reporting$Task$eio,
			$elm$core$Basics$identity,
			A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Extra$System$MVar$newEmpty($author$project$Builder$Elm$Details$lensMVDepMap),
				function (mvar) {
					return A2(
						$author$project$Extra$System$IO$bind,
						A4(
							$author$project$Extra$Type$Map$traverseWithKey,
							$author$project$Extra$System$IO$pure,
							$author$project$Extra$System$IO$liftA2,
							F2(
								function (k, v) {
									return A2(
										$author$project$Builder$Elm$Details$fork,
										$author$project$Builder$Elm$Details$lensMVDep,
										A5(
											$author$project$Builder$Elm$Details$verifyDep,
											env,
											mvar,
											solution,
											$author$project$Compiler$Elm$Package$fromComparable(k),
											v));
								}),
							solution),
						function (mvars) {
							return A2(
								$author$project$Extra$System$IO$bind,
								A3($author$project$Extra$System$MVar$write, $author$project$Builder$Elm$Details$lensMVDepMap, mvar, mvars),
								function (_v0) {
									return A2(
										$author$project$Extra$System$IO$bind,
										A4(
											$author$project$Extra$Type$Map$traverse,
											$author$project$Extra$System$IO$pure,
											$author$project$Extra$System$IO$liftA2,
											$author$project$Extra$System$MVar$read($author$project$Builder$Elm$Details$lensMVDep),
											mvars),
										function (deps) {
											var _v1 = A3($author$project$Extra$Type$Map$sequenceA, $author$project$Extra$Type$Either$pure, $author$project$Extra$Type$Either$liftA2, deps);
											if (_v1.$ === 'Left') {
												return A2(
													$author$project$Extra$System$IO$bind,
													$author$project$Builder$Stuff$getElmHome,
													function (home) {
														return $author$project$Extra$System$IO$return(
															$author$project$Extra$Type$Either$Left(
																A2(
																	$author$project$Builder$Reporting$Exit$DetailsBadDeps,
																	home,
																	$author$project$Extra$Type$Maybe$catMaybes(
																		$author$project$Extra$Type$Either$lefts(
																			$author$project$Extra$Type$Map$elems(deps))))));
													});
											} else {
												var artifacts = _v1.a;
												var objs = A3($author$project$Extra$Type$Map$foldr, $author$project$Builder$Elm$Details$addObjects, $author$project$Compiler$AST$Optimized$empty, artifacts);
												var ifaces = A3(
													$author$project$Extra$Type$Map$foldrWithKey,
													$author$project$Builder$Elm$Details$addInterfaces(directDeps),
													$author$project$Extra$Type$Map$empty,
													artifacts);
												var foreigns = A2(
													$author$project$Extra$Type$Map$map,
													$author$project$Compiler$Data$OneOrMore$destruct($author$project$Builder$Elm$Details$Foreign),
													A3(
														$author$project$Extra$Type$Map$foldrWithKey,
														$author$project$Builder$Elm$Details$gatherForeigns,
														$author$project$Extra$Type$Map$empty,
														A2($author$project$Extra$Type$Map$intersection, artifacts, directDeps)));
												var details = A6(
													$author$project$Builder$Elm$Details$Details,
													time,
													outline,
													0,
													$author$project$Extra$Type$Map$empty,
													foreigns,
													A2($author$project$Builder$Elm$Details$ArtifactsFresh, ifaces, objs));
												return A2(
													$author$project$Extra$System$IO$bind,
													A3(
														$author$project$Builder$File$writeBinary,
														$author$project$Compiler$AST$Optimized$bGlobalGraph,
														$author$project$Builder$Stuff$objects(root),
														objs),
													function (_v2) {
														return A2(
															$author$project$Extra$System$IO$bind,
															A3(
																$author$project$Builder$File$writeBinary,
																$author$project$Builder$Elm$Details$bInterfaces,
																$author$project$Builder$Stuff$interfaces(root),
																ifaces),
															function (_v3) {
																return A2(
																	$author$project$Extra$System$IO$bind,
																	A3(
																		$author$project$Builder$File$writeBinary,
																		$author$project$Builder$Elm$Details$bDetails,
																		$author$project$Builder$Stuff$details(root),
																		details),
																	function (_v4) {
																		return $author$project$Extra$System$IO$return(
																			$author$project$Extra$Type$Either$Right(details));
																	});
															});
													});
											}
										});
								});
						});
				}));
	});
var $author$project$Builder$Elm$Details$verifyApp = F3(
	function (env, time, outline) {
		var elmVersion = outline.a;
		var srcDirs = outline.b;
		var direct = outline.c;
		return _Utils_eq(elmVersion, $author$project$Compiler$Elm$Version$compiler) ? A2(
			$author$project$Builder$Reporting$Task$bind,
			$author$project$Builder$Elm$Details$checkAppDeps(outline),
			function (stated) {
				return A2(
					$author$project$Builder$Reporting$Task$bind,
					A2(
						$author$project$Builder$Elm$Details$verifyConstraints,
						env,
						A2($author$project$Extra$Type$Map$map, $author$project$Compiler$Elm$Constraint$exactly, stated)),
					function (actual) {
						return _Utils_eq(
							$author$project$Extra$Type$Map$size(stated),
							$author$project$Extra$Type$Map$size(actual)) ? A5(
							$author$project$Builder$Elm$Details$verifyDependencies,
							env,
							time,
							$author$project$Builder$Elm$Details$ValidApp(srcDirs),
							actual,
							direct) : $author$project$Builder$Reporting$Task$throw($author$project$Builder$Reporting$Exit$DetailsHandEditedDependencies);
					});
			}) : $author$project$Builder$Reporting$Task$throw(
			$author$project$Builder$Reporting$Exit$DetailsBadElmInAppOutline(elmVersion));
	});
var $author$project$Builder$Reporting$Exit$DetailsBadElmInPkg = function (a) {
	return {$: 'DetailsBadElmInPkg', a: a};
};
var $author$project$Builder$Reporting$Task$andThen = $author$project$Extra$Class$Monad$andThen($author$project$Builder$Reporting$Task$bind);
var $author$project$Builder$Elm$Details$verifyPkg = F3(
	function (env, time, _v0) {
		var pkg = _v0.a;
		var exposed = _v0.e;
		var direct = _v0.f;
		var testDirect = _v0.g;
		var elm = _v0.h;
		return $author$project$Compiler$Elm$Constraint$goodElm(elm) ? A2(
			$author$project$Builder$Reporting$Task$bind,
			A2(
				$author$project$Builder$Reporting$Task$andThen,
				$author$project$Builder$Elm$Details$verifyConstraints(env),
				A3($author$project$Builder$Elm$Details$union, $author$project$Builder$Elm$Details$noDups, direct, testDirect)),
			function (solution) {
				var exposedList = $author$project$Builder$Elm$Outline$flattenExposed(exposed);
				var exactDeps = A2(
					$author$project$Extra$Type$Map$map,
					function (_v1) {
						var v = _v1.a;
						return v;
					},
					solution);
				return A5(
					$author$project$Builder$Elm$Details$verifyDependencies,
					env,
					time,
					A3($author$project$Builder$Elm$Details$ValidPkg, pkg, exposedList, exactDeps),
					solution,
					direct);
			}) : $author$project$Builder$Reporting$Task$throw(
			$author$project$Builder$Reporting$Exit$DetailsBadElmInPkg(elm));
	});
var $author$project$Builder$Elm$Details$generate = F2(
	function (root, time) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$Elm$Details$initEnv(root),
			function (result) {
				if (result.$ === 'Left') {
					var exit = result.a;
					return $author$project$Extra$System$IO$return(
						$author$project$Extra$Type$Either$Left(exit));
				} else {
					var _v1 = result.a;
					var env = _v1.a;
					var outline = _v1.b;
					if (outline.$ === 'Pkg') {
						var pkg = outline.a;
						return $author$project$Builder$Reporting$Task$run(
							A3($author$project$Builder$Elm$Details$verifyPkg, env, time, pkg));
					} else {
						var app = outline.a;
						return $author$project$Builder$Reporting$Task$run(
							A3($author$project$Builder$Elm$Details$verifyApp, env, time, app));
					}
				}
			});
	});
var $author$project$Builder$Elm$Details$setBuildID = F2(
	function (buildID, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var d = _v0.d;
		var e = _v0.e;
		var f = _v0.f;
		return A6($author$project$Builder$Elm$Details$Details, a, b, buildID, d, e, f);
	});
var $author$project$Builder$Elm$Details$load = function (root) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Builder$File$getTime(
			A2($author$project$Extra$System$File$addName, root, 'elm.json')),
		function (newTime) {
			return A2(
				$author$project$Extra$System$IO$bind,
				A2(
					$author$project$Builder$File$readBinary,
					$author$project$Builder$Elm$Details$bDetails,
					$author$project$Builder$Stuff$details(root)),
				function (maybeDetails) {
					if (maybeDetails.$ === 'Nothing') {
						return A2($author$project$Builder$Elm$Details$generate, root, newTime);
					} else {
						var details = maybeDetails.a;
						var oldTime = details.a;
						var buildID = details.c;
						return _Utils_eq(oldTime, newTime) ? $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Right(
								A2($author$project$Builder$Elm$Details$setBuildID, buildID + 1, details))) : A2($author$project$Builder$Elm$Details$generate, root, newTime);
					}
				});
		});
};
var $author$project$Builder$Reporting$Task$mapError = F2(
	function (func, _v0) {
		var task = _v0.a;
		return $author$project$Builder$Reporting$Task$Task(
			F2(
				function (ok, err) {
					return A2(
						task,
						ok,
						A2($elm$core$Basics$composeL, err, func));
				}));
	});
var $author$project$Builder$Reporting$Exit$GenerateCannotLoadArtifacts = {$: 'GenerateCannotLoadArtifacts'};
var $author$project$Builder$Generate$Objects = F2(
	function (a, b) {
		return {$: 'Objects', a: a, b: b};
	});
var $author$project$Builder$Elm$Details$lensMVGlobalGraph = {
	getter: function (_v0) {
		var _v1 = _v0.c;
		var x = _v1.h;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var _v3 = _v2.c;
			var ai = _v3.a;
			var bi = _v3.b;
			var ci = _v3.c;
			var di = _v3.d;
			var ei = _v3.e;
			var fi = _v3.f;
			var gi = _v3.g;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				A8($author$project$Builder$Elm$Details$LocalState, ai, bi, ci, di, ei, fi, gi, x),
				d,
				e,
				f,
				g,
				h);
		})
};
var $author$project$Builder$Generate$lensMVLocalGraph = {
	getter: function (_v0) {
		var _v1 = _v0.e;
		var x = _v1.a;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var _v3 = _v2.e;
			var bi = _v3.b;
			var f = _v2.f;
			var g = _v2.g;
			var h = _v2.h;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				d,
				A2($author$project$Builder$Generate$LocalState, x, bi),
				f,
				g,
				h);
		})
};
var $author$project$Builder$Generate$finalizeObjects = function (_v0) {
	var mvar = _v0.a;
	var mvars = _v0.b;
	return A2(
		$author$project$Builder$Reporting$Task$eio,
		$elm$core$Basics$identity,
		A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Extra$System$MVar$read, $author$project$Builder$Elm$Details$lensMVGlobalGraph, mvar),
			function (result) {
				return A2(
					$author$project$Extra$System$IO$bind,
					A4(
						$author$project$Extra$Type$Map$traverse,
						$author$project$Extra$System$IO$pure,
						$author$project$Extra$System$IO$liftA2,
						$author$project$Extra$System$MVar$read($author$project$Builder$Generate$lensMVLocalGraph),
						mvars),
					function (results) {
						var _v1 = A3(
							$elm$core$Maybe$map2,
							$author$project$Builder$Generate$Objects,
							result,
							A3($author$project$Extra$Type$Map$sequenceA, $elm$core$Maybe$Just, $elm$core$Maybe$map2, results));
						if (_v1.$ === 'Just') {
							var loaded = _v1.a;
							return $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Right(loaded));
						} else {
							return $author$project$Extra$System$IO$return(
								$author$project$Extra$Type$Either$Left($author$project$Builder$Reporting$Exit$GenerateCannotLoadArtifacts));
						}
					});
			}));
};
var $author$project$Compiler$Generate$Mode$Dev = function (a) {
	return {$: 'Dev', a: a};
};
var $author$project$Compiler$Generate$Mode$DevNormal = {$: 'DevNormal'};
var $author$project$Compiler$Generate$JavaScript$HtmlKind = {$: 'HtmlKind'};
var $author$project$Compiler$Generate$JavaScript$ValueKind = {$: 'ValueKind'};
var $author$project$Compiler$Generate$JavaScript$Builder$Assign = F2(
	function (a, b) {
		return {$: 'Assign', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Block = function (a) {
	return {$: 'Block', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$CString = function (a) {
	return {$: 'CString', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Call = F2(
	function (a, b) {
		return {$: 'Call', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$ExprStmt = function (a) {
	return {$: 'ExprStmt', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$LBracket = F2(
	function (a, b) {
		return {$: 'LBracket', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Ref = function (a) {
	return {$: 'Ref', a: a};
};
var $author$project$Compiler$Generate$JavaScript$State = F3(
	function (a, b, c) {
		return {$: 'State', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$addKernel = F2(
	function (_v0, kernel) {
		var revKernels = _v0.a;
		var revBuilders = _v0.b;
		var seen = _v0.c;
		return A3(
			$author$project$Compiler$Generate$JavaScript$State,
			A2($elm$core$List$cons, kernel, revKernels),
			revBuilders,
			seen);
	});
var $author$project$Compiler$Generate$JavaScript$addBuilder = F2(
	function (_v0, builder) {
		var revKernels = _v0.a;
		var revBuilders = _v0.b;
		var seen = _v0.c;
		return A3(
			$author$project$Compiler$Generate$JavaScript$State,
			revKernels,
			A2($elm$core$List$cons, builder, revBuilders),
			seen);
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Atomic = {$: 'Atomic'};
var $author$project$Compiler$Generate$JavaScript$Builder$Many = {$: 'Many'};
var $author$project$Compiler$Generate$JavaScript$Builder$One = {$: 'One'};
var $author$project$Compiler$Generate$JavaScript$Builder$Whatever = {$: 'Whatever'};
var $author$project$Compiler$Generate$JavaScript$Builder$commaNewlineSep = F2(
	function (_v0, builders) {
		var toDeeperIndent = _v0.b;
		var _v1 = toDeeperIndent(_Utils_Tuple0);
		var deeperIndent = _v1.a;
		return $elm$core$String$concat(
			A2($author$project$Extra$Type$List$intersperse, ',\n' + deeperIndent, builders));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$commaSep = function (builders) {
	return $elm$core$String$concat(
		A2($author$project$Extra$Type$List$intersperse, ', ', builders));
};
var $author$project$Compiler$Json$Encode$encodeUgly = function (value) {
	switch (value.$) {
		case 'Array':
			if (!value.a.b) {
				return '[]';
			} else {
				var _v1 = value.a;
				var first = _v1.a;
				var rest = _v1.b;
				var encodeEntry = function (entry) {
					return ',' + $author$project$Compiler$Json$Encode$encodeUgly(entry);
				};
				return '[' + ($author$project$Compiler$Json$Encode$encodeUgly(first) + ($elm$core$String$concat(
					A2($author$project$Extra$Type$List$map, encodeEntry, rest)) + ']'));
			}
		case 'Object':
			if (!value.a.b) {
				return '{}';
			} else {
				var _v2 = value.a;
				var first = _v2.a;
				var rest = _v2.b;
				var encodeEntry = F2(
					function (_char, _v3) {
						var key = _v3.a;
						var entry = _v3.b;
						return $elm$core$String$fromChar(_char) + ('\"' + (key + ('\":' + $author$project$Compiler$Json$Encode$encodeUgly(entry))));
					});
				return A2(
					encodeEntry,
					_Utils_chr('{'),
					first) + ($elm$core$String$concat(
					A2(
						$author$project$Extra$Type$List$map,
						encodeEntry(
							_Utils_chr(',')),
						rest)) + '}');
			}
		default:
			var builder = value.a;
			return builder;
	}
};
var $author$project$Compiler$Generate$JavaScript$Builder$fromInfix = function (op) {
	switch (op.$) {
		case 'OpAdd':
			return ' + ';
		case 'OpSub':
			return ' - ';
		case 'OpMul':
			return ' * ';
		case 'OpDiv':
			return ' / ';
		case 'OpMod':
			return ' % ';
		case 'OpEq':
			return ' === ';
		case 'OpNe':
			return ' !== ';
		case 'OpLt':
			return ' < ';
		case 'OpLe':
			return ' <= ';
		case 'OpGt':
			return ' > ';
		case 'OpGe':
			return ' >= ';
		case 'OpAnd':
			return ' && ';
		case 'OpOr':
			return ' || ';
		case 'OpBitwiseAnd':
			return ' & ';
		case 'OpBitwiseXor':
			return ' ^ ';
		case 'OpBitwiseOr':
			return ' | ';
		case 'OpLShift':
			return ' << ';
		case 'OpSpRShift':
			return ' >> ';
		default:
			return ' >>> ';
	}
};
var $author$project$Compiler$Generate$JavaScript$Builder$fromPrefix = function (op) {
	switch (op.$) {
		case 'PrefixNot':
			return '!';
		case 'PrefixNegate':
			return '-';
		default:
			return '~';
	}
};
var $author$project$Compiler$Generate$JavaScript$Builder$linesMap = F2(
	function (func, xs) {
		var pairs = A2($author$project$Extra$Type$List$map, func, xs);
		return _Utils_Tuple2(
			A2(
				$author$project$Extra$Type$List$any,
				A2(
					$elm$core$Basics$composeL,
					$elm$core$Basics$eq($author$project$Compiler$Generate$JavaScript$Builder$Many),
					$elm$core$Tuple$first),
				pairs),
			A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, pairs));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$merge = F2(
	function (a, b) {
		return (_Utils_eq(a, $author$project$Compiler$Generate$JavaScript$Builder$Many) || _Utils_eq(b, $author$project$Compiler$Generate$JavaScript$Builder$Many)) ? $author$project$Compiler$Generate$JavaScript$Builder$Many : $author$project$Compiler$Generate$JavaScript$Builder$One;
	});
var $author$project$Compiler$Generate$JavaScript$Builder$parensFor = F2(
	function (grouping, builder) {
		if (grouping.$ === 'Atomic') {
			return '(' + (builder + ')');
		} else {
			return builder;
		}
	});
var $author$project$Compiler$Generate$JavaScript$Name$toBuilder = function (_v0) {
	var name = _v0.a;
	return name;
};
var $author$project$Compiler$Generate$JavaScript$Builder$fromClause = F2(
	function (level, clause) {
		var indent = level.a;
		var toNextLevel = level.b;
		if (clause.$ === 'Case') {
			var expr = clause.a;
			var stmts = clause.b;
			return indent + ('case ' + (A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b + (':\n' + A2(
				$author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock,
				toNextLevel(_Utils_Tuple0),
				stmts))));
		} else {
			var stmts = clause.a;
			return indent + ('default:\n' + A2(
				$author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock,
				toNextLevel(_Utils_Tuple0),
				stmts));
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$fromExpr = F3(
	function (level, grouping, expression) {
		var indent = level.a;
		var toNextLevel = level.b;
		var nextLevel = toNextLevel(_Utils_Tuple0);
		var deeperIndent = nextLevel.a;
		switch (expression.$) {
			case 'CString':
				var string = expression.a;
				return _Utils_Tuple2($author$project$Compiler$Generate$JavaScript$Builder$One, '\'' + (string + '\''));
			case 'CFloat':
				var _float = expression.a;
				return _Utils_Tuple2($author$project$Compiler$Generate$JavaScript$Builder$One, _float);
			case 'CInt':
				var n = expression.a;
				return _Utils_Tuple2(
					$author$project$Compiler$Generate$JavaScript$Builder$One,
					$elm$core$String$fromInt(n));
			case 'CBool':
				var bool = expression.a;
				return _Utils_Tuple2(
					$author$project$Compiler$Generate$JavaScript$Builder$One,
					bool ? 'true' : 'false');
			case 'Json':
				var json = expression.a;
				return _Utils_Tuple2(
					$author$project$Compiler$Generate$JavaScript$Builder$One,
					$author$project$Compiler$Json$Encode$encodeUgly(json));
			case 'Array':
				var exprs = expression.a;
				return A2(
					$elm$core$Tuple$pair,
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					function () {
						var _v11 = A2(
							$author$project$Compiler$Generate$JavaScript$Builder$linesMap,
							A2($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever),
							exprs);
						var anyMany = _v11.a;
						var builders = _v11.b;
						return anyMany ? ('[\n' + (deeperIndent + (A2($author$project$Compiler$Generate$JavaScript$Builder$commaNewlineSep, level, builders) + ('\n' + (indent + ']'))))) : ('[' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(builders) + ']'));
					}());
			case 'Object':
				var fields = expression.a;
				return A2(
					$elm$core$Tuple$pair,
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					function () {
						var _v12 = A2(
							$author$project$Compiler$Generate$JavaScript$Builder$linesMap,
							$author$project$Compiler$Generate$JavaScript$Builder$fromField(nextLevel),
							fields);
						var anyMany = _v12.a;
						var builders = _v12.b;
						return anyMany ? ('{\n' + (deeperIndent + (A2($author$project$Compiler$Generate$JavaScript$Builder$commaNewlineSep, level, builders) + ('\n' + (indent + '}'))))) : ('{' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(builders) + '}'));
					}());
			case 'Ref':
				var name = expression.a;
				return _Utils_Tuple2(
					$author$project$Compiler$Generate$JavaScript$Builder$One,
					$author$project$Compiler$Generate$JavaScript$Name$toBuilder(name));
			case 'Access':
				var expr = expression.a;
				var field = expression.b;
				return A3($author$project$Compiler$Generate$JavaScript$Builder$makeDot, level, expr, field);
			case 'Index':
				var expr = expression.a;
				var bracketedExpr = expression.b;
				return A3($author$project$Compiler$Generate$JavaScript$Builder$makeBracketed, level, expr, bracketedExpr);
			case 'Prefix':
				var op = expression.a;
				var expr = expression.b;
				var _v13 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, expr);
				var lines = _v13.a;
				var builder = _v13.b;
				return _Utils_Tuple2(
					lines,
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$parensFor,
						grouping,
						_Utils_ap(
							$author$project$Compiler$Generate$JavaScript$Builder$fromPrefix(op),
							builder)));
			case 'Infix':
				var op = expression.a;
				var leftExpr = expression.b;
				var rightExpr = expression.c;
				var _v14 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, rightExpr);
				var rightLines = _v14.a;
				var right = _v14.b;
				var _v15 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, leftExpr);
				var leftLines = _v15.a;
				var left = _v15.b;
				return _Utils_Tuple2(
					A2($author$project$Compiler$Generate$JavaScript$Builder$merge, leftLines, rightLines),
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$parensFor,
						grouping,
						_Utils_ap(
							left,
							_Utils_ap(
								$author$project$Compiler$Generate$JavaScript$Builder$fromInfix(op),
								right))));
			case 'If':
				var condExpr = expression.a;
				var thenExpr = expression.b;
				var elseExpr = expression.c;
				var thenB = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, thenExpr).b;
				var elseB = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, elseExpr).b;
				var condB = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, condExpr).b;
				return _Utils_Tuple2(
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					A2($author$project$Compiler$Generate$JavaScript$Builder$parensFor, grouping, condB + (' ? ' + (thenB + (' : ' + elseB)))));
			case 'Assign':
				var lValue = expression.a;
				var expr = expression.b;
				var _v16 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr);
				var rightLines = _v16.a;
				var right = _v16.b;
				var _v17 = A2($author$project$Compiler$Generate$JavaScript$Builder$fromLValue, level, lValue);
				var leftLines = _v17.a;
				var left = _v17.b;
				return _Utils_Tuple2(
					A2($author$project$Compiler$Generate$JavaScript$Builder$merge, leftLines, rightLines),
					A2($author$project$Compiler$Generate$JavaScript$Builder$parensFor, grouping, left + (' = ' + right)));
			case 'Call':
				var _function = expression.a;
				var args = expression.b;
				return A2(
					$elm$core$Tuple$pair,
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					function () {
						var _v18 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, _function);
						var funcB = _v18.b;
						var _v19 = A2(
							$author$project$Compiler$Generate$JavaScript$Builder$linesMap,
							A2($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, nextLevel, $author$project$Compiler$Generate$JavaScript$Builder$Whatever),
							args);
						var anyMany = _v19.a;
						var argsB = _v19.b;
						return anyMany ? (funcB + ('(\n' + (deeperIndent + (A2($author$project$Compiler$Generate$JavaScript$Builder$commaNewlineSep, level, argsB) + ')')))) : (funcB + ('(' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(argsB) + ')')));
					}());
			case 'Function':
				var maybeName = expression.a;
				var args = expression.b;
				var stmts = expression.c;
				return A2(
					$elm$core$Tuple$pair,
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					'function ' + (A3($author$project$Extra$Type$Maybe$maybe, '', $author$project$Compiler$Generate$JavaScript$Name$toBuilder, maybeName) + ('(' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(
						A2($author$project$Extra$Type$List$map, $author$project$Compiler$Generate$JavaScript$Name$toBuilder, args)) + (') {\n' + (A2($author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock, nextLevel, stmts) + (indent + '}')))))));
			case 'AsyncCall':
				var _function = expression.a;
				var args = expression.b;
				return A2(
					$elm$core$Tuple$pair,
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					function () {
						var _v20 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, _function);
						var funcB = _v20.b;
						var _v21 = A2(
							$author$project$Compiler$Generate$JavaScript$Builder$linesMap,
							A2($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, nextLevel, $author$project$Compiler$Generate$JavaScript$Builder$Whatever),
							args);
						var anyMany = _v21.a;
						var argsB = _v21.b;
						return 'await ' + (anyMany ? (funcB + ('(\n' + (deeperIndent + (A2($author$project$Compiler$Generate$JavaScript$Builder$commaNewlineSep, level, argsB) + ')')))) : (funcB + ('(' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(argsB) + ')'))));
					}());
			default:
				var maybeName = expression.a;
				var args = expression.b;
				var stmts = expression.c;
				return A2(
					$elm$core$Tuple$pair,
					$author$project$Compiler$Generate$JavaScript$Builder$Many,
					'async function ' + (A3($author$project$Extra$Type$Maybe$maybe, '', $author$project$Compiler$Generate$JavaScript$Name$toBuilder, maybeName) + ('(' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(
						A2($author$project$Extra$Type$List$map, $author$project$Compiler$Generate$JavaScript$Name$toBuilder, args)) + (') {\n' + (A2($author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock, nextLevel, stmts) + (indent + '}')))))));
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$fromField = F2(
	function (level, _v8) {
		var field = _v8.a;
		var expr = _v8.b;
		var _v9 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr);
		var lines = _v9.a;
		var builder = _v9.b;
		return _Utils_Tuple2(
			lines,
			$author$project$Compiler$Generate$JavaScript$Name$toBuilder(field) + (': ' + builder));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$fromLValue = F2(
	function (level, lValue) {
		if (lValue.$ === 'LRef') {
			var name = lValue.a;
			return _Utils_Tuple2(
				$author$project$Compiler$Generate$JavaScript$Builder$One,
				$author$project$Compiler$Generate$JavaScript$Name$toBuilder(name));
		} else {
			var expr = lValue.a;
			var bracketedExpr = lValue.b;
			return A3($author$project$Compiler$Generate$JavaScript$Builder$makeBracketed, level, expr, bracketedExpr);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$fromStmt = F2(
	function (level, statement) {
		var indent = level.a;
		var toNextLevel = level.b;
		switch (statement.$) {
			case 'Block':
				var stmts = statement.a;
				return A2($author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock, level, stmts);
			case 'EmptyStmt':
				return '';
			case 'ExprStmt':
				var expr = statement.a;
				return indent + (A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b + ';\n');
			case 'IfStmt':
				var condition = statement.a;
				var thenStmt = statement.b;
				var elseStmt = statement.c;
				return $elm$core$String$concat(
					_List_fromArray(
						[
							indent,
							'if (',
							A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, condition).b,
							') {\n',
							A2(
							$author$project$Compiler$Generate$JavaScript$Builder$fromStmt,
							toNextLevel(_Utils_Tuple0),
							thenStmt),
							indent,
							'} else {\n',
							A2(
							$author$project$Compiler$Generate$JavaScript$Builder$fromStmt,
							toNextLevel(_Utils_Tuple0),
							elseStmt),
							indent,
							'}\n'
						]));
			case 'Switch':
				var expr = statement.a;
				var clauses = statement.b;
				return $elm$core$String$concat(
					_List_fromArray(
						[
							indent,
							'switch (',
							A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b,
							') {\n',
							$elm$core$String$concat(
							A2(
								$author$project$Extra$Type$List$map,
								$author$project$Compiler$Generate$JavaScript$Builder$fromClause(
									toNextLevel(_Utils_Tuple0)),
								clauses)),
							indent,
							'}\n'
						]));
			case 'While':
				var expr = statement.a;
				var stmt = statement.b;
				return $elm$core$String$concat(
					_List_fromArray(
						[
							indent,
							'while (',
							A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b,
							') {\n',
							A2(
							$author$project$Compiler$Generate$JavaScript$Builder$fromStmt,
							toNextLevel(_Utils_Tuple0),
							stmt),
							indent,
							'}\n'
						]));
			case 'Break':
				if (statement.a.$ === 'Nothing') {
					var _v5 = statement.a;
					return indent + 'break;\n';
				} else {
					var label = statement.a.a;
					return indent + ('break ' + ($author$project$Compiler$Generate$JavaScript$Name$toBuilder(label) + ';\n'));
				}
			case 'Continue':
				if (statement.a.$ === 'Nothing') {
					var _v6 = statement.a;
					return indent + 'continue;\n';
				} else {
					var label = statement.a.a;
					return indent + ('continue ' + ($author$project$Compiler$Generate$JavaScript$Name$toBuilder(label) + ';\n'));
				}
			case 'Labelled':
				var label = statement.a;
				var stmt = statement.b;
				return $elm$core$String$concat(
					_List_fromArray(
						[
							indent,
							$author$project$Compiler$Generate$JavaScript$Name$toBuilder(label),
							':\n',
							A2($author$project$Compiler$Generate$JavaScript$Builder$fromStmt, level, stmt)
						]));
			case 'Try':
				var tryStmt = statement.a;
				var errorName = statement.b;
				var catchStmt = statement.c;
				return $elm$core$String$concat(
					_List_fromArray(
						[
							indent,
							'try {\n',
							A2(
							$author$project$Compiler$Generate$JavaScript$Builder$fromStmt,
							toNextLevel(_Utils_Tuple0),
							tryStmt),
							indent,
							'} catch (',
							$author$project$Compiler$Generate$JavaScript$Name$toBuilder(errorName),
							') {\n',
							A2(
							$author$project$Compiler$Generate$JavaScript$Builder$fromStmt,
							toNextLevel(_Utils_Tuple0),
							catchStmt),
							indent,
							'}\n'
						]));
			case 'Throw':
				var expr = statement.a;
				return indent + ('throw ' + (A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b + ';'));
			case 'Return':
				var expr = statement.a;
				return indent + ('return ' + (A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b + ';\n'));
			case 'Var':
				var name = statement.a;
				var expr = statement.b;
				return indent + ('var ' + ($author$project$Compiler$Generate$JavaScript$Name$toBuilder(name) + (' = ' + (A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b + ';\n'))));
			case 'Vars':
				if (!statement.a.b) {
					return '';
				} else {
					var vars = statement.a;
					return indent + ('var ' + (A2(
						$author$project$Compiler$Generate$JavaScript$Builder$commaNewlineSep,
						level,
						A2(
							$author$project$Extra$Type$List$map,
							$author$project$Compiler$Generate$JavaScript$Builder$varToBuilder(level),
							vars)) + ';\n'));
				}
			default:
				var name = statement.a;
				var args = statement.b;
				var stmts = statement.c;
				return indent + ('function ' + ($author$project$Compiler$Generate$JavaScript$Name$toBuilder(name) + ('(' + ($author$project$Compiler$Generate$JavaScript$Builder$commaSep(
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Generate$JavaScript$Name$toBuilder, args)) + (') {\n' + (A2(
					$author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock,
					toNextLevel(_Utils_Tuple0),
					stmts) + (indent + '}\n')))))));
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$fromStmtBlock = F2(
	function (level, stmts) {
		return $elm$core$String$concat(
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Builder$fromStmt(level),
				stmts));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$makeBracketed = F3(
	function (level, expr, bracketedExpr) {
		var _v2 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, expr);
		var lines = _v2.a;
		var builder = _v2.b;
		var _v3 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, bracketedExpr);
		var bracketedLines = _v3.a;
		var bracketedBuilder = _v3.b;
		return _Utils_Tuple2(
			A2($author$project$Compiler$Generate$JavaScript$Builder$merge, lines, bracketedLines),
			builder + ('[' + (bracketedBuilder + ']')));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$makeDot = F3(
	function (level, expr, field) {
		var _v1 = A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Atomic, expr);
		var lines = _v1.a;
		var builder = _v1.b;
		return _Utils_Tuple2(
			lines,
			builder + ('.' + $author$project$Compiler$Generate$JavaScript$Name$toBuilder(field)));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$varToBuilder = F2(
	function (level, _v0) {
		var name = _v0.a;
		var expr = _v0.b;
		return $author$project$Compiler$Generate$JavaScript$Name$toBuilder(name) + (' = ' + A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, level, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b);
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Level = F2(
	function (a, b) {
		return {$: 'Level', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$makeLevel = F2(
	function (increase, value) {
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Level,
			value,
			function (_v0) {
				return A2(
					$author$project$Compiler$Generate$JavaScript$Builder$makeLevel,
					increase,
					_Utils_ap(value, increase));
			});
	});
var $author$project$Compiler$Generate$JavaScript$Builder$levelZero = A2(
	$author$project$Compiler$Generate$JavaScript$Builder$Level,
	'',
	function (_v0) {
		return A2($author$project$Compiler$Generate$JavaScript$Builder$makeLevel, '\t', '\t');
	});
var $author$project$Compiler$Generate$JavaScript$Builder$stmtToBuilder = function (stmts) {
	return A2($author$project$Compiler$Generate$JavaScript$Builder$fromStmt, $author$project$Compiler$Generate$JavaScript$Builder$levelZero, stmts);
};
var $author$project$Compiler$Generate$JavaScript$addStmt = F2(
	function (state, stmt) {
		return A2(
			$author$project$Compiler$Generate$JavaScript$addBuilder,
			state,
			$author$project$Compiler$Generate$JavaScript$Builder$stmtToBuilder(stmt));
	});
var $author$project$Compiler$Generate$Mode$DevAsync = F2(
	function (a, b) {
		return {$: 'DevAsync', a: a, b: b};
	});
var $author$project$Compiler$Generate$Mode$deActivate = function (mode) {
	if (((mode.$ === 'Dev') && (mode.a.$ === 'DevAsync')) && mode.a.a) {
		var _v1 = mode.a;
		var suspendFuns = _v1.b;
		return $author$project$Compiler$Generate$Mode$Dev(
			A2($author$project$Compiler$Generate$Mode$DevAsync, false, suspendFuns));
	} else {
		return mode;
	}
};
var $author$project$Compiler$AST$Optimized$fromGlobalComparable = function (_v0) {
	var moduleName = _v0.a;
	var name = _v0.b;
	return A2(
		$author$project$Compiler$AST$Optimized$Global,
		$author$project$Compiler$Elm$ModuleName$fromComparable(moduleName),
		name);
};
var $author$project$Compiler$Generate$JavaScript$Name$Name = function (a) {
	return {$: 'Name', a: a};
};
var $author$project$Compiler$Data$Utf8$toBuilder = $elm$core$Basics$identity;
var $author$project$Compiler$Data$Name$toBuilder = $author$project$Compiler$Data$Utf8$toBuilder;
var $author$project$Compiler$Generate$JavaScript$Name$fromKernel = F2(
	function (home, name) {
		return $author$project$Compiler$Generate$JavaScript$Name$Name(
			'_' + ($author$project$Compiler$Data$Name$toBuilder(home) + ('_' + $author$project$Compiler$Data$Name$toBuilder(name))));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Access = F2(
	function (a, b) {
		return {$: 'Access', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Array = function (a) {
	return {$: 'Array', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Break = function (a) {
	return {$: 'Break', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$CBool = function (a) {
	return {$: 'CBool', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$CFloat = function (a) {
	return {$: 'CFloat', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$CInt = function (a) {
	return {$: 'CInt', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Case = F2(
	function (a, b) {
		return {$: 'Case', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Continue = function (a) {
	return {$: 'Continue', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Default = function (a) {
	return {$: 'Default', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Function = F3(
	function (a, b, c) {
		return {$: 'Function', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$IfStmt = F3(
	function (a, b, c) {
		return {$: 'IfStmt', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Infix = F3(
	function (a, b, c) {
		return {$: 'Infix', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$Expression$JsBlock = function (a) {
	return {$: 'JsBlock', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Expression$JsExpr = function (a) {
	return {$: 'JsExpr', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$LRef = function (a) {
	return {$: 'LRef', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Labelled = F2(
	function (a, b) {
		return {$: 'Labelled', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Object = function (a) {
	return {$: 'Object', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$OpAdd = {$: 'OpAdd'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpAnd = {$: 'OpAnd'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseOr = {$: 'OpBitwiseOr'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpDiv = {$: 'OpDiv'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpGe = {$: 'OpGe'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpGt = {$: 'OpGt'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpLe = {$: 'OpLe'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpLt = {$: 'OpLt'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpMod = {$: 'OpMod'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpMul = {$: 'OpMul'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpNe = {$: 'OpNe'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpOr = {$: 'OpOr'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpSub = {$: 'OpSub'};
var $author$project$Compiler$Generate$JavaScript$Builder$Prefix = F2(
	function (a, b) {
		return {$: 'Prefix', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$PrefixNegate = {$: 'PrefixNegate'};
var $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot = {$: 'PrefixNot'};
var $author$project$Compiler$Generate$JavaScript$Builder$Return = function (a) {
	return {$: 'Return', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Switch = F2(
	function (a, b) {
		return {$: 'Switch', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Var = F2(
	function (a, b) {
		return {$: 'Var', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Vars = function (a) {
	return {$: 'Vars', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$While = F2(
	function (a, b) {
		return {$: 'While', a: a, b: b};
	});
var $author$project$Compiler$Generate$Mode$isAsync = function (mode) {
	if ((mode.$ === 'Dev') && (mode.a.$ === 'DevAsync')) {
		var _v1 = mode.a;
		return true;
	} else {
		return false;
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$addAsyncName = F2(
	function (mode, name) {
		return $author$project$Compiler$Generate$Mode$isAsync(mode) ? (name + '_async') : name;
	});
var $author$project$Compiler$Generate$JavaScript$Expression$addAsyncGlobal = F6(
	function (mode, author, pkg, moduleName, name, expr) {
		if (expr.$ === 'VarGlobal') {
			var _v1 = expr.a;
			var _v2 = _v1.a;
			var _v3 = _v2.a;
			var a = _v3.a;
			var p = _v3.b;
			var m = _v2.b;
			var n = _v1.b;
			return (_Utils_eq(a, author) && (_Utils_eq(p, pkg) && (_Utils_eq(m, moduleName) && _Utils_eq(n, name)))) ? $author$project$Compiler$AST$Optimized$VarGlobal(
				A2(
					$author$project$Compiler$AST$Optimized$Global,
					A2(
						$author$project$Compiler$Elm$ModuleName$Canonical,
						A2($author$project$Compiler$Elm$Package$Name, a, p),
						m),
					A2($author$project$Compiler$Generate$JavaScript$Expression$addAsyncName, mode, n))) : expr;
		} else {
			return expr;
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$If = F3(
	function (a, b, c) {
		return {$: 'If', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$Expression$codeToExpr = function (code) {
	if (code.$ === 'JsExpr') {
		var expr = code.a;
		return expr;
	} else {
		if ((code.a.b && (code.a.a.$ === 'Return')) && (!code.a.b.b)) {
			var _v1 = code.a;
			var expr = _v1.a.a;
			return expr;
		} else {
			var stmts = code.a;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Call,
				A3($author$project$Compiler$Generate$JavaScript$Builder$Function, $elm$core$Maybe$Nothing, _List_Nil, stmts),
				_List_Nil);
		}
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$addExprIf = F2(
	function (_v0, _final) {
		var condition = _v0.a;
		var branch = _v0.b;
		return A3(
			$author$project$Compiler$Generate$JavaScript$Builder$If,
			condition,
			$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(branch),
			_final);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$codeToStmt = function (code) {
	if (code.$ === 'JsExpr') {
		if (((((code.a.$ === 'Call') && (code.a.a.$ === 'Function')) && (code.a.a.a.$ === 'Nothing')) && (!code.a.a.b.b)) && (!code.a.b.b)) {
			var _v1 = code.a;
			var _v2 = _v1.a;
			var _v3 = _v2.a;
			var stmts = _v2.c;
			return $author$project$Compiler$Generate$JavaScript$Builder$Block(stmts);
		} else {
			var expr = code.a;
			return $author$project$Compiler$Generate$JavaScript$Builder$Return(expr);
		}
	} else {
		if (code.a.b && (!code.a.b.b)) {
			var _v4 = code.a;
			var stmt = _v4.a;
			return stmt;
		} else {
			var stmts = code.a;
			return $author$project$Compiler$Generate$JavaScript$Builder$Block(stmts);
		}
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$addStmtIf = F2(
	function (_v0, _final) {
		var condition = _v0.a;
		var branch = _v0.b;
		return A3(
			$author$project$Compiler$Generate$JavaScript$Builder$IfStmt,
			condition,
			$author$project$Compiler$Generate$JavaScript$Expression$codeToStmt(branch),
			_final);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$apply = F2(
	function (func, value) {
		switch (func.$) {
			case 'Accessor':
				var field = func.a;
				return A2($author$project$Compiler$AST$Optimized$Access, value, field);
			case 'Call':
				var f = func.a;
				var args = func.b;
				return A2(
					$author$project$Compiler$AST$Optimized$Call,
					f,
					_Utils_ap(
						args,
						_List_fromArray(
							[value])));
			default:
				return A2(
					$author$project$Compiler$AST$Optimized$Call,
					func,
					_List_fromArray(
						[value]));
		}
	});
var $author$project$Compiler$Data$Name$bitwise = 'Bitwise';
var $author$project$Compiler$Generate$JavaScript$Expression$getBreakpointDefSuspendFun = F2(
	function (func, args) {
		var _v0 = _Utils_Tuple2(func, args);
		if ((((((((((((_v0.a.$ === 'VarGlobal') && (_v0.a.a.b === 'apL')) && _v0.b.b) && (_v0.b.a.$ === 'VarGlobal')) && (_v0.b.a.a.a.a.a === 'elm')) && (_v0.b.a.a.a.a.b === 'breakpoint')) && (_v0.b.a.a.a.b === 'Breakpoint')) && (_v0.b.a.a.b === 'new')) && _v0.b.b.b) && (_v0.b.b.a.$ === 'Function')) && _v0.b.b.a.a.b) && (!_v0.b.b.b.b)) {
			var _v1 = _v0.a.a;
			var _v2 = _v1.a;
			var pkg = _v2.a;
			var moduleName = _v2.b;
			var _v3 = _v0.b;
			var _v4 = _v3.a.a;
			var _v5 = _v4.a;
			var _v6 = _v5.a;
			var _v7 = _v3.b;
			var _v8 = _v7.a;
			var _v9 = _v8.a;
			var arg = _v9.a;
			return (_Utils_eq(pkg, $author$project$Compiler$Elm$Package$core) && _Utils_eq(moduleName, $author$project$Compiler$Data$Name$basics)) ? $elm$core$Maybe$Just(arg) : $elm$core$Maybe$Nothing;
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$breakpointDefCall = F4(
	function (func, args, mode, maybeBpNames) {
		var _v0 = _Utils_Tuple3(
			mode,
			A2($author$project$Compiler$Generate$JavaScript$Expression$getBreakpointDefSuspendFun, func, args),
			maybeBpNames);
		if (((((_v0.a.$ === 'Dev') && (_v0.a.a.$ === 'DevAsync')) && _v0.a.a.a) && (_v0.b.$ === 'Just')) && (_v0.c.$ === 'Just')) {
			var _v1 = _v0.a.a;
			var suspendFuns = _v1.b;
			var suspendFun = _v0.b.a;
			var _v2 = _v0.c.a;
			var moduleName = _v2.a;
			var bpName = _v2.b;
			return _Utils_Tuple3(
				$author$project$Compiler$Generate$Mode$Dev(
					A2(
						$author$project$Compiler$Generate$Mode$DevAsync,
						true,
						A2($author$project$Extra$Type$Set$insert, suspendFun, suspendFuns))),
				A2($author$project$Compiler$AST$Optimized$VarKernel, 'Breakpoint', 'named'),
				_List_fromArray(
					[
						$author$project$Compiler$AST$Optimized$Str(moduleName),
						$author$project$Compiler$AST$Optimized$Str(bpName),
						A2($author$project$Compiler$AST$Optimized$Call, func, args)
					]));
		} else {
			return _Utils_Tuple3(mode, func, args);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$isLiteral = function (expr) {
	switch (expr.$) {
		case 'CString':
			return true;
		case 'CFloat':
			return true;
		case 'CInt':
			return true;
		case 'CBool':
			return true;
		default:
			return false;
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$cmp = F5(
	function (idealOp, backupOp, backupInt, left, right) {
		return ($author$project$Compiler$Generate$JavaScript$Expression$isLiteral(left) || $author$project$Compiler$Generate$JavaScript$Expression$isLiteral(right)) ? A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, idealOp, left, right) : A3(
			$author$project$Compiler$Generate$JavaScript$Builder$Infix,
			backupOp,
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Call,
				$author$project$Compiler$Generate$JavaScript$Builder$Ref(
					A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'cmp')),
				_List_fromArray(
					[left, right])),
			$author$project$Compiler$Generate$JavaScript$Builder$CInt(backupInt));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList = function (code) {
	if (code.$ === 'JsExpr') {
		if (((((code.a.$ === 'Call') && (code.a.a.$ === 'Function')) && (code.a.a.a.$ === 'Nothing')) && (!code.a.a.b.b)) && (!code.a.b.b)) {
			var _v1 = code.a;
			var _v2 = _v1.a;
			var _v3 = _v2.a;
			var stmts = _v2.c;
			return stmts;
		} else {
			var expr = code.a;
			return _List_fromArray(
				[
					$author$project$Compiler$Generate$JavaScript$Builder$Return(expr)
				]);
		}
	} else {
		var stmts = code.a;
		return stmts;
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$crushIfsHelp = F3(
	function (visitedBranches, unvisitedBranches, _final) {
		crushIfsHelp:
		while (true) {
			if (!unvisitedBranches.b) {
				if (_final.$ === 'If') {
					var subBranches = _final.a;
					var subFinal = _final.b;
					var $temp$visitedBranches = visitedBranches,
						$temp$unvisitedBranches = subBranches,
						$temp$final = subFinal;
					visitedBranches = $temp$visitedBranches;
					unvisitedBranches = $temp$unvisitedBranches;
					_final = $temp$final;
					continue crushIfsHelp;
				} else {
					return _Utils_Tuple2(
						$author$project$Extra$Type$List$reverse(visitedBranches),
						_final);
				}
			} else {
				var visiting = unvisitedBranches.a;
				var unvisited = unvisitedBranches.b;
				var $temp$visitedBranches = A2($elm$core$List$cons, visiting, visitedBranches),
					$temp$unvisitedBranches = unvisited,
					$temp$final = _final;
				visitedBranches = $temp$visitedBranches;
				unvisitedBranches = $temp$unvisitedBranches;
				_final = $temp$final;
				continue crushIfsHelp;
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$crushIfs = F2(
	function (branches, _final) {
		return A3($author$project$Compiler$Generate$JavaScript$Expression$crushIfsHelp, _List_Nil, branches, _final);
	});
var $author$project$Compiler$Generate$JavaScript$Name$usd = $author$project$Compiler$Data$Name$toBuilder($author$project$Compiler$Data$Name$dollar);
var $author$project$Compiler$Generate$JavaScript$Name$dollar = $author$project$Compiler$Generate$JavaScript$Name$Name($author$project$Compiler$Generate$JavaScript$Name$usd);
var $author$project$Compiler$Generate$JavaScript$Builder$OpEq = {$: 'OpEq'};
var $author$project$Compiler$Generate$JavaScript$Expression$strictEq = F2(
	function (left, right) {
		_v0$2:
		while (true) {
			switch (left.$) {
				case 'CInt':
					if (!left.a) {
						return A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, right);
					} else {
						break _v0$2;
					}
				case 'CBool':
					var bool = left.a;
					return bool ? right : A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, right);
				default:
					break _v0$2;
			}
		}
		_v1$2:
		while (true) {
			switch (right.$) {
				case 'CInt':
					if (!right.a) {
						return A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, left);
					} else {
						break _v1$2;
					}
				case 'CBool':
					var bool = right.a;
					return bool ? left : A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, left);
				default:
					break _v1$2;
			}
		}
		return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpEq, left, right);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$equal = F2(
	function (left, right) {
		return ($author$project$Compiler$Generate$JavaScript$Expression$isLiteral(left) || $author$project$Compiler$Generate$JavaScript$Expression$isLiteral(right)) ? A2($author$project$Compiler$Generate$JavaScript$Expression$strictEq, left, right) : A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Call,
			$author$project$Compiler$Generate$JavaScript$Builder$Ref(
				A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'eq')),
			_List_fromArray(
				[left, right]));
	});
var $author$project$Extra$Type$List$foldl1 = F2(
	function (f, xs) {
		var mf = F2(
			function (m, y) {
				return $elm$core$Maybe$Just(
					function () {
						if (m.$ === 'Nothing') {
							return y;
						} else {
							var x = m.a;
							return A2(f, x, y);
						}
					}());
			});
		var _v0 = A3($author$project$Extra$Type$List$foldl, mf, $elm$core$Maybe$Nothing, xs);
		if (_v0.$ === 'Nothing') {
			return _Debug_todo(
				'Extra.Type.List',
				{
					start: {line: 140, column: 13},
					end: {line: 140, column: 23}
				})('Extra.Type.List_.foldl1: empty list');
		} else {
			var x = _v0.a;
			return x;
		}
	});
var $author$project$Extra$Type$List$foldr1 = F2(
	function (f, xs) {
		var mf = F2(
			function (x, acc) {
				return $elm$core$Maybe$Just(
					function () {
						if (acc.$ === 'Nothing') {
							return x;
						} else {
							var y = acc.a;
							return A2(f, x, y);
						}
					}());
			});
		var _v0 = A3($author$project$Extra$Type$List$foldr, mf, $elm$core$Maybe$Nothing, xs);
		if (_v0.$ === 'Nothing') {
			return _Debug_todo(
				'Extra.Type.List',
				{
					start: {line: 175, column: 13},
					end: {line: 175, column: 23}
				})('Extra.Type.List_.foldr1: empty list');
		} else {
			var x = _v0.a;
			return x;
		}
	});
var $elm$core$String$replace = F3(
	function (before, after, string) {
		return A2(
			$elm$core$String$join,
			after,
			A2($elm$core$String$split, before, string));
	});
var $author$project$Compiler$Generate$JavaScript$Name$homeToBuilder = function (_v0) {
	var _v1 = _v0.a;
	var author = _v1.a;
	var project = _v1.b;
	var home = _v0.b;
	return _Utils_ap(
		$author$project$Compiler$Generate$JavaScript$Name$usd,
		_Utils_ap(
			A3($elm$core$String$replace, '-', '_', author),
			_Utils_ap(
				$author$project$Compiler$Generate$JavaScript$Name$usd,
				_Utils_ap(
					A3($elm$core$String$replace, '-', '_', project),
					_Utils_ap(
						$author$project$Compiler$Generate$JavaScript$Name$usd,
						A3($elm$core$String$replace, '.', '$', home))))));
};
var $author$project$Compiler$Generate$JavaScript$Name$fromCycle = F2(
	function (home, name) {
		return $author$project$Compiler$Generate$JavaScript$Name$Name(
			$author$project$Compiler$Generate$JavaScript$Name$homeToBuilder(home) + ('$cyclic$' + $author$project$Compiler$Data$Name$toBuilder(name)));
	});
var $author$project$Compiler$Generate$JavaScript$Name$fromGlobal = F2(
	function (home, name) {
		return $author$project$Compiler$Generate$JavaScript$Name$Name(
			_Utils_ap(
				$author$project$Compiler$Generate$JavaScript$Name$homeToBuilder(home),
				_Utils_ap(
					$author$project$Compiler$Generate$JavaScript$Name$usd,
					$author$project$Compiler$Data$Name$toBuilder(name))));
	});
var $author$project$Compiler$Generate$JavaScript$Name$elmReservedWords = $author$project$Extra$Type$Set$fromList(
	_List_fromArray(
		['F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9']));
var $author$project$Compiler$Generate$JavaScript$Name$jsReservedWords = $author$project$Extra$Type$Set$fromList(
	_List_fromArray(
		['do', 'if', 'in', 'NaN', 'int', 'for', 'new', 'try', 'var', 'let', 'null', 'true', 'eval', 'byte', 'char', 'goto', 'long', 'case', 'else', 'this', 'void', 'with', 'enum', 'false', 'final', 'float', 'short', 'break', 'catch', 'throw', 'while', 'class', 'const', 'super', 'yield', 'double', 'native', 'throws', 'delete', 'return', 'switch', 'typeof', 'export', 'import', 'public', 'static', 'boolean', 'default', 'finally', 'extends', 'package', 'private', 'Infinity', 'abstract', 'volatile', 'function', 'continue', 'debugger', 'function', 'undefined', 'arguments', 'transient', 'interface', 'protected', 'instanceof', 'implements', 'synchronized']));
var $author$project$Compiler$Generate$JavaScript$Name$reservedNames = A2($author$project$Extra$Type$Set$union, $author$project$Compiler$Generate$JavaScript$Name$jsReservedWords, $author$project$Compiler$Generate$JavaScript$Name$elmReservedWords);
var $author$project$Compiler$Generate$JavaScript$Name$fromLocal = function (name) {
	return A2($author$project$Extra$Type$Set$member, name, $author$project$Compiler$Generate$JavaScript$Name$reservedNames) ? $author$project$Compiler$Generate$JavaScript$Name$Name(
		'_' + $author$project$Compiler$Data$Name$toBuilder(name)) : $author$project$Compiler$Generate$JavaScript$Name$Name(
		$author$project$Compiler$Data$Name$toBuilder(name));
};
var $author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseAnd = {$: 'OpBitwiseAnd'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseXor = {$: 'OpBitwiseXor'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpLShift = {$: 'OpLShift'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpSpRShift = {$: 'OpSpRShift'};
var $author$project$Compiler$Generate$JavaScript$Builder$OpZfRShift = {$: 'OpZfRShift'};
var $author$project$Compiler$Generate$JavaScript$Builder$PrefixComplement = {$: 'PrefixComplement'};
var $author$project$Compiler$Generate$JavaScript$Builder$AsyncCall = F2(
	function (a, b) {
		return {$: 'AsyncCall', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Name$makeA = function (n) {
	return $author$project$Compiler$Generate$JavaScript$Name$Name(
		'A' + $elm$core$String$fromInt(n));
};
var $author$project$Compiler$Generate$JavaScript$Expression$callHelpers = $author$project$Extra$Type$Map$fromList(
	A2(
		$author$project$Extra$Type$List$map,
		function (n) {
			return _Utils_Tuple2(
				n,
				$author$project$Compiler$Generate$JavaScript$Builder$Ref(
					$author$project$Compiler$Generate$JavaScript$Name$makeA(n)));
		},
		A2($author$project$Extra$Type$List$range, 2, 9)));
var $author$project$Compiler$Generate$JavaScript$Expression$generateNormalCallAsync = F3(
	function (isAsync, func, args) {
		var call = isAsync ? $author$project$Compiler$Generate$JavaScript$Builder$AsyncCall : $author$project$Compiler$Generate$JavaScript$Builder$Call;
		var _v0 = A2(
			$author$project$Extra$Type$Map$lookup,
			$author$project$Extra$Type$List$length(args),
			$author$project$Compiler$Generate$JavaScript$Expression$callHelpers);
		if (_v0.$ === 'Just') {
			var helper = _v0.a;
			return A2(
				call,
				helper,
				A2($elm$core$List$cons, func, args));
		} else {
			return A3(
				$author$project$Extra$Type$List$foldl,
				F2(
					function (f, a) {
						return A2(
							call,
							f,
							_List_fromArray(
								[a]));
					}),
				func,
				args);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateNormalCall = $author$project$Compiler$Generate$JavaScript$Expression$generateNormalCallAsync(false);
var $author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall = F3(
	function (home, name, args) {
		return A2(
			$author$project$Compiler$Generate$JavaScript$Expression$generateNormalCall,
			$author$project$Compiler$Generate$JavaScript$Builder$Ref(
				A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name)),
			args);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateBitwiseCall = F3(
	function (home, name, args) {
		_v0$2:
		while (true) {
			if (args.b) {
				if (!args.b.b) {
					var arg = args.a;
					if (name === 'complement') {
						return A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixComplement, arg);
					} else {
						return A3($author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall, home, name, args);
					}
				} else {
					if (!args.b.b.b) {
						var left = args.a;
						var _v2 = args.b;
						var right = _v2.a;
						switch (name) {
							case 'and':
								return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseAnd, left, right);
							case 'or':
								return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseOr, left, right);
							case 'xor':
								return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseXor, left, right);
							case 'shiftLeftBy':
								return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpLShift, right, left);
							case 'shiftRightBy':
								return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpSpRShift, right, left);
							case 'shiftRightZfBy':
								return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpZfRShift, right, left);
							default:
								return A3($author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall, home, name, args);
						}
					} else {
						break _v0$2;
					}
				}
			} else {
				break _v0$2;
			}
		}
		return A3($author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall, home, name, args);
	});
var $author$project$Compiler$Generate$JavaScript$Name$BadFields = function (a) {
	return {$: 'BadFields', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes = 64;
var $author$project$Compiler$Generate$JavaScript$Name$numStartBytes = 54;
var $author$project$Compiler$Data$Name$fromWords = function (words) {
	return $elm$core$String$fromList(
		A2($author$project$Extra$Type$List$map, $elm$core$Char$fromCode, words));
};
var $author$project$Compiler$Generate$JavaScript$Name$toByte = function (n) {
	return (n < 26) ? (97 + n) : ((n < 52) ? ((65 + n) - 26) : ((n === 52) ? 95 : ((n === 53) ? 36 : ((n < 64) ? ((48 + n) - 54) : _Debug_todo(
		'Compiler.Generate.JavaScript.Name',
		{
			start: {line: 224, column: 8},
			end: {line: 224, column: 18}
		})(
		'cannot convert int ' + ($elm$core$String$fromInt(n) + ' to ASCII'))))));
};
var $author$project$Compiler$Generate$JavaScript$Name$unsafeIntToAscii = F3(
	function (width, bytes, n) {
		unsafeIntToAscii:
		while (true) {
			if (width <= 1) {
				return $author$project$Compiler$Data$Name$fromWords(
					A2(
						$elm$core$List$cons,
						$author$project$Compiler$Generate$JavaScript$Name$toByte(n),
						bytes));
			} else {
				var remainder = A2($elm$core$Basics$modBy, $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes, n);
				var quotient = (n / $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes) | 0;
				var $temp$width = width - 1,
					$temp$bytes = A2(
					$elm$core$List$cons,
					$author$project$Compiler$Generate$JavaScript$Name$toByte(remainder),
					bytes),
					$temp$n = quotient;
				width = $temp$width;
				bytes = $temp$bytes;
				n = $temp$n;
				continue unsafeIntToAscii;
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Name$addRenaming = F2(
	function (keyword, maybeBadFields) {
		var width = $elm$core$String$length(keyword);
		var maxName = ($author$project$Compiler$Generate$JavaScript$Name$numStartBytes * A2($elm$core$Basics$pow, $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes, width - 1)) - 1;
		if (maybeBadFields.$ === 'Nothing') {
			return $author$project$Compiler$Generate$JavaScript$Name$BadFields(
				A2(
					$author$project$Extra$Type$Map$singleton,
					keyword,
					A3($author$project$Compiler$Generate$JavaScript$Name$unsafeIntToAscii, width, _List_Nil, maxName)));
		} else {
			var renamings = maybeBadFields.a.a;
			return $author$project$Compiler$Generate$JavaScript$Name$BadFields(
				A3(
					$author$project$Extra$Type$Map$insert,
					keyword,
					A3(
						$author$project$Compiler$Generate$JavaScript$Name$unsafeIntToAscii,
						width,
						_List_Nil,
						maxName - $author$project$Extra$Type$Map$size(renamings)),
					renamings));
		}
	});
var $elm$core$Set$foldr = F3(
	function (func, initialState, _v0) {
		var dict = _v0.a;
		return A3(
			$elm$core$Dict$foldr,
			F3(
				function (key, _v1, state) {
					return A2(func, key, state);
				}),
			initialState,
			dict);
	});
var $author$project$Extra$Type$Set$foldr = $elm$core$Set$foldr;
var $author$project$Compiler$Generate$JavaScript$Name$allBadFields = function () {
	var add = F2(
		function (keyword, dict) {
			return A3(
				$author$project$Extra$Type$Map$alter,
				A2(
					$elm$core$Basics$composeL,
					$elm$core$Maybe$Just,
					$author$project$Compiler$Generate$JavaScript$Name$addRenaming(keyword)),
				$elm$core$String$length(keyword),
				dict);
		});
	return $author$project$Extra$Type$Map$elems(
		A3($author$project$Extra$Type$Set$foldr, add, $author$project$Extra$Type$Map$empty, $author$project$Compiler$Generate$JavaScript$Name$jsReservedWords));
}();
var $author$project$Compiler$Generate$JavaScript$Name$intToAsciiHelp = F4(
	function (width, blockSize, badFields, n) {
		intToAsciiHelp:
		while (true) {
			if (!badFields.b) {
				if (_Utils_cmp(n, blockSize) < 0) {
					return A3($author$project$Compiler$Generate$JavaScript$Name$unsafeIntToAscii, width, _List_Nil, n);
				} else {
					var $temp$width = width + 1,
						$temp$blockSize = blockSize * $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes,
						$temp$badFields = _List_Nil,
						$temp$n = n - blockSize;
					width = $temp$width;
					blockSize = $temp$blockSize;
					badFields = $temp$badFields;
					n = $temp$n;
					continue intToAsciiHelp;
				}
			} else {
				var renamings = badFields.a.a;
				var biggerBadFields = badFields.b;
				var availableSize = blockSize - $author$project$Extra$Type$Map$size(renamings);
				if (_Utils_cmp(n, availableSize) < 0) {
					var name = A3($author$project$Compiler$Generate$JavaScript$Name$unsafeIntToAscii, width, _List_Nil, n);
					return A3($author$project$Extra$Type$Map$findWithDefault, name, name, renamings);
				} else {
					var $temp$width = width + 1,
						$temp$blockSize = blockSize * $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes,
						$temp$badFields = biggerBadFields,
						$temp$n = n - availableSize;
					width = $temp$width;
					blockSize = $temp$blockSize;
					badFields = $temp$badFields;
					n = $temp$n;
					continue intToAsciiHelp;
				}
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Name$intToAscii = function (n) {
	return (n < 53) ? $author$project$Compiler$Data$Name$fromWords(
		_List_fromArray(
			[
				$author$project$Compiler$Generate$JavaScript$Name$toByte(n)
			])) : A4($author$project$Compiler$Generate$JavaScript$Name$intToAsciiHelp, 2, $author$project$Compiler$Generate$JavaScript$Name$numStartBytes * $author$project$Compiler$Generate$JavaScript$Name$numInnerBytes, $author$project$Compiler$Generate$JavaScript$Name$allBadFields, n - 53);
};
var $author$project$Compiler$Generate$JavaScript$Name$fromInt = function (n) {
	return $author$project$Compiler$Generate$JavaScript$Name$Name(
		$author$project$Compiler$Data$Name$toBuilder(
			$author$project$Compiler$Generate$JavaScript$Name$intToAscii(n)));
};
var $author$project$Compiler$Generate$JavaScript$Name$fromIndex = function (index) {
	return $author$project$Compiler$Generate$JavaScript$Name$fromInt(
		$author$project$Compiler$Data$Index$toMachine(index));
};
var $author$project$Compiler$Generate$JavaScript$Expression$pathToJsExpr = F3(
	function (mode, root, path) {
		pathToJsExpr:
		while (true) {
			switch (path.$) {
				case 'Index':
					var index = path.a;
					var subPath = path.b;
					return A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						A3($author$project$Compiler$Generate$JavaScript$Expression$pathToJsExpr, mode, root, subPath),
						$author$project$Compiler$Generate$JavaScript$Name$fromIndex(index));
				case 'Unbox':
					var subPath = path.a;
					if (mode.$ === 'Dev') {
						return A2(
							$author$project$Compiler$Generate$JavaScript$Builder$Access,
							A3($author$project$Compiler$Generate$JavaScript$Expression$pathToJsExpr, mode, root, subPath),
							$author$project$Compiler$Generate$JavaScript$Name$fromIndex($author$project$Compiler$Data$Index$first));
					} else {
						var $temp$mode = mode,
							$temp$root = root,
							$temp$path = subPath;
						mode = $temp$mode;
						root = $temp$root;
						path = $temp$path;
						continue pathToJsExpr;
					}
				default:
					return $author$project$Compiler$Generate$JavaScript$Builder$Ref(
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal(root));
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCaseTest = F4(
	function (mode, root, path, exampleTest) {
		var value = A3($author$project$Compiler$Generate$JavaScript$Expression$pathToJsExpr, mode, root, path);
		switch (exampleTest.$) {
			case 'IsCtor':
				var home = exampleTest.a;
				var name = exampleTest.b;
				var opts = exampleTest.e;
				if (_Utils_eq(name, $author$project$Compiler$Data$Name$bool) && _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics)) {
					return value;
				} else {
					if (mode.$ === 'Dev') {
						return A2($author$project$Compiler$Generate$JavaScript$Builder$Access, value, $author$project$Compiler$Generate$JavaScript$Name$dollar);
					} else {
						switch (opts.$) {
							case 'Normal':
								return A2($author$project$Compiler$Generate$JavaScript$Builder$Access, value, $author$project$Compiler$Generate$JavaScript$Name$dollar);
							case 'Enum':
								return value;
							default:
								return value;
						}
					}
				}
			case 'IsInt':
				return value;
			case 'IsStr':
				return value;
			case 'IsChr':
				if (mode.$ === 'Dev') {
					return A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Call,
						A2(
							$author$project$Compiler$Generate$JavaScript$Builder$Access,
							value,
							$author$project$Compiler$Generate$JavaScript$Name$fromLocal('valueOf')),
						_List_Nil);
				} else {
					return value;
				}
			case 'IsBool':
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 1022, column: 7},
						end: {line: 1022, column: 17}
					})('COMPILER BUG - there should never be three tests on a list');
			case 'IsCons':
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 1025, column: 7},
						end: {line: 1025, column: 17}
					})('COMPILER BUG - there should never be three tests on a list');
			case 'IsNil':
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 1028, column: 7},
						end: {line: 1028, column: 17}
					})('COMPILER BUG - there should never be three tests on a list');
			default:
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 1031, column: 7},
						end: {line: 1031, column: 17}
					})('COMPILER BUG - there should never be three tests on a list');
		}
	});
var $author$project$Compiler$Data$Name$dict = 'Dict';
var $author$project$Compiler$Elm$ModuleName$dict = A2($author$project$Compiler$Elm$ModuleName$Canonical, $author$project$Compiler$Elm$Package$core, $author$project$Compiler$Data$Name$dict);
var $author$project$Compiler$Data$Index$toHuman = function (_v0) {
	var index = _v0.a;
	return index + 1;
};
var $author$project$Compiler$Generate$JavaScript$Expression$ctorToInt = F3(
	function (home, name, index) {
		return ((_Utils_eq(home, $author$project$Compiler$Elm$ModuleName$dict) && (name === 'RBNode_elm_builtin')) || (name === 'RBEmpty_elm_builtin')) ? (0 - $author$project$Compiler$Data$Index$toHuman(index)) : $author$project$Compiler$Data$Index$toMachine(index);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCaseValue = F2(
	function (mode, test) {
		switch (test.$) {
			case 'IsCtor':
				var home = test.a;
				var name = test.b;
				var index = test.c;
				if (mode.$ === 'Dev') {
					return $author$project$Compiler$Generate$JavaScript$Builder$CString(
						$author$project$Compiler$Data$Name$toBuilder(name));
				} else {
					return $author$project$Compiler$Generate$JavaScript$Builder$CInt(
						A3($author$project$Compiler$Generate$JavaScript$Expression$ctorToInt, home, name, index));
				}
			case 'IsInt':
				var _int = test.a;
				return $author$project$Compiler$Generate$JavaScript$Builder$CInt(_int);
			case 'IsChr':
				var _char = test.a;
				return $author$project$Compiler$Generate$JavaScript$Builder$CString(_char);
			case 'IsStr':
				var string = test.a;
				return $author$project$Compiler$Generate$JavaScript$Builder$CString(string);
			case 'IsBool':
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 970, column: 7},
						end: {line: 970, column: 17}
					})('COMPILER BUG - there should never be three tests on a boolean');
			case 'IsCons':
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 973, column: 7},
						end: {line: 973, column: 17}
					})('COMPILER BUG - there should never be three tests on a list');
			case 'IsNil':
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 976, column: 7},
						end: {line: 976, column: 17}
					})('COMPILER BUG - there should never be three tests on a list');
			default:
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 979, column: 7},
						end: {line: 979, column: 17}
					})('COMPILER BUG - there should never be three tests on a tuple');
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$positionToJsExpr = function (_v0) {
	var line = _v0.a;
	var column = _v0.b;
	return $author$project$Compiler$Generate$JavaScript$Builder$Object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				$author$project$Compiler$Generate$JavaScript$Name$fromLocal('line'),
				$author$project$Compiler$Generate$JavaScript$Builder$CInt(line)),
				_Utils_Tuple2(
				$author$project$Compiler$Generate$JavaScript$Name$fromLocal('column'),
				$author$project$Compiler$Generate$JavaScript$Builder$CInt(column))
			]));
};
var $author$project$Compiler$Generate$JavaScript$Expression$regionToJsExpr = function (_v0) {
	var start = _v0.a;
	var end = _v0.b;
	return $author$project$Compiler$Generate$JavaScript$Builder$Object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				$author$project$Compiler$Generate$JavaScript$Name$fromLocal('start'),
				$author$project$Compiler$Generate$JavaScript$Expression$positionToJsExpr(start)),
				_Utils_Tuple2(
				$author$project$Compiler$Generate$JavaScript$Name$fromLocal('end'),
				$author$project$Compiler$Generate$JavaScript$Expression$positionToJsExpr(end))
			]));
};
var $author$project$Compiler$Generate$JavaScript$Expression$generateDebug = F4(
	function (name, _v0, region, unhandledValueName) {
		var home = _v0.b;
		if (name !== 'todo') {
			return $author$project$Compiler$Generate$JavaScript$Builder$Ref(
				A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, $author$project$Compiler$Elm$ModuleName$debug, name));
		} else {
			if (unhandledValueName.$ === 'Nothing') {
				return A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Call,
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$debug, 'todo')),
					_List_fromArray(
						[
							$author$project$Compiler$Generate$JavaScript$Builder$CString(
							$author$project$Compiler$Data$Name$toBuilder(home)),
							$author$project$Compiler$Generate$JavaScript$Expression$regionToJsExpr(region)
						]));
			} else {
				var valueName = unhandledValueName.a;
				return A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Call,
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$debug, 'todoCase')),
					_List_fromArray(
						[
							$author$project$Compiler$Generate$JavaScript$Builder$CString(
							$author$project$Compiler$Data$Name$toBuilder(home)),
							$author$project$Compiler$Generate$JavaScript$Expression$regionToJsExpr(region),
							$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							$author$project$Compiler$Generate$JavaScript$Name$fromLocal(valueName))
						]));
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateField = F2(
	function (mode, name) {
		if (mode.$ === 'Dev') {
			return $author$project$Compiler$Generate$JavaScript$Name$fromLocal(name);
		} else {
			var fields = mode.a;
			return A2($author$project$Extra$Type$Map$ex, fields, name);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$AsyncFunction = F3(
	function (a, b, c) {
		return {$: 'AsyncFunction', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$Name$makeF = function (n) {
	return $author$project$Compiler$Generate$JavaScript$Name$Name(
		'F' + $elm$core$String$fromInt(n));
};
var $author$project$Compiler$Generate$JavaScript$Expression$funcHelpers = $author$project$Extra$Type$Map$fromList(
	A2(
		$author$project$Extra$Type$List$map,
		function (n) {
			return _Utils_Tuple2(
				n,
				$author$project$Compiler$Generate$JavaScript$Builder$Ref(
					$author$project$Compiler$Generate$JavaScript$Name$makeF(n)));
		},
		A2($author$project$Extra$Type$List$range, 2, 9)));
var $author$project$Compiler$Generate$JavaScript$Expression$generateFunctionAsync = F3(
	function (isAsyncDef, args, body) {
		var func = isAsyncDef ? $author$project$Compiler$Generate$JavaScript$Builder$AsyncFunction : $author$project$Compiler$Generate$JavaScript$Builder$Function;
		var _v0 = A2(
			$author$project$Extra$Type$Map$lookup,
			$author$project$Extra$Type$List$length(args),
			$author$project$Compiler$Generate$JavaScript$Expression$funcHelpers);
		if (_v0.$ === 'Just') {
			var helper = _v0.a;
			return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
				A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Call,
					helper,
					_List_fromArray(
						[
							A3(
							func,
							$elm$core$Maybe$Nothing,
							args,
							$author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(body))
						])));
		} else {
			var addArg = F2(
				function (arg, code) {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						A3(
							func,
							$elm$core$Maybe$Nothing,
							_List_fromArray(
								[arg]),
							$author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(code)));
				});
			return A3($author$project$Extra$Type$List$foldr, addArg, body, args);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateFunction = $author$project$Compiler$Generate$JavaScript$Expression$generateFunctionAsync(false);
var $author$project$Compiler$Generate$JavaScript$Expression$generateIfTest = F3(
	function (mode, root, _v0) {
		var path = _v0.a;
		var test = _v0.b;
		var value = A3($author$project$Compiler$Generate$JavaScript$Expression$pathToJsExpr, mode, root, path);
		switch (test.$) {
			case 'IsCtor':
				var home = test.a;
				var name = test.b;
				var index = test.c;
				var opts = test.e;
				var tag = function () {
					if (mode.$ === 'Dev') {
						return A2($author$project$Compiler$Generate$JavaScript$Builder$Access, value, $author$project$Compiler$Generate$JavaScript$Name$dollar);
					} else {
						switch (opts.$) {
							case 'Normal':
								return A2($author$project$Compiler$Generate$JavaScript$Builder$Access, value, $author$project$Compiler$Generate$JavaScript$Name$dollar);
							case 'Enum':
								return value;
							default:
								return value;
						}
					}
				}();
				return A2(
					$author$project$Compiler$Generate$JavaScript$Expression$strictEq,
					tag,
					function () {
						if (mode.$ === 'Dev') {
							return $author$project$Compiler$Generate$JavaScript$Builder$CString(
								$author$project$Compiler$Data$Name$toBuilder(name));
						} else {
							return $author$project$Compiler$Generate$JavaScript$Builder$CInt(
								A3($author$project$Compiler$Generate$JavaScript$Expression$ctorToInt, home, name, index));
						}
					}());
			case 'IsBool':
				if (test.a) {
					return value;
				} else {
					return A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, value);
				}
			case 'IsInt':
				var _int = test.a;
				return A2(
					$author$project$Compiler$Generate$JavaScript$Expression$strictEq,
					value,
					$author$project$Compiler$Generate$JavaScript$Builder$CInt(_int));
			case 'IsChr':
				var _char = test.a;
				return A2(
					$author$project$Compiler$Generate$JavaScript$Expression$strictEq,
					$author$project$Compiler$Generate$JavaScript$Builder$CString(_char),
					function () {
						if (mode.$ === 'Dev') {
							return A2(
								$author$project$Compiler$Generate$JavaScript$Builder$Call,
								A2(
									$author$project$Compiler$Generate$JavaScript$Builder$Access,
									value,
									$author$project$Compiler$Generate$JavaScript$Name$fromLocal('valueOf')),
								_List_Nil);
						} else {
							return value;
						}
					}());
			case 'IsStr':
				var string = test.a;
				return A2(
					$author$project$Compiler$Generate$JavaScript$Expression$strictEq,
					value,
					$author$project$Compiler$Generate$JavaScript$Builder$CString(string));
			case 'IsCons':
				return A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Access,
					value,
					$author$project$Compiler$Generate$JavaScript$Name$fromLocal('b'));
			case 'IsNil':
				return A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Prefix,
					$author$project$Compiler$Generate$JavaScript$Builder$PrefixNot,
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						value,
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal('b')));
			default:
				return _Debug_todo(
					'Compiler.Generate.JavaScript.Expression',
					{
						start: {line: 941, column: 7},
						end: {line: 941, column: 17}
					})('COMPILER BUG - there should never be tests on a tuple');
		}
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Index = F2(
	function (a, b) {
		return {$: 'Index', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateJsArrayCall = F3(
	function (home, name, args) {
		var otherwise = function (_v2) {
			return A3($author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall, home, name, args);
		};
		_v0$2:
		while (true) {
			if (args.b) {
				if (!args.b.b) {
					var entry = args.a;
					return (name === 'singleton') ? $author$project$Compiler$Generate$JavaScript$Builder$Array(
						_List_fromArray(
							[entry])) : otherwise(_Utils_Tuple0);
				} else {
					if (!args.b.b.b) {
						var index = args.a;
						var _v1 = args.b;
						var array = _v1.a;
						return (name === 'unsafeGet') ? A2($author$project$Compiler$Generate$JavaScript$Builder$Index, array, index) : otherwise(_Utils_Tuple0);
					} else {
						break _v0$2;
					}
				}
			} else {
				break _v0$2;
			}
		}
		return otherwise(_Utils_Tuple0);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generatePath = F2(
	function (mode, path) {
		generatePath:
		while (true) {
			switch (path.$) {
				case 'Index':
					var index = path.a;
					var subPath = path.b;
					return A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						A2($author$project$Compiler$Generate$JavaScript$Expression$generatePath, mode, subPath),
						$author$project$Compiler$Generate$JavaScript$Name$fromIndex(index));
				case 'Root':
					var name = path.a;
					return $author$project$Compiler$Generate$JavaScript$Builder$Ref(
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name));
				case 'Field':
					var field = path.a;
					var subPath = path.b;
					return A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						A2($author$project$Compiler$Generate$JavaScript$Expression$generatePath, mode, subPath),
						A2($author$project$Compiler$Generate$JavaScript$Expression$generateField, mode, field));
				default:
					var subPath = path.a;
					if (mode.$ === 'Dev') {
						return A2(
							$author$project$Compiler$Generate$JavaScript$Builder$Access,
							A2($author$project$Compiler$Generate$JavaScript$Expression$generatePath, mode, subPath),
							$author$project$Compiler$Generate$JavaScript$Name$fromIndex($author$project$Compiler$Data$Index$first));
					} else {
						var $temp$mode = mode,
							$temp$path = subPath;
						mode = $temp$mode;
						path = $temp$path;
						continue generatePath;
					}
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateTupleCall = F3(
	function (home, name, args) {
		if (args.b && (!args.b.b)) {
			var value = args.a;
			switch (name) {
				case 'first':
					return A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						value,
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal('a'));
				case 'second':
					return A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						value,
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal('b'));
				default:
					return A3($author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall, home, name, args);
			}
		} else {
			return A3($author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall, home, name, args);
		}
	});
var $author$project$Compiler$Generate$Mode$isAsyncActive = function (mode) {
	if (((mode.$ === 'Dev') && (mode.a.$ === 'DevAsync')) && mode.a.a) {
		var _v1 = mode.a;
		return true;
	} else {
		return false;
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$isBlock = function (code) {
	if (code.$ === 'JsBlock') {
		return true;
	} else {
		return false;
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$isBreakpointFun = F2(
	function (args, mode) {
		var _v0 = _Utils_Tuple2(args, mode);
		if (((_v0.a.b && (_v0.b.$ === 'Dev')) && (_v0.b.a.$ === 'DevAsync')) && _v0.b.a.a) {
			var _v1 = _v0.a;
			var arg = _v1.a;
			var _v2 = _v0.b.a;
			var suspendFuns = _v2.b;
			return A2($author$project$Extra$Type$Set$member, arg, suspendFuns);
		} else {
			return false;
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$isStringLiteral = function (expr) {
	if (expr.$ === 'CString') {
		return true;
	} else {
		return false;
	}
};
var $author$project$Compiler$Generate$JavaScript$Expression$isSuspendCall = F2(
	function (func, mode) {
		var _v0 = _Utils_Tuple2(func, mode);
		if ((((_v0.a.$ === 'VarLocal') && (_v0.b.$ === 'Dev')) && (_v0.b.a.$ === 'DevAsync')) && _v0.b.a.a) {
			var name = _v0.a.a;
			var _v1 = _v0.b.a;
			var suspendFuns = _v1.b;
			return A2($author$project$Extra$Type$Set$member, name, suspendFuns);
		} else {
			return false;
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$jsAppend = F2(
	function (a, b) {
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Call,
			$author$project$Compiler$Generate$JavaScript$Builder$Ref(
				A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'ap')),
			_List_fromArray(
				[a, b]));
	});
var $author$project$Compiler$Data$Name$jsArray = 'JsArray';
var $author$project$Compiler$Generate$JavaScript$Name$makeLabel = F2(
	function (name, index) {
		return $author$project$Compiler$Generate$JavaScript$Name$Name(
			_Utils_ap(
				$author$project$Compiler$Data$Name$toBuilder(name),
				_Utils_ap(
					$author$project$Compiler$Generate$JavaScript$Name$usd,
					$elm$core$String$fromInt(index))));
	});
var $author$project$Compiler$Generate$JavaScript$Name$makeTemp = function (name) {
	return $author$project$Compiler$Generate$JavaScript$Name$Name(
		'$temp$' + $author$project$Compiler$Data$Name$toBuilder(name));
};
var $author$project$Compiler$Generate$JavaScript$Expression$strictNEq = F2(
	function (left, right) {
		_v0$2:
		while (true) {
			switch (left.$) {
				case 'CInt':
					if (!left.a) {
						return A2(
							$author$project$Compiler$Generate$JavaScript$Builder$Prefix,
							$author$project$Compiler$Generate$JavaScript$Builder$PrefixNot,
							A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, right));
					} else {
						break _v0$2;
					}
				case 'CBool':
					var bool = left.a;
					return bool ? A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, right) : right;
				default:
					break _v0$2;
			}
		}
		_v1$2:
		while (true) {
			switch (right.$) {
				case 'CInt':
					if (!right.a) {
						return A2(
							$author$project$Compiler$Generate$JavaScript$Builder$Prefix,
							$author$project$Compiler$Generate$JavaScript$Builder$PrefixNot,
							A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, left));
					} else {
						break _v1$2;
					}
				case 'CBool':
					var bool = right.a;
					return bool ? A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, left) : left;
				default:
					break _v1$2;
			}
		}
		return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpNe, left, right);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$notEqual = F2(
	function (left, right) {
		return ($author$project$Compiler$Generate$JavaScript$Expression$isLiteral(left) || $author$project$Compiler$Generate$JavaScript$Expression$isLiteral(right)) ? A2($author$project$Compiler$Generate$JavaScript$Expression$strictNEq, left, right) : A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Prefix,
			$author$project$Compiler$Generate$JavaScript$Builder$PrefixNot,
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Call,
				$author$project$Compiler$Generate$JavaScript$Builder$Ref(
					A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'eq')),
				_List_fromArray(
					[left, right])));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$toChar = $author$project$Compiler$Generate$JavaScript$Builder$Ref(
	A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'chr'));
var $author$project$Compiler$AST$Utils$Shader$toJsStringBuilder = function (_v0) {
	var src = _v0.a;
	return src;
};
var $author$project$Compiler$Generate$JavaScript$Expression$append = F3(
	function (mode, left, right) {
		var seqs = A2(
			$elm$core$List$cons,
			A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, left),
			A2($author$project$Compiler$Generate$JavaScript$Expression$toSeqs, mode, right));
		return A2($author$project$Extra$Type$List$any, $author$project$Compiler$Generate$JavaScript$Expression$isStringLiteral, seqs) ? A2(
			$author$project$Extra$Type$List$foldr1,
			$author$project$Compiler$Generate$JavaScript$Builder$Infix($author$project$Compiler$Generate$JavaScript$Builder$OpAdd),
			seqs) : A2($author$project$Extra$Type$List$foldr1, $author$project$Compiler$Generate$JavaScript$Expression$jsAppend, seqs);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateAsync = F4(
	function (isAsyncDef, maybeBpNames, mode, expression) {
		switch (expression.$) {
			case 'CBool':
				var bool = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$CBool(bool));
			case 'Chr':
				var _char = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					function () {
						if (mode.$ === 'Dev') {
							return A2(
								$author$project$Compiler$Generate$JavaScript$Builder$Call,
								$author$project$Compiler$Generate$JavaScript$Expression$toChar,
								_List_fromArray(
									[
										$author$project$Compiler$Generate$JavaScript$Builder$CString(_char)
									]));
						} else {
							return $author$project$Compiler$Generate$JavaScript$Builder$CString(_char);
						}
					}());
			case 'Str':
				var string = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$CString(string));
			case 'CInt':
				var _int = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$CInt(_int));
			case 'CFloat':
				var _float = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$CFloat(_float));
			case 'VarLocal':
				var name = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name)));
			case 'VarGlobal':
				var _v26 = expression.a;
				var home = _v26.a;
				var name = _v26.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name)));
			case 'VarEnum':
				var _v27 = expression.a;
				var home = _v27.a;
				var name = _v27.b;
				var index = expression.b;
				if (mode.$ === 'Dev') {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name)));
				} else {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						$author$project$Compiler$Generate$JavaScript$Builder$CInt(
							$author$project$Compiler$Data$Index$toMachine(index)));
				}
			case 'VarBox':
				var _v29 = expression.a;
				var home = _v29.a;
				var name = _v29.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						function () {
							if (mode.$ === 'Dev') {
								return A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name);
							} else {
								return A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$identity_);
							}
						}()));
			case 'VarCycle':
				var home = expression.a;
				var name = expression.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Call,
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2($author$project$Compiler$Generate$JavaScript$Name$fromCycle, home, name)),
						_List_Nil));
			case 'VarDebug':
				var name = expression.a;
				var home = expression.b;
				var region = expression.c;
				var unhandledValueName = expression.d;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A4($author$project$Compiler$Generate$JavaScript$Expression$generateDebug, name, home, region, unhandledValueName));
			case 'VarKernel':
				var home = expression.a;
				var name = expression.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, home, name)));
			case 'CList':
				var entries = expression.a;
				if (!entries.b) {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$list, 'Nil')));
				} else {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						A2(
							$author$project$Compiler$Generate$JavaScript$Builder$Call,
							$author$project$Compiler$Generate$JavaScript$Builder$Ref(
								A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$list, 'fromArray')),
							_List_fromArray(
								[
									$author$project$Compiler$Generate$JavaScript$Builder$Array(
									A2(
										$author$project$Extra$Type$List$map,
										$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
										entries))
								])));
				}
			case 'Function':
				var args = expression.a;
				var body = expression.b;
				return A3(
					$author$project$Compiler$Generate$JavaScript$Expression$generateFunctionAsync,
					isAsyncDef || A2($author$project$Compiler$Generate$JavaScript$Expression$isBreakpointFun, args, mode),
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Generate$JavaScript$Name$fromLocal, args),
					A2(
						$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
						mode,
						body));
			case 'Call':
				var func = expression.a;
				var args = expression.b;
				var _v32 = A4($author$project$Compiler$Generate$JavaScript$Expression$breakpointDefCall, func, args, mode, maybeBpNames);
				var newMode = _v32.a;
				var newFunc = _v32.b;
				var newArgs = _v32.c;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A3($author$project$Compiler$Generate$JavaScript$Expression$generateCall, newMode, newFunc, newArgs));
			case 'TailCall':
				var name = expression.a;
				var args = expression.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsBlock(
					A3($author$project$Compiler$Generate$JavaScript$Expression$generateTailCall, mode, name, args));
			case 'If':
				var branches = expression.a;
				var _final = expression.b;
				return A3($author$project$Compiler$Generate$JavaScript$Expression$generateIf, mode, branches, _final);
			case 'Let':
				var def = expression.a;
				var body = expression.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsBlock(
					A2(
						$elm$core$List$cons,
						A2($author$project$Compiler$Generate$JavaScript$Expression$generateDef, mode, def),
						$author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(
							A2(
								$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
								mode,
								body))));
			case 'Destruct':
				var _v33 = expression.a;
				var name = _v33.a;
				var path = _v33.b;
				var body = expression.b;
				var pathDef = A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Var,
					$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name),
					A2($author$project$Compiler$Generate$JavaScript$Expression$generatePath, mode, path));
				return $author$project$Compiler$Generate$JavaScript$Expression$JsBlock(
					A2(
						$elm$core$List$cons,
						pathDef,
						$author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(
							A2(
								$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
								mode,
								body))));
			case 'Case':
				var label = expression.a;
				var root = expression.b;
				var decider = expression.c;
				var jumps = expression.d;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsBlock(
					A5($author$project$Compiler$Generate$JavaScript$Expression$generateCase, mode, label, root, decider, jumps));
			case 'Accessor':
				var field = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A3(
						$author$project$Compiler$Generate$JavaScript$Builder$Function,
						$elm$core$Maybe$Nothing,
						_List_fromArray(
							[$author$project$Compiler$Generate$JavaScript$Name$dollar]),
						_List_fromArray(
							[
								$author$project$Compiler$Generate$JavaScript$Builder$Return(
								A2(
									$author$project$Compiler$Generate$JavaScript$Builder$Access,
									$author$project$Compiler$Generate$JavaScript$Builder$Ref($author$project$Compiler$Generate$JavaScript$Name$dollar),
									A2($author$project$Compiler$Generate$JavaScript$Expression$generateField, mode, field)))
							])));
			case 'Access':
				var record = expression.a;
				var field = expression.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Access,
						A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, record),
						A2($author$project$Compiler$Generate$JavaScript$Expression$generateField, mode, field)));
			case 'Update':
				var record = expression.a;
				var fields = expression.b;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Call,
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'update')),
						_List_fromArray(
							[
								A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, record),
								A2($author$project$Compiler$Generate$JavaScript$Expression$generateRecord, mode, fields)
							])));
			case 'Record':
				var fields = expression.a;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					A2($author$project$Compiler$Generate$JavaScript$Expression$generateRecord, mode, fields));
			case 'Unit':
				if (mode.$ === 'Dev') {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'Tuple0')));
				} else {
					return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
						$author$project$Compiler$Generate$JavaScript$Builder$CInt(0));
				}
			case 'Tuple':
				var a = expression.a;
				var b = expression.b;
				var maybeC = expression.c;
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					function () {
						if (maybeC.$ === 'Nothing') {
							return A2(
								$author$project$Compiler$Generate$JavaScript$Builder$Call,
								$author$project$Compiler$Generate$JavaScript$Builder$Ref(
									A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'Tuple2')),
								_List_fromArray(
									[
										A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, a),
										A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, b)
									]));
						} else {
							var c = maybeC.a;
							return A2(
								$author$project$Compiler$Generate$JavaScript$Builder$Call,
								$author$project$Compiler$Generate$JavaScript$Builder$Ref(
									A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$utils, 'Tuple3')),
								_List_fromArray(
									[
										A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, a),
										A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, b),
										A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, c)
									]));
						}
					}());
			default:
				var src = expression.a;
				var attributes = expression.b;
				var uniforms = expression.c;
				var toTranlation = function (field) {
					return _Utils_Tuple2(
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal(field),
						$author$project$Compiler$Generate$JavaScript$Builder$CString(
							$author$project$Compiler$Generate$JavaScript$Name$toBuilder(
								A2($author$project$Compiler$Generate$JavaScript$Expression$generateField, mode, field))));
				};
				var toTranslationObject = function (fields) {
					return $author$project$Compiler$Generate$JavaScript$Builder$Object(
						A2(
							$author$project$Extra$Type$List$map,
							toTranlation,
							$author$project$Extra$Type$Set$toList(fields)));
				};
				return $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
					$author$project$Compiler$Generate$JavaScript$Builder$Object(
						_List_fromArray(
							[
								_Utils_Tuple2(
								$author$project$Compiler$Generate$JavaScript$Name$fromLocal('src'),
								$author$project$Compiler$Generate$JavaScript$Builder$CString(
									$author$project$Compiler$AST$Utils$Shader$toJsStringBuilder(src))),
								_Utils_Tuple2(
								$author$project$Compiler$Generate$JavaScript$Name$fromLocal('attributes'),
								toTranslationObject(attributes)),
								_Utils_Tuple2(
								$author$project$Compiler$Generate$JavaScript$Name$fromLocal('uniforms'),
								toTranslationObject(uniforms))
							])));
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateBasicsCall = F4(
	function (mode, home, name, args) {
		_v19$2:
		while (true) {
			if (args.b) {
				if (!args.b.b) {
					var elmArg = args.a;
					var arg = A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, elmArg);
					switch (name) {
						case 'not':
							return A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNot, arg);
						case 'negate':
							return A2($author$project$Compiler$Generate$JavaScript$Builder$Prefix, $author$project$Compiler$Generate$JavaScript$Builder$PrefixNegate, arg);
						case 'toFloat':
							return arg;
						case 'truncate':
							return A3(
								$author$project$Compiler$Generate$JavaScript$Builder$Infix,
								$author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseOr,
								arg,
								$author$project$Compiler$Generate$JavaScript$Builder$CInt(0));
						default:
							return A3(
								$author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall,
								home,
								name,
								_List_fromArray(
									[arg]));
					}
				} else {
					if (!args.b.b.b) {
						var elmLeft = args.a;
						var _v21 = args.b;
						var elmRight = _v21.a;
						switch (name) {
							case 'append':
								return A3($author$project$Compiler$Generate$JavaScript$Expression$append, mode, elmLeft, elmRight);
							case 'apL':
								return A2(
									$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr,
									mode,
									A2($author$project$Compiler$Generate$JavaScript$Expression$apply, elmLeft, elmRight));
							case 'apR':
								return A2(
									$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr,
									mode,
									A2($author$project$Compiler$Generate$JavaScript$Expression$apply, elmRight, elmLeft));
							default:
								var right = A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, elmRight);
								var left = A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, elmLeft);
								switch (name) {
									case 'add':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpAdd, left, right);
									case 'sub':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpSub, left, right);
									case 'mul':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpMul, left, right);
									case 'fdiv':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpDiv, left, right);
									case 'idiv':
										return A3(
											$author$project$Compiler$Generate$JavaScript$Builder$Infix,
											$author$project$Compiler$Generate$JavaScript$Builder$OpBitwiseOr,
											A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpDiv, left, right),
											$author$project$Compiler$Generate$JavaScript$Builder$CInt(0));
									case 'eq':
										return A2($author$project$Compiler$Generate$JavaScript$Expression$equal, left, right);
									case 'neq':
										return A2($author$project$Compiler$Generate$JavaScript$Expression$notEqual, left, right);
									case 'lt':
										return A5($author$project$Compiler$Generate$JavaScript$Expression$cmp, $author$project$Compiler$Generate$JavaScript$Builder$OpLt, $author$project$Compiler$Generate$JavaScript$Builder$OpLt, 0, left, right);
									case 'gt':
										return A5($author$project$Compiler$Generate$JavaScript$Expression$cmp, $author$project$Compiler$Generate$JavaScript$Builder$OpGt, $author$project$Compiler$Generate$JavaScript$Builder$OpGt, 0, left, right);
									case 'le':
										return A5($author$project$Compiler$Generate$JavaScript$Expression$cmp, $author$project$Compiler$Generate$JavaScript$Builder$OpLe, $author$project$Compiler$Generate$JavaScript$Builder$OpLt, 1, left, right);
									case 'ge':
										return A5($author$project$Compiler$Generate$JavaScript$Expression$cmp, $author$project$Compiler$Generate$JavaScript$Builder$OpGe, $author$project$Compiler$Generate$JavaScript$Builder$OpGt, -1, left, right);
									case 'or':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpOr, left, right);
									case 'and':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpAnd, left, right);
									case 'xor':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpNe, left, right);
									case 'remainderBy':
										return A3($author$project$Compiler$Generate$JavaScript$Builder$Infix, $author$project$Compiler$Generate$JavaScript$Builder$OpMod, right, left);
									default:
										return A3(
											$author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall,
											home,
											name,
											_List_fromArray(
												[left, right]));
								}
						}
					} else {
						break _v19$2;
					}
				}
			} else {
				break _v19$2;
			}
		}
		return A3(
			$author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall,
			home,
			name,
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
				args));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCall = F3(
	function (mode, func, args) {
		switch (func.$) {
			case 'VarGlobal':
				var global = func.a;
				var _v16 = global.a;
				var pkg = _v16.a;
				return ($author$project$Compiler$Generate$Mode$isAsyncActive(mode) && _Utils_eq(pkg, $author$project$Compiler$Elm$Package$dummyName)) ? A4($author$project$Compiler$Generate$JavaScript$Expression$generateCallHelpAsync, true, mode, func, args) : (_Utils_eq(pkg, $author$project$Compiler$Elm$Package$core) ? A3($author$project$Compiler$Generate$JavaScript$Expression$generateCoreCall, mode, global, args) : A3(
					$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generateCallHelp(),
					mode,
					A6($author$project$Compiler$Generate$JavaScript$Expression$addAsyncGlobal, mode, 'elm', 'browser', 'Browser', 'sandbox', func),
					args));
			case 'VarBox':
				if (mode.$ === 'Dev') {
					return A3(
						$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generateCallHelp(),
						mode,
						func,
						args);
				} else {
					if (args.b && (!args.b.b)) {
						var arg = args.a;
						return A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, arg);
					} else {
						return A3(
							$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generateCallHelp(),
							mode,
							func,
							args);
					}
				}
			default:
				return A4(
					$author$project$Compiler$Generate$JavaScript$Expression$generateCallHelpAsync,
					A2($author$project$Compiler$Generate$JavaScript$Expression$isSuspendCall, func, mode),
					mode,
					func,
					args);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCallHelpAsync = F4(
	function (isAsync, mode, func, args) {
		return A3(
			$author$project$Compiler$Generate$JavaScript$Expression$generateNormalCallAsync,
			isAsync,
			A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, func),
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
				args));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCase = F5(
	function (mode, label, root, decider, jumps) {
		return A3(
			$author$project$Extra$Type$List$foldr,
			A2($author$project$Compiler$Generate$JavaScript$Expression$goto, mode, label),
			A4($author$project$Compiler$Generate$JavaScript$Expression$generateDecider, mode, label, root, decider),
			jumps);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCaseBranch = F4(
	function (mode, label, root, _v14) {
		var test = _v14.a;
		var subTree = _v14.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Case,
			A2($author$project$Compiler$Generate$JavaScript$Expression$generateCaseValue, mode, test),
			A4($author$project$Compiler$Generate$JavaScript$Expression$generateDecider, mode, label, root, subTree));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateCoreCall = F3(
	function (mode, _v13, args) {
		var home = _v13.a;
		var moduleName = home.b;
		var name = _v13.b;
		return _Utils_eq(moduleName, $author$project$Compiler$Data$Name$basics) ? A4($author$project$Compiler$Generate$JavaScript$Expression$generateBasicsCall, mode, home, name, args) : (_Utils_eq(moduleName, $author$project$Compiler$Data$Name$bitwise) ? A3(
			$author$project$Compiler$Generate$JavaScript$Expression$generateBitwiseCall,
			home,
			name,
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
				args)) : (_Utils_eq(moduleName, $author$project$Compiler$Data$Name$tuple) ? A3(
			$author$project$Compiler$Generate$JavaScript$Expression$generateTupleCall,
			home,
			name,
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
				args)) : (_Utils_eq(moduleName, $author$project$Compiler$Data$Name$jsArray) ? A3(
			$author$project$Compiler$Generate$JavaScript$Expression$generateJsArrayCall,
			home,
			name,
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
				args)) : A3(
			$author$project$Compiler$Generate$JavaScript$Expression$generateGlobalCall,
			home,
			name,
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr(mode),
				args)))));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateDecider = F4(
	function (mode, label, root, decisionTree) {
		switch (decisionTree.$) {
			case 'Leaf':
				if (decisionTree.a.$ === 'Inline') {
					var branch = decisionTree.a.a;
					return $author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(
						A2(
							$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
							mode,
							branch));
				} else {
					var index = decisionTree.a.a;
					return _List_fromArray(
						[
							$author$project$Compiler$Generate$JavaScript$Builder$Break(
							$elm$core$Maybe$Just(
								A2($author$project$Compiler$Generate$JavaScript$Name$makeLabel, label, index)))
						]);
				}
			case 'Chain':
				var testChain = decisionTree.a;
				var success = decisionTree.b;
				var failure = decisionTree.c;
				return _List_fromArray(
					[
						A3(
						$author$project$Compiler$Generate$JavaScript$Builder$IfStmt,
						A2(
							$author$project$Extra$Type$List$foldl1,
							$author$project$Compiler$Generate$JavaScript$Builder$Infix($author$project$Compiler$Generate$JavaScript$Builder$OpAnd),
							A2(
								$author$project$Extra$Type$List$map,
								A2($author$project$Compiler$Generate$JavaScript$Expression$generateIfTest, mode, root),
								testChain)),
						$author$project$Compiler$Generate$JavaScript$Builder$Block(
							A4($author$project$Compiler$Generate$JavaScript$Expression$generateDecider, mode, label, root, success)),
						$author$project$Compiler$Generate$JavaScript$Builder$Block(
							A4($author$project$Compiler$Generate$JavaScript$Expression$generateDecider, mode, label, root, failure)))
					]);
			default:
				var path = decisionTree.a;
				var edges = decisionTree.b;
				var fallback = decisionTree.c;
				return _List_fromArray(
					[
						A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Switch,
						A4(
							$author$project$Compiler$Generate$JavaScript$Expression$generateCaseTest,
							mode,
							root,
							path,
							$author$project$Extra$Type$List$head(edges).a),
						A3(
							$author$project$Extra$Type$List$foldr,
							F2(
								function (edge, cases) {
									return A2(
										$elm$core$List$cons,
										A4($author$project$Compiler$Generate$JavaScript$Expression$generateCaseBranch, mode, label, root, edge),
										cases);
								}),
							_List_fromArray(
								[
									$author$project$Compiler$Generate$JavaScript$Builder$Default(
									A4($author$project$Compiler$Generate$JavaScript$Expression$generateDecider, mode, label, root, fallback))
								]),
							edges))
					]);
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateDef = F2(
	function (mode, def) {
		if (def.$ === 'Def') {
			var name = def.a;
			var body = def.b;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Var,
				$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name),
				A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, body));
		} else {
			var name = def.a;
			var argNames = def.b;
			var body = def.c;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Var,
				$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name),
				$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
					A4($author$project$Compiler$Generate$JavaScript$Expression$generateTailDef, mode, name, argNames, body)));
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateIf = F3(
	function (mode, givenBranches, givenFinal) {
		var convertBranch = function (_v10) {
			var condition = _v10.a;
			var expr = _v10.b;
			return _Utils_Tuple2(
				A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, condition),
				A2(
					$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
					mode,
					expr));
		};
		var _v9 = A2($author$project$Compiler$Generate$JavaScript$Expression$crushIfs, givenBranches, givenFinal);
		var branches = _v9.a;
		var _final = _v9.b;
		var branchExprs = A2($author$project$Extra$Type$List$map, convertBranch, branches);
		var finalCode = A2(
			$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
			mode,
			_final);
		return ($author$project$Compiler$Generate$JavaScript$Expression$isBlock(finalCode) || A2(
			$author$project$Extra$Type$List$any,
			A2($elm$core$Basics$composeL, $author$project$Compiler$Generate$JavaScript$Expression$isBlock, $elm$core$Tuple$second),
			branchExprs)) ? $author$project$Compiler$Generate$JavaScript$Expression$JsBlock(
			_List_fromArray(
				[
					A3(
					$author$project$Extra$Type$List$foldr,
					$author$project$Compiler$Generate$JavaScript$Expression$addStmtIf,
					$author$project$Compiler$Generate$JavaScript$Expression$codeToStmt(finalCode),
					branchExprs)
				])) : $author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
			A3(
				$author$project$Extra$Type$List$foldr,
				$author$project$Compiler$Generate$JavaScript$Expression$addExprIf,
				$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(finalCode),
				branchExprs));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr = F2(
	function (mode, expression) {
		return $author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
			A2(
				$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
				mode,
				expression));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateRecord = F2(
	function (mode, fields) {
		var toPair = function (_v8) {
			var field = _v8.a;
			var value = _v8.b;
			return _Utils_Tuple2(
				A2($author$project$Compiler$Generate$JavaScript$Expression$generateField, mode, field),
				A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, value));
		};
		return $author$project$Compiler$Generate$JavaScript$Builder$Object(
			A2(
				$author$project$Extra$Type$List$map,
				toPair,
				$author$project$Extra$Type$Map$toList(fields)));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateTailCall = F3(
	function (mode, name, args) {
		var toTempVars = function (_v7) {
			var argName = _v7.a;
			var arg = _v7.b;
			return _Utils_Tuple2(
				$author$project$Compiler$Generate$JavaScript$Name$makeTemp(argName),
				A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, arg));
		};
		var toRealVars = function (_v6) {
			var argName = _v6.a;
			return $author$project$Compiler$Generate$JavaScript$Builder$ExprStmt(
				A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Assign,
					$author$project$Compiler$Generate$JavaScript$Builder$LRef(
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal(argName)),
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						$author$project$Compiler$Generate$JavaScript$Name$makeTemp(argName))));
		};
		return A2(
			$elm$core$List$cons,
			$author$project$Compiler$Generate$JavaScript$Builder$Vars(
				A2($author$project$Extra$Type$List$map, toTempVars, args)),
			_Utils_ap(
				A2($author$project$Extra$Type$List$map, toRealVars, args),
				_List_fromArray(
					[
						$author$project$Compiler$Generate$JavaScript$Builder$Continue(
						$elm$core$Maybe$Just(
							$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name)))
					])));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateTailDef = F4(
	function (mode, name, argNames, body) {
		return A2(
			$author$project$Compiler$Generate$JavaScript$Expression$generateFunction,
			A2($author$project$Extra$Type$List$map, $author$project$Compiler$Generate$JavaScript$Name$fromLocal, argNames),
			$author$project$Compiler$Generate$JavaScript$Expression$JsBlock(
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Labelled,
						$author$project$Compiler$Generate$JavaScript$Name$fromLocal(name),
						A2(
							$author$project$Compiler$Generate$JavaScript$Builder$While,
							$author$project$Compiler$Generate$JavaScript$Builder$CBool(true),
							$author$project$Compiler$Generate$JavaScript$Expression$codeToStmt(
								A2(
									$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
									mode,
									body))))
					])));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$goto = F4(
	function (mode, label, _v5, stmts) {
		var index = _v5.a;
		var branch = _v5.b;
		var labeledDeciderStmt = A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Labelled,
			A2($author$project$Compiler$Generate$JavaScript$Name$makeLabel, label, index),
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$While,
				$author$project$Compiler$Generate$JavaScript$Builder$CBool(true),
				$author$project$Compiler$Generate$JavaScript$Builder$Block(stmts)));
		return A2(
			$elm$core$List$cons,
			labeledDeciderStmt,
			$author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(
				A2(
					$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate(),
					mode,
					branch)));
	});
var $author$project$Compiler$Generate$JavaScript$Expression$toSeqs = F2(
	function (mode, expr) {
		var otherwise = function (_v4) {
			return _List_fromArray(
				[
					A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, expr)
				]);
		};
		if ((((((expr.$ === 'Call') && (expr.a.$ === 'VarGlobal')) && (expr.a.a.b === 'append')) && expr.b.b) && expr.b.b.b) && (!expr.b.b.b.b)) {
			var _v1 = expr.a.a;
			var home = _v1.a;
			var _v2 = expr.b;
			var left = _v2.a;
			var _v3 = _v2.b;
			var right = _v3.a;
			return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) ? A2(
				$elm$core$List$cons,
				A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, left),
				A2($author$project$Compiler$Generate$JavaScript$Expression$toSeqs, mode, right)) : otherwise(_Utils_Tuple0);
		} else {
			return otherwise(_Utils_Tuple0);
		}
	});
function $author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate() {
	return A2($author$project$Compiler$Generate$JavaScript$Expression$generateAsync, false, $elm$core$Maybe$Nothing);
}
function $author$project$Compiler$Generate$JavaScript$Expression$cyclic$generateCallHelp() {
	return $author$project$Compiler$Generate$JavaScript$Expression$generateCallHelpAsync(false);
}
try {
	var $author$project$Compiler$Generate$JavaScript$Expression$generate = $author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate();
	$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generate = function () {
		return $author$project$Compiler$Generate$JavaScript$Expression$generate;
	};
	var $author$project$Compiler$Generate$JavaScript$Expression$generateCallHelp = $author$project$Compiler$Generate$JavaScript$Expression$cyclic$generateCallHelp();
	$author$project$Compiler$Generate$JavaScript$Expression$cyclic$generateCallHelp = function () {
		return $author$project$Compiler$Generate$JavaScript$Expression$generateCallHelp;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Generate.JavaScript.Expression` are causing infinite recursion:\n\n  \n      append\n       \n      generate\n       \n      generateAsync\n       \n      generateBasicsCall\n       \n      generateCall\n       \n      generateCallHelp\n       \n      generateCallHelpAsync\n       \n      generateCase\n       \n      generateCaseBranch\n       \n      generateCoreCall\n       \n      generateDecider\n       \n      generateDef\n       \n      generateIf\n       \n      generateJsExpr\n       \n      generateRecord\n       \n      generateTailCall\n       \n      generateTailDef\n       \n      goto\n       \n      toSeqs\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$Generate$JavaScript$Expression$generateCtor = F4(
	function (mode, _v0, index, arity) {
		var home = _v0.a;
		var name = _v0.b;
		var ctorTag = function () {
			if (mode.$ === 'Dev') {
				return $author$project$Compiler$Generate$JavaScript$Builder$CString(
					$author$project$Compiler$Data$Name$toBuilder(name));
			} else {
				return $author$project$Compiler$Generate$JavaScript$Builder$CInt(
					A3($author$project$Compiler$Generate$JavaScript$Expression$ctorToInt, home, name, index));
			}
		}();
		var argNames = A2(
			$author$project$Compiler$Data$Index$indexedMap,
			F2(
				function (i, _v1) {
					return $author$project$Compiler$Generate$JavaScript$Name$fromIndex(i);
				}),
			A2($author$project$Extra$Type$List$range, 1, arity));
		return A2(
			$author$project$Compiler$Generate$JavaScript$Expression$generateFunction,
			argNames,
			$author$project$Compiler$Generate$JavaScript$Expression$JsExpr(
				$author$project$Compiler$Generate$JavaScript$Builder$Object(
					A2(
						$elm$core$List$cons,
						_Utils_Tuple2($author$project$Compiler$Generate$JavaScript$Name$dollar, ctorTag),
						A2(
							$author$project$Extra$Type$List$map,
							function (n) {
								return _Utils_Tuple2(
									n,
									$author$project$Compiler$Generate$JavaScript$Builder$Ref(n));
							},
							argNames)))));
	});
var $author$project$Compiler$Generate$JavaScript$generateBox = F2(
	function (mode, global) {
		var home = global.a;
		var name = global.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Var,
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
			function () {
				if (mode.$ === 'Dev') {
					return $author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
						A4($author$project$Compiler$Generate$JavaScript$Expression$generateCtor, mode, global, $author$project$Compiler$Data$Index$first, 1));
				} else {
					return $author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$identity_));
				}
			}());
	});
var $author$project$Compiler$Generate$JavaScript$Builder$EmptyStmt = {$: 'EmptyStmt'};
var $author$project$Compiler$Generate$JavaScript$Builder$Throw = function (a) {
	return {$: 'Throw', a: a};
};
var $author$project$Compiler$Generate$JavaScript$Builder$Try = F3(
	function (a, b, c) {
		return {$: 'Try', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$drawCycle = function (names) {
	var topLine = '\\n  ';
	var nameLine = function (name) {
		return '\\n      ' + $author$project$Compiler$Data$Name$toBuilder(name);
	};
	var midLine = '\\n       ';
	var bottomLine = '\\n  ';
	return $elm$core$String$concat(
		A2(
			$elm$core$List$cons,
			topLine,
			_Utils_ap(
				A2(
					$author$project$Extra$Type$List$intersperse,
					midLine,
					A2($author$project$Extra$Type$List$map, nameLine, names)),
				_List_fromArray(
					[bottomLine]))));
};
var $author$project$Compiler$Generate$JavaScript$generateCycleFunc = F3(
	function (mode, home, def) {
		if (def.$ === 'Def') {
			var name = def.a;
			var expr = def.b;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Var,
				A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
				$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
					A2($author$project$Compiler$Generate$JavaScript$Expression$generate, mode, expr)));
		} else {
			var name = def.a;
			var args = def.b;
			var expr = def.c;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Var,
				A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
				$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
					A4($author$project$Compiler$Generate$JavaScript$Expression$generateTailDef, mode, name, args, expr)));
		}
	});
var $author$project$Compiler$Generate$JavaScript$generateRealCycle = F2(
	function (home, _v0) {
		var name = _v0.a;
		var safeName = A2($author$project$Compiler$Generate$JavaScript$Name$fromCycle, home, name);
		var realName = A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name);
		return $author$project$Compiler$Generate$JavaScript$Builder$Block(
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Var,
					realName,
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Call,
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(safeName),
						_List_Nil)),
					$author$project$Compiler$Generate$JavaScript$Builder$ExprStmt(
					A2(
						$author$project$Compiler$Generate$JavaScript$Builder$Assign,
						$author$project$Compiler$Generate$JavaScript$Builder$LRef(safeName),
						A3(
							$author$project$Compiler$Generate$JavaScript$Builder$Function,
							$elm$core$Maybe$Nothing,
							_List_Nil,
							_List_fromArray(
								[
									$author$project$Compiler$Generate$JavaScript$Builder$Return(
									$author$project$Compiler$Generate$JavaScript$Builder$Ref(realName))
								]))))
				]));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$FunctionStmt = F3(
	function (a, b, c) {
		return {$: 'FunctionStmt', a: a, b: b, c: c};
	});
var $author$project$Compiler$Generate$JavaScript$generateSafeCycle = F3(
	function (mode, home, _v0) {
		var name = _v0.a;
		var expr = _v0.b;
		return A3(
			$author$project$Compiler$Generate$JavaScript$Builder$FunctionStmt,
			A2($author$project$Compiler$Generate$JavaScript$Name$fromCycle, home, name),
			_List_Nil,
			$author$project$Compiler$Generate$JavaScript$Expression$codeToStmtList(
				A2($author$project$Compiler$Generate$JavaScript$Expression$generate, mode, expr)));
	});
var $author$project$Compiler$Elm$ModuleName$getModule = function (_v0) {
	var name = _v0.b;
	return name;
};
var $author$project$Compiler$Reporting$Doc$makeNakedLink = function (fileName) {
	return 'https://elm-lang.org/' + ($author$project$Compiler$Elm$Version$toChars($author$project$Compiler$Elm$Version$compiler) + ('/' + fileName));
};
var $author$project$Compiler$Generate$JavaScript$generateCycle = F5(
	function (mode, _v0, names, values, functions) {
		var home = _v0.a;
		return $author$project$Compiler$Generate$JavaScript$Builder$Block(
			_List_fromArray(
				[
					$author$project$Compiler$Generate$JavaScript$Builder$Block(
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Generate$JavaScript$generateCycleFunc, mode, home),
						functions)),
					$author$project$Compiler$Generate$JavaScript$Builder$Block(
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Generate$JavaScript$generateSafeCycle, mode, home),
						values)),
					function () {
					var _v1 = A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$Generate$JavaScript$generateRealCycle(home),
						values);
					if (!_v1.b) {
						return $author$project$Compiler$Generate$JavaScript$Builder$EmptyStmt;
					} else {
						var realBlock = _v1;
						if (mode.$ === 'Prod') {
							return $author$project$Compiler$Generate$JavaScript$Builder$Block(realBlock);
						} else {
							return A3(
								$author$project$Compiler$Generate$JavaScript$Builder$Try,
								$author$project$Compiler$Generate$JavaScript$Builder$Block(realBlock),
								$author$project$Compiler$Generate$JavaScript$Name$dollar,
								$author$project$Compiler$Generate$JavaScript$Builder$Throw(
									$author$project$Compiler$Generate$JavaScript$Builder$CString(
										'Some top-level definitions from `' + ($author$project$Compiler$Data$Name$toBuilder(
											$author$project$Compiler$Elm$ModuleName$getModule(home)) + ('` are causing infinite recursion:\\n' + ($author$project$Compiler$Generate$JavaScript$drawCycle(names) + ('\\n\\nThese errors are very tricky, so read ' + ($author$project$Compiler$Reporting$Doc$makeNakedLink('bad-recursion') + ' to learn how to fix it!'))))))));
						}
					}
				}()
				]));
	});
var $author$project$Compiler$Generate$JavaScript$generateEnum = F3(
	function (mode, global, index) {
		var home = global.a;
		var name = global.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Var,
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
			function () {
				if (mode.$ === 'Dev') {
					return $author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
						A4($author$project$Compiler$Generate$JavaScript$Expression$generateCtor, mode, global, index, 0));
				} else {
					return $author$project$Compiler$Generate$JavaScript$Builder$CInt(
						$author$project$Compiler$Data$Index$toMachine(index));
				}
			}());
	});
var $author$project$Compiler$Generate$JavaScript$addChunk = F3(
	function (mode, chunk, builder) {
		switch (chunk.$) {
			case 'JS':
				var javascript = chunk.a;
				return _Utils_ap(javascript, builder);
			case 'ElmVar':
				var home = chunk.a;
				var name = chunk.b;
				return _Utils_ap(
					$author$project$Compiler$Generate$JavaScript$Name$toBuilder(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name)),
					builder);
			case 'JsVar':
				var home = chunk.a;
				var name = chunk.b;
				return _Utils_ap(
					$author$project$Compiler$Generate$JavaScript$Name$toBuilder(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, home, name)),
					builder);
			case 'ElmField':
				var name = chunk.a;
				return _Utils_ap(
					$author$project$Compiler$Generate$JavaScript$Name$toBuilder(
						A2($author$project$Compiler$Generate$JavaScript$Expression$generateField, mode, name)),
					builder);
			case 'JsField':
				var _int = chunk.a;
				return _Utils_ap(
					$author$project$Compiler$Generate$JavaScript$Name$toBuilder(
						$author$project$Compiler$Generate$JavaScript$Name$fromInt(_int)),
					builder);
			case 'JsEnum':
				var _int = chunk.a;
				return _Utils_ap(
					$elm$core$String$fromInt(_int),
					builder);
			case 'Debug':
				if (mode.$ === 'Dev') {
					return builder;
				} else {
					return '_UNUSED' + builder;
				}
			case 'Prod':
				if (mode.$ === 'Dev') {
					return '_UNUSED' + builder;
				} else {
					return builder;
				}
			default:
				if ((mode.$ === 'Dev') && (mode.a.$ === 'DevAsync')) {
					var _v4 = mode.a;
					return builder;
				} else {
					return '_UNUSED' + builder;
				}
		}
	});
var $author$project$Compiler$Generate$JavaScript$generateKernel = F2(
	function (mode, chunks) {
		return A3(
			$author$project$Extra$Type$List$foldr,
			$author$project$Compiler$Generate$JavaScript$addChunk(mode),
			'',
			chunks);
	});
var $author$project$Compiler$Generate$JavaScript$leaf = $author$project$Compiler$Generate$JavaScript$Builder$Ref(
	A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$platform, 'leaf'));
var $author$project$Compiler$Generate$JavaScript$generateLeaf = F2(
	function (home, name) {
		var moduleName = home.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Var,
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Call,
				$author$project$Compiler$Generate$JavaScript$leaf,
				_List_fromArray(
					[
						$author$project$Compiler$Generate$JavaScript$Builder$CString(
						$author$project$Compiler$Data$Name$toBuilder(moduleName))
					])));
	});
var $author$project$Compiler$Generate$JavaScript$generateManagerHelp = F2(
	function (home, effectsType) {
		var ref = function (name) {
			return $author$project$Compiler$Generate$JavaScript$Builder$Ref(
				A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name));
		};
		var dep = function (name) {
			return $author$project$Compiler$AST$Optimized$toGlobalComparable(
				A2($author$project$Compiler$AST$Optimized$Global, home, name));
		};
		switch (effectsType.$) {
			case 'CCmd':
				return _Utils_Tuple3(
					_List_fromArray(
						[
							dep('init'),
							dep('onEffects'),
							dep('onSelfMsg'),
							dep('cmdMap')
						]),
					_List_fromArray(
						[
							ref('init'),
							ref('onEffects'),
							ref('onSelfMsg'),
							ref('cmdMap')
						]),
					_List_fromArray(
						[
							A2($author$project$Compiler$Generate$JavaScript$generateLeaf, home, 'command')
						]));
			case 'CSub':
				return _Utils_Tuple3(
					_List_fromArray(
						[
							dep('init'),
							dep('onEffects'),
							dep('onSelfMsg'),
							dep('subMap')
						]),
					_List_fromArray(
						[
							ref('init'),
							ref('onEffects'),
							ref('onSelfMsg'),
							$author$project$Compiler$Generate$JavaScript$Builder$CInt(0),
							ref('subMap')
						]),
					_List_fromArray(
						[
							A2($author$project$Compiler$Generate$JavaScript$generateLeaf, home, 'subscription')
						]));
			default:
				return _Utils_Tuple3(
					_List_fromArray(
						[
							dep('init'),
							dep('onEffects'),
							dep('onSelfMsg'),
							dep('cmdMap'),
							dep('subMap')
						]),
					_List_fromArray(
						[
							ref('init'),
							ref('onEffects'),
							ref('onSelfMsg'),
							ref('cmdMap'),
							ref('subMap')
						]),
					_List_fromArray(
						[
							A2($author$project$Compiler$Generate$JavaScript$generateLeaf, home, 'command'),
							A2($author$project$Compiler$Generate$JavaScript$generateLeaf, home, 'subscription')
						]));
		}
	});
var $author$project$Compiler$Generate$JavaScript$generatePort = F4(
	function (mode, _v0, makePort, converter) {
		var home = _v0.a;
		var name = _v0.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Var,
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Call,
				$author$project$Compiler$Generate$JavaScript$Builder$Ref(
					A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$platform, makePort)),
				_List_fromArray(
					[
						$author$project$Compiler$Generate$JavaScript$Builder$CString(
						$author$project$Compiler$Data$Name$toBuilder(name)),
						$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(
						A2($author$project$Compiler$Generate$JavaScript$Expression$generate, mode, converter))
					])));
	});
var $author$project$Compiler$Generate$JavaScript$identity_ = A2($author$project$Compiler$AST$Optimized$Global, $author$project$Compiler$Elm$ModuleName$basics, $author$project$Compiler$Data$Name$identity_);
var $author$project$Compiler$Generate$JavaScript$Expression$isBreakpointDef = F2(
	function (func, args) {
		return !_Utils_eq(
			A2($author$project$Compiler$Generate$JavaScript$Expression$getBreakpointDefSuspendFun, func, args),
			$elm$core$Maybe$Nothing);
	});
var $author$project$Compiler$Generate$Mode$isDebug = function (mode) {
	if ((mode.$ === 'Dev') && (mode.a.$ === 'DevDebug')) {
		return true;
	} else {
		return false;
	}
};
var $author$project$Compiler$Data$Name$debugger = 'Debugger';
var $author$project$Compiler$Generate$JavaScript$isDebugger = function (_v0) {
	var _v1 = _v0.a;
	var home = _v1.b;
	return _Utils_eq(home, $author$project$Compiler$Data$Name$debugger);
};
var $author$project$Compiler$Generate$JavaScript$var = F2(
	function (_v0, code) {
		var home = _v0.a;
		var name = _v0.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Var,
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name),
			$author$project$Compiler$Generate$JavaScript$Expression$codeToExpr(code));
	});
var $author$project$Compiler$Generate$JavaScript$addGlobal = F4(
	function (mode, graph, state, global) {
		var revKernels = state.a;
		var builders = state.b;
		var seen = state.c;
		return A2($author$project$Extra$Type$Set$member, global, seen) ? state : A4(
			$author$project$Compiler$Generate$JavaScript$addGlobalHelp,
			mode,
			graph,
			global,
			A3(
				$author$project$Compiler$Generate$JavaScript$State,
				revKernels,
				builders,
				A2($author$project$Extra$Type$Set$insert, global, seen)));
	});
var $author$project$Compiler$Generate$JavaScript$addGlobalHelp = F4(
	function (mode, graph, comparable, state) {
		var global = $author$project$Compiler$AST$Optimized$fromGlobalComparable(comparable);
		var addDeps = F2(
			function (deps, someState) {
				return A3(
					$author$project$Extra$Type$Set$foldl,
					A2($author$project$Compiler$Generate$JavaScript$addGlobal, mode, graph),
					someState,
					deps);
			});
		var _v2 = A2($author$project$Extra$Type$Map$ex, graph, comparable);
		switch (_v2.$) {
			case 'Define':
				var expr = _v2.a;
				var deps = _v2.b;
				var _v3 = function () {
					var _v5 = global.a;
					var pkg = _v5.a;
					var mName = _v5.b;
					var dName = global.b;
					return _Utils_Tuple3(
						_Utils_eq(pkg, $author$project$Compiler$Elm$Package$dummyName),
						mName,
						dName);
				}();
				var isLocalAppDef = _v3.a;
				var moduleName = _v3.b;
				var defName = _v3.c;
				var _v6 = function () {
					switch (expr.$) {
						case 'Function':
							return _Utils_Tuple2(
								$author$project$Compiler$Generate$Mode$isAsyncActive(mode) && isLocalAppDef,
								$elm$core$Maybe$Nothing);
						case 'Call':
							var func = expr.a;
							var args = expr.b;
							return _Utils_Tuple2(
								$author$project$Compiler$Generate$Mode$isAsyncActive(mode) && (isLocalAppDef && A2($author$project$Compiler$Generate$JavaScript$Expression$isBreakpointDef, func, args)),
								$elm$core$Maybe$Just(
									_Utils_Tuple2(moduleName, defName)));
						default:
							return _Utils_Tuple2(false, $elm$core$Maybe$Nothing);
					}
				}();
				var isAsyncDef = _v6.a;
				var maybeBpNames = _v6.b;
				var exprMode = isAsyncDef ? mode : $author$project$Compiler$Generate$Mode$deActivate(mode);
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					A2(addDeps, deps, state),
					A2(
						$author$project$Compiler$Generate$JavaScript$var,
						global,
						A4($author$project$Compiler$Generate$JavaScript$Expression$generateAsync, isAsyncDef, maybeBpNames, exprMode, expr)));
			case 'DefineTailFunc':
				var argNames = _v2.a;
				var body = _v2.b;
				var deps = _v2.c;
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					A2(addDeps, deps, state),
					function () {
						var _v8 = global;
						var name = _v8.b;
						return A2(
							$author$project$Compiler$Generate$JavaScript$var,
							global,
							A4($author$project$Compiler$Generate$JavaScript$Expression$generateTailDef, mode, name, argNames, body));
					}());
			case 'Ctor':
				var index = _v2.a;
				var arity = _v2.b;
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					state,
					A2(
						$author$project$Compiler$Generate$JavaScript$var,
						global,
						A4($author$project$Compiler$Generate$JavaScript$Expression$generateCtor, mode, global, index, arity)));
			case 'Link':
				var linkedGlobal = _v2.a;
				return A4(
					$author$project$Compiler$Generate$JavaScript$addGlobal,
					mode,
					graph,
					state,
					$author$project$Compiler$AST$Optimized$toGlobalComparable(linkedGlobal));
			case 'Cycle':
				var names = _v2.a;
				var values = _v2.b;
				var functions = _v2.c;
				var deps = _v2.d;
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					A2(addDeps, deps, state),
					A5($author$project$Compiler$Generate$JavaScript$generateCycle, mode, global, names, values, functions));
			case 'Manager':
				var effectsType = _v2.a;
				return A5($author$project$Compiler$Generate$JavaScript$generateManager, mode, graph, global, effectsType, state);
			case 'Kernel':
				var chunks = _v2.a;
				var deps = _v2.b;
				return ($author$project$Compiler$Generate$JavaScript$isDebugger(global) && (!$author$project$Compiler$Generate$Mode$isDebug(mode))) ? state : A2(
					$author$project$Compiler$Generate$JavaScript$addKernel,
					A2(addDeps, deps, state),
					A2($author$project$Compiler$Generate$JavaScript$generateKernel, mode, chunks));
			case 'Enum':
				var index = _v2.a;
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					state,
					A3($author$project$Compiler$Generate$JavaScript$generateEnum, mode, global, index));
			case 'Box':
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					A4(
						$author$project$Compiler$Generate$JavaScript$addGlobal,
						mode,
						graph,
						state,
						$author$project$Compiler$AST$Optimized$toGlobalComparable($author$project$Compiler$Generate$JavaScript$identity_)),
					A2($author$project$Compiler$Generate$JavaScript$generateBox, mode, global));
			case 'PortIncoming':
				var decoder = _v2.a;
				var deps = _v2.b;
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					A2(addDeps, deps, state),
					A4($author$project$Compiler$Generate$JavaScript$generatePort, mode, global, 'incomingPort', decoder));
			default:
				var encoder = _v2.a;
				var deps = _v2.b;
				return A2(
					$author$project$Compiler$Generate$JavaScript$addStmt,
					A2(addDeps, deps, state),
					A4($author$project$Compiler$Generate$JavaScript$generatePort, mode, global, 'outgoingPort', encoder));
		}
	});
var $author$project$Compiler$Generate$JavaScript$generateManager = F5(
	function (mode, graph, _v0, effectsType, state) {
		var home = _v0.a;
		var moduleName = home.b;
		var managerLVar = A2(
			$author$project$Compiler$Generate$JavaScript$Builder$LBracket,
			$author$project$Compiler$Generate$JavaScript$Builder$Ref(
				A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$platform, 'effectManagers')),
			$author$project$Compiler$Generate$JavaScript$Builder$CString(
				$author$project$Compiler$Data$Name$toBuilder(moduleName)));
		var _v1 = A2($author$project$Compiler$Generate$JavaScript$generateManagerHelp, home, effectsType);
		var deps = _v1.a;
		var args = _v1.b;
		var stmts = _v1.c;
		var createManager = $author$project$Compiler$Generate$JavaScript$Builder$ExprStmt(
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Assign,
				managerLVar,
				A2(
					$author$project$Compiler$Generate$JavaScript$Builder$Call,
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$platform, 'createManager')),
					args)));
		return A2(
			$author$project$Compiler$Generate$JavaScript$addStmt,
			A3(
				$author$project$Extra$Type$List$foldl,
				A2($author$project$Compiler$Generate$JavaScript$addGlobal, mode, graph),
				state,
				deps),
			$author$project$Compiler$Generate$JavaScript$Builder$Block(
				A2($elm$core$List$cons, createManager, stmts)));
	});
var $author$project$Compiler$Generate$JavaScript$emptyState = A3($author$project$Compiler$Generate$JavaScript$State, _List_Nil, _List_Nil, $author$project$Extra$Type$Set$empty);
var $author$project$Compiler$Generate$JavaScript$Functions$functions = '\n\nfunction F(arity, fun, wrapper) {\n  wrapper.a = arity;\n  wrapper.f = fun;\n  return wrapper;\n}\n\nfunction F2(fun) {\n  return F(2, fun, function(a) { return function(b) { return fun(a,b); }; })\n}\nfunction F3(fun) {\n  return F(3, fun, function(a) {\n    return function(b) { return function(c) { return fun(a, b, c); }; };\n  });\n}\nfunction F4(fun) {\n  return F(4, fun, function(a) { return function(b) { return function(c) {\n    return function(d) { return fun(a, b, c, d); }; }; };\n  });\n}\nfunction F5(fun) {\n  return F(5, fun, function(a) { return function(b) { return function(c) {\n    return function(d) { return function(e) { return fun(a, b, c, d, e); }; }; }; };\n  });\n}\nfunction F6(fun) {\n  return F(6, fun, function(a) { return function(b) { return function(c) {\n    return function(d) { return function(e) { return function(f) {\n    return fun(a, b, c, d, e, f); }; }; }; }; };\n  });\n}\nfunction F7(fun) {\n  return F(7, fun, function(a) { return function(b) { return function(c) {\n    return function(d) { return function(e) { return function(f) {\n    return function(g) { return fun(a, b, c, d, e, f, g); }; }; }; }; }; };\n  });\n}\nfunction F8(fun) {\n  return F(8, fun, function(a) { return function(b) { return function(c) {\n    return function(d) { return function(e) { return function(f) {\n    return function(g) { return function(h) {\n    return fun(a, b, c, d, e, f, g, h); }; }; }; }; }; }; };\n  });\n}\nfunction F9(fun) {\n  return F(9, fun, function(a) { return function(b) { return function(c) {\n    return function(d) { return function(e) { return function(f) {\n    return function(g) { return function(h) { return function(i) {\n    return fun(a, b, c, d, e, f, g, h, i); }; }; }; }; }; }; }; };\n  });\n}\n\nfunction A2(fun, a, b) {\n  return fun.a === 2 ? fun.f(a, b) : fun(a)(b);\n}\nfunction A3(fun, a, b, c) {\n  return fun.a === 3 ? fun.f(a, b, c) : fun(a)(b)(c);\n}\nfunction A4(fun, a, b, c, d) {\n  return fun.a === 4 ? fun.f(a, b, c, d) : fun(a)(b)(c)(d);\n}\nfunction A5(fun, a, b, c, d, e) {\n  return fun.a === 5 ? fun.f(a, b, c, d, e) : fun(a)(b)(c)(d)(e);\n}\nfunction A6(fun, a, b, c, d, e, f) {\n  return fun.a === 6 ? fun.f(a, b, c, d, e, f) : fun(a)(b)(c)(d)(e)(f);\n}\nfunction A7(fun, a, b, c, d, e, f, g) {\n  return fun.a === 7 ? fun.f(a, b, c, d, e, f, g) : fun(a)(b)(c)(d)(e)(f)(g);\n}\nfunction A8(fun, a, b, c, d, e, f, g, h) {\n  return fun.a === 8 ? fun.f(a, b, c, d, e, f, g, h) : fun(a)(b)(c)(d)(e)(f)(g)(h);\n}\nfunction A9(fun, a, b, c, d, e, f, g, h, i) {\n  return fun.a === 9 ? fun.f(a, b, c, d, e, f, g, h, i) : fun(a)(b)(c)(d)(e)(f)(g)(h)(i);\n}\n\n';
var $author$project$Compiler$Generate$JavaScript$prependBuilders = F2(
	function (revBuilders, monolith) {
		return A3(
			$author$project$Extra$Type$List$foldl,
			F2(
				function (m, b) {
					return _Utils_ap(b, m);
				}),
			monolith,
			revBuilders);
	});
var $author$project$Compiler$Generate$JavaScript$stateToBuilder = function (_v0) {
	var revKernels = _v0.a;
	var revBuilders = _v0.b;
	return A2(
		$author$project$Compiler$Generate$JavaScript$prependBuilders,
		revKernels,
		A2($author$project$Compiler$Generate$JavaScript$prependBuilders, revBuilders, ''));
};
var $author$project$Compiler$Generate$JavaScript$Trie = F2(
	function (a, b) {
		return {$: 'Trie', a: a, b: b};
	});
var $author$project$Compiler$Generate$JavaScript$checkedMerge = F2(
	function (a, b) {
		var _v0 = _Utils_Tuple2(a, b);
		if (_v0.a.$ === 'Nothing') {
			var _v1 = _v0.a;
			var main = _v0.b;
			return main;
		} else {
			if (_v0.b.$ === 'Nothing') {
				var main = _v0.a;
				var _v2 = _v0.b;
				return main;
			} else {
				return _Debug_todo(
					'Compiler.Generate.JavaScript',
					{
						start: {line: 633, column: 7},
						end: {line: 633, column: 17}
					})('cannot have two modules with the same name');
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$merge = F2(
	function (_v0, _v1) {
		var main1 = _v0.a;
		var subs1 = _v0.b;
		var main2 = _v1.a;
		var subs2 = _v1.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$Trie,
			A2($author$project$Compiler$Generate$JavaScript$checkedMerge, main1, main2),
			A3($author$project$Extra$Type$Map$unionWith, $author$project$Compiler$Generate$JavaScript$merge, subs1, subs2));
	});
var $author$project$Compiler$Generate$JavaScript$segmentsToTrie = F3(
	function (home, segments, main) {
		if (!segments.b) {
			return A2(
				$author$project$Compiler$Generate$JavaScript$Trie,
				$elm$core$Maybe$Just(
					_Utils_Tuple2(home, main)),
				$author$project$Extra$Type$Map$empty);
		} else {
			var segment = segments.a;
			var otherSegments = segments.b;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Trie,
				$elm$core$Maybe$Nothing,
				A2(
					$author$project$Extra$Type$Map$singleton,
					segment,
					A3($author$project$Compiler$Generate$JavaScript$segmentsToTrie, home, otherSegments, main)));
		}
	});
var $author$project$Compiler$Data$Utf8$split = F2(
	function (divider, str) {
		return A2(
			$elm$core$String$split,
			$elm$core$String$fromChar(
				$elm$core$Char$fromCode(divider)),
			str);
	});
var $author$project$Compiler$Data$Name$splitDots = function (name) {
	return A2($author$project$Compiler$Data$Utf8$split, 46, name);
};
var $author$project$Compiler$Generate$JavaScript$addToTrie = F3(
	function (comparable, main, trie) {
		var home = $author$project$Compiler$Elm$ModuleName$fromComparable(comparable);
		var moduleName = home.b;
		return A2(
			$author$project$Compiler$Generate$JavaScript$merge,
			trie,
			A3(
				$author$project$Compiler$Generate$JavaScript$segmentsToTrie,
				home,
				$author$project$Compiler$Data$Name$splitDots(moduleName),
				main));
	});
var $author$project$Compiler$Generate$JavaScript$emptyTrie = A2($author$project$Compiler$Generate$JavaScript$Trie, $elm$core$Maybe$Nothing, $author$project$Extra$Type$Map$empty);
var $author$project$Compiler$Generate$JavaScript$Builder$exprToBuilder = function (expr) {
	return A3($author$project$Compiler$Generate$JavaScript$Builder$fromExpr, $author$project$Compiler$Generate$JavaScript$Builder$levelZero, $author$project$Compiler$Generate$JavaScript$Builder$Whatever, expr).b;
};
var $author$project$Compiler$Generate$JavaScript$Expression$hash = F2(
	function (arg, func) {
		return A2(
			$author$project$Compiler$Generate$JavaScript$Builder$Call,
			func,
			_List_fromArray(
				[arg]));
	});
var $author$project$Compiler$Generate$JavaScript$Builder$Json = function (a) {
	return {$: 'Json', a: a};
};
var $author$project$Compiler$Json$Encode$CString = function (a) {
	return {$: 'CString', a: a};
};
var $author$project$Compiler$Json$Encode$escape = function (chrs) {
	var _v0 = $elm$core$String$uncons(chrs);
	if (_v0.$ === 'Nothing') {
		return '';
	} else {
		var _v1 = _v0.a;
		var c = _v1.a;
		var cs = _v1.b;
		return _Utils_eq(
			c,
			_Utils_chr('\r')) ? A2(
			$elm$core$String$cons,
			_Utils_chr('\\'),
			A2(
				$elm$core$String$cons,
				_Utils_chr('r'),
				$author$project$Compiler$Json$Encode$escape(cs))) : (_Utils_eq(
			c,
			_Utils_chr('\n')) ? A2(
			$elm$core$String$cons,
			_Utils_chr('\\'),
			A2(
				$elm$core$String$cons,
				_Utils_chr('n'),
				$author$project$Compiler$Json$Encode$escape(cs))) : (_Utils_eq(
			c,
			_Utils_chr('\"')) ? A2(
			$elm$core$String$cons,
			_Utils_chr('\\'),
			A2(
				$elm$core$String$cons,
				_Utils_chr('\"'),
				$author$project$Compiler$Json$Encode$escape(cs))) : (_Utils_eq(
			c,
			_Utils_chr('\\')) ? A2(
			$elm$core$String$cons,
			_Utils_chr('\\'),
			A2(
				$elm$core$String$cons,
				_Utils_chr('\\'),
				$author$project$Compiler$Json$Encode$escape(cs))) : A2(
			$elm$core$String$cons,
			c,
			$author$project$Compiler$Json$Encode$escape(cs)))));
	}
};
var $author$project$Compiler$Json$Encode$chars = function (chrs) {
	return $author$project$Compiler$Json$Encode$CString(
		'\"' + ($author$project$Compiler$Json$Encode$escape(chrs) + '\"'));
};
var $author$project$Compiler$Elm$Version$encode = function (version) {
	return $author$project$Compiler$Json$Encode$chars(
		$author$project$Compiler$Elm$Version$toChars(version));
};
var $author$project$Compiler$Elm$Compiler$Type$collectLambdas = function (tipe) {
	if (tipe.$ === 'Lambda') {
		var arg = tipe.a;
		var body = tipe.b;
		return A2(
			$elm$core$List$cons,
			arg,
			$author$project$Compiler$Elm$Compiler$Type$collectLambdas(body));
	} else {
		return _List_fromArray(
			[tipe]);
	}
};
var $author$project$Compiler$Elm$Compiler$Type$entryToDoc = F2(
	function (localizer, _v3) {
		var field = _v3.a;
		var fieldType = _v3.b;
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$fromName(field),
			A3($author$project$Compiler$Elm$Compiler$Type$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, fieldType));
	});
var $author$project$Compiler$Elm$Compiler$Type$toDoc = F3(
	function (localizer, context, tipe) {
		switch (tipe.$) {
			case 'Lambda':
				var _v1 = A2(
					$author$project$Extra$Type$List$map,
					A2($author$project$Compiler$Elm$Compiler$Type$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func),
					$author$project$Compiler$Elm$Compiler$Type$collectLambdas(tipe));
				if (_v1.b && _v1.b.b) {
					var a = _v1.a;
					var _v2 = _v1.b;
					var b = _v2.a;
					var cs = _v2.b;
					return A4($author$project$Compiler$Reporting$Render$Type$lambda, context, a, b, cs);
				} else {
					var x = _v1;
					return _Debug_todo(
						'Compiler.Elm.Compiler.Type',
						{
							start: {line: 58, column: 14},
							end: {line: 58, column: 24}
						})(
						'toDoc Lambda ' + $elm$core$Debug$toString(x));
				}
			case 'Var':
				var name = tipe.a;
				return $author$project$Compiler$Reporting$Doc$fromName(name);
			case 'Unit':
				return $author$project$Compiler$Reporting$Doc$d('()');
			case 'Tuple':
				var a = tipe.a;
				var b = tipe.b;
				var cs = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$tuple,
					A3($author$project$Compiler$Elm$Compiler$Type$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, a),
					A3($author$project$Compiler$Elm$Compiler$Type$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, b),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Elm$Compiler$Type$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None),
						cs));
			case 'Type':
				var name = tipe.a;
				var args = tipe.b;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					context,
					$author$project$Compiler$Reporting$Doc$fromName(name),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Elm$Compiler$Type$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App),
						args));
			default:
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$Reporting$Render$Type$record,
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$Elm$Compiler$Type$entryToDoc(localizer),
						fields),
					A2($elm$core$Maybe$map, $author$project$Compiler$Reporting$Doc$fromName, ext));
		}
	});
var $author$project$Compiler$Reporting$Doc$toLine = function (doc) {
	return A2(
		$author$project$Extra$Data$Pretty$pretty,
		A2($elm$core$Basics$pow, 2, 40),
		doc);
};
var $author$project$Compiler$Elm$Compiler$Type$encode = function (tipe) {
	return $author$project$Compiler$Json$Encode$chars(
		$author$project$Compiler$Reporting$Doc$toLine(
			A3($author$project$Compiler$Elm$Compiler$Type$toDoc, $author$project$Compiler$Reporting$Render$Type$Localizer$empty, $author$project$Compiler$Reporting$Render$Type$None, tipe)));
};
var $author$project$Compiler$Json$Encode$Object = function (a) {
	return {$: 'Object', a: a};
};
var $author$project$Compiler$Json$Encode$object = $author$project$Compiler$Json$Encode$Object;
var $author$project$Compiler$Json$String$fromName = $elm$core$Basics$identity;
var $author$project$Compiler$Json$Encode$Array = function (a) {
	return {$: 'Array', a: a};
};
var $author$project$Compiler$Json$Encode$list = F2(
	function (encodeEntry, entries) {
		return $author$project$Compiler$Json$Encode$Array(
			A2($author$project$Extra$Type$List$map, encodeEntry, entries));
	});
var $author$project$Compiler$Json$Encode$name = function (nm) {
	return $author$project$Compiler$Json$Encode$CString(
		'\"' + ($author$project$Compiler$Data$Name$toBuilder(nm) + '\"'));
};
var $author$project$Compiler$Elm$Compiler$Type$toVariantObject = function (_v0) {
	var name = _v0.a;
	var args = _v0.b;
	return _Utils_Tuple2(
		$author$project$Compiler$Json$String$fromName(name),
		A2($author$project$Compiler$Json$Encode$list, $author$project$Compiler$Elm$Compiler$Type$encode, args));
};
var $author$project$Compiler$Elm$Compiler$Type$toCustomTypeField = function (_v0) {
	var name = _v0.a;
	var args = _v0.b;
	var constructors = _v0.c;
	return _Utils_Tuple2(
		$author$project$Compiler$Json$String$fromName(name),
		$author$project$Compiler$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'args',
					A2($author$project$Compiler$Json$Encode$list, $author$project$Compiler$Json$Encode$name, args)),
					_Utils_Tuple2(
					'tags',
					$author$project$Compiler$Json$Encode$object(
						A2($author$project$Extra$Type$List$map, $author$project$Compiler$Elm$Compiler$Type$toVariantObject, constructors)))
				])));
};
var $author$project$Compiler$Elm$Compiler$Type$toTypeAliasField = function (_v0) {
	var name = _v0.a;
	var args = _v0.b;
	var tipe = _v0.c;
	return _Utils_Tuple2(
		$author$project$Compiler$Json$String$fromName(name),
		$author$project$Compiler$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'args',
					A2($author$project$Compiler$Json$Encode$list, $author$project$Compiler$Json$Encode$name, args)),
					_Utils_Tuple2(
					'type',
					$author$project$Compiler$Elm$Compiler$Type$encode(tipe))
				])));
};
var $author$project$Compiler$Elm$Compiler$Type$encodeMetadata = function (_v0) {
	var msg = _v0.a;
	var aliases = _v0.b;
	var unions = _v0.c;
	return $author$project$Compiler$Json$Encode$object(
		_List_fromArray(
			[
				_Utils_Tuple2(
				'message',
				$author$project$Compiler$Elm$Compiler$Type$encode(msg)),
				_Utils_Tuple2(
				'aliases',
				$author$project$Compiler$Json$Encode$object(
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Elm$Compiler$Type$toTypeAliasField, aliases))),
				_Utils_Tuple2(
				'unions',
				$author$project$Compiler$Json$Encode$object(
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Elm$Compiler$Type$toCustomTypeField, unions)))
			]));
};
var $author$project$Compiler$Elm$Compiler$Type$DebugMetadata = F3(
	function (a, b, c) {
		return {$: 'DebugMetadata', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Compiler$Type$Lambda = F2(
	function (a, b) {
		return {$: 'Lambda', a: a, b: b};
	});
var $author$project$Compiler$Elm$Compiler$Type$Record = F2(
	function (a, b) {
		return {$: 'Record', a: a, b: b};
	});
var $author$project$Compiler$Elm$Compiler$Type$Tuple = F3(
	function (a, b, c) {
		return {$: 'Tuple', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Compiler$Type$Type = F2(
	function (a, b) {
		return {$: 'Type', a: a, b: b};
	});
var $author$project$Compiler$Elm$Compiler$Type$Unit = {$: 'Unit'};
var $author$project$Compiler$Elm$Compiler$Type$Var = function (a) {
	return {$: 'Var', a: a};
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor = function (a) {
	return {$: 'Extractor', a: a};
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$addAlias = F2(
	function (alias, value) {
		return $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor(
			F3(
				function (aliases, unions, ok) {
					return A3(
						ok,
						A2($author$project$Extra$Type$Set$insert, alias, aliases),
						unions,
						value);
				}));
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$addUnion = F2(
	function (union, value) {
		return $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor(
			F3(
				function (aliases, unions, ok) {
					return A3(
						ok,
						aliases,
						A2($author$project$Extra$Type$Set$insert, union, unions),
						value);
				}));
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$andMap = F2(
	function (_v0, _v1) {
		var kv = _v0.a;
		var kf = _v1.a;
		return $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor(
			F3(
				function (aliases, unions, ok) {
					var ok1 = F3(
						function (a1, u1, func) {
							var ok2 = F3(
								function (a2, u2, value) {
									return A3(
										ok,
										a2,
										u2,
										func(value));
								});
							return A3(kv, a1, u1, ok2);
						});
					return A3(kf, aliases, unions, ok1);
				}));
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$bind = F2(
	function (_v0, callback) {
		var ka = _v0.a;
		return $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor(
			F3(
				function (aliases, unions, ok) {
					var ok1 = F3(
						function (a1, u1, value) {
							var _v1 = callback(value);
							var kb = _v1.a;
							return A3(kb, a1, u1, ok);
						});
					return A3(ka, aliases, unions, ok1);
				}));
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$fmap = F2(
	function (func, _v0) {
		var k = _v0.a;
		return $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor(
			F3(
				function (aliases, unions, ok) {
					var ok1 = F3(
						function (a1, u1, value) {
							return A3(
								ok,
								a1,
								u1,
								func(value));
						});
					return A3(k, aliases, unions, ok1);
				}));
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$liftA2 = A2($author$project$Extra$Class$Applicative$liftA2, $author$project$Compiler$Elm$Compiler$Type$Extract$fmap, $author$project$Compiler$Elm$Compiler$Type$Extract$andMap);
var $author$project$Compiler$Elm$Compiler$Type$Extract$pure = function (value) {
	return $author$project$Compiler$Elm$Compiler$Type$Extract$Extractor(
		F3(
			function (aliases, unions, ok) {
				return A3(ok, aliases, unions, value);
			}));
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$return = $author$project$Compiler$Elm$Compiler$Type$Extract$pure;
var $author$project$Compiler$Elm$Compiler$Type$Extract$toPublicName = F2(
	function (_v0, name) {
		var home = _v0.b;
		return A3($author$project$Compiler$Data$Name$sepBy, 46, home, name);
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$extract = function (astType) {
	switch (astType.$) {
		case 'TLambda':
			var arg = astType.a;
			var result = astType.b;
			return A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
				$author$project$Compiler$Elm$Compiler$Type$Extract$extract(result),
				A2(
					$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
					$author$project$Compiler$Elm$Compiler$Type$Extract$extract(arg),
					$author$project$Compiler$Elm$Compiler$Type$Extract$return($author$project$Compiler$Elm$Compiler$Type$Lambda)));
		case 'TVar':
			var x = astType.a;
			return $author$project$Compiler$Elm$Compiler$Type$Extract$pure(
				$author$project$Compiler$Elm$Compiler$Type$Var(x));
		case 'TType':
			var home = astType.a;
			var name = astType.b;
			var args = astType.c;
			return A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
				A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Elm$Compiler$Type$Extract$pure, $author$project$Compiler$Elm$Compiler$Type$Extract$liftA2, $author$project$Compiler$Elm$Compiler$Type$Extract$extract, args),
				A2(
					$author$project$Compiler$Elm$Compiler$Type$Extract$addUnion,
					$author$project$Compiler$AST$Optimized$toGlobalComparable(
						A2($author$project$Compiler$AST$Optimized$Global, home, name)),
					$author$project$Compiler$Elm$Compiler$Type$Type(
						A2($author$project$Compiler$Elm$Compiler$Type$Extract$toPublicName, home, name))));
		case 'TRecord':
			var fields = astType.a;
			var ext = astType.b;
			return A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$bind,
				A4(
					$author$project$Extra$Type$List$traverse,
					$author$project$Compiler$Elm$Compiler$Type$Extract$pure,
					$author$project$Compiler$Elm$Compiler$Type$Extract$liftA2,
					A2($author$project$Extra$Type$Tuple$traverseSecond, $author$project$Compiler$Elm$Compiler$Type$Extract$fmap, $author$project$Compiler$Elm$Compiler$Type$Extract$extract),
					$author$project$Compiler$AST$Canonical$fieldsToList(fields)),
				function (efields) {
					return $author$project$Compiler$Elm$Compiler$Type$Extract$pure(
						A2($author$project$Compiler$Elm$Compiler$Type$Record, efields, ext));
				});
		case 'TUnit':
			return $author$project$Compiler$Elm$Compiler$Type$Extract$pure($author$project$Compiler$Elm$Compiler$Type$Unit);
		case 'TTuple':
			var a = astType.a;
			var b = astType.b;
			var maybeC = astType.c;
			return A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
				A4(
					$author$project$Extra$Type$List$traverse,
					$author$project$Compiler$Elm$Compiler$Type$Extract$pure,
					$author$project$Compiler$Elm$Compiler$Type$Extract$liftA2,
					$author$project$Compiler$Elm$Compiler$Type$Extract$extract,
					$author$project$Extra$Type$Maybe$maybeToList(maybeC)),
				A2(
					$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
					$author$project$Compiler$Elm$Compiler$Type$Extract$extract(b),
					A2(
						$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
						$author$project$Compiler$Elm$Compiler$Type$Extract$extract(a),
						$author$project$Compiler$Elm$Compiler$Type$Extract$return($author$project$Compiler$Elm$Compiler$Type$Tuple))));
		default:
			var home = astType.a;
			var name = astType.b;
			var args = astType.c;
			var aliasType = astType.d;
			return A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$bind,
				A2(
					$author$project$Compiler$Elm$Compiler$Type$Extract$addAlias,
					$author$project$Compiler$AST$Optimized$toGlobalComparable(
						A2($author$project$Compiler$AST$Optimized$Global, home, name)),
					_Utils_Tuple0),
				function (_v1) {
					return A2(
						$author$project$Compiler$Elm$Compiler$Type$Extract$bind,
						$author$project$Compiler$Elm$Compiler$Type$Extract$extract(
							A2($author$project$Compiler$AST$Utils$Type$dealias, args, aliasType)),
						function (_v2) {
							return A2(
								$author$project$Compiler$Elm$Compiler$Type$Extract$fmap,
								$author$project$Compiler$Elm$Compiler$Type$Type(
									A2($author$project$Compiler$Elm$Compiler$Type$Extract$toPublicName, home, name)),
								A4(
									$author$project$Extra$Type$List$traverse,
									$author$project$Compiler$Elm$Compiler$Type$Extract$pure,
									$author$project$Compiler$Elm$Compiler$Type$Extract$liftA2,
									A2($elm$core$Basics$composeL, $author$project$Compiler$Elm$Compiler$Type$Extract$extract, $elm$core$Tuple$second),
									args));
						});
				});
	}
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$Deps = F2(
	function (a, b) {
		return {$: 'Deps', a: a, b: b};
	});
var $author$project$Compiler$Elm$Compiler$Type$Alias = F3(
	function (a, b, c) {
		return {$: 'Alias', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$getAliasInfo = function (_v0) {
	var alias_info = _v0.b;
	return alias_info;
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$extractAlias = F2(
	function (_v0, comparable) {
		var dict = _v0.a;
		var _v1 = $author$project$Compiler$AST$Optimized$fromGlobalComparable(comparable);
		var home = _v1.a;
		var name = _v1.b;
		var _v2 = A2(
			$author$project$Extra$Type$Map$ex,
			$author$project$Compiler$Elm$Compiler$Type$Extract$getAliasInfo(
				A2(
					$author$project$Extra$Type$Map$ex,
					dict,
					$author$project$Compiler$Elm$ModuleName$toComparable(home))),
			name);
		var args = _v2.a;
		var aliasType = _v2.b;
		return A2(
			$author$project$Compiler$Elm$Compiler$Type$Extract$fmap,
			A2(
				$author$project$Compiler$Elm$Compiler$Type$Alias,
				A2($author$project$Compiler$Elm$Compiler$Type$Extract$toPublicName, home, name),
				args),
			$author$project$Compiler$Elm$Compiler$Type$Extract$extract(aliasType));
	});
var $author$project$Compiler$Elm$Compiler$Type$Union = F3(
	function (a, b, c) {
		return {$: 'Union', a: a, b: b, c: c};
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$extractCtor = function (_v0) {
	var ctor = _v0.a;
	var args = _v0.d;
	return A2(
		$author$project$Compiler$Elm$Compiler$Type$Extract$fmap,
		$elm$core$Tuple$pair(ctor),
		A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Elm$Compiler$Type$Extract$pure, $author$project$Compiler$Elm$Compiler$Type$Extract$liftA2, $author$project$Compiler$Elm$Compiler$Type$Extract$extract, args));
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$getUnionInfo = function (_v0) {
	var union_info = _v0.a;
	return union_info;
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$extractUnion = F2(
	function (_v0, comparable) {
		var dict = _v0.a;
		var _v1 = $author$project$Compiler$AST$Optimized$fromGlobalComparable(comparable);
		var home = _v1.a;
		var name = _v1.b;
		if (_Utils_eq(name, $author$project$Compiler$Data$Name$list) && _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$list)) {
			return $author$project$Compiler$Elm$Compiler$Type$Extract$return(
				A3(
					$author$project$Compiler$Elm$Compiler$Type$Union,
					A2($author$project$Compiler$Elm$Compiler$Type$Extract$toPublicName, home, name),
					_List_fromArray(
						['a']),
					_List_Nil));
		} else {
			var pname = A2($author$project$Compiler$Elm$Compiler$Type$Extract$toPublicName, home, name);
			var _v2 = A2(
				$author$project$Extra$Type$Map$ex,
				$author$project$Compiler$Elm$Compiler$Type$Extract$getUnionInfo(
					A2(
						$author$project$Extra$Type$Map$ex,
						dict,
						$author$project$Compiler$Elm$ModuleName$toComparable(home))),
				name);
			var vars = _v2.a;
			var ctors = _v2.b;
			return A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$fmap,
				A2($author$project$Compiler$Elm$Compiler$Type$Union, pname, vars),
				A4($author$project$Extra$Type$List$traverse, $author$project$Compiler$Elm$Compiler$Type$Extract$pure, $author$project$Compiler$Elm$Compiler$Type$Extract$liftA2, $author$project$Compiler$Elm$Compiler$Type$Extract$extractCtor, ctors));
		}
	});
var $author$project$Extra$Type$List$mappend = $elm$core$List$append;
var $author$project$Extra$Type$Tuple$mappend = F4(
	function (pMappendA, pMappendB, _v0, _v1) {
		var a1 = _v0.a;
		var b1 = _v0.b;
		var a2 = _v1.a;
		var b2 = _v1.b;
		return _Utils_Tuple2(
			A2(pMappendA, a1, a2),
			A2(pMappendB, b1, b2));
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$run = function (_v0) {
	var k = _v0.a;
	return A3(
		k,
		$author$project$Extra$Type$Set$empty,
		$author$project$Extra$Type$Set$empty,
		F3(
			function (aliases, unions, value) {
				return _Utils_Tuple2(
					A2($author$project$Compiler$Elm$Compiler$Type$Extract$Deps, aliases, unions),
					value);
			}));
};
var $author$project$Compiler$Elm$Compiler$Type$Extract$extractTransitive = F3(
	function (types, _v0, _v1) {
		var seenAliases = _v0.a;
		var seenUnions = _v0.b;
		var nextAliases = _v1.a;
		var nextUnions = _v1.b;
		var unions = A2($author$project$Extra$Type$Set$difference, nextUnions, seenUnions);
		var aliases = A2($author$project$Extra$Type$Set$difference, nextAliases, seenAliases);
		if ($author$project$Extra$Type$Set$null(aliases) && $author$project$Extra$Type$Set$null(unions)) {
			return _Utils_Tuple2(_List_Nil, _List_Nil);
		} else {
			var oldDeps = A2(
				$author$project$Compiler$Elm$Compiler$Type$Extract$Deps,
				A2($author$project$Extra$Type$Set$union, seenAliases, nextAliases),
				A2($author$project$Extra$Type$Set$union, seenUnions, nextUnions));
			var _v2 = $author$project$Compiler$Elm$Compiler$Type$Extract$run(
				A2(
					$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
					A4(
						$author$project$Extra$Type$List$traverse,
						$author$project$Compiler$Elm$Compiler$Type$Extract$pure,
						$author$project$Compiler$Elm$Compiler$Type$Extract$liftA2,
						$author$project$Compiler$Elm$Compiler$Type$Extract$extractUnion(types),
						$author$project$Extra$Type$Set$toList(unions)),
					A2(
						$author$project$Compiler$Elm$Compiler$Type$Extract$andMap,
						A4(
							$author$project$Extra$Type$List$traverse,
							$author$project$Compiler$Elm$Compiler$Type$Extract$pure,
							$author$project$Compiler$Elm$Compiler$Type$Extract$liftA2,
							$author$project$Compiler$Elm$Compiler$Type$Extract$extractAlias(types),
							$author$project$Extra$Type$Set$toList(aliases)),
						$author$project$Compiler$Elm$Compiler$Type$Extract$return($elm$core$Tuple$pair))));
			var newDeps = _v2.a;
			var result = _v2.b;
			var remainingResult = A3($author$project$Compiler$Elm$Compiler$Type$Extract$extractTransitive, types, oldDeps, newDeps);
			return A4($author$project$Extra$Type$Tuple$mappend, $author$project$Extra$Type$List$mappend, $author$project$Extra$Type$List$mappend, result, remainingResult);
		}
	});
var $author$project$Compiler$Elm$Compiler$Type$Extract$noDeps = A2($author$project$Compiler$Elm$Compiler$Type$Extract$Deps, $author$project$Extra$Type$Set$empty, $author$project$Extra$Type$Set$empty);
var $author$project$Compiler$Elm$Compiler$Type$Extract$fromMsg = F2(
	function (types, message) {
		var _v0 = $author$project$Compiler$Elm$Compiler$Type$Extract$run(
			$author$project$Compiler$Elm$Compiler$Type$Extract$extract(message));
		var msgDeps = _v0.a;
		var msgType = _v0.b;
		var _v1 = A3($author$project$Compiler$Elm$Compiler$Type$Extract$extractTransitive, types, $author$project$Compiler$Elm$Compiler$Type$Extract$noDeps, msgDeps);
		var aliases = _v1.a;
		var unions = _v1.b;
		return A3($author$project$Compiler$Elm$Compiler$Type$DebugMetadata, msgType, aliases, unions);
	});
var $author$project$Compiler$Generate$JavaScript$Expression$toDebugMetadata = F2(
	function (mode, msgType) {
		if (mode.$ === 'Prod') {
			return $author$project$Compiler$Generate$JavaScript$Builder$CInt(0);
		} else {
			if (mode.a.$ === 'DevDebug') {
				var interfaces = mode.a.a;
				return $author$project$Compiler$Generate$JavaScript$Builder$Json(
					$author$project$Compiler$Json$Encode$object(
						_List_fromArray(
							[
								_Utils_Tuple2(
								'versions',
								$author$project$Compiler$Json$Encode$object(
									_List_fromArray(
										[
											_Utils_Tuple2(
											'elm',
											$author$project$Compiler$Elm$Version$encode($author$project$Compiler$Elm$Version$compiler))
										]))),
								_Utils_Tuple2(
								'types',
								$author$project$Compiler$Elm$Compiler$Type$encodeMetadata(
									A2($author$project$Compiler$Elm$Compiler$Type$Extract$fromMsg, interfaces, msgType)))
							])));
			} else {
				return $author$project$Compiler$Generate$JavaScript$Builder$CInt(0);
			}
		}
	});
var $author$project$Compiler$Generate$JavaScript$Expression$generateMain = F3(
	function (mode, home, main) {
		if (main.$ === 'Static') {
			return A2(
				$author$project$Compiler$Generate$JavaScript$Expression$hash,
				$author$project$Compiler$Generate$JavaScript$Builder$CInt(0),
				A2(
					$author$project$Compiler$Generate$JavaScript$Expression$hash,
					$author$project$Compiler$Generate$JavaScript$Builder$CInt(0),
					A2(
						$author$project$Compiler$Generate$JavaScript$Expression$hash,
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, 'main')),
						$author$project$Compiler$Generate$JavaScript$Builder$Ref(
							A2(
								$author$project$Compiler$Generate$JavaScript$Name$fromKernel,
								$author$project$Compiler$Data$Name$virtualDom,
								A2($author$project$Compiler$Generate$JavaScript$Expression$addAsyncName, mode, 'init'))))));
		} else {
			var msgType = main.a;
			var decoder = main.b;
			return A2(
				$author$project$Compiler$Generate$JavaScript$Expression$hash,
				A2($author$project$Compiler$Generate$JavaScript$Expression$toDebugMetadata, mode, msgType),
				A2(
					$author$project$Compiler$Generate$JavaScript$Expression$hash,
					A2($author$project$Compiler$Generate$JavaScript$Expression$generateJsExpr, mode, decoder),
					$author$project$Compiler$Generate$JavaScript$Builder$Ref(
						A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, 'main'))));
		}
	});
var $author$project$Compiler$Generate$JavaScript$addSubTrie = F3(
	function (mode, end, _v5) {
		var name = _v5.a;
		var trie = _v5.b;
		return ',\'' + (name + ('\':' + (A2($author$project$Compiler$Generate$JavaScript$generateExports, mode, trie) + end)));
	});
var $author$project$Compiler$Generate$JavaScript$generateExports = F2(
	function (mode, _v0) {
		var maybeMain = _v0.a;
		var subs = _v0.b;
		var starter = function (end) {
			if (maybeMain.$ === 'Nothing') {
				return '{';
			} else {
				var _v4 = maybeMain.a;
				var home = _v4.a;
				var main = _v4.b;
				return '{\'init\':' + ($author$project$Compiler$Generate$JavaScript$Builder$exprToBuilder(
					A3($author$project$Compiler$Generate$JavaScript$Expression$generateMain, mode, home, main)) + end);
			}
		};
		var lastLine = $author$project$Compiler$Generate$Mode$isAsyncActive(mode) ? ', \'get_state\': _Breakpoint_get_state }' : '}';
		var _v1 = $author$project$Extra$Type$Map$toList(subs);
		if (!_v1.b) {
			return _Utils_ap(
				starter(''),
				lastLine);
		} else {
			var _v2 = _v1.a;
			var name = _v2.a;
			var subTrie = _v2.b;
			var otherSubTries = _v1.b;
			return starter(',') + ('\'' + (name + ('\':' + (A2(
				$author$project$Compiler$Generate$JavaScript$generateExports,
				$author$project$Compiler$Generate$Mode$deActivate(mode),
				subTrie) + A3(
				$author$project$Extra$Type$List$foldl,
				$author$project$Compiler$Generate$JavaScript$addSubTrie(mode),
				lastLine,
				otherSubTries)))));
		}
	});
var $author$project$Compiler$Generate$JavaScript$toMainExports = F2(
	function (mode, mains) {
		var exports = A2(
			$author$project$Compiler$Generate$JavaScript$generateExports,
			mode,
			A3($author$project$Extra$Type$Map$foldrWithKey, $author$project$Compiler$Generate$JavaScript$addToTrie, $author$project$Compiler$Generate$JavaScript$emptyTrie, mains));
		var _export = A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$platform, 'export');
		return $author$project$Compiler$Generate$JavaScript$Name$toBuilder(_export) + ('(' + (exports + ');'));
	});
var $author$project$Compiler$Generate$JavaScript$generateHtmlForRepl = F3(
	function (_v0, home, name) {
		var graph = _v0.a;
		var mode = $author$project$Compiler$Generate$Mode$Dev($author$project$Compiler$Generate$Mode$DevNormal);
		var state = A4(
			$author$project$Compiler$Generate$JavaScript$addGlobal,
			mode,
			graph,
			$author$project$Compiler$Generate$JavaScript$emptyState,
			$author$project$Compiler$AST$Optimized$toGlobalComparable(
				A2($author$project$Compiler$AST$Optimized$Global, home, name)));
		var mains = A2(
			$author$project$Extra$Type$Map$singleton,
			$author$project$Compiler$Elm$ModuleName$toComparable(home),
			$author$project$Compiler$AST$Optimized$Static);
		var evalState = A2(
			$author$project$Compiler$Generate$JavaScript$addStmt,
			state,
			A2(
				$author$project$Compiler$Generate$JavaScript$Builder$Var,
				A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, $author$project$Compiler$Data$Name$l_main),
				$author$project$Compiler$Generate$JavaScript$Builder$Ref(
					A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name))));
		return '(function(scope){\n\'use strict\';' + ($author$project$Compiler$Generate$JavaScript$Functions$functions + ($author$project$Compiler$Generate$JavaScript$stateToBuilder(evalState) + (A2($author$project$Compiler$Generate$JavaScript$toMainExports, mode, mains) + '}(this));')));
	});
var $author$project$Compiler$Generate$JavaScript$isStaticHtml = function (tipe) {
	if (((tipe.$ === 'TAlias') && (tipe.d.$ === 'Filled')) && (tipe.d.a.$ === 'TType')) {
		var _v1 = tipe.d.a;
		var valModule = _v1.a;
		var valType = _v1.b;
		return _Utils_eq(valModule, $author$project$Compiler$Elm$ModuleName$virtualDom) && _Utils_eq(valType, $author$project$Compiler$Data$Name$node);
	} else {
		return false;
	}
};
var $author$project$Compiler$Reporting$Render$Type$collectArgs = function (tipe) {
	if (tipe.$ === 'TLambda') {
		var a = tipe.a;
		var rest = tipe.b;
		var _v1 = $author$project$Compiler$Reporting$Render$Type$collectArgs(rest);
		var b = _v1.a;
		var cs = _v1.b;
		return _Utils_Tuple2(
			a,
			A2($elm$core$List$cons, b, cs));
	} else {
		return _Utils_Tuple2(tipe, _List_Nil);
	}
};
var $author$project$Compiler$Reporting$Render$Type$canFieldToDoc = F2(
	function (localizer, _v2) {
		var name = _v2.a;
		var tipe = _v2.b;
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$fromName(name),
			A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, tipe));
	});
var $author$project$Compiler$Reporting$Render$Type$canToDoc = F3(
	function (localizer, context, tipe) {
		switch (tipe.$) {
			case 'TLambda':
				var arg1 = tipe.a;
				var result = tipe.b;
				var _v1 = $author$project$Compiler$Reporting$Render$Type$collectArgs(result);
				var arg2 = _v1.a;
				var rest = _v1.b;
				return A4(
					$author$project$Compiler$Reporting$Render$Type$lambda,
					context,
					A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func, arg1),
					A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func, arg2),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func),
						rest));
			case 'TVar':
				var name = tipe.a;
				return $author$project$Compiler$Reporting$Doc$fromName(name);
			case 'TType':
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					context,
					A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home, name),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App),
						args));
			case 'TRecord':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$Reporting$Render$Type$record,
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$Reporting$Render$Type$canFieldToDoc(localizer),
						$author$project$Compiler$AST$Canonical$fieldsToList(fields)),
					A2($elm$core$Maybe$map, $author$project$Compiler$Reporting$Doc$fromName, ext));
			case 'TUnit':
				return $author$project$Compiler$Reporting$Doc$d('()');
			case 'TTuple':
				var a = tipe.a;
				var b = tipe.b;
				var maybeC = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$tuple,
					A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, a),
					A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, b),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None),
						$author$project$Extra$Type$Maybe$maybeToList(maybeC)));
			default:
				var home = tipe.a;
				var name = tipe.b;
				var args = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					context,
					A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home, name),
					A2(
						$author$project$Extra$Type$List$map,
						A2(
							$elm$core$Basics$composeL,
							A2($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App),
							$elm$core$Tuple$second),
						args));
		}
	});
var $author$project$Compiler$Generate$JavaScript$print = F5(
	function (ansi, localizer, home, name, tipe) {
		var value = $author$project$Compiler$Generate$JavaScript$Name$toBuilder(
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, name));
		var toString = $author$project$Compiler$Generate$JavaScript$Name$toBuilder(
			A2($author$project$Compiler$Generate$JavaScript$Name$fromKernel, $author$project$Compiler$Data$Name$debug, 'toAnsiString'));
		var tipeDoc = A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, tipe);
		var bool = ansi ? 'true' : 'false';
		return 'var _value = ' + (toString + ('(' + (bool + (', ' + (value + (');\n' + ('var _type = ' + ($author$project$Compiler$Json$Encode$encodeUgly(
			$author$project$Compiler$Json$Encode$chars(
				$author$project$Compiler$Reporting$Doc$toString(tipeDoc))) + (';\n' + ('function _print(t) { return _value + (' + (bool + (' ? \'\u001B[90m\' + t + \'\u001B[0m\' : t); }\n' + ('var _result = (_value.length + 3 + _type.length >= 80 || _type.indexOf(\'\\n\') >= 0)\n' + ('  ? _print(\'\\n    : \' + _type.split(\'\\n\').join(\'\\n      \'))\n' + ('  : _print(\' : \' + _type);\n' + ('var force_quit_ = ' + ($author$project$Compiler$Generate$JavaScript$Name$toBuilder(
			A2($author$project$Compiler$Generate$JavaScript$Name$fromGlobal, home, 'force_quit_')) + '();\n')))))))))))))))));
	});
var $author$project$Compiler$Generate$JavaScript$generateForRepl = F7(
	function (ansi, htmlEnabled, localizer, globalGraph, home, name, _v0) {
		var graph = globalGraph.a;
		var tipe = _v0.b;
		return (htmlEnabled && $author$project$Compiler$Generate$JavaScript$isStaticHtml(tipe)) ? _Utils_Tuple2(
			$author$project$Compiler$Generate$JavaScript$HtmlKind,
			A3($author$project$Compiler$Generate$JavaScript$generateHtmlForRepl, globalGraph, home, name)) : _Utils_Tuple2(
			$author$project$Compiler$Generate$JavaScript$ValueKind,
			function () {
				var mode = $author$project$Compiler$Generate$Mode$Dev($author$project$Compiler$Generate$Mode$DevNormal);
				var pipeAddGlobal = F3(
					function (moduleName, defName, state) {
						return A4(
							$author$project$Compiler$Generate$JavaScript$addGlobal,
							mode,
							graph,
							state,
							$author$project$Compiler$AST$Optimized$toGlobalComparable(
								A2($author$project$Compiler$AST$Optimized$Global, moduleName, defName)));
					});
				var evalState = A3(
					pipeAddGlobal,
					home,
					name,
					A3(
						pipeAddGlobal,
						home,
						'force_quit_',
						A3(pipeAddGlobal, $author$project$Compiler$Elm$ModuleName$debug, 'toString', $author$project$Compiler$Generate$JavaScript$emptyState)));
				return '' + ($author$project$Compiler$Generate$JavaScript$Functions$functions + ($author$project$Compiler$Generate$JavaScript$stateToBuilder(evalState) + A5($author$project$Compiler$Generate$JavaScript$print, ansi, localizer, home, name, tipe)));
			}());
	});
var $author$project$Builder$Generate$LoadingObjects = F2(
	function (a, b) {
		return {$: 'LoadingObjects', a: a, b: b};
	});
var $author$project$Builder$Generate$loadObject = F2(
	function (root, modul) {
		if (modul.$ === 'Fresh') {
			var name = modul.a;
			var graph = modul.c;
			return A2(
				$author$project$Extra$System$IO$bind,
				A2(
					$author$project$Extra$System$MVar$new,
					$author$project$Builder$Generate$lensMVLocalGraph,
					$elm$core$Maybe$Just(graph)),
				function (mvar) {
					return $author$project$Extra$System$IO$return(
						_Utils_Tuple2(name, mvar));
				});
		} else {
			var name = modul.a;
			return A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Extra$System$MVar$newEmpty($author$project$Builder$Generate$lensMVLocalGraph),
				function (mvar) {
					return A2(
						$author$project$Extra$System$IO$bind,
						A3(
							$author$project$Extra$System$MVar$wait,
							$author$project$Builder$Generate$lensMVLocalGraph,
							mvar,
							function (_v1) {
								return A2(
									$author$project$Builder$File$readBinary,
									$author$project$Compiler$AST$Optimized$bLocalGraph,
									A2($author$project$Builder$Stuff$elmo, root, name));
							}),
						function (_v2) {
							return $author$project$Extra$System$IO$return(
								_Utils_Tuple2(name, mvar));
						});
				});
		}
	});
var $author$project$Builder$Elm$Details$loadObjects = F2(
	function (root, _v0) {
		var extras = _v0.f;
		if (extras.$ === 'ArtifactsFresh') {
			var o = extras.b;
			return A2(
				$author$project$Extra$System$MVar$new,
				$author$project$Builder$Elm$Details$lensMVGlobalGraph,
				$elm$core$Maybe$Just(o));
		} else {
			return A2(
				$author$project$Builder$Elm$Details$fork,
				$author$project$Builder$Elm$Details$lensMVGlobalGraph,
				function (_v2) {
					return A2(
						$author$project$Builder$File$readBinary,
						$author$project$Compiler$AST$Optimized$bGlobalGraph,
						$author$project$Builder$Stuff$objects(root));
				});
		}
	});
var $author$project$Builder$Generate$loadObjects = F3(
	function (root, details, modules) {
		return $author$project$Builder$Reporting$Task$io(
			A2(
				$author$project$Extra$System$IO$bind,
				A2($author$project$Builder$Elm$Details$loadObjects, root, details),
				function (mvar) {
					return A2(
						$author$project$Extra$System$IO$bind,
						A4(
							$author$project$Extra$Type$List$traverse,
							$author$project$Extra$System$IO$pure,
							$author$project$Extra$System$IO$liftA2,
							$author$project$Builder$Generate$loadObject(root),
							modules),
						function (mvars) {
							return $author$project$Extra$System$IO$return(
								A2(
									$author$project$Builder$Generate$LoadingObjects,
									mvar,
									$author$project$Extra$Type$Map$fromList(mvars)));
						});
				}));
	});
var $author$project$Builder$Generate$objectsToGlobalGraph = function (_v0) {
	var globals = _v0.a;
	var locals = _v0.b;
	return A3($author$project$Extra$Type$Map$foldr, $author$project$Compiler$AST$Optimized$addLocalGraph, globals, locals);
};
var $author$project$Builder$Generate$repl = F6(
	function (root, details, ansi, htmlEnabled, _v0, name) {
		var home = _v0.a;
		var modules = _v0.b;
		var localizer = _v0.c;
		var annotations = _v0.d;
		return A2(
			$author$project$Builder$Reporting$Task$bind,
			A2(
				$author$project$Builder$Reporting$Task$andThen,
				$author$project$Builder$Generate$finalizeObjects,
				A3($author$project$Builder$Generate$loadObjects, root, details, modules)),
			function (objects) {
				var graph = $author$project$Builder$Generate$objectsToGlobalGraph(objects);
				return $author$project$Builder$Reporting$Task$return(
					A7(
						$author$project$Compiler$Generate$JavaScript$generateForRepl,
						ansi,
						htmlEnabled,
						localizer,
						graph,
						home,
						name,
						A2($author$project$Extra$Type$Map$ex, annotations, name)));
			});
	});
var $author$project$Terminal$Repl$outputToBuilder = function (output) {
	return $author$project$Compiler$Data$Name$toBuilder($author$project$Compiler$Data$Name$replValueToPrint) + (' =' + function () {
		switch (output.$) {
			case 'OutputNothing':
				return ' ()\n';
			case 'OutputDecl':
				return ' ()\n';
			default:
				var expr = output.a;
				return A3(
					$author$project$Extra$Type$List$foldr,
					F2(
						function (line, rest) {
							return '\n  ' + (line + rest);
						}),
					'\n',
					A2($elm$core$String$split, '\n', expr));
		}
	}());
};
var $author$project$Terminal$Repl$toByteString = F3(
	function (modulePrefix, _v0, output) {
		var imports = _v0.a;
		var types = _v0.b;
		var decls = _v0.c;
		return $elm$core$String$concat(
			_List_fromArray(
				[
					modulePrefix,
					'\n',
					A3($author$project$Extra$Type$Map$foldr, $elm$core$Basics$append, '', imports),
					A3($author$project$Extra$Type$Map$foldr, $elm$core$Basics$append, '', types),
					A3($author$project$Extra$Type$Map$foldr, $elm$core$Basics$append, '', decls),
					$author$project$Terminal$Repl$outputToBuilder(output)
				]));
	});
var $author$project$Terminal$Repl$toPrintName = function (output) {
	switch (output.$) {
		case 'OutputNothing':
			return $elm$core$Maybe$Nothing;
		case 'OutputDecl':
			var name = output.a;
			return $elm$core$Maybe$Just(name);
		default:
			return $elm$core$Maybe$Just($author$project$Compiler$Data$Name$replValueToPrint);
	}
};
var $author$project$Terminal$Repl$attemptEval = F4(
	function (_v0, oldState, newState, output) {
		var root = _v0.a;
		var interpreter = _v0.b;
		var ansi = _v0.c;
		var mode = _v0.d;
		var modulePrefix = _v0.e;
		var htmlEnabled = _v0.f;
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Builder$Reporting$Task$run(
				A2(
					$author$project$Builder$Reporting$Task$bind,
					A2(
						$author$project$Builder$Reporting$Task$eio,
						$author$project$Builder$Reporting$Exit$ReplBadDetails,
						$author$project$Builder$Elm$Details$load(root)),
					function (details) {
						return A2(
							$author$project$Builder$Reporting$Task$bind,
							A2(
								$author$project$Builder$Reporting$Task$eio,
								$elm$core$Basics$identity,
								A3(
									$author$project$Builder$Build$fromRepl,
									root,
									details,
									A3($author$project$Terminal$Repl$toByteString, modulePrefix, newState, output))),
							function (artifacts) {
								return A4(
									$author$project$Extra$Type$Maybe$traverse,
									$author$project$Builder$Reporting$Task$pure,
									$author$project$Builder$Reporting$Task$fmap,
									A2(
										$elm$core$Basics$composeL,
										$author$project$Builder$Reporting$Task$mapError($author$project$Builder$Reporting$Exit$ReplBadGenerate),
										A5($author$project$Builder$Generate$repl, root, details, ansi, htmlEnabled, artifacts)),
									$author$project$Terminal$Repl$toPrintName(output));
							});
					})),
			function (result) {
				if (result.$ === 'Left') {
					var exit = result.a;
					return A2(
						$author$project$Extra$System$IO$bind,
						A2(
							$author$project$Terminal$Repl$interpret,
							interpreter,
							$author$project$Terminal$Repl$ShowError(exit)),
						function (_v2) {
							return $author$project$Extra$System$IO$return(oldState);
						});
				} else {
					if (result.a.$ === 'Nothing') {
						var _v3 = result.a;
						return $author$project$Extra$System$IO$return(newState);
					} else {
						var _v4 = result.a.a;
						var kind = _v4.a;
						var javascript = _v4.b;
						return A2(
							$author$project$Extra$System$IO$bind,
							A2(
								$author$project$Terminal$Repl$interpret,
								interpreter,
								A3(
									$author$project$Terminal$Repl$inputForKind,
									kind,
									$author$project$Terminal$Repl$generatedModule(mode),
									javascript)),
							function (interpreterResult) {
								if (interpreterResult.$ === 'InterpreterSuccess') {
									return $author$project$Extra$System$IO$return(newState);
								} else {
									return $author$project$Extra$System$IO$return(oldState);
								}
							});
					}
				}
			});
	});
var $author$project$Terminal$Repl$State = F3(
	function (a, b, c) {
		return {$: 'State', a: a, b: b, c: c};
	});
var $author$project$Terminal$Repl$addForceQuit = function (decls) {
	return A4(
		$author$project$Extra$Type$Map$insertWith,
		F2(
			function (_v0, old) {
				return old;
			}),
		'force_quit_',
		'force_quit_ () = False\n',
		decls);
};
var $author$project$Terminal$Repl$initialState = function (_v0) {
	var mode = _v0.d;
	switch (mode.$) {
		case 'Breakpoint':
			var decls = mode.b;
			return A3(
				$author$project$Terminal$Repl$State,
				$author$project$Extra$Type$Map$empty,
				$author$project$Extra$Type$Map$empty,
				$author$project$Terminal$Repl$addForceQuit(decls));
		case 'Configured':
			var imports = mode.a;
			var types = mode.b;
			var decls = mode.c;
			return A3(
				$author$project$Terminal$Repl$State,
				imports,
				types,
				$author$project$Terminal$Repl$addForceQuit(decls));
		default:
			return A3(
				$author$project$Terminal$Repl$State,
				$author$project$Extra$Type$Map$empty,
				$author$project$Extra$Type$Map$empty,
				$author$project$Terminal$Repl$addForceQuit($author$project$Extra$Type$Map$empty));
	}
};
var $author$project$Terminal$Command$Permanent = function (a) {
	return {$: 'Permanent', a: a};
};
var $author$project$Terminal$Command$putOutput = function (output) {
	return A2(
		$author$project$Extra$System$IO$modifyLens,
		$author$project$Terminal$Command$lensStdOut,
		function (stdOut) {
			if (stdOut.b && (stdOut.a.$ === 'Temporary')) {
				var rest = stdOut.b;
				return A2($elm$core$List$cons, output, rest);
			} else {
				return A2($elm$core$List$cons, output, stdOut);
			}
		});
};
var $author$project$Terminal$Command$putLine = function (line) {
	return $author$project$Terminal$Command$putOutput(
		$author$project$Terminal$Command$Permanent(line));
};
var $author$project$Terminal$Command$Temporary = function (a) {
	return {$: 'Temporary', a: a};
};
var $author$project$Terminal$Command$putTemporary = function (line) {
	return $author$project$Terminal$Command$putOutput(
		$author$project$Terminal$Command$Temporary(line));
};
var $author$project$Terminal$Repl$setDecls = F2(
	function (decls, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		return A3($author$project$Terminal$Repl$State, a, b, decls);
	});
var $author$project$Terminal$Repl$setImports = F2(
	function (imports, _v0) {
		var b = _v0.b;
		var c = _v0.c;
		return A3($author$project$Terminal$Repl$State, imports, b, c);
	});
var $author$project$Terminal$Repl$setTypes = F2(
	function (types, _v0) {
		var a = _v0.a;
		var c = _v0.c;
		return A3($author$project$Terminal$Repl$State, a, types, c);
	});
var $author$project$Terminal$Repl$genericHelpMessage = function (showResume) {
	return 'Valid commands include:\n' + ('\n' + ('  :exit    Exit the REPL\n' + ('  :help    Show this information\n' + ('  :reset   Clear all previous imports and definitions\n' + ((showResume ? '  :resume  Resume from current breakpoint\n' : '') + ('\n' + ('More info at ' + ($author$project$Compiler$Reporting$Doc$makeLink('repl') + '\n'))))))));
};
var $author$project$Terminal$Repl$toHelpMessage = F2(
	function (showResume, maybeBadCommand) {
		if (maybeBadCommand.$ === 'Nothing') {
			return $author$project$Terminal$Repl$genericHelpMessage(showResume);
		} else {
			var command = maybeBadCommand.a;
			return 'I do not recognize the :' + (command + (' command. ' + $author$project$Terminal$Repl$genericHelpMessage(showResume)));
		}
	});
var $author$project$Terminal$Repl$eval = F3(
	function (env, state, input) {
		var mode = env.d;
		var imports = state.a;
		var types = state.b;
		var decls = state.c;
		switch (input.$) {
			case 'Skip':
				return $author$project$Extra$System$IO$return(
					$author$project$Terminal$Repl$Loop(state));
			case 'Exit':
				return $author$project$Extra$System$IO$return($author$project$Terminal$Repl$End);
			case 'Reset':
				return A2(
					$author$project$Extra$System$IO$bindSequence,
					_List_fromArray(
						[
							$author$project$Terminal$Command$putLine('<reset>')
						]),
					$author$project$Extra$System$IO$return(
						$author$project$Terminal$Repl$Loop(
							$author$project$Terminal$Repl$initialState(env))));
			case 'Help':
				var maybeUnknownCommand = input.a;
				return A2(
					$author$project$Extra$System$IO$bind,
					$author$project$Terminal$Command$putTemporary(
						A2(
							$author$project$Terminal$Repl$toHelpMessage,
							$author$project$Terminal$Repl$isBreakpoint(mode),
							maybeUnknownCommand)),
					function (_v1) {
						return $author$project$Extra$System$IO$return(
							$author$project$Terminal$Repl$Loop(state));
					});
			case 'Import':
				var name = input.a;
				var src = input.b;
				var newState = A2(
					$author$project$Terminal$Repl$setImports,
					A3($author$project$Extra$Type$Map$insert, name, src, imports),
					state);
				return A2(
					$author$project$Extra$System$IO$fmap,
					$author$project$Terminal$Repl$Loop,
					A4($author$project$Terminal$Repl$attemptEval, env, state, newState, $author$project$Terminal$Repl$OutputNothing));
			case 'Type':
				var name = input.a;
				var src = input.b;
				var newState = A2(
					$author$project$Terminal$Repl$setTypes,
					A3($author$project$Extra$Type$Map$insert, name, src, types),
					state);
				return A2(
					$author$project$Extra$System$IO$fmap,
					$author$project$Terminal$Repl$Loop,
					A4($author$project$Terminal$Repl$attemptEval, env, state, newState, $author$project$Terminal$Repl$OutputNothing));
			case 'Port':
				return A2(
					$author$project$Extra$System$IO$bind,
					$author$project$Terminal$Command$putLine('I cannot handle port declarations.'),
					function (_v2) {
						return $author$project$Extra$System$IO$return(
							$author$project$Terminal$Repl$Loop(state));
					});
			case 'Decl':
				var name = input.a;
				var src = input.b;
				var newState = A2(
					$author$project$Terminal$Repl$setDecls,
					A3($author$project$Extra$Type$Map$insert, name, src, decls),
					state);
				return A2(
					$author$project$Extra$System$IO$fmap,
					$author$project$Terminal$Repl$Loop,
					A4(
						$author$project$Terminal$Repl$attemptEval,
						env,
						state,
						newState,
						$author$project$Terminal$Repl$OutputDecl(name)));
			default:
				var src = input.a;
				return A2(
					$author$project$Extra$System$IO$fmap,
					$author$project$Terminal$Repl$Loop,
					A4(
						$author$project$Terminal$Repl$attemptEval,
						env,
						state,
						state,
						$author$project$Terminal$Repl$OutputExpr(src)));
		}
	});
var $author$project$Repl$Worker$lensReplState = {
	getter: function (_v0) {
		var _v1 = _v0.h;
		var x = _v1.c;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var _v3 = _v2.h;
			var ai = _v3.a;
			var bi = _v3.b;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				d,
				e,
				f,
				g,
				A3($author$project$Repl$Worker$LocalState, ai, bi, x));
		})
};
var $author$project$Terminal$Repl$renderPrefill = function (lineStart) {
	if (lineStart.$ === 'Indent') {
		return '  ';
	} else {
		var name = lineStart.a;
		return name + ' ';
	}
};
var $author$project$Repl$Worker$handleClientRequestHelp = F3(
	function (env, state, lines) {
		var mode = env.d;
		var _v0 = A2($author$project$Terminal$Repl$categorize, mode, lines);
		if (_v0.$ === 'Done') {
			var input = _v0.a;
			return A2(
				$author$project$Extra$System$IO$bind,
				A3($author$project$Terminal$Repl$eval, env, state, input),
				function (outcome) {
					if (outcome.$ === 'Loop') {
						var newState = outcome.a;
						return A2(
							$author$project$Extra$System$IO$bindSequence,
							_List_fromArray(
								[
									A2(
									$author$project$Extra$System$IO$putLens,
									$author$project$Repl$Worker$lensReplState,
									A3($author$project$Repl$Worker$ReplRunning, env, newState, $elm$core$Maybe$Nothing))
								]),
							$author$project$Extra$System$IO$return(
								$author$project$Repl$Api$WorkerStateRunning($elm$core$Maybe$Nothing)));
					} else {
						return A2(
							$author$project$Extra$System$IO$bindSequence,
							_List_fromArray(
								[
									A2($author$project$Extra$System$IO$putLens, $author$project$Repl$Worker$lensReplState, $author$project$Repl$Worker$ReplStopped)
								]),
							$author$project$Extra$System$IO$return(
								$author$project$Repl$Api$WorkerStateStopped($elm$core$Maybe$Nothing)));
					}
				});
		} else {
			var prefill = _v0.a;
			return A2(
				$author$project$Extra$System$IO$bindSequence,
				_List_fromArray(
					[
						A2(
						$author$project$Extra$System$IO$putLens,
						$author$project$Repl$Worker$lensReplState,
						A3(
							$author$project$Repl$Worker$ReplRunning,
							env,
							state,
							$elm$core$Maybe$Just(lines)))
					]),
				$author$project$Extra$System$IO$return(
					$author$project$Repl$Api$WorkerStateRunning(
						$elm$core$Maybe$Just(
							$author$project$Terminal$Repl$renderPrefill(prefill)))));
		}
	});
var $author$project$Builder$Reporting$Exit$Help$CompilerReport = F3(
	function (a, b, c) {
		return {$: 'CompilerReport', a: a, b: b, c: c};
	});
var $author$project$Builder$Reporting$Exit$Help$compilerReport = $author$project$Builder$Reporting$Exit$Help$CompilerReport;
var $author$project$Builder$Reporting$Exit$Help$Report = F3(
	function (a, b, c) {
		return {$: 'Report', a: a, b: b, c: c};
	});
var $author$project$Builder$Reporting$Exit$Help$report = F4(
	function (title, path, startString, others) {
		return A3(
			$author$project$Builder$Reporting$Exit$Help$Report,
			title,
			path,
			$author$project$Compiler$Reporting$Doc$stack(
				A2(
					$elm$core$List$cons,
					$author$project$Compiler$Reporting$Doc$reflow(startString),
					others)));
	});
var $author$project$Builder$Reporting$Exit$corruptCacheReport = A4(
	$author$project$Builder$Reporting$Exit$Help$report,
	'CORRUPT CACHE',
	$elm$core$Maybe$Nothing,
	'It looks like some of the information cached in elm-stuff/ has been corrupted.',
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$reflow('Try deleting your elm-stuff/ directory to get unstuck.'),
			$author$project$Compiler$Reporting$Doc$toSimpleNote('This almost certainly means that a 3rd party tool (or editor plugin) is' + (' causing problems your the elm-stuff/ directory. Try disabling 3rd party tools' + ' one by one until you figure out which it is!'))
		]));
var $author$project$Compiler$Reporting$Doc$fromVersion = function (vsn) {
	return $author$project$Extra$Data$Pretty$text(
		$author$project$Compiler$Elm$Version$toChars(vsn));
};
var $author$project$Extra$Data$Pretty$red = $the_sett$elm_pretty_printer$Pretty$setTag(
	function ($) {
		return $.red;
	});
var $author$project$Compiler$Reporting$Doc$red = $author$project$Extra$Data$Pretty$red;
var $author$project$Builder$Reporting$Exit$toBadDepRank = function (badDep) {
	if (badDep.$ === 'BD_BadDownload') {
		return 0;
	} else {
		return 1;
	}
};
var $author$project$Compiler$Elm$Constraint$opToChars = function (op) {
	if (op.$ === 'Less') {
		return ' < ';
	} else {
		return ' <= ';
	}
};
var $author$project$Compiler$Elm$Constraint$toChars = function (constraint) {
	var lower = constraint.a;
	var lowerOp = constraint.b;
	var upperOp = constraint.c;
	var upper = constraint.d;
	return $author$project$Compiler$Elm$Version$toChars(lower) + ($author$project$Compiler$Elm$Constraint$opToChars(lowerOp) + ('v' + ($author$project$Compiler$Elm$Constraint$opToChars(upperOp) + $author$project$Compiler$Elm$Version$toChars(upper))));
};
var $author$project$Compiler$Reporting$Error$Json$ExplicitReason = function (a) {
	return {$: 'ExplicitReason', a: a};
};
var $author$project$Compiler$Reporting$Error$Json$FailureToReport = function (a) {
	return {$: 'FailureToReport', a: a};
};
var $author$project$Compiler$Reporting$Doc$fromPath = function (path) {
	return $author$project$Extra$Data$Pretty$text(
		$author$project$Extra$System$File$toString(path));
};
var $author$project$Compiler$Elm$Version$bumpMajor = function (_v0) {
	var major = _v0.a;
	return A3($author$project$Compiler$Elm$Version$Version, major + 1, 0, 0);
};
var $author$project$Builder$Reporting$Exit$Help$jsonReport = $author$project$Builder$Reporting$Exit$Help$Report;
var $author$project$Builder$Reporting$Exit$toOutlineProblemReport = F5(
	function (path, source, _v0, region, problem) {
		var toSnippet = F3(
			function (title, highlight, pair) {
				return A3(
					$author$project$Builder$Reporting$Exit$Help$jsonReport,
					title,
					$elm$core$Maybe$Just(path),
					A4($author$project$Compiler$Reporting$Render$Code$toSnippet, source, region, highlight, pair));
			});
		var toHighlight = F2(
			function (row, col) {
				return $elm$core$Maybe$Just(
					A2(
						$author$project$Compiler$Reporting$Annotation$Region,
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col),
						A2($author$project$Compiler$Reporting$Annotation$Position, row, col)));
			});
		switch (problem.$) {
			case 'OP_BadType':
				return A3(
					toSnippet,
					'UNEXPECTED TYPE',
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I cannot handle a \"type\" like this:'),
						$author$project$Compiler$Reporting$Doc$fillSep(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('Try'),
									$author$project$Compiler$Reporting$Doc$d('changing'),
									$author$project$Compiler$Reporting$Doc$d('the'),
									$author$project$Compiler$Reporting$Doc$d('\"type\"'),
									$author$project$Compiler$Reporting$Doc$d('to'),
									$author$project$Compiler$Reporting$Doc$greenS('\"application\"'),
									$author$project$Compiler$Reporting$Doc$d('or'),
									$author$project$Compiler$Reporting$Doc$greenS('\"package\"'),
									$author$project$Compiler$Reporting$Doc$d('instead.')
								]))));
			case 'OP_BadPkgName':
				var row = problem.a;
				var col = problem.b;
				return A3(
					toSnippet,
					'INVALID PACKAGE NAME',
					A2(toHighlight, row, col),
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I ran into trouble with the package name:'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Package'),
											$author$project$Compiler$Reporting$Doc$d('names'),
											$author$project$Compiler$Reporting$Doc$d('are'),
											$author$project$Compiler$Reporting$Doc$d('always'),
											$author$project$Compiler$Reporting$Doc$d('written'),
											$author$project$Compiler$Reporting$Doc$d('as'),
											$author$project$Compiler$Reporting$Doc$greenS('\"author/project\"'),
											$author$project$Compiler$Reporting$Doc$d('so'),
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('am'),
											$author$project$Compiler$Reporting$Doc$d('expecting'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('see'),
											$author$project$Compiler$Reporting$Doc$d('something'),
											$author$project$Compiler$Reporting$Doc$d('like:')
										])),
									$author$project$Compiler$Reporting$Doc$dullyellow(
									A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$d('\"mdgriffith/elm-ui\"'),
													$author$project$Compiler$Reporting$Doc$d('\"w0rm/elm-physics\"'),
													$author$project$Compiler$Reporting$Doc$d('\"Microsoft/elm-json-tree-view\"'),
													$author$project$Compiler$Reporting$Doc$d('\"FordLabs/elm-star-rating\"'),
													$author$project$Compiler$Reporting$Doc$d('\"1602/json-schema\"')
												])))),
									$author$project$Compiler$Reporting$Doc$reflow('The author name should match your GitHub name exactly, and the project name' + ' needs to follow these rules:'),
									A2(
									$author$project$Compiler$Reporting$Doc$indent,
									4,
									$author$project$Compiler$Reporting$Doc$vcat(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('+--------------------------------------+-----------+-----------+'),
												$author$project$Compiler$Reporting$Doc$d('| RULE                                 | BAD       | GOOD      |'),
												$author$project$Compiler$Reporting$Doc$d('+--------------------------------------+-----------+-----------+'),
												$author$project$Compiler$Reporting$Doc$d('| only lower case, digits, and hyphens | elm-HTTP  | elm-http  |'),
												$author$project$Compiler$Reporting$Doc$d('| no leading digits                    | 3D        | elm-3d    |'),
												$author$project$Compiler$Reporting$Doc$d('| no non-ASCII characters              | elm-bjrn | elm-bear  |'),
												$author$project$Compiler$Reporting$Doc$d('| no underscores                       | elm_ui    | elm-ui    |'),
												$author$project$Compiler$Reporting$Doc$d('| no double hyphens                    | elm--hash | elm-hash  |'),
												$author$project$Compiler$Reporting$Doc$d('| no starting or ending hyphen         | -elm-tar- | elm-tar   |'),
												$author$project$Compiler$Reporting$Doc$d('+--------------------------------------+-----------+-----------+')
											]))),
									$author$project$Compiler$Reporting$Doc$toSimpleNote('These rules only apply to the project name, so you should never need' + ' to change your GitHub name!')
								]))));
			case 'OP_BadVersion':
				var row = problem.a;
				var col = problem.b;
				return A3(
					toSnippet,
					'PROBLEM WITH VERSION',
					A2(toHighlight, row, col),
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I was expecting a version number here:'),
						$author$project$Compiler$Reporting$Doc$fillSep(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('I'),
									$author$project$Compiler$Reporting$Doc$d('need'),
									$author$project$Compiler$Reporting$Doc$d('something'),
									$author$project$Compiler$Reporting$Doc$d('like'),
									$author$project$Compiler$Reporting$Doc$greenS('\"1.0.0\"'),
									$author$project$Compiler$Reporting$Doc$d('or'),
									$author$project$Compiler$Reporting$Doc$greenS('\"2.0.4\"'),
									$author$project$Compiler$Reporting$Doc$d('that'),
									$author$project$Compiler$Reporting$Doc$d('explicitly'),
									$author$project$Compiler$Reporting$Doc$d('states'),
									$author$project$Compiler$Reporting$Doc$d('all'),
									$author$project$Compiler$Reporting$Doc$d('three'),
									$author$project$Compiler$Reporting$Doc$d('numbers!')
								]))));
			case 'OP_BadConstraint':
				var constraintError = problem.a;
				if (constraintError.$ === 'BadFormat') {
					var row = constraintError.a;
					var col = constraintError.b;
					return A3(
						toSnippet,
						'PROBLEM WITH CONSTRAINT',
						A2(toHighlight, row, col),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I do not understand this version constraint:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('need'),
												$author$project$Compiler$Reporting$Doc$d('something'),
												$author$project$Compiler$Reporting$Doc$d('like'),
												$author$project$Compiler$Reporting$Doc$greenS('\"1.0.0 <= v < 2.0.0\"'),
												$author$project$Compiler$Reporting$Doc$d('that'),
												$author$project$Compiler$Reporting$Doc$d('explicitly'),
												$author$project$Compiler$Reporting$Doc$d('lists'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('lower'),
												$author$project$Compiler$Reporting$Doc$d('and'),
												$author$project$Compiler$Reporting$Doc$d('upper'),
												$author$project$Compiler$Reporting$Doc$d('bounds.')
											])),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('The spaces in there are required! Taking them out will confuse me. Adding' + (' extra spaces confuses me too. I recommend starting with a valid example' + ' and just changing the version numbers.'))
									]))));
				} else {
					var before = constraintError.a;
					var after = constraintError.b;
					return _Utils_eq(before, after) ? A3(
						toSnippet,
						'PROBLEM WITH CONSTRAINT',
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I ran into an invalid version constraint:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('Elm'),
										$author$project$Compiler$Reporting$Doc$d('checks'),
										$author$project$Compiler$Reporting$Doc$d('that'),
										$author$project$Compiler$Reporting$Doc$d('all'),
										$author$project$Compiler$Reporting$Doc$d('package'),
										$author$project$Compiler$Reporting$Doc$d('APIs'),
										$author$project$Compiler$Reporting$Doc$d('follow'),
										$author$project$Compiler$Reporting$Doc$d('semantic'),
										$author$project$Compiler$Reporting$Doc$d('versioning,d'),
										$author$project$Compiler$Reporting$Doc$d('so'),
										$author$project$Compiler$Reporting$Doc$d('it'),
										$author$project$Compiler$Reporting$Doc$d('is'),
										$author$project$Compiler$Reporting$Doc$d('best'),
										$author$project$Compiler$Reporting$Doc$d('to'),
										$author$project$Compiler$Reporting$Doc$d('use'),
										$author$project$Compiler$Reporting$Doc$d('wide'),
										$author$project$Compiler$Reporting$Doc$d('constraints.'),
										$author$project$Compiler$Reporting$Doc$d('I'),
										$author$project$Compiler$Reporting$Doc$d('recommend'),
										$author$project$Compiler$Reporting$Doc$green(
										$author$project$Compiler$Reporting$Doc$da(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$d('\"'),
													$author$project$Compiler$Reporting$Doc$fromVersion(before),
													$author$project$Compiler$Reporting$Doc$d(' <= v < '),
													$author$project$Compiler$Reporting$Doc$fromVersion(
													$author$project$Compiler$Elm$Version$bumpMajor(after)),
													$author$project$Compiler$Reporting$Doc$d('\"')
												]))),
										$author$project$Compiler$Reporting$Doc$d('since'),
										$author$project$Compiler$Reporting$Doc$d('it'),
										$author$project$Compiler$Reporting$Doc$d('is'),
										$author$project$Compiler$Reporting$Doc$d('guaranteed'),
										$author$project$Compiler$Reporting$Doc$d('that'),
										$author$project$Compiler$Reporting$Doc$d('breaking'),
										$author$project$Compiler$Reporting$Doc$d('API'),
										$author$project$Compiler$Reporting$Doc$d('changes'),
										$author$project$Compiler$Reporting$Doc$d('cannot'),
										$author$project$Compiler$Reporting$Doc$d('happen'),
										$author$project$Compiler$Reporting$Doc$d('in'),
										$author$project$Compiler$Reporting$Doc$d('any'),
										$author$project$Compiler$Reporting$Doc$d('of'),
										$author$project$Compiler$Reporting$Doc$d('the'),
										$author$project$Compiler$Reporting$Doc$d('versions'),
										$author$project$Compiler$Reporting$Doc$d('in'),
										$author$project$Compiler$Reporting$Doc$d('that'),
										$author$project$Compiler$Reporting$Doc$d('range.')
									])))) : A3(
						toSnippet,
						'PROBLEM WITH CONSTRAINT',
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I ran into an invalid version constraint:'),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('Maybe'),
										$author$project$Compiler$Reporting$Doc$d('you'),
										$author$project$Compiler$Reporting$Doc$d('want'),
										$author$project$Compiler$Reporting$Doc$d('something'),
										$author$project$Compiler$Reporting$Doc$d('like'),
										$author$project$Compiler$Reporting$Doc$green(
										$author$project$Compiler$Reporting$Doc$da(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$d('\"'),
													$author$project$Compiler$Reporting$Doc$fromVersion(before),
													$author$project$Compiler$Reporting$Doc$d(' <= v < '),
													$author$project$Compiler$Reporting$Doc$fromVersion(
													$author$project$Compiler$Elm$Version$bumpMajor(before)),
													$author$project$Compiler$Reporting$Doc$d('\"')
												]))),
										$author$project$Compiler$Reporting$Doc$d('instead?'),
										$author$project$Compiler$Reporting$Doc$d('Elm'),
										$author$project$Compiler$Reporting$Doc$d('checks'),
										$author$project$Compiler$Reporting$Doc$d('that'),
										$author$project$Compiler$Reporting$Doc$d('all'),
										$author$project$Compiler$Reporting$Doc$d('package'),
										$author$project$Compiler$Reporting$Doc$d('APIs'),
										$author$project$Compiler$Reporting$Doc$d('follow'),
										$author$project$Compiler$Reporting$Doc$d('semantic'),
										$author$project$Compiler$Reporting$Doc$d('versioning,d'),
										$author$project$Compiler$Reporting$Doc$d('so'),
										$author$project$Compiler$Reporting$Doc$d('it'),
										$author$project$Compiler$Reporting$Doc$d('is'),
										$author$project$Compiler$Reporting$Doc$d('guaranteed'),
										$author$project$Compiler$Reporting$Doc$d('that'),
										$author$project$Compiler$Reporting$Doc$d('breaking'),
										$author$project$Compiler$Reporting$Doc$d('API'),
										$author$project$Compiler$Reporting$Doc$d('changes'),
										$author$project$Compiler$Reporting$Doc$d('cannot'),
										$author$project$Compiler$Reporting$Doc$d('happen'),
										$author$project$Compiler$Reporting$Doc$d('in'),
										$author$project$Compiler$Reporting$Doc$d('any'),
										$author$project$Compiler$Reporting$Doc$d('of'),
										$author$project$Compiler$Reporting$Doc$d('the'),
										$author$project$Compiler$Reporting$Doc$d('versions'),
										$author$project$Compiler$Reporting$Doc$d('in'),
										$author$project$Compiler$Reporting$Doc$d('that'),
										$author$project$Compiler$Reporting$Doc$d('range.')
									]))));
				}
			case 'OP_BadModuleName':
				var row = problem.a;
				var col = problem.b;
				return A3(
					toSnippet,
					'PROBLEM WITH MODULE NAME',
					A2(toHighlight, row, col),
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I was expecting a module name here:'),
						$author$project$Compiler$Reporting$Doc$fillSep(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('I'),
									$author$project$Compiler$Reporting$Doc$d('need'),
									$author$project$Compiler$Reporting$Doc$d('something'),
									$author$project$Compiler$Reporting$Doc$d('like'),
									$author$project$Compiler$Reporting$Doc$greenS('\"Html.Events\"'),
									$author$project$Compiler$Reporting$Doc$d('or'),
									$author$project$Compiler$Reporting$Doc$greenS('\"Browser.Navigation\"'),
									$author$project$Compiler$Reporting$Doc$d('where'),
									$author$project$Compiler$Reporting$Doc$d('each'),
									$author$project$Compiler$Reporting$Doc$d('segment'),
									$author$project$Compiler$Reporting$Doc$d('starts'),
									$author$project$Compiler$Reporting$Doc$d('with'),
									$author$project$Compiler$Reporting$Doc$d('a'),
									$author$project$Compiler$Reporting$Doc$d('capital'),
									$author$project$Compiler$Reporting$Doc$d('letter'),
									$author$project$Compiler$Reporting$Doc$d('and'),
									$author$project$Compiler$Reporting$Doc$d('the'),
									$author$project$Compiler$Reporting$Doc$d('segments'),
									$author$project$Compiler$Reporting$Doc$d('are'),
									$author$project$Compiler$Reporting$Doc$d('separated'),
									$author$project$Compiler$Reporting$Doc$d('by'),
									$author$project$Compiler$Reporting$Doc$d('dots.')
								]))));
			case 'OP_BadModuleHeaderTooLong':
				return A3(
					toSnippet,
					'HEADER TOO LONG',
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. This section header is too long:'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('need'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('be'),
											$author$project$Compiler$Reporting$Doc$greenS('under'),
											$author$project$Compiler$Reporting$Doc$greenS('20'),
											$author$project$Compiler$Reporting$Doc$greenS('bytes'),
											$author$project$Compiler$Reporting$Doc$d('so'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('renders'),
											$author$project$Compiler$Reporting$Doc$d('nicely'),
											$author$project$Compiler$Reporting$Doc$d('on'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('package'),
											$author$project$Compiler$Reporting$Doc$d('website!')
										])),
									$author$project$Compiler$Reporting$Doc$toSimpleNote('I count the length in bytes, so using non-ASCII characters costs extra.' + (' Please report your case at https://github.com/elm/compiler/issues if this seems' + ' overly restrictive for your needs.'))
								]))));
			case 'OP_BadDependencyName':
				var row = problem.a;
				var col = problem.b;
				return A3(
					toSnippet,
					'PROBLEM WITH DEPENDENCY NAME',
					A2(toHighlight, row, col),
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. There is something wrong with this dependency name:'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Package'),
											$author$project$Compiler$Reporting$Doc$d('names'),
											$author$project$Compiler$Reporting$Doc$d('always'),
											$author$project$Compiler$Reporting$Doc$d('include'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('name'),
											$author$project$Compiler$Reporting$Doc$d('of'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('author,d'),
											$author$project$Compiler$Reporting$Doc$d('so'),
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('am'),
											$author$project$Compiler$Reporting$Doc$d('expecting'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('see'),
											$author$project$Compiler$Reporting$Doc$d('dependencies'),
											$author$project$Compiler$Reporting$Doc$d('like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('\"mdgriffith/elm-ui\"'),
											$author$project$Compiler$Reporting$Doc$d('and'),
											$author$project$Compiler$Reporting$Doc$da(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$dullyellowS('\"Microsoft/elm-json-tree-view\"'),
													$author$project$Compiler$Reporting$Doc$d('.')
												]))
										])),
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('generally'),
											$author$project$Compiler$Reporting$Doc$d('recommend'),
											$author$project$Compiler$Reporting$Doc$d('finding'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('package'),
											$author$project$Compiler$Reporting$Doc$d('you'),
											$author$project$Compiler$Reporting$Doc$d('want'),
											$author$project$Compiler$Reporting$Doc$d('on'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('package'),
											$author$project$Compiler$Reporting$Doc$d('website,'),
											$author$project$Compiler$Reporting$Doc$d('and'),
											$author$project$Compiler$Reporting$Doc$d('installing'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('with'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$greenS('elm install'),
											$author$project$Compiler$Reporting$Doc$d('command!')
										]))
								]))));
			case 'OP_BadLicense':
				var suggestions = problem.a;
				return A3(
					toSnippet,
					'UNKNOWN LICENSE',
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. I do not know about this type of license:'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Elm'),
											$author$project$Compiler$Reporting$Doc$d('packages'),
											$author$project$Compiler$Reporting$Doc$d('generally'),
											$author$project$Compiler$Reporting$Doc$d('use'),
											$author$project$Compiler$Reporting$Doc$greenS('\"BSD-3-Clause\"'),
											$author$project$Compiler$Reporting$Doc$d('or'),
											$author$project$Compiler$Reporting$Doc$da(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$greenS('\"MIT\"'),
													$author$project$Compiler$Reporting$Doc$d(',d')
												])),
											$author$project$Compiler$Reporting$Doc$d('but'),
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('accept'),
											$author$project$Compiler$Reporting$Doc$d('any'),
											$author$project$Compiler$Reporting$Doc$d('OSI'),
											$author$project$Compiler$Reporting$Doc$d('approved'),
											$author$project$Compiler$Reporting$Doc$d('SPDX'),
											$author$project$Compiler$Reporting$Doc$d('license.'),
											$author$project$Compiler$Reporting$Doc$d('Here'),
											$author$project$Compiler$Reporting$Doc$d('some'),
											$author$project$Compiler$Reporting$Doc$d('that'),
											$author$project$Compiler$Reporting$Doc$d('seem'),
											$author$project$Compiler$Reporting$Doc$d('close'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('what'),
											$author$project$Compiler$Reporting$Doc$d('you'),
											$author$project$Compiler$Reporting$Doc$d('wrote:')
										])),
									A2(
									$author$project$Compiler$Reporting$Doc$indent,
									4,
									$author$project$Compiler$Reporting$Doc$dullyellow(
										$author$project$Compiler$Reporting$Doc$vcat(
											A2(
												$author$project$Extra$Type$List$map,
												A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$fromChars, $author$project$Compiler$Json$String$toChars),
												suggestions)))),
									$author$project$Compiler$Reporting$Doc$reflow('Check out https://spdx.org/licenses/ for the full list of options.')
								]))));
			case 'OP_BadSummaryTooLong':
				return A3(
					toSnippet,
					'SUMMARY TOO LONG',
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. Your \"summary\" is too long:'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('need'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('be'),
											$author$project$Compiler$Reporting$Doc$greenS('under'),
											$author$project$Compiler$Reporting$Doc$greenS('80'),
											$author$project$Compiler$Reporting$Doc$greenS('bytes'),
											$author$project$Compiler$Reporting$Doc$d('so'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('renders'),
											$author$project$Compiler$Reporting$Doc$d('nicely'),
											$author$project$Compiler$Reporting$Doc$d('on'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('package'),
											$author$project$Compiler$Reporting$Doc$d('website!')
										])),
									$author$project$Compiler$Reporting$Doc$toSimpleNote('I count the length in bytes, so using non-ASCII characters costs extra.' + (' Please report your case at https://github.com/elm/compiler/issues if this seems' + ' overly restrictive for your needs.'))
								]))));
			default:
				return A3(
					toSnippet,
					'NO SOURCE DIRECTORIES',
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I got stuck while reading your elm.json file. You do not have any \"source-directories\" listed here:'),
						$author$project$Compiler$Reporting$Doc$fillSep(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('I'),
									$author$project$Compiler$Reporting$Doc$d('need'),
									$author$project$Compiler$Reporting$Doc$d('something'),
									$author$project$Compiler$Reporting$Doc$d('like'),
									$author$project$Compiler$Reporting$Doc$greenS('[\"src\"]'),
									$author$project$Compiler$Reporting$Doc$d('so'),
									$author$project$Compiler$Reporting$Doc$d('I'),
									$author$project$Compiler$Reporting$Doc$d('know'),
									$author$project$Compiler$Reporting$Doc$d('where'),
									$author$project$Compiler$Reporting$Doc$d('to'),
									$author$project$Compiler$Reporting$Doc$d('look'),
									$author$project$Compiler$Reporting$Doc$d('for'),
									$author$project$Compiler$Reporting$Doc$d('your'),
									$author$project$Compiler$Reporting$Doc$d('modules!')
								]))));
		}
	});
var $author$project$Compiler$Reporting$Error$Json$CRoot = {$: 'CRoot'};
var $author$project$Compiler$Reporting$Error$Json$because = F2(
	function (_v0, problem) {
		var iNeedThings = _v0.a;
		return iNeedThings + (' ' + problem);
	});
var $author$project$Compiler$Reporting$Error$Json$objectNote = $author$project$Compiler$Reporting$Doc$stack(
	_List_fromArray(
		[
			$author$project$Compiler$Reporting$Doc$toSimpleNote('Here is an example of a valid JSON object for reference:'),
			$author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$d('{')),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$da(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"name\"'),
								$author$project$Compiler$Reporting$Doc$d(': '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"Tom\"'),
								$author$project$Compiler$Reporting$Doc$d(',')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					6,
					$author$project$Compiler$Reporting$Doc$da(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$dullyellowS('\"age\"'),
								$author$project$Compiler$Reporting$Doc$d(': '),
								$author$project$Compiler$Reporting$Doc$dullyellowS('42')
							]))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$d('}'))
				])),
			$author$project$Compiler$Reporting$Doc$reflow('Notice that (1) the field names are in double quotes and (2) there is no' + ' trailing comma after the last entry. Both are strict requirements in JSON!')
		]));
var $author$project$Compiler$Reporting$Error$Json$parseErrorToReport = F4(
	function (path, source, parseError, reason) {
		var toSnippet = F4(
			function (title, row, col, _v2) {
				var problem = _v2.a;
				var details = _v2.b;
				var pos = A2($author$project$Compiler$Reporting$Annotation$Position, row, col);
				var region = A2($author$project$Compiler$Reporting$Annotation$Region, pos, pos);
				var surroundings = A2(
					$author$project$Compiler$Reporting$Annotation$Region,
					A2(
						$author$project$Compiler$Reporting$Annotation$Position,
						A2($elm$core$Basics$max, 1, row - 2),
						1),
					pos);
				return A3(
					$author$project$Builder$Reporting$Exit$Help$jsonReport,
					title,
					$elm$core$Maybe$Just(path),
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						surroundings,
						$elm$core$Maybe$Just(region),
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								A2($author$project$Compiler$Reporting$Error$Json$because, reason, problem)),
							details)));
			});
		switch (parseError.$) {
			case 'Start':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'EXPECTING A VALUE',
					row,
					col,
					_Utils_Tuple2(
						'I was expecting to see a JSON value next:',
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Try'),
											$author$project$Compiler$Reporting$Doc$d('something'),
											$author$project$Compiler$Reporting$Doc$d('like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('\"this\"'),
											$author$project$Compiler$Reporting$Doc$d('or'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('42'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('move'),
											$author$project$Compiler$Reporting$Doc$d('on'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('better'),
											$author$project$Compiler$Reporting$Doc$d('hints!')
										])),
									$author$project$Compiler$Reporting$Doc$toSimpleNote('The JSON specification does not allow trailing commas, so you can sometimes' + (' get this error in arrays that have an extra comma at the end. In that case,' + ' remove that last comma or add another array entry after it!'))
								]))));
			case 'ObjectField':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'EXTRA COMMA',
					row,
					col,
					_Utils_Tuple2(
						'I was partway through parsing a JSON object when I got stuck here:',
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('saw'),
											$author$project$Compiler$Reporting$Doc$d('a'),
											$author$project$Compiler$Reporting$Doc$d('comma'),
											$author$project$Compiler$Reporting$Doc$d('right'),
											$author$project$Compiler$Reporting$Doc$d('before'),
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('got'),
											$author$project$Compiler$Reporting$Doc$d('stuck'),
											$author$project$Compiler$Reporting$Doc$d('here,d'),
											$author$project$Compiler$Reporting$Doc$d('so'),
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('was'),
											$author$project$Compiler$Reporting$Doc$d('expecting'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('see'),
											$author$project$Compiler$Reporting$Doc$d('a'),
											$author$project$Compiler$Reporting$Doc$d('field'),
											$author$project$Compiler$Reporting$Doc$d('name'),
											$author$project$Compiler$Reporting$Doc$d('like'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('\"type\"'),
											$author$project$Compiler$Reporting$Doc$d('or'),
											$author$project$Compiler$Reporting$Doc$dullyellowS('\"dependencies\"'),
											$author$project$Compiler$Reporting$Doc$d('next.')
										])),
									$author$project$Compiler$Reporting$Doc$reflow('This error is commonly caused by trailing commas in JSON objects. Those are' + (' actually disallowed by <https://json.org> so check the previous line for a' + ' trailing comma that may need to be deleted.')),
									$author$project$Compiler$Reporting$Error$Json$objectNote
								]))));
			case 'ObjectColon':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'EXPECTING COLON',
					row,
					col,
					_Utils_Tuple2(
						'I was partway through parsing a JSON object when I got stuck here:',
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a colon next.'),
									$author$project$Compiler$Reporting$Error$Json$objectNote
								]))));
			case 'ObjectEnd':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'UNFINISHED OBJECT',
					row,
					col,
					_Utils_Tuple2(
						'I was partway through parsing a JSON object when I got stuck here:',
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a comma or a closing curly brace next.'),
									$author$project$Compiler$Reporting$Doc$reflow('Is a comma missing on the previous line? Is an array missing a closing square' + ' bracket? It is often something tricky like that!'),
									$author$project$Compiler$Reporting$Error$Json$objectNote
								]))));
			case 'ArrayEnd':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'UNFINISHED ARRAY',
					row,
					col,
					_Utils_Tuple2(
						'I was partway through parsing a JSON array when I got stuck here:',
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$reflow('I was expecting to see a comma or a closing square bracket next.'),
									$author$project$Compiler$Reporting$Doc$reflow('Is a comma missing on the previous line? It is often something like that!')
								]))));
			case 'StringProblem':
				var stringProblem = parseError.a;
				var row = parseError.b;
				var col = parseError.c;
				switch (stringProblem.$) {
					case 'BadStringEnd':
						return A4(
							toSnippet,
							'ENDLESS STRING',
							row,
							col,
							_Utils_Tuple2(
								'I got to the end of the line without seeing the closing double quote:',
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Strings'),
											$author$project$Compiler$Reporting$Doc$d('look'),
											$author$project$Compiler$Reporting$Doc$d('like'),
											$author$project$Compiler$Reporting$Doc$greenS('\"this\"'),
											$author$project$Compiler$Reporting$Doc$d('with'),
											$author$project$Compiler$Reporting$Doc$d('double'),
											$author$project$Compiler$Reporting$Doc$d('quotes'),
											$author$project$Compiler$Reporting$Doc$d('on'),
											$author$project$Compiler$Reporting$Doc$d('each'),
											$author$project$Compiler$Reporting$Doc$d('end.'),
											$author$project$Compiler$Reporting$Doc$d('Is'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('closing'),
											$author$project$Compiler$Reporting$Doc$d('double'),
											$author$project$Compiler$Reporting$Doc$d('quote'),
											$author$project$Compiler$Reporting$Doc$d('missing'),
											$author$project$Compiler$Reporting$Doc$d('in'),
											$author$project$Compiler$Reporting$Doc$d('your'),
											$author$project$Compiler$Reporting$Doc$d('code?')
										]))));
					case 'BadStringControlChar':
						return A4(
							toSnippet,
							'UNEXPECTED CONTROL CHARACTER',
							row,
							col,
							_Utils_Tuple2(
								'I ran into a control character unexpectedly:',
								$author$project$Compiler$Reporting$Doc$reflow('These are characters that represent tabs, backspaces, newlines, and' + (' a bunch of other invisible characters. They all come before 20 in the' + (' ASCII range, and they are disallowed by the JSON specificaiton. Maybe' + ' a copy/paste added one of these invisible characters to your JSON?')))));
					case 'BadStringEscapeChar':
						return A4(
							toSnippet,
							'UNKNOWN ESCAPE',
							row,
							col,
							_Utils_Tuple2(
								'Backslashes always start escaped characters, but I do not recognize this one:',
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('Valid escape characters include:'),
											$author$project$Compiler$Reporting$Doc$dullyellow(
											A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$vcat(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$d('\\\"'),
															$author$project$Compiler$Reporting$Doc$d('\\\\'),
															$author$project$Compiler$Reporting$Doc$d('\\/'),
															$author$project$Compiler$Reporting$Doc$d('\\b'),
															$author$project$Compiler$Reporting$Doc$d('\\f'),
															$author$project$Compiler$Reporting$Doc$d('\\n'),
															$author$project$Compiler$Reporting$Doc$d('\\r'),
															$author$project$Compiler$Reporting$Doc$d('\\t'),
															$author$project$Compiler$Reporting$Doc$d('\\u003D')
														])))),
											$author$project$Compiler$Reporting$Doc$reflow('Do you want one of those instead? Maybe you need \\\\ to escape a backslash?')
										]))));
					default:
						return A4(
							toSnippet,
							'BAD HEX ESCAPE',
							row,
							col,
							_Utils_Tuple2(
								'This is not a valid hex escape:',
								$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Valid'),
											$author$project$Compiler$Reporting$Doc$d('hex'),
											$author$project$Compiler$Reporting$Doc$d('escapes'),
											$author$project$Compiler$Reporting$Doc$d('in'),
											$author$project$Compiler$Reporting$Doc$d('JSON'),
											$author$project$Compiler$Reporting$Doc$d('are'),
											$author$project$Compiler$Reporting$Doc$d('between'),
											$author$project$Compiler$Reporting$Doc$greenS('\\u0000'),
											$author$project$Compiler$Reporting$Doc$d('and'),
											$author$project$Compiler$Reporting$Doc$greenS('\\uFFFF'),
											$author$project$Compiler$Reporting$Doc$d('and'),
											$author$project$Compiler$Reporting$Doc$d('always'),
											$author$project$Compiler$Reporting$Doc$d('have'),
											$author$project$Compiler$Reporting$Doc$d('exactly'),
											$author$project$Compiler$Reporting$Doc$d('four'),
											$author$project$Compiler$Reporting$Doc$d('digits.')
										]))));
				}
			case 'NoLeadingZeros':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'BAD NUMBER',
					row,
					col,
					_Utils_Tuple2(
						'Numbers cannot start with zeros like this:',
						$author$project$Compiler$Reporting$Doc$reflow('Try deleting the leading zeros?')));
			case 'NoFloats':
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'UNEXPECTED NUMBER',
					row,
					col,
					_Utils_Tuple2(
						'I got stuck while trying to parse this number:',
						$author$project$Compiler$Reporting$Doc$reflow('I do not accept floating point numbers like 3.1415 right now. That kind' + ' of JSON value is not needed for any of the uses that Elm has for now.')));
			default:
				var row = parseError.a;
				var col = parseError.b;
				return A4(
					toSnippet,
					'JSON PROBLEM',
					row,
					col,
					_Utils_Tuple2(
						'I was partway through parsing some JSON when I got stuck here:',
						$author$project$Compiler$Reporting$Doc$reflow('I am not really sure what is wrong. This sometimes means there is extra' + ' stuff after a valid JSON value?')));
		}
	});
var $author$project$Compiler$Reporting$Error$Json$CField = function (a) {
	return {$: 'CField', a: a};
};
var $author$project$Compiler$Reporting$Error$Json$CIndex = F2(
	function (a, b) {
		return {$: 'CIndex', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Doc$intToOrdinal = function (number) {
	var remainder100 = A2($elm$core$Basics$modBy, 100, number);
	var remainder10 = A2($elm$core$Basics$modBy, 10, number);
	var ending = A2(
		$author$project$Extra$Type$List$elem,
		remainder100,
		_List_fromArray(
			[11, 12, 13])) ? 'th' : ((remainder10 === 1) ? 'st' : ((remainder10 === 2) ? 'nd' : ((remainder10 === 3) ? 'rd' : 'th')));
	return _Utils_ap(
		$elm$core$String$fromInt(number),
		ending);
};
var $author$project$Compiler$Reporting$Error$Json$expectationToReport = F6(
	function (path, source, context, _v0, expectation, reason) {
		var start = _v0.a;
		var region = A2($author$project$Compiler$Reporting$Annotation$Region, start, start);
		var introduction = function () {
			switch (context.$) {
				case 'CRoot':
					return 'I ran into some trouble here:';
				case 'CField':
					var field = context.a;
					return 'I ran into trouble with the value of the \"' + (field + '\" field:');
				default:
					if (context.b.$ === 'CField') {
						var index = context.a;
						var field = context.b.a;
						return 'When looking at the \"' + (field + ('\" field, I ran into trouble with the ' + ($author$project$Compiler$Reporting$Doc$intToOrdinal(index) + ' entry:')));
					} else {
						var index = context.a;
						return 'I ran into trouble with the ' + ($author$project$Compiler$Reporting$Doc$intToOrdinal(index) + ' index of this array:');
					}
			}
		}();
		var toSnippet = F2(
			function (title, aThing) {
				return A3(
					$author$project$Builder$Reporting$Exit$Help$jsonReport,
					title,
					$elm$core$Maybe$Just(path),
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								A2($author$project$Compiler$Reporting$Error$Json$because, reason, introduction)),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_Utils_ap(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('I'),
											$author$project$Compiler$Reporting$Doc$d('was'),
											$author$project$Compiler$Reporting$Doc$d('expecting'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('run'),
											$author$project$Compiler$Reporting$Doc$d('into')
										]),
									aThing)))));
			});
		switch (expectation.$) {
			case 'TObject':
				return A2(
					toSnippet,
					'EXPECTING OBJECT',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$greenS('OBJECT'),
									$author$project$Compiler$Reporting$Doc$d('.')
								]))
						]));
			case 'TArray':
				return A2(
					toSnippet,
					'EXPECTING ARRAY',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$greenS('ARRAY'),
									$author$project$Compiler$Reporting$Doc$d('.')
								]))
						]));
			case 'TString':
				return A2(
					toSnippet,
					'EXPECTING STRING',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$greenS('STRING'),
									$author$project$Compiler$Reporting$Doc$d('.')
								]))
						]));
			default:
				var field = expectation.a;
				return A2(
					toSnippet,
					'MISSING FIELD',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$greenS('OBJECT'),
							$author$project$Compiler$Reporting$Doc$d('with'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$green(
							$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('\"'),
										$author$project$Compiler$Reporting$Doc$fromChars(field),
										$author$project$Compiler$Reporting$Doc$d('\"')
									]))),
							$author$project$Compiler$Reporting$Doc$d('field.')
						]));
		}
	});
var $author$project$Compiler$Reporting$Error$Json$getFailureToReport = function (_v0) {
	var a = _v0.a;
	return a;
};
var $elm$core$List$maximum = function (list) {
	if (list.b) {
		var x = list.a;
		var xs = list.b;
		return $elm$core$Maybe$Just(
			A3($elm$core$List$foldl, $elm$core$Basics$max, x, xs));
	} else {
		return $elm$core$Maybe$Nothing;
	}
};
var $author$project$Extra$Type$List$maximum = function (l) {
	var _v0 = $elm$core$List$maximum(l);
	if (_v0.$ === 'Just') {
		var x = _v0.a;
		return x;
	} else {
		return _Debug_todo(
			'Extra.Type.List',
			{
				start: {line: 275, column: 13},
				end: {line: 275, column: 23}
			})('Extra.Type.List.maximum: empty list');
	}
};
var $author$project$Compiler$Reporting$Error$Json$getMaxDepth = function (problem) {
	switch (problem.$) {
		case 'Field':
			var prob = problem.b;
			return 1 + $author$project$Compiler$Reporting$Error$Json$getMaxDepth(prob);
		case 'Index':
			var prob = problem.b;
			return 1 + $author$project$Compiler$Reporting$Error$Json$getMaxDepth(prob);
		case 'OneOf':
			var p = problem.a;
			var ps = problem.b;
			return $author$project$Extra$Type$List$maximum(
				A2(
					$elm$core$List$cons,
					$author$project$Compiler$Reporting$Error$Json$getMaxDepth(p),
					A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Error$Json$getMaxDepth, ps)));
		case 'Failure':
			return 0;
		default:
			return 0;
	}
};
var $author$project$Extra$Type$List$insertBy = F3(
	function (cmp, x, ys) {
		if (!ys.b) {
			return _List_fromArray(
				[x]);
		} else {
			var y = ys.a;
			var ys_ = ys.b;
			var _v1 = A2(cmp, x, y);
			if (_v1.$ === 'GT') {
				return A2(
					$elm$core$List$cons,
					y,
					A3($author$project$Extra$Type$List$insertBy, cmp, x, ys_));
			} else {
				return A2($elm$core$List$cons, x, ys);
			}
		}
	});
var $author$project$Compiler$Data$NonEmptyList$sortBy = F2(
	function (toRank, _v0) {
		var x = _v0.a;
		var xs = _v0.b;
		var comparison = F2(
			function (a, b) {
				return A2(
					$elm$core$Basics$compare,
					toRank(a),
					toRank(b));
			});
		var _v1 = A2($author$project$Extra$Type$List$sortBy, comparison, xs);
		if (!_v1.b) {
			return A2($author$project$Compiler$Data$NonEmptyList$CList, x, _List_Nil);
		} else {
			var y = _v1.a;
			var ys = _v1.b;
			var _v2 = A2(comparison, x, y);
			switch (_v2.$) {
				case 'LT':
					return A2(
						$author$project$Compiler$Data$NonEmptyList$CList,
						x,
						A2($elm$core$List$cons, y, ys));
				case 'EQ':
					return A2(
						$author$project$Compiler$Data$NonEmptyList$CList,
						x,
						A2($elm$core$List$cons, y, ys));
				default:
					return A2(
						$author$project$Compiler$Data$NonEmptyList$CList,
						y,
						A3($author$project$Extra$Type$List$insertBy, comparison, x, ys));
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Json$problemToReport = F6(
	function (path, ftr, source, context, problem, reason) {
		problemToReport:
		while (true) {
			switch (problem.$) {
				case 'Field':
					var field = problem.a;
					var prob = problem.b;
					var $temp$path = path,
						$temp$ftr = ftr,
						$temp$source = source,
						$temp$context = $author$project$Compiler$Reporting$Error$Json$CField(field),
						$temp$problem = prob,
						$temp$reason = reason;
					path = $temp$path;
					ftr = $temp$ftr;
					source = $temp$source;
					context = $temp$context;
					problem = $temp$problem;
					reason = $temp$reason;
					continue problemToReport;
				case 'Index':
					var index = problem.a;
					var prob = problem.b;
					var $temp$path = path,
						$temp$ftr = ftr,
						$temp$source = source,
						$temp$context = A2($author$project$Compiler$Reporting$Error$Json$CIndex, index, context),
						$temp$problem = prob,
						$temp$reason = reason;
					path = $temp$path;
					ftr = $temp$ftr;
					source = $temp$source;
					context = $temp$context;
					problem = $temp$problem;
					reason = $temp$reason;
					continue problemToReport;
				case 'OneOf':
					var p = problem.a;
					var ps = problem.b;
					var _v1 = A2(
						$author$project$Compiler$Data$NonEmptyList$sortBy,
						A2($elm$core$Basics$composeL, $elm$core$Basics$negate, $author$project$Compiler$Reporting$Error$Json$getMaxDepth),
						A2($author$project$Compiler$Data$NonEmptyList$CList, p, ps));
					var prob = _v1.a;
					var $temp$path = path,
						$temp$ftr = ftr,
						$temp$source = source,
						$temp$context = context,
						$temp$problem = prob,
						$temp$reason = reason;
					path = $temp$path;
					ftr = $temp$ftr;
					source = $temp$source;
					context = $temp$context;
					problem = $temp$problem;
					reason = $temp$reason;
					continue problemToReport;
				case 'Failure':
					var region = problem.a;
					var x = problem.b;
					return A6($author$project$Compiler$Reporting$Error$Json$getFailureToReport, ftr, path, source, context, region, x);
				default:
					var region = problem.a;
					var expectation = problem.b;
					return A6($author$project$Compiler$Reporting$Error$Json$expectationToReport, path, source, context, region, expectation, reason);
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Json$toReport = F4(
	function (path, ftr, err, reason) {
		if (err.$ === 'DecodeProblem') {
			var bytes = err.a;
			var problem = err.b;
			return A6(
				$author$project$Compiler$Reporting$Error$Json$problemToReport,
				path,
				ftr,
				$author$project$Compiler$Reporting$Render$Code$toSource(bytes),
				$author$project$Compiler$Reporting$Error$Json$CRoot,
				problem,
				reason);
		} else {
			var bytes = err.a;
			var parseError = err.b;
			return A4(
				$author$project$Compiler$Reporting$Error$Json$parseErrorToReport,
				path,
				$author$project$Compiler$Reporting$Render$Code$toSource(bytes),
				parseError,
				reason);
		}
	});
var $author$project$Builder$Reporting$Exit$toOutlineReport = function (problem) {
	switch (problem.$) {
		case 'OutlineHasBadStructure':
			var decodeError = problem.a;
			return A4(
				$author$project$Compiler$Reporting$Error$Json$toReport,
				$author$project$Extra$System$File$fromString('elm.json'),
				$author$project$Compiler$Reporting$Error$Json$FailureToReport($author$project$Builder$Reporting$Exit$toOutlineProblemReport),
				decodeError,
				$author$project$Compiler$Reporting$Error$Json$ExplicitReason('I ran into a problem with your elm.json file.'));
		case 'OutlineHasMissingSrcDirs':
			var dir = problem.a;
			var dirs = problem.b;
			if (!dirs.b) {
				return A4(
					$author$project$Builder$Reporting$Exit$Help$report,
					'MISSING SOURCE DIRECTORY',
					$elm$core$Maybe$Just(
						$author$project$Extra$System$File$fromString('elm.json')),
					'I need a valid elm.json file, but the \"source-directories\" field lists the following directory:',
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Reporting$Doc$indent,
							4,
							$author$project$Compiler$Reporting$Doc$red(
								$author$project$Compiler$Reporting$Doc$fromPath(dir))),
							$author$project$Compiler$Reporting$Doc$reflow('I cannot find it though. Is it missing? Is there a typo?')
						]));
			} else {
				return A4(
					$author$project$Builder$Reporting$Exit$Help$report,
					'MISSING SOURCE DIRECTORIES',
					$elm$core$Maybe$Just(
						$author$project$Extra$System$File$fromString('elm.json')),
					'I need a valid elm.json file, but the \"source-directories\" field lists the following directories:',
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Reporting$Doc$indent,
							4,
							$author$project$Compiler$Reporting$Doc$vcat(
								A2(
									$author$project$Extra$Type$List$map,
									A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$red, $author$project$Compiler$Reporting$Doc$fromPath),
									A2($elm$core$List$cons, dir, dirs)))),
							$author$project$Compiler$Reporting$Doc$reflow('I cannot find them though. Are they missing? Are there typos?')
						]));
			}
		case 'OutlineHasDuplicateSrcDirs':
			var canonicalDir = problem.a;
			var dir1 = problem.b;
			var dir2 = problem.c;
			return _Utils_eq(dir1, dir2) ? A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'REDUNDANT SOURCE DIRECTORIES',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'I need a valid elm.json file, but the \"source-directories\" field lists the same directory twice:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$vcat(
							A2(
								$author$project$Extra$Type$List$map,
								A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$red, $author$project$Compiler$Reporting$Doc$fromPath),
								_List_fromArray(
									[dir1, dir2])))),
						$author$project$Compiler$Reporting$Doc$reflow('Remove one of the entries!')
					])) : A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'REDUNDANT SOURCE DIRECTORIES',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'I need a valid elm.json file, but the \"source-directories\" field has some redundant directories:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$vcat(
							A2(
								$author$project$Extra$Type$List$map,
								A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$red, $author$project$Compiler$Reporting$Doc$fromPath),
								_List_fromArray(
									[dir1, dir2])))),
						$author$project$Compiler$Reporting$Doc$reflow('These are two different ways of refering to the same directory:'),
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							$author$project$Compiler$Reporting$Doc$fromChars(canonicalDir))),
						$author$project$Compiler$Reporting$Doc$reflow('Remove one of the redundant entries from your \"source-directories\" field.')
					]));
		case 'OutlineNoPkgCore':
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'MISSING DEPENDENCY',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'I need to see an \"elm/core\" dependency your elm.json file. The default imports' + ' of `List` and `Maybe` do not work without it.',
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow('If you modified your elm.json by hand, try to change it back! And if you are' + (' having trouble getting back to a working elm.json, it may be easier to find a' + ' working package and start fresh with their elm.json file.'))
					]));
		case 'OutlineNoAppCore':
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'MISSING DEPENDENCY',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'I need to see an \"elm/core\" dependency your elm.json file. The default imports' + ' of `List` and `Maybe` do not work without it.',
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow('If you modified your elm.json by hand, try to change it back! And if you are' + (' having trouble getting back to a working elm.json, it may be easier to delete it' + ' and use `elm init` to start fresh.'))
					]));
		default:
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'MISSING DEPENDENCY',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'I need to see an \"elm/json\" dependency your elm.json file. It helps me handle' + ' flags and ports.',
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow('If you modified your elm.json by hand, try to change it back! And if you are' + (' having trouble getting back to a working elm.json, it may be easier to delete it' + ' and use `elm init` to start fresh.'))
					]));
	}
};
var $author$project$Compiler$Reporting$Doc$fromInt = function (n) {
	return $author$project$Extra$Data$Pretty$text(
		$elm$core$String$fromInt(n));
};
var $author$project$Builder$Reporting$Exit$toHttpErrorReport = F3(
	function (title, err, context) {
		var toHttpReport = F3(
			function (intro, url, details) {
				return A4(
					$author$project$Builder$Reporting$Exit$Help$report,
					title,
					$elm$core$Maybe$Nothing,
					intro,
					A2(
						$elm$core$List$cons,
						A2(
							$author$project$Compiler$Reporting$Doc$indent,
							4,
							$author$project$Compiler$Reporting$Doc$dullyellow(
								$author$project$Compiler$Reporting$Doc$fromChars(url))),
						details));
			});
		var url = err.a;
		var httpExceptionContent = err.b;
		if (httpExceptionContent.$ === 'BadStatus') {
			var code = httpExceptionContent.a;
			return A3(
				toHttpReport,
				context + ', so I tried to fetch:',
				url,
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_Utils_ap(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('But'),
									$author$project$Compiler$Reporting$Doc$d('it'),
									$author$project$Compiler$Reporting$Doc$d('came'),
									$author$project$Compiler$Reporting$Doc$d('back'),
									$author$project$Compiler$Reporting$Doc$d('as'),
									$author$project$Compiler$Reporting$Doc$red(
									$author$project$Compiler$Reporting$Doc$fromInt(code))
								]),
							A2(
								$author$project$Extra$Type$List$map,
								$author$project$Compiler$Reporting$Doc$fromChars,
								$elm$core$String$words('(message)')))),
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$reflow('(body)')),
						$author$project$Compiler$Reporting$Doc$reflow('This may mean some online endpoint changed in an unexpected way, so if does not' + (' seem like something on your side is causing this (e.g. firewall) please report' + (' this to https://github.com/elm/compiler/issues with your operating system, Elm' + (' version, the command you ran, the terminal output, and any additional information' + ' that can help others reproduce the error!'))))
					]));
		} else {
			var otherException = httpExceptionContent;
			return A3(
				toHttpReport,
				context + ', so I tried to fetch:',
				url,
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow('But my HTTP library is giving me the following error message:'),
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$fromChars(
							$elm$core$Debug$toString(otherException))),
						$author$project$Compiler$Reporting$Doc$reflow('Are you somewhere with a slow internet connection? Or no internet?' + (' Does the link I am trying to fetch work in your browser? Maybe the' + (' site is down? Does your internet connection have a firewall that' + ' blocks certain domains? It is usually something like that!')))
					]));
		}
	});
var $author$project$Builder$Reporting$Exit$toPackageProblemReport = F3(
	function (pkg, vsn, problem) {
		var thePackage = $author$project$Compiler$Elm$Package$toChars(pkg) + (' ' + $author$project$Compiler$Elm$Version$toChars(vsn));
		switch (problem.$) {
			case 'PP_BadEndpointRequest':
				var httpError = problem.a;
				return A3($author$project$Builder$Reporting$Exit$toHttpErrorReport, 'PROBLEM DOWNLOADING PACKAGE', httpError, 'I need to find the latest download link for ' + thePackage);
			case 'PP_BadEndpointContent':
				var url = problem.a;
				return A4(
					$author$project$Builder$Reporting$Exit$Help$report,
					'PROBLEM DOWNLOADING PACKAGE',
					$elm$core$Maybe$Nothing,
					'I need to find the latest download link for ' + (thePackage + ', but I ran into corrupted information from:'),
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Reporting$Doc$indent,
							4,
							$author$project$Compiler$Reporting$Doc$dullyellow(
								$author$project$Compiler$Reporting$Doc$fromChars(url))),
							$author$project$Compiler$Reporting$Doc$reflow('Is something weird with your internet connection. We have gotten reports that' + (' schools, businesses, airports, etc. sometimes intercept requests and add things' + ' to the body or change its contents entirely. Could that be the problem?'))
						]));
			case 'PP_BadArchiveRequest':
				var httpError = problem.a;
				return A3($author$project$Builder$Reporting$Exit$toHttpErrorReport, 'PROBLEM DOWNLOADING PACKAGE', httpError, 'I was trying to download the source code for ' + thePackage);
			default:
				var url = problem.a;
				return A4(
					$author$project$Builder$Reporting$Exit$Help$report,
					'PROBLEM DOWNLOADING PACKAGE',
					$elm$core$Maybe$Nothing,
					'I downloaded the source code for ' + (thePackage + ' from:'),
					_List_fromArray(
						[
							A2(
							$author$project$Compiler$Reporting$Doc$indent,
							4,
							$author$project$Compiler$Reporting$Doc$dullyellow(
								$author$project$Compiler$Reporting$Doc$fromChars(url))),
							$author$project$Compiler$Reporting$Doc$reflow('But I was unable to unzip the data. Maybe there is something weird with' + (' your internet connection. We have gotten reports that schools, businesses,' + (' airports, etc. sometimes intercept requests and add things to the body or' + ' change its contents entirely. Could that be the problem?')))
						]));
		}
	});
var $elm$core$String$left = F2(
	function (n, string) {
		return (n < 1) ? '' : A3($elm$core$String$slice, 0, n, string);
	});
var $author$project$Builder$Reporting$Exit$toRegistryProblemReport = F3(
	function (title, problem, context) {
		if (problem.$ === 'RP_Http') {
			var err = problem.a;
			return A3($author$project$Builder$Reporting$Exit$toHttpErrorReport, title, err, context);
		} else {
			var url = problem.a;
			var body = problem.b;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				title,
				$elm$core$Maybe$Nothing,
				context + ', so I fetched:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							$author$project$Compiler$Reporting$Doc$fromChars(url))),
						$author$project$Compiler$Reporting$Doc$reflow(
						'I got the data back, but it was not what I was expecting. The response' + (' body contains ' + ($elm$core$String$fromInt(
							$elm$core$String$length(body)) + (' bytes. Here is the ' + (($elm$core$String$length(body) <= 76) ? 'whole thing:' : 'beginning:'))))),
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							$author$project$Compiler$Reporting$Doc$fromChars(
								($elm$core$String$length(body) <= 76) ? body : (A2($elm$core$String$left, 73, body) + '...')))),
						$author$project$Compiler$Reporting$Doc$reflow('Does this error keep showing up? Maybe there is something weird with your' + (' internet connection. We have gotten reports that schools, businesses,' + (' airports, etc. sometimes intercept requests and add things to the body' + ' or change its contents entirely. Could that be the problem?')))
					]));
		}
	});
var $author$project$Builder$Reporting$Exit$toSolverReport = function (problem) {
	switch (problem.$) {
		case 'SolverBadCacheData':
			var pkg = problem.a;
			var vsn = problem.b;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'PROBLEM SOLVING PACKAGE CONSTRAINTS',
				$elm$core$Maybe$Nothing,
				'I need the elm.json of ' + ($author$project$Compiler$Elm$Package$toChars(pkg) + (' ' + ($author$project$Compiler$Elm$Version$toChars(vsn) + (' to' + (' help me search for a set of compatible packages. I had it cached locally, but' + ' it looks like the file was corrupted!'))))),
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow('I deleted the cached version, so the next run should download a fresh copy.' + (' Hopefully that will get you unstuck, but it will not resolve the root' + ' problem if a 3rd party tool is modifing cached files for some reason.'))
					]));
		case 'SolverBadHttpData':
			var pkg = problem.a;
			var vsn = problem.b;
			var url = problem.c;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'PROBLEM SOLVING PACKAGE CONSTRAINTS',
				$elm$core$Maybe$Nothing,
				'I need the elm.json of ' + ($author$project$Compiler$Elm$Package$toChars(pkg) + (' ' + ($author$project$Compiler$Elm$Version$toChars(vsn) + (' to' + (' help me search for a set of compatible packages, but I ran into corrupted' + ' information from:'))))),
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							$author$project$Compiler$Reporting$Doc$fromChars(url))),
						$author$project$Compiler$Reporting$Doc$reflow('Is something weird with your internet connection. We have gotten reports that' + (' schools, businesses, airports, etc. sometimes intercept requests and add things' + ' to the body or change its contents entirely. Could that be the problem?'))
					]));
		default:
			var pkg = problem.a;
			var vsn = problem.b;
			var httpError = problem.c;
			return A3(
				$author$project$Builder$Reporting$Exit$toHttpErrorReport,
				'PROBLEM SOLVING PACKAGE CONSTRAINTS',
				httpError,
				'I need the elm.json of ' + ($author$project$Compiler$Elm$Package$toChars(pkg) + (' ' + ($author$project$Compiler$Elm$Version$toChars(vsn) + ' to help me search for a set of compatible packages'))));
	}
};
var $author$project$Builder$Reporting$Exit$toDetailsReport = function (details) {
	switch (details.$) {
		case 'DetailsNoSolution':
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'INCOMPATIBLE DEPENDENCIES',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'The dependencies in your elm.json are not compatible.',
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('Did'),
								$author$project$Compiler$Reporting$Doc$d('you'),
								$author$project$Compiler$Reporting$Doc$d('change'),
								$author$project$Compiler$Reporting$Doc$d('them'),
								$author$project$Compiler$Reporting$Doc$d('by'),
								$author$project$Compiler$Reporting$Doc$d('hand?'),
								$author$project$Compiler$Reporting$Doc$d('Try'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('change'),
								$author$project$Compiler$Reporting$Doc$d('it'),
								$author$project$Compiler$Reporting$Doc$d('back!'),
								$author$project$Compiler$Reporting$Doc$d('It'),
								$author$project$Compiler$Reporting$Doc$d('is'),
								$author$project$Compiler$Reporting$Doc$d('much'),
								$author$project$Compiler$Reporting$Doc$d('more'),
								$author$project$Compiler$Reporting$Doc$d('reliable'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('add'),
								$author$project$Compiler$Reporting$Doc$d('dependencies'),
								$author$project$Compiler$Reporting$Doc$d('with'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('elm install'),
										$author$project$Compiler$Reporting$Doc$d('.')
									]))
							])),
						$author$project$Compiler$Reporting$Doc$reflow('Please ask for help on the community forums if you try those paths and are still' + ' having problems!')
					]));
		case 'DetailsNoOfflineSolution':
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'TROUBLE VERIFYING DEPENDENCIES',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'I could not connect to https://package.elm-lang.org to get the latest list of' + (' packages, and I was unable to verify your dependencies with the information I' + ' have cached locally.'),
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow('Are you able to connect to the internet? These dependencies may work once you' + ' get access to the registry!'),
						$author$project$Compiler$Reporting$Doc$toFancyNote(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('If'),
								$author$project$Compiler$Reporting$Doc$d('you'),
								$author$project$Compiler$Reporting$Doc$d('changed'),
								$author$project$Compiler$Reporting$Doc$d('your'),
								$author$project$Compiler$Reporting$Doc$d('dependencies'),
								$author$project$Compiler$Reporting$Doc$d('by'),
								$author$project$Compiler$Reporting$Doc$d('hand,d'),
								$author$project$Compiler$Reporting$Doc$d('try'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('change'),
								$author$project$Compiler$Reporting$Doc$d('them'),
								$author$project$Compiler$Reporting$Doc$d('back!'),
								$author$project$Compiler$Reporting$Doc$d('It'),
								$author$project$Compiler$Reporting$Doc$d('is'),
								$author$project$Compiler$Reporting$Doc$d('much'),
								$author$project$Compiler$Reporting$Doc$d('more'),
								$author$project$Compiler$Reporting$Doc$d('reliable'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('add'),
								$author$project$Compiler$Reporting$Doc$d('dependencies'),
								$author$project$Compiler$Reporting$Doc$d('with'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('elm install'),
										$author$project$Compiler$Reporting$Doc$d('.')
									]))
							]))
					]));
		case 'DetailsSolverProblem':
			var solver = details.a;
			return $author$project$Builder$Reporting$Exit$toSolverReport(solver);
		case 'DetailsBadElmInPkg':
			var constraint = details.a;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'ELM VERSION MISMATCH',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'Your elm.json says this package needs a version of Elm in this range:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							$author$project$Compiler$Reporting$Doc$fromChars(
								$author$project$Compiler$Elm$Constraint$toChars(constraint)))),
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('But'),
								$author$project$Compiler$Reporting$Doc$d('you'),
								$author$project$Compiler$Reporting$Doc$d('are'),
								$author$project$Compiler$Reporting$Doc$d('using'),
								$author$project$Compiler$Reporting$Doc$d('Elm'),
								$author$project$Compiler$Reporting$Doc$red(
								$author$project$Compiler$Reporting$Doc$fromVersion($author$project$Compiler$Elm$Version$compiler)),
								$author$project$Compiler$Reporting$Doc$d('right'),
								$author$project$Compiler$Reporting$Doc$d('now.')
							]))
					]));
		case 'DetailsBadElmInAppOutline':
			var version = details.a;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'ELM VERSION MISMATCH',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'Your elm.json says this application needs a different version of Elm.',
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('It'),
								$author$project$Compiler$Reporting$Doc$d('requires'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$green(
										$author$project$Compiler$Reporting$Doc$fromVersion(version)),
										$author$project$Compiler$Reporting$Doc$d(',')
									])),
								$author$project$Compiler$Reporting$Doc$d('but'),
								$author$project$Compiler$Reporting$Doc$d('you'),
								$author$project$Compiler$Reporting$Doc$d('are'),
								$author$project$Compiler$Reporting$Doc$d('using'),
								$author$project$Compiler$Reporting$Doc$red(
								$author$project$Compiler$Reporting$Doc$fromVersion($author$project$Compiler$Elm$Version$compiler)),
								$author$project$Compiler$Reporting$Doc$d('right'),
								$author$project$Compiler$Reporting$Doc$d('now.')
							]))
					]));
		case 'DetailsHandEditedDependencies':
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'ERROR IN DEPENDENCIES',
				$elm$core$Maybe$Just(
					$author$project$Extra$System$File$fromString('elm.json')),
				'It looks like the dependencies elm.json in were edited by hand (or by a 3rd' + ' party tool) leaving them in an invalid state.',
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('Try'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('change'),
								$author$project$Compiler$Reporting$Doc$d('them'),
								$author$project$Compiler$Reporting$Doc$d('back'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('what'),
								$author$project$Compiler$Reporting$Doc$d('they'),
								$author$project$Compiler$Reporting$Doc$d('were'),
								$author$project$Compiler$Reporting$Doc$d('before!'),
								$author$project$Compiler$Reporting$Doc$d('It'),
								$author$project$Compiler$Reporting$Doc$d('is'),
								$author$project$Compiler$Reporting$Doc$d('much'),
								$author$project$Compiler$Reporting$Doc$d('more'),
								$author$project$Compiler$Reporting$Doc$d('reliable'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('add'),
								$author$project$Compiler$Reporting$Doc$d('dependencies'),
								$author$project$Compiler$Reporting$Doc$d('with'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('elm install'),
										$author$project$Compiler$Reporting$Doc$d('.')
									]))
							])),
						$author$project$Compiler$Reporting$Doc$reflow('Please ask for help on the community forums if you try those paths and are still' + ' having problems!')
					]));
		case 'DetailsBadOutline':
			var outline = details.a;
			return $author$project$Builder$Reporting$Exit$toOutlineReport(outline);
		case 'DetailsCannotGetRegistry':
			var problem = details.a;
			return A3($author$project$Builder$Reporting$Exit$toRegistryProblemReport, 'PROBLEM LOADING PACKAGE LIST', problem, 'I need the list of published packages to verify your dependencies');
		default:
			var cacheDir = details.a;
			var deps = details.b;
			var _v1 = A2($author$project$Extra$Type$List$sortOn, $author$project$Builder$Reporting$Exit$toBadDepRank, deps);
			if (!_v1.b) {
				return A4(
					$author$project$Builder$Reporting$Exit$Help$report,
					'PROBLEM BUILDING DEPENDENCIES',
					$elm$core$Maybe$Nothing,
					'I am not sure what is going wrong though.',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$reflow(
							'I would try deleting the ' + ($author$project$Extra$System$File$toString(cacheDir) + (' and elm-stuff/ directories, then' + (' trying to build again. That will work if some cached files got corrupted' + ' somehow.')))),
							$author$project$Compiler$Reporting$Doc$reflow('If that does not work, go to https://elm-lang.org/community and ask for' + ' help. This is a weird case!')
						]));
			} else {
				var d = _v1.a;
				if (d.$ === 'BD_BadDownload') {
					var pkg = d.a;
					var vsn = d.b;
					var packageProblem = d.c;
					return A3($author$project$Builder$Reporting$Exit$toPackageProblemReport, pkg, vsn, packageProblem);
				} else {
					var pkg = d.a;
					var vsn = d.b;
					var fingerprint = d.c;
					return A4(
						$author$project$Builder$Reporting$Exit$Help$report,
						'PROBLEM BUILDING DEPENDENCIES',
						$elm$core$Maybe$Nothing,
						'I ran into a compilation error when trying to build the following package:',
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$red(
									$author$project$Compiler$Reporting$Doc$fromChars(
										$author$project$Compiler$Elm$Package$toChars(pkg) + (' ' + $author$project$Compiler$Elm$Version$toChars(vsn))))),
								$author$project$Compiler$Reporting$Doc$reflow('This probably means it has package constraints that are too wide. It may be' + (' possible to tweak your elm.json to avoid the root problem as a stopgap. Head' + (' over to https://elm-lang.org/community to get help figuring out how to take' + ' this path!'))),
								$author$project$Compiler$Reporting$Doc$toSimpleNote('To help with the root problem, please report this to the package author along' + ' with the following information:'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$vcat(
									A2(
										$author$project$Extra$Type$List$map,
										function (_v3) {
											var p = _v3.a;
											var v = _v3.b;
											return $author$project$Compiler$Reporting$Doc$fromChars(
												$author$project$Compiler$Elm$Package$toChars(
													$author$project$Compiler$Elm$Package$fromComparable(p)) + (' ' + $author$project$Compiler$Elm$Version$toChars(v)));
										},
										$author$project$Extra$Type$Map$toList(fingerprint)))),
								$author$project$Compiler$Reporting$Doc$reflow('If you want to help out even more, try building the package locally. That should' + (' give you much more specific information about why this package is failing to' + ' build, which will in turn make it easier for the package author to fix it!'))
							]));
				}
			}
	}
};
var $author$project$Builder$Reporting$Exit$toGenerateReport = function (problem) {
	if (problem.$ === 'GenerateCannotLoadArtifacts') {
		return $author$project$Builder$Reporting$Exit$corruptCacheReport;
	} else {
		var m = problem.a;
		var ms = problem.b;
		return A4(
			$author$project$Builder$Reporting$Exit$Help$report,
			'DEBUG REMNANTS',
			$elm$core$Maybe$Nothing,
			'There are uses of the `Debug` module in the following modules:',
			_List_fromArray(
				[
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$red(
						$author$project$Compiler$Reporting$Doc$vcat(
							A2(
								$author$project$Extra$Type$List$map,
								A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$fromChars, $author$project$Compiler$Elm$ModuleName$toChars),
								A2($elm$core$List$cons, m, ms))))),
					$author$project$Compiler$Reporting$Doc$reflow('But the --optimize flag only works if all `Debug` functions are removed!'),
					$author$project$Compiler$Reporting$Doc$toSimpleNote('The issue is that --optimize strips out info needed by `Debug` functions.' + ' Here are two examples:'),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$reflow('(1) It shortens record field names. This makes the generated JavaScript' + ' smaller, but `Debug.toString` cannot know the real field names anymore.')),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$reflow('(2) Values like `type Height = Height Float` are unboxed. This reduces' + (' allocation, but it also means that `Debug.toString` cannot tell if it is' + ' looking at a `Height` or `Float` value.'))),
					$author$project$Compiler$Reporting$Doc$reflow('There are a few other cases like that, and it will be much worse once we start' + (' inlining code. That optimization could move `Debug.log` and `Debug.todo` calls,' + (' resulting in unpredictable behavior. I hope that clarifies why this restriction' + ' exists!')))
				]));
	}
};
var $author$project$Compiler$Reporting$Doc$cycleEnd = $author$project$Extra$Data$Pretty$text('');
var $author$project$Compiler$Reporting$Doc$cycleLn = $author$project$Extra$Data$Pretty$text('    ');
var $author$project$Compiler$Reporting$Doc$cycleMid = $author$project$Extra$Data$Pretty$text('     ');
var $author$project$Compiler$Reporting$Doc$cycleTop = $author$project$Extra$Data$Pretty$text('');
var $author$project$Compiler$Reporting$Doc$cycle = F3(
	function (indent_, name, names) {
		var toLn = function (n) {
			return $author$project$Compiler$Reporting$Doc$hcat(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$cycleLn,
						$author$project$Compiler$Reporting$Doc$dullyellowS(n)
					]));
		};
		return A2(
			$author$project$Extra$Data$Pretty$indent,
			indent_,
			$author$project$Extra$Data$Pretty$vcat(
				A2(
					$elm$core$List$cons,
					$author$project$Compiler$Reporting$Doc$cycleTop,
					_Utils_ap(
						A2(
							$author$project$Extra$Type$List$intersperse,
							$author$project$Compiler$Reporting$Doc$cycleMid,
							A2(
								$elm$core$List$cons,
								toLn(name),
								A2($author$project$Extra$Type$List$map, toLn, names))),
						_List_fromArray(
							[$author$project$Compiler$Reporting$Doc$cycleEnd])))));
	});
var $author$project$Builder$Reporting$Exit$toModuleNameConventionTable = F2(
	function (srcDir, names) {
		var toPair = function (name) {
			return _Utils_Tuple2(
				name,
				$author$project$Extra$System$File$toString(srcDir) + (A2(
					$elm$core$String$map,
					function (c) {
						return _Utils_eq(
							c,
							_Utils_chr('.')) ? _Utils_chr('/') : c;
					},
					name) + '.elm'));
		};
		var padded = F2(
			function (width, str) {
				return _Utils_ap(
					str,
					A2(
						$elm$core$String$repeat,
						width - $elm$core$String$length(str),
						' '));
			});
		var namePairs = A2($author$project$Extra$Type$List$map, toPair, names);
		var nameWidth = $author$project$Extra$Type$List$maximum(
			A2(
				$elm$core$List$cons,
				11,
				A2(
					$author$project$Extra$Type$List$map,
					A2($elm$core$Basics$composeL, $elm$core$String$length, $elm$core$Tuple$first),
					namePairs)));
		var pathWidth = $author$project$Extra$Type$List$maximum(
			A2(
				$elm$core$List$cons,
				9,
				A2(
					$author$project$Extra$Type$List$map,
					A2($elm$core$Basics$composeL, $elm$core$String$length, $elm$core$Tuple$second),
					namePairs)));
		var toRow = function (_v0) {
			var name = _v0.a;
			var path = _v0.b;
			return $author$project$Compiler$Reporting$Doc$fromChars(
				'| ' + (A2(padded, nameWidth, name) + (' | ' + (A2(padded, pathWidth, path) + ' |'))));
		};
		var bar = $author$project$Compiler$Reporting$Doc$fromChars(
			'+-' + (A2($elm$core$String$repeat, nameWidth, '-') + ('-+-' + (A2($elm$core$String$repeat, pathWidth, '-') + '-+'))));
		return A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			$author$project$Compiler$Reporting$Doc$vcat(
				_Utils_ap(
					_List_fromArray(
						[
							bar,
							toRow(
							_Utils_Tuple2('Module Name', 'File Path')),
							bar
						]),
					_Utils_ap(
						A2($author$project$Extra$Type$List$map, toRow, namePairs),
						_List_fromArray(
							[bar])))));
	});
var $author$project$Builder$Reporting$Exit$toProjectProblemReport = function (projectProblem) {
	switch (projectProblem.$) {
		case 'BP_PathUnknown':
			var path = projectProblem.a;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'FILE NOT FOUND',
				$elm$core$Maybe$Nothing,
				'I cannot find this file:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$fromPath(path))),
						$author$project$Compiler$Reporting$Doc$reflow('Is there a typo?'),
						$author$project$Compiler$Reporting$Doc$toSimpleNote('If you are just getting started, try working through the examples in the' + (' official guide https://guide.elm-lang.org to get an idea of the kinds of things' + ' that typically go in a src/Main.elm file.'))
					]));
		case 'BP_WithBadExtension':
			var path = projectProblem.a;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'UNEXPECTED FILE EXTENSION',
				$elm$core$Maybe$Nothing,
				'I can only compile Elm files (with a .elm extension) but you want me to compile:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$fromPath(path))),
						$author$project$Compiler$Reporting$Doc$reflow('Is there a typo? Can the file extension be changed?')
					]));
		case 'BP_WithAmbiguousSrcDir':
			var path = projectProblem.a;
			var srcDir1 = projectProblem.b;
			var srcDir2 = projectProblem.c;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'CONFUSING FILE',
				$elm$core$Maybe$Nothing,
				'I am getting confused when I try to compile this file:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$fromPath(path))),
						$author$project$Compiler$Reporting$Doc$reflow('I always check if files appear in any of the \"source-directories\" listed in' + (' your elm.json to see if there might be some cached information about them. That' + (' can help me compile faster! But in this case, it looks like this file may be in' + ' either of these directories:'))),
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$vcat(
								A2(
									$author$project$Extra$Type$List$map,
									$author$project$Compiler$Reporting$Doc$fromPath,
									_List_fromArray(
										[srcDir1, srcDir2]))))),
						$author$project$Compiler$Reporting$Doc$reflow('Try to make it so no source directory contains another source directory!')
					]));
		case 'BP_MainPathDuplicate':
			var path1 = projectProblem.a;
			var path2 = projectProblem.b;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'CONFUSING FILES',
				$elm$core$Maybe$Nothing,
				'You are telling me to compile these two files:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$vcat(
								A2(
									$author$project$Extra$Type$List$map,
									$author$project$Compiler$Reporting$Doc$fromPath,
									_List_fromArray(
										[path1, path2]))))),
						$author$project$Compiler$Reporting$Doc$reflow(
						_Utils_eq(path1, path2) ? ('Why are you telling me twice? Is something weird going on with a script?' + (' I figured I would let you know about it just in case something is wrong.' + ' Only list it once and you should be all set!')) : ('But seem to be the same file though... It makes me think something tricky is' + (' going on with symlinks in your project, so I figured I would let you know' + (' about it just in case. Remove one of these files from your command to get' + ' unstuck!'))))
					]));
		case 'BP_RootNameDuplicate':
			var name = projectProblem.a;
			var outsidePath = projectProblem.b;
			var otherPath = projectProblem.c;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'MODULE NAME CLASH',
				$elm$core$Maybe$Nothing,
				'These two files are causing a module name clash:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$vcat(
								A2(
									$author$project$Extra$Type$List$map,
									$author$project$Compiler$Reporting$Doc$fromPath,
									_List_fromArray(
										[outsidePath, otherPath]))))),
						$author$project$Compiler$Reporting$Doc$reflow(
						'They both say `module ' + ($author$project$Compiler$Elm$ModuleName$toChars(name) + (' exposing (..)` up' + ' at the top, but they cannot have the same name!'))),
						$author$project$Compiler$Reporting$Doc$reflow('Try changing to a different module name in one of them!')
					]));
		case 'BP_RootNameInvalid':
			var givenPath = projectProblem.a;
			var srcDir = projectProblem.b;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'UNEXPECTED FILE NAME',
				$elm$core$Maybe$Nothing,
				'I am having trouble with this file name:',
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						4,
						$author$project$Compiler$Reporting$Doc$red(
							$author$project$Compiler$Reporting$Doc$fromPath(givenPath))),
						$author$project$Compiler$Reporting$Doc$reflow(
						'I found it in your ' + ($author$project$Extra$System$File$toString(srcDir) + ('/ directory' + (' which is good, but I expect all of the files in there to use the following' + ' module naming convention:')))),
						A2(
						$author$project$Builder$Reporting$Exit$toModuleNameConventionTable,
						srcDir,
						_List_fromArray(
							['Main', 'HomePage', 'Http.Helpers'])),
						$author$project$Compiler$Reporting$Doc$reflow('Notice that the names always start with capital letters! Can you make your file' + ' use this naming convention?'),
						$author$project$Compiler$Reporting$Doc$toSimpleNote('Having a strict naming convention like this makes it a lot easier to find' + (' things in large projects. If you see a module imported, you know where to look' + ' for the corresponding file every time!'))
					]));
		case 'BP_CannotLoadDependencies':
			return $author$project$Builder$Reporting$Exit$corruptCacheReport;
		case 'BP_Cycle':
			var name = projectProblem.a;
			var names = projectProblem.b;
			return A4(
				$author$project$Builder$Reporting$Exit$Help$report,
				'IMPORT CYCLE',
				$elm$core$Maybe$Nothing,
				'Your module imports form a cycle:',
				_List_fromArray(
					[
						A3($author$project$Compiler$Reporting$Doc$cycle, 4, name, names),
						$author$project$Compiler$Reporting$Doc$reflow(
						'Learn more about why this is disallowed and how to break cycles here:' + $author$project$Compiler$Reporting$Doc$makeLink('import-cycles'))
					]));
		default:
			var _v1 = projectProblem.a;
			var _v2 = _v1.a;
			var name = _v2.a;
			var problem = _v2.b;
			switch (problem.$) {
				case 'NotFound':
					return A4(
						$author$project$Builder$Reporting$Exit$Help$report,
						'MISSING MODULE',
						$elm$core$Maybe$Just(
							$author$project$Extra$System$File$fromString('elm.json')),
						'The  \"exposed-modules\" of your elm.json lists the following module:',
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$red(
									$author$project$Compiler$Reporting$Doc$fromName(name))),
								$author$project$Compiler$Reporting$Doc$reflow('But I cannot find it in your src/ directory. Is there a typo? Was it renamed?')
							]));
				case 'Ambiguous':
					var pkg = problem.b;
					return A4(
						$author$project$Builder$Reporting$Exit$Help$report,
						'AMBIGUOUS MODULE NAME',
						$elm$core$Maybe$Just(
							$author$project$Extra$System$File$fromString('elm.json')),
						'The  \"exposed-modules\" of your elm.json lists the following module:',
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$red(
									$author$project$Compiler$Reporting$Doc$fromName(name))),
								$author$project$Compiler$Reporting$Doc$reflow(
								'But a module from ' + ($author$project$Compiler$Elm$Package$toChars(pkg) + (' already uses that name. Try' + ' choosing a different name for your local file.')))
							]));
				case 'AmbiguousLocal':
					var path1 = problem.a;
					var path2 = problem.b;
					var paths = problem.c;
					return A4(
						$author$project$Builder$Reporting$Exit$Help$report,
						'AMBIGUOUS MODULE NAME',
						$elm$core$Maybe$Just(
							$author$project$Extra$System$File$fromString('elm.json')),
						'The  \"exposed-modules\" of your elm.json lists the following module:',
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$red(
									$author$project$Compiler$Reporting$Doc$fromName(name))),
								$author$project$Compiler$Reporting$Doc$reflow('But I found multiple files with that name:'),
								$author$project$Compiler$Reporting$Doc$dullyellow(
								A2(
									$author$project$Compiler$Reporting$Doc$indent,
									4,
									$author$project$Compiler$Reporting$Doc$vcat(
										A2(
											$author$project$Extra$Type$List$map,
											$author$project$Compiler$Reporting$Doc$fromPath,
											A2(
												$elm$core$List$cons,
												path1,
												A2($elm$core$List$cons, path2, paths)))))),
								$author$project$Compiler$Reporting$Doc$reflow('Change the module names to be distinct!')
							]));
				default:
					return A4(
						$author$project$Builder$Reporting$Exit$Help$report,
						'MISSING MODULE',
						$elm$core$Maybe$Just(
							$author$project$Extra$System$File$fromString('elm.json')),
						'The  \"exposed-modules\" of your elm.json lists the following module:',
						_List_fromArray(
							[
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$red(
									$author$project$Compiler$Reporting$Doc$fromName(name))),
								$author$project$Compiler$Reporting$Doc$reflow('But I cannot find it in your src/ directory. Is there a typo? Was it renamed?'),
								$author$project$Compiler$Reporting$Doc$toSimpleNote('It is not possible to \"re-export\" modules from other packages. You can only' + ' expose modules that you define in your own code.')
							]));
			}
	}
};
var $author$project$Builder$Reporting$Exit$replToReport = function (problem) {
	switch (problem.$) {
		case 'ReplBadDetails':
			var details = problem.a;
			return $author$project$Builder$Reporting$Exit$toDetailsReport(details);
		case 'ReplBadInput':
			var source = problem.a;
			var err = problem.b;
			return A3(
				$author$project$Builder$Reporting$Exit$Help$compilerReport,
				$author$project$Extra$System$File$fromString('/'),
				A5(
					$author$project$Compiler$Reporting$Error$Module,
					$author$project$Compiler$Data$Name$replModule,
					$author$project$Extra$System$File$fromString('REPL'),
					$author$project$Builder$File$zeroTime,
					source,
					err),
				_List_Nil);
		case 'ReplBadLocalDeps':
			var root = problem.a;
			var e = problem.b;
			var es = problem.c;
			return A3($author$project$Builder$Reporting$Exit$Help$compilerReport, root, e, es);
		case 'ReplProjectProblem':
			var projectProblem = problem.a;
			return $author$project$Builder$Reporting$Exit$toProjectProblemReport(projectProblem);
		case 'ReplBadGenerate':
			var generate = problem.a;
			return $author$project$Builder$Reporting$Exit$toGenerateReport(generate);
		case 'ReplBadCache':
			return $author$project$Builder$Reporting$Exit$corruptCacheReport;
		default:
			return $author$project$Builder$Reporting$Exit$corruptCacheReport;
	}
};
var $author$project$Extra$Data$Pretty$dullcyan = $the_sett$elm_pretty_printer$Pretty$setTag(
	function ($) {
		return $.dullcyan;
	});
var $author$project$Compiler$Reporting$Doc$dullcyan = $author$project$Extra$Data$Pretty$dullcyan;
var $author$project$Builder$File$toMillis = function (_v0) {
	var time = _v0.a;
	return $elm$time$Time$posixToMillis(time);
};
var $author$project$Compiler$Reporting$Error$getModificationTime = function (_v0) {
	var time = _v0.c;
	return $author$project$Builder$File$toMillis(time);
};
var $author$project$Compiler$Reporting$Error$toMessageBar = F2(
	function (title, filePath) {
		var usedSpace = ((4 + $elm$core$String$length(title)) + 1) + $elm$core$String$length(
			$author$project$Extra$System$File$toString(filePath));
		return $author$project$Compiler$Reporting$Doc$dullcyan(
			$author$project$Compiler$Reporting$Doc$fromChars(
				'-- ' + (title + (' ' + (A2(
					$elm$core$String$repeat,
					A2($elm$core$Basics$max, 1, 80 - usedSpace),
					'-') + (' ' + $author$project$Extra$System$File$toString(filePath)))))));
	});
var $author$project$Compiler$Reporting$Error$reportToDoc = F2(
	function (relativePath, _v0) {
		var title = _v0.a;
		var message = _v0.c;
		return $author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					A2($author$project$Compiler$Reporting$Error$toMessageBar, title, relativePath),
					$author$project$Compiler$Reporting$Doc$d(''),
					message,
					$author$project$Compiler$Reporting$Doc$d('')
				]));
	});
var $author$project$Compiler$Reporting$Render$Type$collectSrcArgs = function (tipe) {
	if (tipe.b.$ === 'TLambda') {
		var _v1 = tipe.b;
		var a = _v1.a;
		var result = _v1.b;
		var _v2 = $author$project$Compiler$Reporting$Render$Type$collectSrcArgs(result);
		var b = _v2.a;
		var cs = _v2.b;
		return _Utils_Tuple2(
			a,
			A2($elm$core$List$cons, b, cs));
	} else {
		return _Utils_Tuple2(tipe, _List_Nil);
	}
};
var $author$project$Compiler$Reporting$Render$Type$srcFieldToDocs = F2(
	function (tagger, _v3) {
		var _v4 = _v3.a;
		var fieldName = _v4.b;
		var fieldType = _v3.b;
		return _Utils_Tuple2(
			tagger(fieldName),
			A3($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$None, fieldType));
	});
var $author$project$Compiler$Reporting$Render$Type$srcToDoc = F3(
	function (tagger, context, _v0) {
		var tipe = _v0.b;
		switch (tipe.$) {
			case 'TLambda':
				var arg1 = tipe.a;
				var result = tipe.b;
				var _v2 = $author$project$Compiler$Reporting$Render$Type$collectSrcArgs(result);
				var arg2 = _v2.a;
				var rest = _v2.b;
				return A4(
					$author$project$Compiler$Reporting$Render$Type$lambda,
					context,
					A3($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$Func, arg1),
					A3($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$Func, arg2),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$Func),
						rest));
			case 'TVar':
				var name = tipe.a;
				return tagger(name);
			case 'TType':
				var name = tipe.b;
				var args = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					context,
					tagger(name),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$App),
						args));
			case 'TTypeQual':
				var home = tipe.b;
				var name = tipe.c;
				var args = tipe.d;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					context,
					$author$project$Compiler$Reporting$Doc$hcat(
						A2(
							$author$project$Extra$Type$List$map,
							tagger,
							_List_fromArray(
								[home, '.', name]))),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$App),
						args));
			case 'TRecord':
				var fields = tipe.a;
				var ext = tipe.b;
				return A2(
					$author$project$Compiler$Reporting$Render$Type$record,
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$Reporting$Render$Type$srcFieldToDocs(tagger),
						fields),
					A2(
						$elm$core$Maybe$map,
						A2($elm$core$Basics$composeL, tagger, $author$project$Compiler$Reporting$Annotation$toValue),
						ext));
			case 'TUnit':
				return tagger('()');
			default:
				var a = tipe.a;
				var b = tipe.b;
				var cs = tipe.c;
				return A3(
					$author$project$Compiler$Reporting$Render$Type$tuple,
					A3($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$None, a),
					A3($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$None, b),
					A2(
						$author$project$Extra$Type$List$map,
						A2($author$project$Compiler$Reporting$Render$Type$srcToDoc, tagger, $author$project$Compiler$Reporting$Render$Type$None),
						cs));
		}
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$aliasToUnionDoc = F3(
	function (name, args, tipe) {
		return $author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$hcat(
					A2(
						$author$project$Extra$Type$List$map,
						$author$project$Compiler$Reporting$Doc$dullyellowS,
						_Utils_ap(
							_List_fromArray(
								['type', name]),
							_Utils_ap(
								args,
								_List_fromArray(
									['=']))))),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					4,
					$author$project$Compiler$Reporting$Doc$greenS(name)),
					A2(
					$author$project$Compiler$Reporting$Doc$indent,
					8,
					A3($author$project$Compiler$Reporting$Render$Type$srcToDoc, $author$project$Compiler$Reporting$Doc$dullyellowS, $author$project$Compiler$Reporting$Render$Type$App, tipe))
				]));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$aliasRecursionReport = F6(
	function (source, region, name, args, tipe, others) {
		if (!others.b) {
			return A3(
				$author$project$Compiler$Reporting$Report$Report,
				'ALIAS PROBLEM',
				region,
				A4(
					$author$project$Compiler$Reporting$Render$Code$toSnippet,
					source,
					region,
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$fromChars('This type alias is recursive, forming an infinite type!'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$reflow('When I expand a recursive type alias, it just keeps getting bigger and bigger.' + ' So dealiasing results in an infinitely large type! Try this instead:'),
									A2(
									$author$project$Compiler$Reporting$Doc$indent,
									4,
									A3($author$project$Compiler$Reporting$Error$Canonicalize$aliasToUnionDoc, name, args, tipe)),
									A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'This is kind of a subtle distinction. I suggested the naive fix, but I recommend reading', 'recursive-alias', 'for ideas on how to do better.')
								])))));
		} else {
			return A3(
				$author$project$Compiler$Reporting$Report$Report,
				'ALIAS PROBLEM',
				region,
				A4(
					$author$project$Compiler$Reporting$Render$Code$toSnippet,
					source,
					region,
					$elm$core$Maybe$Nothing,
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$fromChars('This type alias is part of a mutually recursive set of type aliases.'),
						$author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fromChars('It is part of this cycle of type aliases:'),
									A3($author$project$Compiler$Reporting$Doc$cycle, 4, name, others),
									$author$project$Compiler$Reporting$Doc$reflow('You need to convert at least one of these type aliases into a `type`.'),
									A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Read', 'recursive-alias', 'to learn why this `type` vs `type alias` distinction matters. It is subtle but important!')
								])))));
		}
	});
var $author$project$Compiler$Elm$ModuleName$comparison = F2(
	function (can1, can2) {
		return A2(
			$elm$core$Basics$compare,
			$author$project$Compiler$Elm$ModuleName$toComparable(can1),
			$author$project$Compiler$Elm$ModuleName$toComparable(can2));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$toQualString_ = F2(
	function (prefix, name) {
		return prefix + ('.' + name);
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$toQualString = F2(
	function (prefix, name) {
		return A2($author$project$Compiler$Reporting$Error$Canonicalize$toQualString_, prefix, name);
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$ambiguousName = F7(
	function (source, region, maybePrefix, name, h, hs, thing) {
		var possibleHomes = A2(
			$author$project$Extra$Type$List$sortBy,
			$author$project$Compiler$Elm$ModuleName$comparison,
			A2(
				$elm$core$List$cons,
				h,
				A2($author$project$Compiler$Data$OneOrMore$destruct, $elm$core$List$cons, hs)));
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'AMBIGUOUS NAME',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				region,
				$elm$core$Maybe$Nothing,
				function () {
					if (maybePrefix.$ === 'Nothing') {
						var homeToYellowDoc = function (_v1) {
							var home = _v1.b;
							return $author$project$Compiler$Reporting$Doc$hcat(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS(home),
										$author$project$Compiler$Reporting$Doc$dullyellowS('.'),
										$author$project$Compiler$Reporting$Doc$dullyellowS(name)
									]));
						};
						return _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('This usage of `' + (name + '` is ambiguous:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow(
										'This name is exposed by ' + ($elm$core$String$fromInt(
											$author$project$Extra$Type$List$length(possibleHomes)) + (' of your imports, so I am not' + ' sure which one to use:'))),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											A2($author$project$Extra$Type$List$map, homeToYellowDoc, possibleHomes))),
										$author$project$Compiler$Reporting$Doc$reflow('I recommend using qualified names for imported values. I also recommend having' + (' at most one `exposing (..)` per file to make name clashes like this less common' + ' in the long run.')),
										A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Check out', 'imports', 'for more info on the import syntax.')
									])));
					} else {
						var prefix = maybePrefix.a;
						var homeToYellowDoc = function (_v2) {
							var home = _v2.b;
							return _Utils_eq(prefix, home) ? $author$project$Compiler$Reporting$Doc$hcat(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$cyanS('import'),
										$author$project$Compiler$Reporting$Doc$fromChars(' '),
										$author$project$Compiler$Reporting$Doc$fromName(home)
									])) : $author$project$Compiler$Reporting$Doc$hcat(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$cyanS('import'),
										$author$project$Compiler$Reporting$Doc$fromChars(' '),
										$author$project$Compiler$Reporting$Doc$fromName(home),
										$author$project$Compiler$Reporting$Doc$fromChars(' '),
										$author$project$Compiler$Reporting$Doc$cyanS('as'),
										$author$project$Compiler$Reporting$Doc$fromChars(' '),
										$author$project$Compiler$Reporting$Doc$fromName(prefix)
									]));
						};
						var eitherOrAny = ($author$project$Extra$Type$List$length(possibleHomes) === 2) ? 'either' : 'any';
						return _Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								'This usage of `' + (A2($author$project$Compiler$Reporting$Error$Canonicalize$toQualString, prefix, name) + '` is ambiguous.')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('It could refer to a ' + (thing + (' from ' + (eitherOrAny + ' of these imports:')))),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$vcat(
											A2($author$project$Extra$Type$List$map, homeToYellowDoc, possibleHomes))),
										A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'imports', 'to learn how to clarify which one you want.')
									])));
					}
				}()));
	});
var $author$project$Compiler$Reporting$Doc$args = function (n) {
	return _Utils_ap(
		$elm$core$String$fromInt(n),
		(n === 1) ? ' argument' : ' arguments');
};
var $author$project$Compiler$Reporting$Doc$commaSep = F3(
	function (conjunction, addStyle, names) {
		_v0$2:
		while (true) {
			if (names.b) {
				if (!names.b.b) {
					var name = names.a;
					return _List_fromArray(
						[
							addStyle(name)
						]);
				} else {
					if (!names.b.b.b) {
						var name1 = names.a;
						var _v1 = names.b;
						var name2 = _v1.a;
						return _List_fromArray(
							[
								addStyle(name1),
								conjunction,
								addStyle(name2)
							]);
					} else {
						break _v0$2;
					}
				}
			} else {
				break _v0$2;
			}
		}
		return _Utils_ap(
			A2(
				$author$project$Extra$Type$List$map,
				function (name) {
					return $author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								addStyle(name),
								$author$project$Compiler$Reporting$Doc$fromChars(',')
							]));
				},
				$author$project$Extra$Type$List$init(names)),
			_List_fromArray(
				[
					conjunction,
					addStyle(
					$author$project$Extra$Type$List$last(names))
				]));
	});
var $author$project$Compiler$Reporting$Render$Code$OneLine = function (a) {
	return {$: 'OneLine', a: a};
};
var $author$project$Compiler$Reporting$Render$Code$TwoChunks = F2(
	function (a, b) {
		return {$: 'TwoChunks', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Render$Code$renderPair = F3(
	function (source, region1, region2) {
		var sourceLines = source.a;
		var _v0 = region2;
		var _v1 = _v0.a;
		var startRow2 = _v1.a;
		var startCol2 = _v1.b;
		var _v2 = _v0.b;
		var endRow2 = _v2.a;
		var endCol2 = _v2.b;
		var _v3 = region1;
		var _v4 = _v3.a;
		var startRow1 = _v4.a;
		var startCol1 = _v4.b;
		var _v5 = _v3.b;
		var endRow1 = _v5.a;
		var endCol1 = _v5.b;
		if (_Utils_eq(startRow1, endRow1) && (_Utils_eq(endRow1, startRow2) && _Utils_eq(startRow2, endRow2))) {
			var zigzag2 = A2($elm$core$String$repeat, endCol2 - startCol2, '^');
			var zigzag1 = A2($elm$core$String$repeat, endCol1 - startCol1, '^');
			var spaces2 = A2($elm$core$String$repeat, startCol2 - endCol1, ' ');
			var lineNumber = $elm$core$String$fromInt(startRow1);
			var spaces1 = A2(
				$elm$core$String$repeat,
				(startCol1 + $elm$core$String$length(lineNumber)) + 1,
				' ');
			var line = A2(
				$elm$core$Maybe$withDefault,
				'',
				A2($author$project$Extra$Type$List$lookup, startRow1, sourceLines));
			return $author$project$Compiler$Reporting$Render$Code$OneLine(
				$author$project$Compiler$Reporting$Doc$vcat(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$hcat(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fromChars(lineNumber),
									$author$project$Compiler$Reporting$Doc$fromChars('| '),
									$author$project$Compiler$Reporting$Doc$fromChars(line)
								])),
							$author$project$Compiler$Reporting$Doc$hcat(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fromChars(spaces1),
									$author$project$Compiler$Reporting$Doc$redS(zigzag1),
									$author$project$Compiler$Reporting$Doc$fromChars(spaces2),
									$author$project$Compiler$Reporting$Doc$redS(zigzag2)
								]))
						])));
		} else {
			return A2(
				$author$project$Compiler$Reporting$Render$Code$TwoChunks,
				A3($author$project$Compiler$Reporting$Render$Code$render, source, region1, $elm$core$Maybe$Nothing),
				A3($author$project$Compiler$Reporting$Render$Code$render, source, region2, $elm$core$Maybe$Nothing));
		}
	});
var $author$project$Compiler$Reporting$Render$Code$toPair = F5(
	function (source, r1, r2, _v0, _v1) {
		var oneStart = _v0.a;
		var oneEnd = _v0.b;
		var twoStart = _v1.a;
		var twoMiddle = _v1.b;
		var twoEnd = _v1.c;
		var _v2 = A3($author$project$Compiler$Reporting$Render$Code$renderPair, source, r1, r2);
		if (_v2.$ === 'OneLine') {
			var codeDocs = _v2.a;
			return $author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						oneStart,
						$author$project$Compiler$Reporting$Doc$fromChars(''),
						codeDocs,
						oneEnd
					]));
		} else {
			var code1 = _v2.a;
			var code2 = _v2.b;
			return $author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						twoStart,
						$author$project$Compiler$Reporting$Doc$fromChars(''),
						code1,
						twoMiddle,
						$author$project$Compiler$Reporting$Doc$fromChars(''),
						code2,
						twoEnd
					]));
		}
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$nameClash = F4(
	function (source, r1, r2, messageThatEndsWithPunctuation) {
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'NAME CLASH',
			r2,
			A5(
				$author$project$Compiler$Reporting$Render$Code$toPair,
				source,
				r1,
				r2,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow(messageThatEndsWithPunctuation),
					$author$project$Compiler$Reporting$Doc$fromChars('How can I know which one you want? Rename one of them!')),
				_Utils_Tuple3(
					$author$project$Compiler$Reporting$Doc$reflow(messageThatEndsWithPunctuation + ' One here:'),
					$author$project$Compiler$Reporting$Doc$fromChars('And another one here:'),
					$author$project$Compiler$Reporting$Doc$fromChars('How can I know which one you want? Rename one of them!'))));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$notFound = F6(
	function (source, region, maybePrefix, name, thing, _v0) {
		var locals = _v0.a;
		var quals = _v0.b;
		var possibleNames = function () {
			var addQuals = F3(
				function (prefix, localSet, allNames) {
					return A3(
						$author$project$Extra$Type$Set$foldr,
						F2(
							function (x, xs) {
								return A2(
									$elm$core$List$cons,
									A2($author$project$Compiler$Reporting$Error$Canonicalize$toQualString_, prefix, x),
									xs);
							}),
						allNames,
						localSet);
				});
			return A3(
				$author$project$Extra$Type$Map$foldrWithKey,
				addQuals,
				$author$project$Extra$Type$Set$toList(locals),
				quals);
		}();
		var givenName = A4($author$project$Extra$Type$Maybe$maybe, $elm$core$Basics$identity, $author$project$Compiler$Reporting$Error$Canonicalize$toQualString, maybePrefix, name);
		var nearbyNames = A2(
			$author$project$Extra$Type$List$take,
			4,
			A3($author$project$Compiler$Reporting$Suggest$sort, givenName, $elm$core$Basics$identity, possibleNames));
		var toDetails = F2(
			function (noSuggestionDetails, yesSuggestionDetails) {
				if (!nearbyNames.b) {
					return $author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow(noSuggestionDetails),
								A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'Read', 'imports', 'to see how `import` declarations work in Elm.')
							]));
				} else {
					var suggestions = nearbyNames;
					return $author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow(yesSuggestionDetails),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$vcat(
									A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Doc$dullyellowS, suggestions))),
								A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'Read', 'imports', 'to see how `import` declarations work in Elm.')
							]));
				}
			});
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'NAMING ERROR',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				region,
				$elm$core$Maybe$Nothing,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I cannot find a `' + (givenName + ('` ' + (thing + ':')))),
					function () {
						if (maybePrefix.$ === 'Nothing') {
							return A2(toDetails, 'Is there an `import` or `exposing` missing up top?', 'These names seem close though:');
						} else {
							var prefix = maybePrefix.a;
							var _v2 = A2($author$project$Extra$Type$Map$lookup, prefix, quals);
							if (_v2.$ === 'Nothing') {
								return A2(toDetails, 'I cannot find a `' + (prefix + '` module. Is there an `import` for it?'), 'I cannot find a `' + (prefix + '` import. These names seem close though:'));
							} else {
								return A2(toDetails, 'The `' + (prefix + ('` module does not expose a `' + (name + ('` ' + (thing + '.'))))), 'The `' + (prefix + ('` module does not expose a `' + (name + ('` ' + (thing + '. These names seem close though:'))))));
							}
						}
					}())));
	});
var $author$project$Extra$Type$List$notelem = F2(
	function (a, l) {
		return !A2($author$project$Extra$Type$List$elem, a, l);
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$toKindInfo = F2(
	function (kind, name) {
		switch (kind.$) {
			case 'BadOp':
				return _Utils_Tuple3(
					$author$project$Compiler$Reporting$Doc$fromChars('an'),
					$author$project$Compiler$Reporting$Doc$fromChars('operator'),
					$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('('),
								$author$project$Compiler$Reporting$Doc$fromName(name),
								$author$project$Compiler$Reporting$Doc$fromChars(')')
							])));
			case 'BadVar':
				return _Utils_Tuple3(
					$author$project$Compiler$Reporting$Doc$fromChars('a'),
					$author$project$Compiler$Reporting$Doc$fromChars('value'),
					$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('`'),
								$author$project$Compiler$Reporting$Doc$fromName(name),
								$author$project$Compiler$Reporting$Doc$fromChars('`')
							])));
			default:
				return _Utils_Tuple3(
					$author$project$Compiler$Reporting$Doc$fromChars('a'),
					$author$project$Compiler$Reporting$Doc$fromChars('type'),
					$author$project$Compiler$Reporting$Doc$hcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('`'),
								$author$project$Compiler$Reporting$Doc$fromName(name),
								$author$project$Compiler$Reporting$Doc$fromChars('`')
							])));
		}
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$unboundTypeVars = F7(
	function (source, declRegion, tipe, typeName, allVars, _v0, unboundVars) {
		var unboundVar = _v0.a;
		var varRegion = _v0.b;
		var backQuote = F2(
			function (tagger, name) {
				return $author$project$Compiler$Reporting$Doc$hcat(
					_List_fromArray(
						[
							tagger('`'),
							tagger(name),
							tagger('`')
						]));
			});
		var _v1 = function () {
			var _v2 = A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, unboundVars);
			if (!_v2.b) {
				return _Utils_Tuple3(
					'UNBOUND TYPE VARIABLE',
					$elm$core$Maybe$Just(varRegion),
					_Utils_ap(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('The'),
								A2(backQuote, $author$project$Compiler$Reporting$Doc$fromChars, typeName)
							]),
						_Utils_ap(
							tipe,
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$reflow('uses an unbound type variable'),
									A2(backQuote, $author$project$Compiler$Reporting$Doc$dullyellowS, unboundVar),
									$author$project$Compiler$Reporting$Doc$reflow('in its definition:')
								]))));
			} else {
				var vars = _v2;
				return _Utils_Tuple3(
					'UNBOUND TYPE VARIABLES',
					$elm$core$Maybe$Nothing,
					_Utils_ap(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fromChars('Type'),
								$author$project$Compiler$Reporting$Doc$fromChars('variables')
							]),
						_Utils_ap(
							A3(
								$author$project$Compiler$Reporting$Doc$commaSep,
								$author$project$Compiler$Reporting$Doc$fromChars('and'),
								$author$project$Compiler$Reporting$Doc$dullyellowS,
								A2($elm$core$List$cons, unboundVar, vars)),
							_Utils_ap(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('are unbound in the'),
										A2(backQuote, $author$project$Compiler$Reporting$Doc$fromChars, typeName)
									]),
								_Utils_ap(
									tipe,
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fromChars('definition:')
										]))))));
			}
		}();
		var title = _v1.a;
		var subRegion = _v1.b;
		var overview = _v1.c;
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			title,
			declRegion,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				declRegion,
				subRegion,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$fillSep(overview),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('You probably need to change the declaration to something like this:'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$hsep(
									_Utils_ap(
										tipe,
										A2(
											$elm$core$List$cons,
											$author$project$Compiler$Reporting$Doc$fromName(typeName),
											_Utils_ap(
												A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Doc$fromName, allVars),
												_Utils_ap(
													A2(
														$author$project$Extra$Type$List$map,
														$author$project$Compiler$Reporting$Doc$greenS,
														A2(
															$elm$core$List$cons,
															unboundVar,
															A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, unboundVars))),
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$fromChars('='),
															$author$project$Compiler$Reporting$Doc$fromChars('...')
														]))))))),
								$author$project$Compiler$Reporting$Doc$reflow('Why? Well, imagine one `' + (typeName + ('` where `' + (unboundVar + ('` is an Int and another where it is a Bool. When we explicitly list the type' + ' variables, the type checker can see that they are actually different types.')))))
							])))));
	});
var $author$project$Compiler$Reporting$Error$Canonicalize$toReport = F2(
	function (source, err) {
		switch (err.$) {
			case 'AnnotationTooShort':
				var region = err.a;
				var name = err.b;
				var index = err.c;
				var leftovers = err.d;
				var numTypeArgs = $author$project$Compiler$Data$Index$toMachine(index);
				var numDefArgs = numTypeArgs + leftovers;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD TYPE ANNOTATION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								('The type annotation for `' + (name + '` says it can accept ')) + (($author$project$Compiler$Reporting$Doc$args(numTypeArgs) + ', but the definition says it has ') + ($author$project$Compiler$Reporting$Doc$args(numDefArgs) + ':'))),
							$author$project$Compiler$Reporting$Doc$reflow(
								'Is the type annotation missing something? Should some argument' + (((leftovers === 1) ? '' : 's') + ' be deleted? Maybe some parentheses are missing?')))));
			case 'AmbiguousVar':
				var region = err.a;
				var maybePrefix = err.b;
				var name = err.c;
				var h = err.d;
				var hs = err.e;
				return A7($author$project$Compiler$Reporting$Error$Canonicalize$ambiguousName, source, region, maybePrefix, name, h, hs, 'variable');
			case 'AmbiguousType':
				var region = err.a;
				var maybePrefix = err.b;
				var name = err.c;
				var h = err.d;
				var hs = err.e;
				return A7($author$project$Compiler$Reporting$Error$Canonicalize$ambiguousName, source, region, maybePrefix, name, h, hs, 'type');
			case 'AmbiguousVariant':
				var region = err.a;
				var maybePrefix = err.b;
				var name = err.c;
				var h = err.d;
				var hs = err.e;
				return A7($author$project$Compiler$Reporting$Error$Canonicalize$ambiguousName, source, region, maybePrefix, name, h, hs, 'variant');
			case 'AmbiguousBinop':
				var region = err.a;
				var name = err.b;
				var h = err.c;
				var hs = err.d;
				return A7($author$project$Compiler$Reporting$Error$Canonicalize$ambiguousName, source, region, $elm$core$Maybe$Nothing, name, h, hs, 'operator');
			case 'BadArity':
				var region = err.a;
				var badArityContext = err.b;
				var name = err.c;
				var expected = err.d;
				var actual = err.e;
				var thing = function () {
					if (badArityContext.$ === 'TypeArity') {
						return 'type';
					} else {
						return 'variant';
					}
				}();
				return (_Utils_cmp(actual, expected) < 0) ? A3(
					$author$project$Compiler$Reporting$Report$Report,
					'TOO FEW ARGS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								('The `' + (name + ('` ' + (thing + ' needs ')))) + ($author$project$Compiler$Reporting$Doc$args(expected) + (', but I see ' + ($elm$core$String$fromInt(actual) + ' instead:')))),
							$author$project$Compiler$Reporting$Doc$reflow('What is missing? Are some parentheses misplaced?')))) : A3(
					$author$project$Compiler$Reporting$Report$Report,
					'TOO MANY ARGS',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								('The `' + (name + ('` ' + (thing + ' needs ')))) + ($author$project$Compiler$Reporting$Doc$args(expected) + (', but I see ' + ($elm$core$String$fromInt(actual) + ' instead:')))),
							((actual - expected) === 1) ? $author$project$Compiler$Reporting$Doc$fromChars('Which is the extra one? Maybe some parentheses are missing?') : $author$project$Compiler$Reporting$Doc$fromChars('Which are the extra ones? Maybe some parentheses are missing?'))));
			case 'Binop':
				var region = err.a;
				var op1 = err.b;
				var op2 = err.c;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'INFIX PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('You cannot mix (' + (op1 + (') and (' + (op2 + ') without parentheses.')))),
							$author$project$Compiler$Reporting$Doc$reflow('I do not know how to group these expressions. Add parentheses for me!'))));
			case 'DuplicateDecl':
				var name = err.a;
				var r1 = err.b;
				var r2 = err.c;
				return A4($author$project$Compiler$Reporting$Error$Canonicalize$nameClash, source, r1, r2, 'This file has multiple `' + (name + '` declarations.'));
			case 'DuplicateType':
				var name = err.a;
				var r1 = err.b;
				var r2 = err.c;
				return A4($author$project$Compiler$Reporting$Error$Canonicalize$nameClash, source, r1, r2, 'This file defines multiple `' + (name + '` types.'));
			case 'DuplicateCtor':
				var name = err.a;
				var r1 = err.b;
				var r2 = err.c;
				return A4($author$project$Compiler$Reporting$Error$Canonicalize$nameClash, source, r1, r2, 'This file defines multiple `' + (name + '` type constructors.'));
			case 'DuplicateField':
				var name = err.a;
				var r1 = err.b;
				var r2 = err.c;
				return A4($author$project$Compiler$Reporting$Error$Canonicalize$nameClash, source, r1, r2, 'This record has multiple `' + (name + '` fields.'));
			case 'DuplicateAliasArg':
				var typeName = err.a;
				var name = err.b;
				var r1 = err.c;
				var r2 = err.d;
				return A4($author$project$Compiler$Reporting$Error$Canonicalize$nameClash, source, r1, r2, 'The `' + (typeName + ('` type alias has multiple `' + (name + '` type variables.'))));
			case 'DuplicateUnionArg':
				var typeName = err.a;
				var name = err.b;
				var r1 = err.c;
				var r2 = err.d;
				return A4($author$project$Compiler$Reporting$Error$Canonicalize$nameClash, source, r1, r2, 'The `' + (typeName + ('` type has multiple `' + (name + '` type variables.'))));
			case 'DuplicatePattern':
				var context = err.a;
				var name = err.b;
				var r1 = err.c;
				var r2 = err.d;
				return A4(
					$author$project$Compiler$Reporting$Error$Canonicalize$nameClash,
					source,
					r1,
					r2,
					function () {
						switch (context.$) {
							case 'DPLambdaArgs':
								return 'This anonymous function has multiple `' + (name + '` arguments.');
							case 'DPFuncArgs':
								var funcName = context.a;
								return 'The `' + (funcName + ('` function has multiple `' + (name + '` arguments.')));
							case 'DPCaseBranch':
								return 'This `case` pattern has multiple `' + (name + '` variables.');
							case 'DPLetBinding':
								return 'This `let` expression defines `' + (name + '` more than once!');
							default:
								return 'This pattern contains multiple `' + (name + '` variables.');
						}
					}());
			case 'EffectNotFound':
				var region = err.a;
				var name = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EFFECT PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('You have declared that `' + (name + '` is an effect type:')),
							$author$project$Compiler$Reporting$Doc$reflow('But I cannot find a custom type named `' + (name + '` in this file!')))));
			case 'EffectFunctionNotFound':
				var region = err.a;
				var name = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'EFFECT PROBLEM',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('This kind of effect module must define a `' + (name + '` function.')),
							$author$project$Compiler$Reporting$Doc$reflow('But I cannot find `' + (name + '` in this file!')))));
			case 'ExportDuplicate':
				var name = err.a;
				var r1 = err.b;
				var r2 = err.c;
				var messageThatEndsWithPunctuation = 'You are trying to expose `' + (name + '` multiple times!');
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'REDUNDANT EXPORT',
					r2,
					A5(
						$author$project$Compiler$Reporting$Render$Code$toPair,
						source,
						r1,
						r2,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(messageThatEndsWithPunctuation),
							$author$project$Compiler$Reporting$Doc$fromChars('Remove one of them and you should be all set!')),
						_Utils_Tuple3(
							$author$project$Compiler$Reporting$Doc$reflow(messageThatEndsWithPunctuation + ' Once here:'),
							$author$project$Compiler$Reporting$Doc$fromChars('And again right here:'),
							$author$project$Compiler$Reporting$Doc$fromChars('Remove one of them and you should be all set!'))));
			case 'ExportNotFound':
				var region = err.a;
				var kind = err.b;
				var rawName = err.c;
				var possibleNames = err.d;
				var suggestions = A2(
					$author$project$Extra$Type$List$take,
					4,
					A3($author$project$Compiler$Reporting$Suggest$sort, rawName, $elm$core$Basics$identity, possibleNames));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'UNKNOWN EXPORT',
					region,
					function () {
						var _v3 = A2($author$project$Compiler$Reporting$Error$Canonicalize$toKindInfo, kind, rawName);
						var a = _v3.a;
						var thing = _v3.b;
						var name = _v3.c;
						return $author$project$Compiler$Reporting$Doc$stack(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$fillSep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$reflow('You are trying to expose'),
											a,
											thing,
											$author$project$Compiler$Reporting$Doc$fromChars('named'),
											name,
											$author$project$Compiler$Reporting$Doc$reflow('but I cannot find its definition.')
										])),
									function () {
									if (!suggestions.b) {
										return $author$project$Compiler$Reporting$Doc$reflow('I do not see any super similar names in this file. Is the definition missing?');
									} else {
										if (!suggestions.b.b) {
											var alt = suggestions.a;
											return $author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
														$author$project$Compiler$Reporting$Doc$dullyellowS(alt),
														$author$project$Compiler$Reporting$Doc$fromChars('instead?')
													]));
										} else {
											var alts = suggestions;
											return $author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('These names seem close though:'),
														A2(
														$author$project$Compiler$Reporting$Doc$indent,
														4,
														$author$project$Compiler$Reporting$Doc$vcat(
															A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Doc$dullyellowS, alts)))
													]));
										}
									}
								}()
								]));
					}());
			case 'ExportOpenAlias':
				var region = err.a;
				var name = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD EXPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('The (..) syntax is for exposing variants of a custom type. It cannot be used with a type alias like `' + (name + '` though.')),
							$author$project$Compiler$Reporting$Doc$reflow('Remove the (..) and you should be fine!'))));
			case 'ImportCtorByName':
				var region = err.a;
				var ctor = err.b;
				var tipe = err.c;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('You are trying to import the `' + (ctor + '` variant by name:')),
							$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('Try importing'),
										$author$project$Compiler$Reporting$Doc$greenS(tipe + '(..)'),
										$author$project$Compiler$Reporting$Doc$fromChars('instead.'),
										$author$project$Compiler$Reporting$Doc$reflow('The dots mean expose the'),
										$author$project$Compiler$Reporting$Doc$fromName(tipe),
										$author$project$Compiler$Reporting$Doc$reflow('type and'),
										$author$project$Compiler$Reporting$Doc$reflow('all its variants so it gives you access to'),
										$author$project$Compiler$Reporting$Doc$fromName(ctor),
										$author$project$Compiler$Reporting$Doc$fromChars('.')
									])))));
			case 'ImportOpenAlias':
				var region = err.a;
				var name = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('The `' + (name + '` type alias cannot be followed by (..) like this:')),
							$author$project$Compiler$Reporting$Doc$reflow('Remove the (..) and it should work.'))));
			case 'ImportExposingNotFound':
				var region = err.a;
				var _v5 = err.b;
				var home = _v5.b;
				var value = err.c;
				var possibleNames = err.d;
				var suggestions = A2(
					$author$project$Extra$Type$List$take,
					4,
					A3($author$project$Compiler$Reporting$Suggest$sort, home, $elm$core$Basics$identity, possibleNames));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('The `' + (home + ('` module does not expose `' + (value + '`:')))),
							function () {
								if (!suggestions.b) {
									return $author$project$Compiler$Reporting$Doc$fromChars('I cannot find any super similar exposed names. Maybe it is private?');
								} else {
									if (!suggestions.b.b) {
										var alt = suggestions.a;
										return $author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
													$author$project$Compiler$Reporting$Doc$dullyellowS(alt),
													$author$project$Compiler$Reporting$Doc$fromChars('instead?')
												]));
									} else {
										var alts = suggestions;
										return $author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fromChars('These names seem close though:'),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$vcat(
														A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Doc$dullyellowS, alts)))
												]));
									}
								}
							}())));
			case 'NotFoundVar':
				var region = err.a;
				var prefix = err.b;
				var name = err.c;
				var possibleNames = err.d;
				return A6($author$project$Compiler$Reporting$Error$Canonicalize$notFound, source, region, prefix, name, 'variable', possibleNames);
			case 'NotFoundType':
				var region = err.a;
				var prefix = err.b;
				var name = err.c;
				var possibleNames = err.d;
				return A6($author$project$Compiler$Reporting$Error$Canonicalize$notFound, source, region, prefix, name, 'type', possibleNames);
			case 'NotFoundVariant':
				var region = err.a;
				var prefix = err.b;
				var name = err.c;
				var possibleNames = err.d;
				return A6($author$project$Compiler$Reporting$Error$Canonicalize$notFound, source, region, prefix, name, 'variant', possibleNames);
			case 'NotFoundBinop':
				var region = err.a;
				var op = err.b;
				var locals = err.c;
				if (op === '===') {
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNKNOWN OPERATOR',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$fromChars('Elm does not have a (===) operator like JavaScript.'),
								$author$project$Compiler$Reporting$Doc$fromChars('Switch to (==) instead.'))));
				} else {
					if ((op === '!=') || (op === '!==')) {
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'UNKNOWN OPERATOR',
							region,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								region,
								$elm$core$Maybe$Nothing,
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('Elm uses a different name for the not equal operator:'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Switch to (/=) instead.'),
												$author$project$Compiler$Reporting$Doc$toSimpleNote('Our (/=) operator is supposed to look like a real not equal sign (). I hope that history will remember (' + (op + ') as a weird and temporary choice.'))
											])))));
					} else {
						if (op === '**') {
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								'UNKNOWN OPERATOR',
								region,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									region,
									$elm$core$Maybe$Nothing,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('I do not recognize the (**) operator:'),
										$author$project$Compiler$Reporting$Doc$reflow('Switch to (^) for exponentiation. Or switch to (*) for multiplication.'))));
						} else {
							if (op === '%') {
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'UNKNOWN OPERATOR',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										region,
										$elm$core$Maybe$Nothing,
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('Elm does not use (%) as the remainder operator:'),
											$author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow('If you want the behavior of (%) like in JavaScript, switch to:' + ' <https://package.elm-lang.org/packages/elm/core/latest/Basics#remainderBy>'),
														$author$project$Compiler$Reporting$Doc$reflow('If you want modular arithmetic like in math, switch to:' + ' <https://package.elm-lang.org/packages/elm/core/latest/Basics#modBy>'),
														$author$project$Compiler$Reporting$Doc$reflow('The difference is how things work when negative numbers are involved.')
													])))));
							} else {
								var suggestions = A2(
									$author$project$Extra$Type$List$take,
									2,
									A3(
										$author$project$Compiler$Reporting$Suggest$sort,
										op,
										$elm$core$Basics$identity,
										$author$project$Extra$Type$Set$toList(locals)));
								var format = function (altOp) {
									return $author$project$Compiler$Reporting$Doc$greenS('(' + (altOp + ')'));
								};
								return A3(
									$author$project$Compiler$Reporting$Report$Report,
									'UNKNOWN OPERATOR',
									region,
									A4(
										$author$project$Compiler$Reporting$Render$Code$toSnippet,
										source,
										region,
										$elm$core$Maybe$Nothing,
										_Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow('I do not recognize the (' + (op + ') operator.')),
											$author$project$Compiler$Reporting$Doc$fillSep(
												A2(
													$elm$core$List$cons,
													$author$project$Compiler$Reporting$Doc$reflow('Is there an `import` and `exposing` entry for it?'),
													function () {
														if (!suggestions.b) {
															return _List_Nil;
														} else {
															var alts = suggestions;
															return A2(
																$elm$core$List$cons,
																$author$project$Compiler$Reporting$Doc$reflow('Maybe you want'),
																_Utils_ap(
																	A3(
																		$author$project$Compiler$Reporting$Doc$commaSep,
																		$author$project$Compiler$Reporting$Doc$fromChars('or'),
																		format,
																		alts),
																	_List_fromArray(
																		[
																			$author$project$Compiler$Reporting$Doc$fromChars('instead?')
																		])));
														}
													}())))));
							}
						}
					}
				}
			case 'PatternHasRecordCtor':
				var region = err.a;
				var name = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD PATTERN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('You can construct records by using `' + (name + '` as a function, but it is not available in pattern matching like this:')),
							$author$project$Compiler$Reporting$Doc$reflow('I recommend matching the record as a variable and unpacking it later.'))));
			case 'PortPayloadInvalid':
				var region = err.a;
				var portName = err.b;
				var invalidPayload = err.c;
				var formatDetails = function (_v9) {
					var aBadKindOfThing = _v9.a;
					var elaboration = _v9.b;
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'PORT ERROR',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('The `' + (portName + ('` port is trying to transmit ' + (aBadKindOfThing + ':')))),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											elaboration,
											A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'Ports are not a traditional FFI, so if you have tons of annoying ports, definitely read', 'ports', 'to learn how they are meant to work. They require a different mindset!')
										])))));
				};
				return formatDetails(
					function () {
						switch (invalidPayload.$) {
							case 'ExtendedRecord':
								return _Utils_Tuple2(
									'an extended record',
									$author$project$Compiler$Reporting$Doc$reflow('But the exact shape of the record must be known at compile time. No type variables!'));
							case 'Function':
								return _Utils_Tuple2(
									'a function',
									$author$project$Compiler$Reporting$Doc$reflow('But functions cannot be sent in and out ports. If we allowed functions in from JS' + (' they may perform some side-effects. If we let functions out, they could produce' + ' incorrect results because Elm optimizations assume there are no side-effects.')));
							case 'TypeVariable':
								var name = invalidPayload.a;
								return _Utils_Tuple2(
									'an unspecified type',
									$author$project$Compiler$Reporting$Doc$reflow('But type variables like `' + (name + ('` cannot flow through ports.' + (' I need to know exactly what type of data I am getting, so I can guarantee that' + ' unexpected data cannot sneak in and crash the Elm program.')))));
							default:
								var name = invalidPayload.a;
								return _Utils_Tuple2(
									'a `' + (name + '` value'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I cannot handle that. The types that CAN flow in and out of Elm include:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$reflow('Ints, Floats, Bools, Strings, Maybes, Lists, Arrays,' + ' tuples, records, and JSON values.')),
												$author$project$Compiler$Reporting$Doc$reflow('Since JSON values can flow through, you can use JSON encoders and decoders' + (' to allow other types through as well. More advanced users often just do' + ' everything with encoders and decoders for more control and better errors.'))
											])));
						}
					}());
			case 'PortTypeInvalid':
				var region = err.a;
				var name = err.b;
				var portProblem = err.c;
				var formatDetails = function (_v11) {
					var before = _v11.a;
					var after = _v11.b;
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'BAD PORT',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow(before),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											after,
											A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'Read', 'ports', 'for more advice. For example, do not end up with one port per JS function!')
										])))));
				};
				return formatDetails(
					function () {
						switch (portProblem.$) {
							case 'CmdNoArg':
								return _Utils_Tuple2(
									'The `' + (name + '` port cannot be just a command.'),
									$author$project$Compiler$Reporting$Doc$reflow('It can be (() -> Cmd msg) if you just need to trigger a JavaScript' + ' function, but there is often a better way to set things up.'));
							case 'CmdExtraArgs':
								var n = portProblem.a;
								return _Utils_Tuple2(
									'The `' + (name + '` port can only send ONE value out to JavaScript.'),
									function () {
										var theseItemsInSomething = (n === 2) ? 'both of these items into a tuple or record' : ((n === 3) ? ('these ' + ($elm$core$String$fromInt(n) + ' items into a tuple or record')) : ('these ' + ($elm$core$String$fromInt(n) + ' items into a record')));
										return $author$project$Compiler$Reporting$Doc$reflow('You can put ' + (theseItemsInSomething + ' to send them out though.'));
									}());
							case 'CmdBadMsg':
								return _Utils_Tuple2(
									'The `' + (name + '` port cannot send any messages to the `update` function.'),
									$author$project$Compiler$Reporting$Doc$reflow('It must produce a (Cmd msg) type. Notice the lower case `msg` type' + (' variable. The command will trigger some JS code, but it will not send' + ' anything particular back to Elm.')));
							case 'SubBad':
								return _Utils_Tuple2(
									'There is something off about this `' + (name + '` port declaration.'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('To receive messages from JavaScript, you need to define a port like this:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$dullyellowS('port ' + (name + ' : (Int -> msg) -> Sub msg'))),
												$author$project$Compiler$Reporting$Doc$reflow('Now every time JS sends an `Int` to this port, it is converted to a `msg`.' + (' And if you subscribe, those `msg` values will be piped into your `update`' + ' function. The only thing you can customize here is the `Int` type.'))
											])));
							default:
								return _Utils_Tuple2(
									'I am confused about the `' + (name + '` port declaration.'),
									$author$project$Compiler$Reporting$Doc$reflow('Ports need to produce a command (Cmd) or a subscription (Sub) but' + ' this is neither. I do not know how to handle this.'));
						}
					}());
			case 'RecursiveAlias':
				var region = err.a;
				var name = err.b;
				var args = err.c;
				var tipe = err.d;
				var others = err.e;
				return A6($author$project$Compiler$Reporting$Error$Canonicalize$aliasRecursionReport, source, region, name, args, tipe, others);
			case 'RecursiveDecl':
				var region = err.a;
				var name = err.b;
				var names = err.c;
				var makeTheory = F2(
					function (question, details) {
						return $author$project$Compiler$Reporting$Doc$fillSep(
							_Utils_ap(
								A2(
									$author$project$Extra$Type$List$map,
									$author$project$Compiler$Reporting$Doc$dullyellowS,
									$elm$core$String$words(question)),
								A2(
									$author$project$Extra$Type$List$map,
									$author$project$Compiler$Reporting$Doc$fromChars,
									$elm$core$String$words(details))));
					});
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'CYCLIC DEFINITION',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						function () {
							if (!names.b) {
								return _Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('The `' + (name + '` value is defined directly in terms of itself, causing an infinite loop.')),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												A2(makeTheory, 'Are you trying to mutate a variable?', 'Elm does not have mutation, so when I see ' + (name + (' defined in terms of ' + (name + ', I treat it as a recursive definition. Try giving the new value a new name!')))),
												A2(makeTheory, 'Maybe you DO want a recursive value?', 'To define ' + (name + (' we need to know what ' + (name + (' is, so lets expand it. Wait, but now we need to know what ' + (name + ' is, so lets expand it... This will keep going infinitely!')))))),
												A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'The root problem is often a typo in some variable name, but I recommend reading', 'bad-recursion', 'for more detailed advice, especially if you actually do need a recursive value.')
											])));
							} else {
								return _Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('The `' + (name + '` definition is causing a very tricky infinite loop.')),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('The `' + (name + '` value depends on itself through the following chain of definitions:')),
												A3($author$project$Compiler$Reporting$Doc$cycle, 4, name, names),
												A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'The root problem is often a typo in some variable name, but I recommend reading', 'bad-recursion', 'for more detailed advice, especially if you actually do want mutually recursive values.')
											])));
							}
						}()));
			case 'RecursiveLet':
				var _v13 = err.a;
				var region = _v13.a;
				var name = _v13.b;
				var names = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'CYCLIC VALUE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						function () {
							if (!names.b) {
								var makeTheory = F2(
									function (question, details) {
										return $author$project$Compiler$Reporting$Doc$fillSep(
											_Utils_ap(
												A2(
													$author$project$Extra$Type$List$map,
													$author$project$Compiler$Reporting$Doc$dullyellowS,
													$elm$core$String$words(question)),
												A2(
													$author$project$Extra$Type$List$map,
													$author$project$Compiler$Reporting$Doc$fromChars,
													$elm$core$String$words(details))));
									});
								return _Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('The `' + (name + '` value is defined directly in terms of itself, causing an infinite loop.')),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												A2(makeTheory, 'Are you trying to mutate a variable?', ('Elm does not have mutation, so when I see ' + name) + ((' defined in terms of ' + name) + ', I treat it as a recursive definition. Try giving the new value a new name!')),
												A2(makeTheory, 'Maybe you DO want a recursive value?', ('To define ' + (name + (' we need to know what ' + name))) + ((' is, so lets expand it. Wait, but now we need to know what ' + name) + ' is, so lets expand it... This will keep going infinitely!')),
												A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'The root problem is often a typo in some variable name, but I recommend reading', 'bad-recursion', 'for more detailed advice, especially if you actually do need a recursive value.')
											])));
							} else {
								return _Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('I do not allow cyclic values in `let` expressions.'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow(('The `' + name) + '` value depends on itself through the following chain of definitions:'),
												A3($author$project$Compiler$Reporting$Doc$cycle, 4, name, names),
												A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'The root problem is often a typo in some variable name, but I recommend reading', 'bad-recursion', 'for more detailed advice, especially if you actually do want mutually recursive values.')
											])));
							}
						}()));
			case 'Shadowing':
				var name = err.a;
				var r1 = err.b;
				var r2 = err.c;
				var advice = $author$project$Compiler$Reporting$Doc$stack(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$reflow('Think of a more helpful name for one of them and you should be all set!'),
							A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Linters advise against shadowing, so Elm makes best practices the default. Read', 'shadowing', 'for more details on this choice.')
						]));
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'SHADOWING',
					r2,
					A5(
						$author$project$Compiler$Reporting$Render$Code$toPair,
						source,
						r1,
						r2,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$fromChars('These variables cannot have the same name:'),
							advice),
						_Utils_Tuple3(
							$author$project$Compiler$Reporting$Doc$reflow('The name `' + (name + '` is first defined here:')),
							$author$project$Compiler$Reporting$Doc$fromChars('But then it is defined AGAIN over here:'),
							advice)));
			case 'TupleLargerThanThree':
				var region = err.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD TUPLE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$fromChars('I only accept tuples with two or three items. This has too many:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I recommend switching to records. Each item will be named, and you can use' + ' the `point.x` syntax to access them.'),
										A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Read', 'tuples', 'for more comprehensive advice on working with large chunks of data in Elm.')
									])))));
			case 'TypeVarsUnboundInUnion':
				var unionRegion = err.a;
				var typeName = err.b;
				var allVars = err.c;
				var unbound = err.d;
				var unbounds = err.e;
				return A7(
					$author$project$Compiler$Reporting$Error$Canonicalize$unboundTypeVars,
					source,
					unionRegion,
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$fromChars('type')
						]),
					typeName,
					allVars,
					unbound,
					unbounds);
			default:
				var aliasRegion = err.a;
				var typeName = err.b;
				var allVars = err.c;
				var unusedVars = err.d;
				var unboundVars = err.e;
				var _v15 = _Utils_Tuple2(unusedVars, unboundVars);
				_v15$2:
				while (true) {
					if (_v15.a.b) {
						if (!_v15.b.b) {
							var _v16 = _v15.a;
							var unused = _v16.a;
							var unuseds = _v16.b;
							var backQuote = F2(
								function (tagger, name) {
									return $author$project$Compiler$Reporting$Doc$hcat(
										_List_fromArray(
											[
												tagger('`'),
												tagger(name),
												tagger('`')
											]));
								});
							var allUnusedNames = A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, unusedVars);
							var _v17 = function () {
								if (!unuseds.b) {
									return _Utils_Tuple2(
										_Utils_Tuple2(
											'UNUSED TYPE VARIABLE',
											$elm$core$Maybe$Just(unused.b)),
										_Utils_Tuple2(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Type alias'),
													A2(backQuote, $author$project$Compiler$Reporting$Doc$fromChars, typeName),
													$author$project$Compiler$Reporting$Doc$reflow('does not use the'),
													A2(backQuote, $author$project$Compiler$Reporting$Doc$fromChars, unused.a),
													$author$project$Compiler$Reporting$Doc$reflow('type variable.')
												]),
											_List_fromArray(
												[
													A2(backQuote, $author$project$Compiler$Reporting$Doc$dullyellowS, unused.a)
												])));
								} else {
									return _Utils_Tuple2(
										_Utils_Tuple2('UNUSED TYPE VARIABLES', $elm$core$Maybe$Nothing),
										_Utils_Tuple2(
											_Utils_ap(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('Type'),
														$author$project$Compiler$Reporting$Doc$fromChars('variables')
													]),
												_Utils_ap(
													A3(
														$author$project$Compiler$Reporting$Doc$commaSep,
														$author$project$Compiler$Reporting$Doc$fromChars('and'),
														$author$project$Compiler$Reporting$Doc$fromChars,
														allUnusedNames),
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$reflow('are unused in the'),
															A2(backQuote, $author$project$Compiler$Reporting$Doc$fromChars, typeName),
															$author$project$Compiler$Reporting$Doc$fromChars('definition.')
														]))),
											A3(
												$author$project$Compiler$Reporting$Doc$commaSep,
												$author$project$Compiler$Reporting$Doc$fromChars('and'),
												$author$project$Compiler$Reporting$Doc$dullyellowS,
												allUnusedNames)));
								}
							}();
							var _v18 = _v17.a;
							var title = _v18.a;
							var subRegion = _v18.b;
							var _v19 = _v17.b;
							var overview = _v19.a;
							var stuff = _v19.b;
							return A3(
								$author$project$Compiler$Reporting$Report$Report,
								title,
								aliasRegion,
								A4(
									$author$project$Compiler$Reporting$Render$Code$toSnippet,
									source,
									aliasRegion,
									subRegion,
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$fillSep(overview),
										$author$project$Compiler$Reporting$Doc$stack(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$fillSep(
													A2(
														$elm$core$List$cons,
														$author$project$Compiler$Reporting$Doc$reflow('I recommend removing'),
														_Utils_ap(
															stuff,
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$reflow('from the declaration, like this:')
																])))),
													A2(
													$author$project$Compiler$Reporting$Doc$indent,
													4,
													$author$project$Compiler$Reporting$Doc$hsep(
														_Utils_ap(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$fromChars('type'),
																	$author$project$Compiler$Reporting$Doc$fromChars('alias'),
																	$author$project$Compiler$Reporting$Doc$greenS(typeName)
																]),
															_Utils_ap(
																A2(
																	$author$project$Extra$Type$List$map,
																	$author$project$Compiler$Reporting$Doc$fromName,
																	A2(
																		$author$project$Extra$Type$List$filter,
																		function (n) {
																			return A2($author$project$Extra$Type$List$notelem, n, allUnusedNames);
																		},
																		allVars)),
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$fromChars('='),
																		$author$project$Compiler$Reporting$Doc$fromChars('...')
																	]))))),
													$author$project$Compiler$Reporting$Doc$reflow('Why? Well, if I allowed `type alias Height a = Float` I would need to answer' + (' some weird questions. Is `Height Bool` the same as `Float`? Is `Height Bool`' + ' the same as `Height Int`? My solution is to not need to ask them!'))
												])))));
						} else {
							break _v15$2;
						}
					} else {
						if (_v15.b.b) {
							var _v21 = _v15.b;
							var unbound = _v21.a;
							var unbounds = _v21.b;
							return A7(
								$author$project$Compiler$Reporting$Error$Canonicalize$unboundTypeVars,
								source,
								aliasRegion,
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fromChars('type'),
										$author$project$Compiler$Reporting$Doc$fromChars('alias')
									]),
								typeName,
								allVars,
								unbound,
								unbounds);
						} else {
							break _v15$2;
						}
					}
				}
				var unused = A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, unusedVars);
				var unbound = A2($author$project$Extra$Type$List$map, $elm$core$Tuple$first, unboundVars);
				var theseAreUsed = function () {
					if (unbound.b && (!unbound.b.b)) {
						var x = unbound.a;
						return _List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('Type variable'),
								$author$project$Compiler$Reporting$Doc$hcat(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('`'),
										$author$project$Compiler$Reporting$Doc$dullyellowS(x),
										$author$project$Compiler$Reporting$Doc$dullyellowS('`')
									])),
								$author$project$Compiler$Reporting$Doc$fromChars('appears'),
								$author$project$Compiler$Reporting$Doc$reflow('in the definition, but I do not see it declared.')
							]);
					} else {
						return A2(
							$elm$core$List$cons,
							$author$project$Compiler$Reporting$Doc$reflow('Type variables'),
							_Utils_ap(
								A3(
									$author$project$Compiler$Reporting$Doc$commaSep,
									$author$project$Compiler$Reporting$Doc$fromChars('and'),
									$author$project$Compiler$Reporting$Doc$dullyellowS,
									unbound),
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('are used in the definition, but I do not see them declared.')
									])));
					}
				}();
				var butTheseAreUnused = function () {
					if (unused.b && (!unused.b.b)) {
						var x = unused.a;
						return _List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('Likewise, type variable'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('`' + (x + '`')),
								$author$project$Compiler$Reporting$Doc$reflow('is delared, but not used.')
							]);
					} else {
						return A2(
							$elm$core$List$cons,
							$author$project$Compiler$Reporting$Doc$reflow('Likewise, type variables'),
							_Utils_ap(
								A3(
									$author$project$Compiler$Reporting$Doc$commaSep,
									$author$project$Compiler$Reporting$Doc$fromChars('and'),
									$author$project$Compiler$Reporting$Doc$dullyellowS,
									unused),
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('are delared, but not used.')
									])));
					}
				}();
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'TYPE VARIABLE PROBLEMS',
					aliasRegion,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						aliasRegion,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Type alias `' + (typeName + '` has some type variable problems.')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_Utils_ap(theseAreUsed, butTheseAreUnused)),
										$author$project$Compiler$Reporting$Doc$reflow('My guess is that a definition like this will work better:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$hsep(
											_Utils_ap(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$fromChars('type'),
														$author$project$Compiler$Reporting$Doc$fromChars('alias'),
														$author$project$Compiler$Reporting$Doc$fromName(typeName)
													]),
												_Utils_ap(
													A2(
														$author$project$Extra$Type$List$map,
														$author$project$Compiler$Reporting$Doc$fromName,
														A2(
															$author$project$Extra$Type$List$filter,
															function (n) {
																return A2($author$project$Extra$Type$List$notelem, n, unused);
															},
															allVars)),
													_Utils_ap(
														A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Doc$greenS, unbound),
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$fromChars('='),
																$author$project$Compiler$Reporting$Doc$fromChars('...')
															]))))))
									])))));
		}
	});
var $author$project$Compiler$Elm$Package$browser = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'browser');
var $author$project$Compiler$Elm$Package$html = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'html');
var $author$project$Compiler$Elm$Package$http = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'http');
var $author$project$Compiler$Elm$Package$url = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'url');
var $author$project$Compiler$Elm$Package$suggestions = function () {
	var time = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'time');
	var random = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'random');
	var file = A2($author$project$Compiler$Elm$Package$toName, $author$project$Compiler$Elm$Package$elm, 'file');
	return $author$project$Extra$Type$Map$fromList(
		_List_fromArray(
			[
				_Utils_Tuple2('Browser', $author$project$Compiler$Elm$Package$browser),
				_Utils_Tuple2('File', file),
				_Utils_Tuple2('File.Download', file),
				_Utils_Tuple2('File.Select', file),
				_Utils_Tuple2('Html', $author$project$Compiler$Elm$Package$html),
				_Utils_Tuple2('Html.Attributes', $author$project$Compiler$Elm$Package$html),
				_Utils_Tuple2('Html.Events', $author$project$Compiler$Elm$Package$html),
				_Utils_Tuple2('Http', $author$project$Compiler$Elm$Package$http),
				_Utils_Tuple2('Json.Decode', $author$project$Compiler$Elm$Package$json),
				_Utils_Tuple2('Json.Encode', $author$project$Compiler$Elm$Package$json),
				_Utils_Tuple2('Random', random),
				_Utils_Tuple2('Time', time),
				_Utils_Tuple2('Url.Parser', $author$project$Compiler$Elm$Package$url),
				_Utils_Tuple2('Url', $author$project$Compiler$Elm$Package$url)
			]));
}();
var $author$project$Compiler$Reporting$Error$Import$toSuggestions = F2(
	function (name, unimportedModules) {
		return A2(
			$author$project$Extra$Type$List$take,
			4,
			A3(
				$author$project$Compiler$Reporting$Suggest$sort,
				$author$project$Compiler$Elm$ModuleName$toChars(name),
				$author$project$Compiler$Elm$ModuleName$toChars,
				$author$project$Extra$Type$Set$toList(unimportedModules)));
	});
var $author$project$Compiler$Reporting$Error$Import$toReport = F2(
	function (source, _v0) {
		var region = _v0.a;
		var name = _v0.b;
		var unimportedModules = _v0.c;
		var problem = _v0.d;
		switch (problem.$) {
			case 'NotFound':
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'MODULE NOT FOUND',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								'You are trying to import a `' + ($author$project$Compiler$Elm$ModuleName$toChars(name) + '` module:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('I checked the \"dependencies\" and \"source-directories\" listed in your elm.json,' + ' but I cannot find it! Maybe it is a typo for one of these names?'),
										$author$project$Compiler$Reporting$Doc$dullyellow(
										A2(
											$author$project$Compiler$Reporting$Doc$indent,
											4,
											$author$project$Compiler$Reporting$Doc$vcat(
												A2(
													$author$project$Extra$Type$List$map,
													$author$project$Compiler$Reporting$Doc$fromName,
													A2($author$project$Compiler$Reporting$Error$Import$toSuggestions, name, unimportedModules))))),
										function () {
										var _v2 = A2($author$project$Extra$Type$Map$lookup, name, $author$project$Compiler$Elm$Package$suggestions);
										if (_v2.$ === 'Nothing') {
											return $author$project$Compiler$Reporting$Doc$toSimpleHint('If it is not a typo, check the \"dependencies\" and \"source-directories\"' + ' of your elm.json to make sure all the packages you need are listed there!');
										} else {
											var dependency = _v2.a;
											return $author$project$Compiler$Reporting$Doc$toFancyHint(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$d('Maybe'),
														$author$project$Compiler$Reporting$Doc$d('you'),
														$author$project$Compiler$Reporting$Doc$d('want'),
														$author$project$Compiler$Reporting$Doc$d('the'),
														$author$project$Compiler$Reporting$Doc$da(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$d('`'),
																$author$project$Compiler$Reporting$Doc$fromName(name),
																$author$project$Compiler$Reporting$Doc$d('`')
															])),
														$author$project$Compiler$Reporting$Doc$d('module'),
														$author$project$Compiler$Reporting$Doc$d('defined'),
														$author$project$Compiler$Reporting$Doc$d('in'),
														$author$project$Compiler$Reporting$Doc$d('the'),
														$author$project$Compiler$Reporting$Doc$fromChars(
														$author$project$Compiler$Elm$Package$toChars(dependency)),
														$author$project$Compiler$Reporting$Doc$d('package?'),
														$author$project$Compiler$Reporting$Doc$d('Running'),
														$author$project$Compiler$Reporting$Doc$green(
														$author$project$Compiler$Reporting$Doc$fromChars(
															'elm install ' + $author$project$Compiler$Elm$Package$toChars(dependency))),
														$author$project$Compiler$Reporting$Doc$d('should'),
														$author$project$Compiler$Reporting$Doc$d('make'),
														$author$project$Compiler$Reporting$Doc$d('it'),
														$author$project$Compiler$Reporting$Doc$d('available!')
													]));
										}
									}()
									])))));
			case 'Ambiguous':
				var path = problem.a;
				var pkg = problem.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'AMBIGUOUS IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								'You are trying to import a `' + ($author$project$Compiler$Elm$ModuleName$toChars(name) + '` module:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('But'),
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('found'),
												$author$project$Compiler$Reporting$Doc$d('multiple'),
												$author$project$Compiler$Reporting$Doc$d('modules'),
												$author$project$Compiler$Reporting$Doc$d('with'),
												$author$project$Compiler$Reporting$Doc$d('that'),
												$author$project$Compiler$Reporting$Doc$d('name.'),
												$author$project$Compiler$Reporting$Doc$d('One'),
												$author$project$Compiler$Reporting$Doc$d('in'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$dullyellow(
												$author$project$Compiler$Reporting$Doc$fromChars(
													$author$project$Compiler$Elm$Package$toChars(pkg))),
												$author$project$Compiler$Reporting$Doc$d('package,d'),
												$author$project$Compiler$Reporting$Doc$d('and'),
												$author$project$Compiler$Reporting$Doc$d('another'),
												$author$project$Compiler$Reporting$Doc$d('defined'),
												$author$project$Compiler$Reporting$Doc$d('locally'),
												$author$project$Compiler$Reporting$Doc$d('in'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$dullyellow(
												$author$project$Compiler$Reporting$Doc$fromPath(path)),
												$author$project$Compiler$Reporting$Doc$d('file.'),
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('do'),
												$author$project$Compiler$Reporting$Doc$d('not'),
												$author$project$Compiler$Reporting$Doc$d('have'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$d('way'),
												$author$project$Compiler$Reporting$Doc$d('to'),
												$author$project$Compiler$Reporting$Doc$d('choose'),
												$author$project$Compiler$Reporting$Doc$d('between'),
												$author$project$Compiler$Reporting$Doc$d('them.')
											])),
										$author$project$Compiler$Reporting$Doc$reflow('Try changing the name of the locally defined module to clear up the ambiguity?')
									])))));
			case 'AmbiguousLocal':
				var path1 = problem.a;
				var path2 = problem.b;
				var paths = problem.c;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'AMBIGUOUS IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								'You are trying to import a `' + ($author$project$Compiler$Elm$ModuleName$toChars(name) + '` module:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('But I found multiple files in your \"source-directories\" with that name:'),
										$author$project$Compiler$Reporting$Doc$dullyellow(
										A2(
											$author$project$Compiler$Reporting$Doc$indent,
											4,
											$author$project$Compiler$Reporting$Doc$vcat(
												A2(
													$author$project$Extra$Type$List$map,
													$author$project$Compiler$Reporting$Doc$fromPath,
													A2(
														$elm$core$List$cons,
														path1,
														A2($elm$core$List$cons, path2, paths)))))),
										$author$project$Compiler$Reporting$Doc$reflow('Change the module names to be distinct!')
									])))));
			default:
				var pkg1 = problem.a;
				var pkg2 = problem.b;
				var pkgs = problem.c;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'AMBIGUOUS IMPORT',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow(
								'You are trying to import a `' + ($author$project$Compiler$Elm$ModuleName$toChars(name) + '` module:')),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('But multiple packages in your \"dependencies\" that expose a module that name:'),
										$author$project$Compiler$Reporting$Doc$dullyellow(
										A2(
											$author$project$Compiler$Reporting$Doc$indent,
											4,
											$author$project$Compiler$Reporting$Doc$vcat(
												A2(
													$author$project$Extra$Type$List$map,
													A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$fromChars, $author$project$Compiler$Elm$Package$toChars),
													A2(
														$elm$core$List$cons,
														pkg1,
														A2($elm$core$List$cons, pkg2, pkgs)))))),
										$author$project$Compiler$Reporting$Doc$reflow('There is no way to disambiguate in cases like this right now. Of the known name' + (' clashes, they are usually for packages with similar purposes, so the current' + ' recommendation is to pick just one of them.')),
										$author$project$Compiler$Reporting$Doc$toSimpleNote('It seems possible to resolve this with new syntax in imports, but that is' + (' more complicated than it sounds. Right now, our module names are tied to GitHub' + (' repos, but we may want to get rid of that dependency for a variety of reasons.' + (' That would in turn have implications for our package infrastructure, hosting' + (' costs, and possibly on how package names are specified. The particular syntax' + (' chosen seems like it would interact with all these factors in ways that are' + (' difficult to predict, potentially leading to harder problems later on. So more' + ' design work and planning is needed on these topics.')))))))
									])))));
		}
	});
var $author$project$Compiler$Reporting$Error$Main$toReport = F3(
	function (localizer, source, err) {
		switch (err.$) {
			case 'BadType':
				var region = err.a;
				var tipe = err.b;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD MAIN TYPE',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$d('I cannot handle this type of `main` value:'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('The type of `main` value I am seeing is:'),
										A2(
										$author$project$Compiler$Reporting$Doc$indent,
										4,
										$author$project$Compiler$Reporting$Doc$dullyellow(
											A3($author$project$Compiler$Reporting$Render$Type$canToDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, tipe))),
										$author$project$Compiler$Reporting$Doc$reflow('I only know how to handle Html, Svg, and Programs' + ' though. Modify `main` to be one of those types of values!')
									])))));
			case 'BadCycle':
				var region = err.a;
				var name = err.b;
				var names = err.c;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'BAD MAIN',
					region,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$d('A `main` definition cannot be defined in terms of itself.'),
							$author$project$Compiler$Reporting$Doc$stack(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$reflow('It should be a boring value with no recursion. But' + ' instead it is involved in this cycle of definitions:'),
										A3($author$project$Compiler$Reporting$Doc$cycle, 4, name, names)
									])))));
			default:
				var region = err.a;
				var invalidPayload = err.b;
				var formatDetails = function (_v2) {
					var aBadKindOfThing = _v2.a;
					var butThatIsNoGood = _v2.b;
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'BAD FLAGS',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow('Your `main` program wants ' + (aBadKindOfThing + ' from JavaScript.')),
								butThatIsNoGood)));
				};
				return formatDetails(
					function () {
						switch (invalidPayload.$) {
							case 'ExtendedRecord':
								return _Utils_Tuple2(
									'an extended record',
									$author$project$Compiler$Reporting$Doc$reflow('But the exact shape of the record must be known at compile time. No type variables!'));
							case 'Function':
								return _Utils_Tuple2(
									'a function',
									$author$project$Compiler$Reporting$Doc$reflow('But if I allowed functions from JS, it would be possible to sneak' + ' side-effects and runtime exceptions into Elm!'));
							case 'TypeVariable':
								var name = invalidPayload.a;
								return _Utils_Tuple2(
									'an unspecified type',
									$author$project$Compiler$Reporting$Doc$reflow('But type variables like `' + (name + ('` cannot be given as flags.' + (' I need to know exactly what type of data I am getting, so I can guarantee that' + ' unexpected data cannot sneak in and crash the Elm program.')))));
							default:
								var name = invalidPayload.a;
								return _Utils_Tuple2(
									'a `' + (name + '` value'),
									$author$project$Compiler$Reporting$Doc$stack(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('I cannot handle that. The types that CAN be in flags include:'),
												A2(
												$author$project$Compiler$Reporting$Doc$indent,
												4,
												$author$project$Compiler$Reporting$Doc$reflow('Ints, Floats, Bools, Strings, Maybes, Lists, Arrays,' + ' tuples, records, and JSON values.')),
												$author$project$Compiler$Reporting$Doc$reflow('Since JSON values can flow through, you can use JSON encoders and decoders' + (' to allow other types through as well. More advanced users often just do' + ' everything with encoders and decoders for more control and better errors.'))
											])));
						}
					}());
		}
	});
var $author$project$Compiler$Reporting$Error$Pattern$Unambiguous = {$: 'Unambiguous'};
var $author$project$Compiler$Reporting$Error$Pattern$Arg = {$: 'Arg'};
var $author$project$Compiler$Reporting$Error$Pattern$Head = {$: 'Head'};
var $author$project$Compiler$Reporting$Error$Pattern$Conses = F2(
	function (a, b) {
		return {$: 'Conses', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Pattern$FiniteList = function (a) {
	return {$: 'FiniteList', a: a};
};
var $author$project$Compiler$Reporting$Error$Pattern$NonList = function (a) {
	return {$: 'NonList', a: a};
};
var $author$project$Compiler$Reporting$Error$Pattern$delist = F2(
	function (pattern, revEntries) {
		delist:
		while (true) {
			_v0$2:
			while (true) {
				if (pattern.$ === 'Ctor') {
					if (!pattern.c.b) {
						if (pattern.b === '[]') {
							return $author$project$Compiler$Reporting$Error$Pattern$FiniteList(revEntries);
						} else {
							break _v0$2;
						}
					} else {
						if (((pattern.b === '::') && pattern.c.b.b) && (!pattern.c.b.b.b)) {
							var _v1 = pattern.c;
							var hd = _v1.a;
							var _v2 = _v1.b;
							var tl = _v2.a;
							var $temp$pattern = tl,
								$temp$revEntries = A2($elm$core$List$cons, hd, revEntries);
							pattern = $temp$pattern;
							revEntries = $temp$revEntries;
							continue delist;
						} else {
							break _v0$2;
						}
					}
				} else {
					break _v0$2;
				}
			}
			if (!revEntries.b) {
				return $author$project$Compiler$Reporting$Error$Pattern$NonList(pattern);
			} else {
				return A2(
					$author$project$Compiler$Reporting$Error$Pattern$Conses,
					$author$project$Extra$Type$List$reverse(revEntries),
					pattern);
			}
		}
	});
var $author$project$Compiler$Elm$String$toChars = $elm$core$Basics$identity;
var $author$project$Compiler$Reporting$Error$Pattern$patternToDoc = F2(
	function (context, pattern) {
		var _v0 = A2($author$project$Compiler$Reporting$Error$Pattern$delist, pattern, _List_Nil);
		_v0$5:
		while (true) {
			switch (_v0.$) {
				case 'NonList':
					switch (_v0.a.$) {
						case 'Anything':
							var _v1 = _v0.a;
							return $author$project$Compiler$Reporting$Doc$d('_');
						case 'Literal':
							var literal = _v0.a.a;
							switch (literal.$) {
								case 'Chr':
									var chr = literal.a;
									return $author$project$Compiler$Reporting$Doc$da(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('\''),
												$author$project$Compiler$Reporting$Doc$fromChars(
												$author$project$Compiler$Elm$String$toChars(chr)),
												$author$project$Compiler$Reporting$Doc$d('\'')
											]));
								case 'Str':
									var str = literal.a;
									return $author$project$Compiler$Reporting$Doc$da(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('\"'),
												$author$project$Compiler$Reporting$Doc$fromChars(
												$author$project$Compiler$Elm$String$toChars(str)),
												$author$project$Compiler$Reporting$Doc$d('\"')
											]));
								default:
									var _int = literal.a;
									return $author$project$Compiler$Reporting$Doc$fromInt(_int);
							}
						default:
							if (!_v0.a.c.b) {
								if (_v0.a.b === '#0') {
									var _v3 = _v0.a;
									return $author$project$Compiler$Reporting$Doc$d('()');
								} else {
									break _v0$5;
								}
							} else {
								if (_v0.a.c.b.b) {
									if (!_v0.a.c.b.b.b) {
										if (_v0.a.b === '#2') {
											var _v4 = _v0.a;
											var _v5 = _v4.c;
											var a = _v5.a;
											var _v6 = _v5.b;
											var b = _v6.a;
											return $author$project$Compiler$Reporting$Doc$da(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$d('( '),
														A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous, a),
														$author$project$Compiler$Reporting$Doc$d(', '),
														A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous, b),
														$author$project$Compiler$Reporting$Doc$d(' )')
													]));
										} else {
											break _v0$5;
										}
									} else {
										if ((_v0.a.b === '#3') && (!_v0.a.c.b.b.b.b)) {
											var _v7 = _v0.a;
											var _v8 = _v7.c;
											var a = _v8.a;
											var _v9 = _v8.b;
											var b = _v9.a;
											var _v10 = _v9.b;
											var c = _v10.a;
											return $author$project$Compiler$Reporting$Doc$da(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$d('( '),
														A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous, a),
														$author$project$Compiler$Reporting$Doc$d(', '),
														A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous, b),
														$author$project$Compiler$Reporting$Doc$d(', '),
														A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous, c),
														$author$project$Compiler$Reporting$Doc$d(' )')
													]));
										} else {
											break _v0$5;
										}
									}
								} else {
									break _v0$5;
								}
							}
					}
				case 'FiniteList':
					if (!_v0.a.b) {
						return $author$project$Compiler$Reporting$Doc$d('[]');
					} else {
						var entries = _v0.a;
						var entryDocs = A2(
							$author$project$Extra$Type$List$map,
							$author$project$Compiler$Reporting$Error$Pattern$patternToDoc($author$project$Compiler$Reporting$Error$Pattern$Unambiguous),
							entries);
						return $author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('['),
									$author$project$Compiler$Reporting$Doc$hcat(
									A2(
										$author$project$Extra$Type$List$intersperse,
										$author$project$Compiler$Reporting$Doc$d(','),
										entryDocs)),
									$author$project$Compiler$Reporting$Doc$d(']')
								]));
					}
				default:
					var conses = _v0.a;
					var finalPattern = _v0.b;
					var consDoc = A3(
						$author$project$Extra$Type$List$foldr,
						F2(
							function (hd, tl) {
								return $author$project$Compiler$Reporting$Doc$da(
									_List_fromArray(
										[
											A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Head, hd),
											$author$project$Compiler$Reporting$Doc$d(' :: '),
											tl
										]));
							}),
						A2($author$project$Compiler$Reporting$Error$Pattern$patternToDoc, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous, finalPattern),
						conses);
					return _Utils_eq(context, $author$project$Compiler$Reporting$Error$Pattern$Unambiguous) ? consDoc : $author$project$Compiler$Reporting$Doc$da(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('('),
								consDoc,
								$author$project$Compiler$Reporting$Doc$d(')')
							]));
			}
		}
		var _v11 = _v0.a;
		var name = _v11.b;
		var args = _v11.c;
		var ctorDoc = $author$project$Compiler$Reporting$Doc$hsep(
			A2(
				$elm$core$List$cons,
				$author$project$Compiler$Reporting$Doc$fromName(name),
				A2(
					$author$project$Extra$Type$List$map,
					$author$project$Compiler$Reporting$Error$Pattern$patternToDoc($author$project$Compiler$Reporting$Error$Pattern$Arg),
					args)));
		return (_Utils_eq(context, $author$project$Compiler$Reporting$Error$Pattern$Arg) && ($author$project$Extra$Type$List$length(args) > 0)) ? $author$project$Compiler$Reporting$Doc$da(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$d('('),
					ctorDoc,
					$author$project$Compiler$Reporting$Doc$d(')')
				])) : ctorDoc;
	});
var $author$project$Compiler$Reporting$Error$Pattern$unhandledPatternsToDocBlock = function (unhandledPatterns) {
	return A2(
		$author$project$Compiler$Reporting$Doc$indent,
		4,
		$author$project$Compiler$Reporting$Doc$dullyellow(
			$author$project$Compiler$Reporting$Doc$vcat(
				A2(
					$author$project$Extra$Type$List$map,
					$author$project$Compiler$Reporting$Error$Pattern$patternToDoc($author$project$Compiler$Reporting$Error$Pattern$Unambiguous),
					unhandledPatterns))));
};
var $author$project$Compiler$Reporting$Error$Pattern$toReport = F2(
	function (source, err) {
		if (err.$ === 'Redundant') {
			var caseRegion = err.a;
			var patternRegion = err.b;
			var index = err.c;
			return A3(
				$author$project$Compiler$Reporting$Report$Report,
				'REDUNDANT PATTERN',
				patternRegion,
				A4(
					$author$project$Compiler$Reporting$Render$Code$toSnippet,
					source,
					caseRegion,
					$elm$core$Maybe$Just(patternRegion),
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow(
							'The ' + ($author$project$Compiler$Reporting$Doc$intToOrdinal(index) + ' pattern is redundant:')),
						$author$project$Compiler$Reporting$Doc$reflow('Any value with this shape will be handled by a previous' + ' pattern, so it should be removed.'))));
		} else {
			var region = err.a;
			var context = err.b;
			var unhandled = err.c;
			switch (context.$) {
				case 'BadArg':
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNSAFE PATTERN',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$d('This pattern does not cover all possibilities:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Other possibilities include:'),
											$author$project$Compiler$Reporting$Error$Pattern$unhandledPatternsToDocBlock(unhandled),
											$author$project$Compiler$Reporting$Doc$reflow('I would have to crash if I saw one of those! So rather than' + (' pattern matching in function arguments, put a `case` in' + ' the function body to account for all possibilities.'))
										])))));
				case 'BadDestruct':
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'UNSAFE PATTERN',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$d('This pattern does not cover all possible values:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Other possibilities include:'),
											$author$project$Compiler$Reporting$Error$Pattern$unhandledPatternsToDocBlock(unhandled),
											$author$project$Compiler$Reporting$Doc$reflow('I would have to crash if I saw one of those! You can use' + (' `let` to deconstruct values only if there is ONE possibility.' + ' Switch to a `case` expression to account for all possibilities.')),
											$author$project$Compiler$Reporting$Doc$toSimpleHint('Are you calling a function that definitely returns values' + (' with a very specific shape? Try making the return type of' + ' that function more specific!'))
										])))));
				default:
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'MISSING PATTERNS',
						region,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							$elm$core$Maybe$Nothing,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$d('This `case` does not have branches for all possibilities:'),
								$author$project$Compiler$Reporting$Doc$stack(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Missing possibilities include:'),
											$author$project$Compiler$Reporting$Error$Pattern$unhandledPatternsToDocBlock(unhandled),
											$author$project$Compiler$Reporting$Doc$reflow('I would have to crash if I saw one of those. Add branches for them!'),
											A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'If you want to write the code for each branch later, use `Debug.todo` as a placeholder. Read', 'missing-patterns', 'for more guidance on this workflow.')
										])))));
			}
		}
	});
var $author$project$Compiler$Reporting$Error$Type$addCategory = F2(
	function (thisIs, category) {
		switch (category.$) {
			case 'Local':
				var name = category.a;
				return 'This `' + (name + '` value is a:');
			case 'Foreign':
				var name = category.a;
				return 'This `' + (name + '` value is a:');
			case 'Access':
				var field = category.a;
				return 'The value at .' + (field + ' is a:');
			case 'Accessor':
				var field = category.a;
				return 'This .' + (field + ' field access function has type:');
			case 'If':
				return 'This `if` expression produces:';
			case 'Case':
				return 'This `case` expression produces:';
			case 'CList':
				return thisIs + ' a list of type:';
			case 'Number':
				return thisIs + ' a number of type:';
			case 'CFloat':
				return thisIs + ' a float of type:';
			case 'CString':
				return thisIs + ' a string of type:';
			case 'CChar':
				return thisIs + ' a character of type:';
			case 'Lambda':
				return thisIs + ' an anonymous function of type:';
			case 'Record':
				return thisIs + ' a record of type:';
			case 'Tuple':
				return thisIs + ' a tuple of type:';
			case 'Unit':
				return thisIs + ' a unit value:';
			case 'Shader':
				return thisIs + ' a GLSL shader of type:';
			case 'Effects':
				return thisIs + ' a thing for CORE LIBRARIES ONLY.';
			default:
				var maybeName = category.a;
				switch (maybeName.$) {
					case 'NoName':
						return thisIs + ':';
					case 'FuncName':
						var name = maybeName.a;
						return 'This `' + (name + '` call produces:');
					case 'CtorName':
						var name = maybeName.a;
						return 'This `' + (name + '` call produces:');
					default:
						return thisIs + ':';
				}
		}
	});
var $author$project$Compiler$Reporting$Error$Type$countArgs = function (tipe) {
	if (tipe.$ === 'Lambda') {
		var stuff = tipe.c;
		return 1 + $author$project$Extra$Type$List$length(stuff);
	} else {
		return 0;
	}
};
var $author$project$Compiler$Reporting$Error$Type$badDoubleRigid = F2(
	function (x, y) {
		return _List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$toSimpleHint('Your type annotation uses `' + (x + ('` and `' + (y + ('` as separate type variables. Your code seems to be saying they are the' + (' same though. Maybe they should be the same in your type annotation?' + ' Maybe your code uses them in a weird way?')))))),
				A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'type-annotations', 'for more advice!')
			]);
	});
var $author$project$Compiler$Reporting$Error$Type$badFlexFlexSuper = F2(
	function (s1, s2) {
		var likeThis = function (_super) {
			switch (_super.$) {
				case 'Number':
					return 'a number';
				case 'Comparable':
					return 'comparable';
				case 'CompAppend':
					return 'a compappend';
				default:
					return 'appendable';
			}
		};
		return _List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$toSimpleHint(
				'There are no values in Elm that are both ' + (likeThis(s1) + (' and ' + (likeThis(s2) + '.'))))
			]);
	});
var $author$project$Compiler$Reporting$Error$Type$badFlexSuper = F3(
	function (direction, _super, tipe) {
		switch (_super.$) {
			case 'Comparable':
				switch (tipe.$) {
					case 'Record':
						return _List_fromArray(
							[
								A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'I do not know how to compare records. I can only compare ints, floats,' + (' chars, strings, lists of comparable values, and tuples of comparable values.' + ' Check out'), 'comparing-records', 'for ideas on how to proceed.')
							]);
					case 'Type':
						var name = tipe.b;
						return _List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$toSimpleHint('I do not know how to compare `' + (name + ('` values. I can only' + (' compare ints, floats, chars, strings, lists of comparable values, and tuples' + ' of comparable values.')))),
								A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Check out', 'comparing-custom-types', 'for ideas on how to proceed.')
							]);
					default:
						return _List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$toSimpleHint('I only know how to compare ints, floats, chars, strings, lists of' + ' comparable values, and tuples of comparable values.')
							]);
				}
			case 'Appendable':
				return _List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$toSimpleHint('I only know how to append strings and lists.')
					]);
			case 'CompAppend':
				return _List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$toSimpleHint('Only strings and lists are both comparable and appendable.')
					]);
			default:
				var otherwise = function (_v4) {
					return _List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$toFancyHint(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('Only'),
									$author$project$Compiler$Reporting$Doc$greenS('Int'),
									$author$project$Compiler$Reporting$Doc$d('and'),
									$author$project$Compiler$Reporting$Doc$greenS('Float'),
									$author$project$Compiler$Reporting$Doc$d('values'),
									$author$project$Compiler$Reporting$Doc$d('work'),
									$author$project$Compiler$Reporting$Doc$d('as'),
									$author$project$Compiler$Reporting$Doc$d('numbers.')
								]))
						]);
				};
				if (tipe.$ === 'Type') {
					var home = tipe.a;
					var name = tipe.b;
					if (A2($author$project$Compiler$Type$Error$isString, home, name)) {
						if (direction.$ === 'Have') {
							return _List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$toFancyHint(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Try'),
											$author$project$Compiler$Reporting$Doc$d('using'),
											$author$project$Compiler$Reporting$Doc$greenS('String.fromInt'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('convert'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('a'),
											$author$project$Compiler$Reporting$Doc$d('string?')
										]))
								]);
						} else {
							return _List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$toFancyHint(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('Try'),
											$author$project$Compiler$Reporting$Doc$d('using'),
											$author$project$Compiler$Reporting$Doc$greenS('String.toInt'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('convert'),
											$author$project$Compiler$Reporting$Doc$d('it'),
											$author$project$Compiler$Reporting$Doc$d('to'),
											$author$project$Compiler$Reporting$Doc$d('an'),
											$author$project$Compiler$Reporting$Doc$d('integer?')
										]))
								]);
						}
					} else {
						return otherwise(_Utils_Tuple0);
					}
				} else {
					return otherwise(_Utils_Tuple0);
				}
		}
	});
var $author$project$Compiler$Reporting$Error$Type$badRigidSuper = F2(
	function (_super, aThing) {
		var _v0 = function () {
			switch (_super.$) {
				case 'Number':
					return _Utils_Tuple2('number', 'ints AND floats');
				case 'Comparable':
					return _Utils_Tuple2('comparable', 'ints, floats, chars, strings, lists, and tuples');
				case 'Appendable':
					return _Utils_Tuple2('appendable', 'strings AND lists');
				default:
					return _Utils_Tuple2('compappend', 'strings AND lists');
			}
		}();
		var superType = _v0.a;
		var manyThings = _v0.b;
		return _List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$toSimpleHint('The `' + (superType + ('` in your type annotation is saying that ' + (manyThings + (' can flow through, but your code is saying it specifically wants ' + (aThing + ('. Maybe change your type annotation to' + ' be more specific? Maybe change the code to be more general?'))))))),
				A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'type-annotations', 'for more advice!')
			]);
	});
var $author$project$Compiler$Reporting$Error$Type$badRigidVar = F2(
	function (name, aThing) {
		return _List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$toSimpleHint('Your type annotation uses type variable `' + (name + ('` which means ANY type of value can flow through, but your code is saying it specifically wants ' + (aThing + ('. Maybe change your type annotation to' + ' be more specific? Maybe change the code to be more general?'))))),
				A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Read', 'type-annotations', 'for more advice!')
			]);
	});
var $author$project$Compiler$Reporting$Doc$fancyLink = F4(
	function (word, before, fileName, after) {
		return $author$project$Extra$Data$Pretty$fillSep(
			A2(
				$elm$core$List$cons,
				$author$project$Extra$Data$Pretty$hcat(
					_List_fromArray(
						[
							$author$project$Extra$Data$Pretty$underline(word),
							$author$project$Extra$Data$Pretty$text(':')
						])),
				_Utils_ap(
					before,
					A2(
						$elm$core$List$cons,
						$author$project$Extra$Data$Pretty$text(
							$author$project$Compiler$Reporting$Doc$makeLink(fileName)),
						after))));
	});
var $author$project$Compiler$Reporting$Error$Type$toASuperThing = function (_super) {
	switch (_super.$) {
		case 'Number':
			return 'a `number` value';
		case 'Comparable':
			return 'a `comparable` value';
		case 'CompAppend':
			return 'a `compappend` value';
		default:
			return 'an `appendable` value';
	}
};
var $author$project$Compiler$Reporting$Error$Type$problemToHint = function (problem) {
	switch (problem.$) {
		case 'IntFloat':
			return _List_fromArray(
				[
					A4(
					$author$project$Compiler$Reporting$Doc$fancyLink,
					'Note',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Read')
						]),
					'implicit-casts',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('learn'),
							$author$project$Compiler$Reporting$Doc$d('why'),
							$author$project$Compiler$Reporting$Doc$d('Elm'),
							$author$project$Compiler$Reporting$Doc$d('does'),
							$author$project$Compiler$Reporting$Doc$d('not'),
							$author$project$Compiler$Reporting$Doc$d('implicitly'),
							$author$project$Compiler$Reporting$Doc$d('convert'),
							$author$project$Compiler$Reporting$Doc$d('Ints'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('Floats.'),
							$author$project$Compiler$Reporting$Doc$d('Use'),
							$author$project$Compiler$Reporting$Doc$greenS('toFloat'),
							$author$project$Compiler$Reporting$Doc$d('and'),
							$author$project$Compiler$Reporting$Doc$greenS('round'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('do'),
							$author$project$Compiler$Reporting$Doc$d('explicit'),
							$author$project$Compiler$Reporting$Doc$d('conversions.')
						]))
				]);
		case 'StringFromInt':
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toFancyHint(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Want'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('convert'),
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$d('Int'),
							$author$project$Compiler$Reporting$Doc$d('into'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('String?'),
							$author$project$Compiler$Reporting$Doc$d('Use'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$greenS('String.fromInt'),
							$author$project$Compiler$Reporting$Doc$d('function!')
						]))
				]);
		case 'StringFromFloat':
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toFancyHint(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Want'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('convert'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('Float'),
							$author$project$Compiler$Reporting$Doc$d('into'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('String?'),
							$author$project$Compiler$Reporting$Doc$d('Use'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$greenS('String.fromFloat'),
							$author$project$Compiler$Reporting$Doc$d('function!')
						]))
				]);
		case 'StringToInt':
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toFancyHint(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Want'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('convert'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('String'),
							$author$project$Compiler$Reporting$Doc$d('into'),
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$d('Int?'),
							$author$project$Compiler$Reporting$Doc$d('Use'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$greenS('String.toInt'),
							$author$project$Compiler$Reporting$Doc$d('function!')
						]))
				]);
		case 'StringToFloat':
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toFancyHint(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Want'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('convert'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('String'),
							$author$project$Compiler$Reporting$Doc$d('into'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('Float?'),
							$author$project$Compiler$Reporting$Doc$d('Use'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$greenS('String.toFloat'),
							$author$project$Compiler$Reporting$Doc$d('function!')
						]))
				]);
		case 'AnythingToBool':
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toSimpleHint('Elm does not have truthiness such that ints and strings and lists' + ' are automatically converted to booleans. Do that conversion explicitly!')
				]);
		case 'AnythingFromMaybe':
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toFancyHint(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Use'),
							$author$project$Compiler$Reporting$Doc$greenS('Maybe.withDefault'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('handle'),
							$author$project$Compiler$Reporting$Doc$d('possible'),
							$author$project$Compiler$Reporting$Doc$d('errors.'),
							$author$project$Compiler$Reporting$Doc$d('Longer'),
							$author$project$Compiler$Reporting$Doc$d('term,d'),
							$author$project$Compiler$Reporting$Doc$d('it'),
							$author$project$Compiler$Reporting$Doc$d('is'),
							$author$project$Compiler$Reporting$Doc$d('usually'),
							$author$project$Compiler$Reporting$Doc$d('better'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('write'),
							$author$project$Compiler$Reporting$Doc$d('out'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$d('full'),
							$author$project$Compiler$Reporting$Doc$d('`case`'),
							$author$project$Compiler$Reporting$Doc$d('though!')
						]))
				]);
		case 'ArityMismatch':
			var x = problem.a;
			var y = problem.b;
			return _List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toSimpleHint(
					(_Utils_cmp(x, y) < 0) ? ('It looks like it takes too few arguments. I was expecting ' + ($elm$core$String$fromInt(y - x) + ' more.')) : ('It looks like it takes too many arguments. I see ' + ($elm$core$String$fromInt(x - y) + ' extra.')))
				]);
		case 'BadFlexSuper':
			var direction = problem.a;
			var _super = problem.b;
			var tipe = problem.c;
			switch (tipe.$) {
				case 'Lambda':
					return A3($author$project$Compiler$Reporting$Error$Type$badFlexSuper, direction, _super, tipe);
				case 'Infinite':
					return _List_Nil;
				case 'Error':
					return _List_Nil;
				case 'FlexVar':
					return _List_Nil;
				case 'FlexSuper':
					var s = tipe.a;
					return A2($author$project$Compiler$Reporting$Error$Type$badFlexFlexSuper, _super, s);
				case 'RigidVar':
					var y = tipe.a;
					return A2(
						$author$project$Compiler$Reporting$Error$Type$badRigidVar,
						y,
						$author$project$Compiler$Reporting$Error$Type$toASuperThing(_super));
				case 'RigidSuper':
					var s = tipe.a;
					return A2(
						$author$project$Compiler$Reporting$Error$Type$badRigidSuper,
						s,
						$author$project$Compiler$Reporting$Error$Type$toASuperThing(_super));
				case 'Type':
					return A3($author$project$Compiler$Reporting$Error$Type$badFlexSuper, direction, _super, tipe);
				case 'Record':
					return A3($author$project$Compiler$Reporting$Error$Type$badFlexSuper, direction, _super, tipe);
				case 'Unit':
					return A3($author$project$Compiler$Reporting$Error$Type$badFlexSuper, direction, _super, tipe);
				case 'Tuple':
					return A3($author$project$Compiler$Reporting$Error$Type$badFlexSuper, direction, _super, tipe);
				default:
					return A3($author$project$Compiler$Reporting$Error$Type$badFlexSuper, direction, _super, tipe);
			}
		case 'BadRigidVar':
			var x = problem.a;
			var tipe = problem.b;
			switch (tipe.$) {
				case 'Lambda':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidVar, x, 'a function');
				case 'Infinite':
					return _List_Nil;
				case 'Error':
					return _List_Nil;
				case 'FlexVar':
					return _List_Nil;
				case 'FlexSuper':
					var s = tipe.a;
					return A2(
						$author$project$Compiler$Reporting$Error$Type$badRigidVar,
						x,
						$author$project$Compiler$Reporting$Error$Type$toASuperThing(s));
				case 'RigidVar':
					var y = tipe.a;
					return A2($author$project$Compiler$Reporting$Error$Type$badDoubleRigid, x, y);
				case 'RigidSuper':
					var y = tipe.b;
					return A2($author$project$Compiler$Reporting$Error$Type$badDoubleRigid, x, y);
				case 'Type':
					var n = tipe.b;
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidVar, x, 'a `' + (n + '` value'));
				case 'Record':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidVar, x, 'a record');
				case 'Unit':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidVar, x, 'a unit value');
				case 'Tuple':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidVar, x, 'a tuple');
				default:
					var n = tipe.b;
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidVar, x, 'a `' + (n + '` value'));
			}
		case 'BadRigidSuper':
			var _super = problem.a;
			var x = problem.b;
			var tipe = problem.c;
			switch (tipe.$) {
				case 'Lambda':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidSuper, _super, 'a function');
				case 'Infinite':
					return _List_Nil;
				case 'Error':
					return _List_Nil;
				case 'FlexVar':
					return _List_Nil;
				case 'FlexSuper':
					var s = tipe.a;
					return A2(
						$author$project$Compiler$Reporting$Error$Type$badRigidSuper,
						_super,
						$author$project$Compiler$Reporting$Error$Type$toASuperThing(s));
				case 'RigidVar':
					var y = tipe.a;
					return A2($author$project$Compiler$Reporting$Error$Type$badDoubleRigid, x, y);
				case 'RigidSuper':
					var y = tipe.b;
					return A2($author$project$Compiler$Reporting$Error$Type$badDoubleRigid, x, y);
				case 'Type':
					var n = tipe.b;
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidSuper, _super, 'a `' + (n + '` value'));
				case 'Record':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidSuper, _super, 'a record');
				case 'Unit':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidSuper, _super, 'a unit value');
				case 'Tuple':
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidSuper, _super, 'a tuple');
				default:
					var n = tipe.b;
					return A2($author$project$Compiler$Reporting$Error$Type$badRigidSuper, _super, 'a `' + (n + '` value'));
			}
		case 'FieldsMissing':
			var fields = problem.a;
			var _v4 = A2(
				$author$project$Extra$Type$List$map,
				A2($elm$core$Basics$composeL, $author$project$Compiler$Reporting$Doc$green, $author$project$Compiler$Reporting$Doc$fromName),
				fields);
			if (!_v4.b) {
				return _List_Nil;
			} else {
				if (!_v4.b.b) {
					var f1 = _v4.a;
					return _List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$toFancyHint(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('Looks'),
									$author$project$Compiler$Reporting$Doc$d('like'),
									$author$project$Compiler$Reporting$Doc$d('the'),
									f1,
									$author$project$Compiler$Reporting$Doc$d('field'),
									$author$project$Compiler$Reporting$Doc$d('is'),
									$author$project$Compiler$Reporting$Doc$d('missing.')
								]))
						]);
				} else {
					var fieldDocs = _v4;
					return _List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$toFancyHint(
							_Utils_ap(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('Looks'),
										$author$project$Compiler$Reporting$Doc$d('like'),
										$author$project$Compiler$Reporting$Doc$d('fields')
									]),
								_Utils_ap(
									A3(
										$author$project$Compiler$Reporting$Doc$commaSep,
										$author$project$Compiler$Reporting$Doc$d('and'),
										$elm$core$Basics$identity,
										fieldDocs),
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('are'),
											$author$project$Compiler$Reporting$Doc$d('missing.')
										]))))
						]);
				}
			}
		default:
			var typo = problem.a;
			var possibilities = problem.b;
			var _v5 = A3($author$project$Compiler$Reporting$Suggest$sort, typo, $elm$core$Basics$identity, possibilities);
			if (!_v5.b) {
				return _List_Nil;
			} else {
				var nearest = _v5.a;
				return _List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$toFancyHint(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('Seems'),
								$author$project$Compiler$Reporting$Doc$d('like'),
								$author$project$Compiler$Reporting$Doc$d('a'),
								$author$project$Compiler$Reporting$Doc$d('record'),
								$author$project$Compiler$Reporting$Doc$d('field'),
								$author$project$Compiler$Reporting$Doc$d('typo.'),
								$author$project$Compiler$Reporting$Doc$d('Maybe'),
								$author$project$Compiler$Reporting$Doc$dullyellow(
								$author$project$Compiler$Reporting$Doc$fromName(typo)),
								$author$project$Compiler$Reporting$Doc$d('should'),
								$author$project$Compiler$Reporting$Doc$d('be'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$green(
										$author$project$Compiler$Reporting$Doc$fromName(nearest)),
										$author$project$Compiler$Reporting$Doc$d('?')
									]))
							])),
						$author$project$Compiler$Reporting$Doc$toSimpleHint('Can more type annotations be added? Type annotations always help me give' + ' more specific messages, and I think they could help a lot in this case!')
					]);
			}
	}
};
var $author$project$Compiler$Reporting$Error$Type$problemsToHint = function (problems) {
	if (!problems.b) {
		return _List_Nil;
	} else {
		var problem = problems.a;
		return $author$project$Compiler$Reporting$Error$Type$problemToHint(problem);
	}
};
var $author$project$Compiler$Type$Error$AnythingFromMaybe = {$: 'AnythingFromMaybe'};
var $author$project$Compiler$Type$Error$AnythingToBool = {$: 'AnythingToBool'};
var $author$project$Compiler$Type$Error$ArityMismatch = F2(
	function (a, b) {
		return {$: 'ArityMismatch', a: a, b: b};
	});
var $author$project$Compiler$Type$Error$BadFlexSuper = F3(
	function (a, b, c) {
		return {$: 'BadFlexSuper', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Error$BadRigidSuper = F3(
	function (a, b, c) {
		return {$: 'BadRigidSuper', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Error$BadRigidVar = F2(
	function (a, b) {
		return {$: 'BadRigidVar', a: a, b: b};
	});
var $author$project$Compiler$Type$Error$Diff = F3(
	function (a, b, c) {
		return {$: 'Diff', a: a, b: b, c: c};
	});
var $author$project$Compiler$Type$Error$Different = function (a) {
	return {$: 'Different', a: a};
};
var $author$project$Compiler$Type$Error$FieldTypo = F2(
	function (a, b) {
		return {$: 'FieldTypo', a: a, b: b};
	});
var $author$project$Compiler$Type$Error$FieldsMissing = function (a) {
	return {$: 'FieldsMissing', a: a};
};
var $author$project$Compiler$Type$Error$Have = {$: 'Have'};
var $author$project$Compiler$Type$Error$IntFloat = {$: 'IntFloat'};
var $author$project$Compiler$Type$Error$Need = {$: 'Need'};
var $author$project$Compiler$Type$Error$Similar = {$: 'Similar'};
var $author$project$Compiler$Type$Error$StringFromFloat = {$: 'StringFromFloat'};
var $author$project$Compiler$Type$Error$StringFromInt = {$: 'StringFromInt'};
var $author$project$Compiler$Type$Error$StringToFloat = {$: 'StringToFloat'};
var $author$project$Compiler$Type$Error$StringToInt = {$: 'StringToInt'};
var $author$project$Compiler$Data$Bag$Two = F2(
	function (a, b) {
		return {$: 'Two', a: a, b: b};
	});
var $author$project$Compiler$Data$Bag$append = F2(
	function (left, right) {
		var _v0 = _Utils_Tuple2(left, right);
		if (_v0.b.$ === 'Empty') {
			var other = _v0.a;
			var _v1 = _v0.b;
			return other;
		} else {
			if (_v0.a.$ === 'Empty') {
				var _v2 = _v0.a;
				var other = _v0.b;
				return other;
			} else {
				return A2($author$project$Compiler$Data$Bag$Two, left, right);
			}
		}
	});
var $author$project$Compiler$Type$Error$merge = F2(
	function (status1, status2) {
		if (status1.$ === 'Similar') {
			return status2;
		} else {
			var problems1 = status1.a;
			if (status2.$ === 'Similar') {
				return status1;
			} else {
				var problems2 = status2.a;
				return $author$project$Compiler$Type$Error$Different(
					A2($author$project$Compiler$Data$Bag$append, problems1, problems2));
			}
		}
	});
var $author$project$Compiler$Type$Error$andMap = F2(
	function (_v0, _v1) {
		var aArg = _v0.a;
		var bArg = _v0.b;
		var status2 = _v0.c;
		var aFunc = _v1.a;
		var bFunc = _v1.b;
		var status1 = _v1.c;
		return A3(
			$author$project$Compiler$Type$Error$Diff,
			aFunc(aArg),
			bFunc(bArg),
			A2($author$project$Compiler$Type$Error$merge, status1, status2));
	});
var $author$project$Compiler$Type$Error$different = F3(
	function (a, b, problems) {
		return A3(
			$author$project$Compiler$Type$Error$Diff,
			a,
			b,
			$author$project$Compiler$Type$Error$Different(problems));
	});
var $author$project$Compiler$Data$Bag$Empty = {$: 'Empty'};
var $author$project$Compiler$Data$Bag$empty = $author$project$Compiler$Data$Bag$Empty;
var $author$project$Compiler$Data$Bag$One = function (a) {
	return {$: 'One', a: a};
};
var $author$project$Compiler$Data$Bag$one = $author$project$Compiler$Data$Bag$One;
var $author$project$Compiler$Type$Error$extToStatus = F2(
	function (ext1, ext2) {
		switch (ext1.$) {
			case 'Closed':
				switch (ext2.$) {
					case 'Closed':
						return $author$project$Compiler$Type$Error$Similar;
					case 'FlexOpen':
						return $author$project$Compiler$Type$Error$Similar;
					default:
						return $author$project$Compiler$Type$Error$Different($author$project$Compiler$Data$Bag$empty);
				}
			case 'FlexOpen':
				return $author$project$Compiler$Type$Error$Similar;
			default:
				var x = ext1.a;
				switch (ext2.$) {
					case 'Closed':
						return $author$project$Compiler$Type$Error$Different($author$project$Compiler$Data$Bag$empty);
					case 'FlexOpen':
						return $author$project$Compiler$Type$Error$Similar;
					default:
						var y = ext2.a;
						return _Utils_eq(x, y) ? $author$project$Compiler$Type$Error$Similar : $author$project$Compiler$Type$Error$Different(
							$author$project$Compiler$Data$Bag$one(
								A2(
									$author$project$Compiler$Type$Error$BadRigidVar,
									x,
									$author$project$Compiler$Type$Error$RigidVar(y))));
				}
		}
	});
var $author$project$Compiler$Type$Error$extToDiff = F2(
	function (ext1, ext2) {
		var status = A2($author$project$Compiler$Type$Error$extToStatus, ext1, ext2);
		var extDoc2 = $author$project$Compiler$Type$Error$extToDoc(ext2);
		var extDoc1 = $author$project$Compiler$Type$Error$extToDoc(ext1);
		if (status.$ === 'Similar') {
			return A3($author$project$Compiler$Type$Error$Diff, extDoc1, extDoc2, status);
		} else {
			return A3(
				$author$project$Compiler$Type$Error$Diff,
				A2($elm$core$Maybe$map, $author$project$Compiler$Reporting$Doc$dullyellow, extDoc1),
				A2($elm$core$Maybe$map, $author$project$Compiler$Reporting$Doc$dullyellow, extDoc2),
				status);
		}
	});
var $author$project$Compiler$Type$Error$fmap = F2(
	function (func, _v0) {
		var a = _v0.a;
		var b = _v0.b;
		var status = _v0.c;
		return A3(
			$author$project$Compiler$Type$Error$Diff,
			func(a),
			func(b),
			status);
	});
var $author$project$Compiler$Type$Error$hasFixedFields = function (ext) {
	switch (ext.$) {
		case 'Closed':
			return true;
		case 'FlexOpen':
			return false;
		default:
			return true;
	}
};
var $author$project$Compiler$Type$Error$isBool = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) && _Utils_eq(name, $author$project$Compiler$Data$Name$bool);
	});
var $author$project$Compiler$Type$Error$isFloat = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) && _Utils_eq(name, $author$project$Compiler$Data$Name$float);
	});
var $author$project$Compiler$Type$Error$isInt = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$basics) && _Utils_eq(name, $author$project$Compiler$Data$Name$int);
	});
var $author$project$Compiler$Type$Error$isList = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$list) && _Utils_eq(name, $author$project$Compiler$Data$Name$list);
	});
var $author$project$Compiler$Type$Error$isMaybe = F2(
	function (home, name) {
		return _Utils_eq(home, $author$project$Compiler$Elm$ModuleName$maybe) && _Utils_eq(name, $author$project$Compiler$Data$Name$maybe);
	});
var $author$project$Compiler$Type$Error$isSimilar = function (_v0) {
	var status = _v0.c;
	if (status.$ === 'Similar') {
		return true;
	} else {
		return false;
	}
};
var $author$project$Compiler$Type$Error$isSuper = F2(
	function (_super, tipe) {
		var _v0 = $author$project$Compiler$Type$Error$iteratedDealias(tipe);
		switch (_v0.$) {
			case 'Type':
				var h = _v0.a;
				var n = _v0.b;
				var args = _v0.c;
				switch (_super.$) {
					case 'Number':
						return A2($author$project$Compiler$Type$Error$isInt, h, n) || A2($author$project$Compiler$Type$Error$isFloat, h, n);
					case 'Comparable':
						return A2($author$project$Compiler$Type$Error$isInt, h, n) || (A2($author$project$Compiler$Type$Error$isFloat, h, n) || (A2($author$project$Compiler$Type$Error$isString, h, n) || (A2($author$project$Compiler$Type$Error$isChar, h, n) || (A2($author$project$Compiler$Type$Error$isList, h, n) && A2(
							$author$project$Compiler$Type$Error$isSuper,
							_super,
							$author$project$Extra$Type$List$head(args))))));
					case 'Appendable':
						return A2($author$project$Compiler$Type$Error$isString, h, n) || A2($author$project$Compiler$Type$Error$isList, h, n);
					default:
						return A2($author$project$Compiler$Type$Error$isString, h, n) || (A2($author$project$Compiler$Type$Error$isList, h, n) && A2(
							$author$project$Compiler$Type$Error$isSuper,
							$author$project$Compiler$Type$Error$Comparable,
							$author$project$Extra$Type$List$head(args)));
				}
			case 'Tuple':
				var a = _v0.a;
				var b = _v0.b;
				var maybeC = _v0.c;
				switch (_super.$) {
					case 'Number':
						return false;
					case 'Comparable':
						return A2($author$project$Compiler$Type$Error$isSuper, _super, a) && (A2($author$project$Compiler$Type$Error$isSuper, _super, b) && A3(
							$author$project$Extra$Type$Maybe$maybe,
							true,
							$author$project$Compiler$Type$Error$isSuper(_super),
							maybeC));
					case 'Appendable':
						return false;
					default:
						return false;
				}
			default:
				return false;
		}
	});
var $author$project$Compiler$Type$Error$liftA2 = A2($author$project$Extra$Class$Applicative$liftA2, $author$project$Compiler$Type$Error$fmap, $author$project$Compiler$Type$Error$andMap);
var $author$project$Extra$Data$Pretty$yellow = $the_sett$elm_pretty_printer$Pretty$setTag(
	function ($) {
		return $.yellow;
	});
var $author$project$Compiler$Reporting$Doc$yellow = $author$project$Extra$Data$Pretty$yellow;
var $author$project$Compiler$Type$Error$nameClashToDoc = F5(
	function (ctx, localizer, _v0, name, args) {
		var home = _v0.b;
		return A3(
			$author$project$Compiler$Reporting$Render$Type$apply,
			ctx,
			$author$project$Compiler$Reporting$Doc$da(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$yellow(
						$author$project$Compiler$Reporting$Doc$fromName(home)),
						$author$project$Compiler$Reporting$Doc$dullyellow(
						$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('.'),
									$author$project$Compiler$Reporting$Doc$fromName(name)
								])))
					])),
			A2(
				$author$project$Extra$Type$List$map,
				A2($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App),
				args));
	});
var $author$project$Compiler$Type$Error$pure = function (a) {
	return A3($author$project$Compiler$Type$Error$Diff, a, a, $author$project$Compiler$Type$Error$Similar);
};
var $author$project$Compiler$Type$Error$same = F3(
	function (localizer, ctx, tipe) {
		var doc = A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe);
		return A3($author$project$Compiler$Type$Error$Diff, doc, doc, $author$project$Compiler$Type$Error$Similar);
	});
var $author$project$Compiler$Type$Error$similar = F4(
	function (localizer, ctx, t1, t2) {
		return A3(
			$author$project$Compiler$Type$Error$Diff,
			A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, t1),
			A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, t2),
			$author$project$Compiler$Type$Error$Similar);
	});
var $author$project$Compiler$Type$Error$diffAliasedRecord = F3(
	function (localizer, t1, t2) {
		var _v64 = _Utils_Tuple2(
			$author$project$Compiler$Type$Error$iteratedDealias(t1),
			$author$project$Compiler$Type$Error$iteratedDealias(t2));
		if ((_v64.a.$ === 'Record') && (_v64.b.$ === 'Record')) {
			var _v65 = _v64.a;
			var fields1 = _v65.a;
			var ext1 = _v65.b;
			var _v66 = _v64.b;
			var fields2 = _v66.a;
			var ext2 = _v66.b;
			return $elm$core$Maybe$Just(
				A5($author$project$Compiler$Type$Error$diffRecord, localizer, fields1, ext1, fields2, ext2));
		} else {
			return $elm$core$Maybe$Nothing;
		}
	});
var $author$project$Compiler$Type$Error$diffRecord = F5(
	function (localizer, fields1, ext1, fields2, ext2) {
		var toUnknownDocs = F2(
			function (field, tipe) {
				return _Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$dullyellow(
						$author$project$Compiler$Reporting$Doc$fromName(field)),
					A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, tipe));
			});
		var toOverlapDocs = F3(
			function (field, t1, t2) {
				return A2(
					$author$project$Compiler$Type$Error$fmap,
					$elm$core$Tuple$pair(
						$author$project$Compiler$Reporting$Doc$fromName(field)),
					A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, t1, t2));
			});
		var right = A2(
			$author$project$Extra$Type$Map$mapWithKey,
			toUnknownDocs,
			A2($author$project$Extra$Type$Map$difference, fields2, fields1));
		var left = A2(
			$author$project$Extra$Type$Map$mapWithKey,
			toUnknownDocs,
			A2($author$project$Extra$Type$Map$difference, fields1, fields2));
		var both = A3($author$project$Extra$Type$Map$intersectionWithKey, toOverlapDocs, fields1, fields2);
		var fieldsDiff = A2(
			$author$project$Compiler$Type$Error$fmap,
			$author$project$Extra$Type$Map$elems,
			($author$project$Extra$Type$Map$null(left) && $author$project$Extra$Type$Map$null(right)) ? A3($author$project$Extra$Type$Map$sequenceA, $author$project$Compiler$Type$Error$pure, $author$project$Compiler$Type$Error$liftA2, both) : A2(
				$author$project$Compiler$Type$Error$andMap,
				A3(
					$author$project$Compiler$Type$Error$Diff,
					left,
					right,
					$author$project$Compiler$Type$Error$Different($author$project$Compiler$Data$Bag$empty)),
				A2(
					$author$project$Compiler$Type$Error$andMap,
					A3($author$project$Extra$Type$Map$sequenceA, $author$project$Compiler$Type$Error$pure, $author$project$Compiler$Type$Error$liftA2, both),
					$author$project$Compiler$Type$Error$pure($author$project$Extra$Type$Map$union))));
		var _v56 = A2(
			$author$project$Compiler$Type$Error$andMap,
			A2($author$project$Compiler$Type$Error$extToDiff, ext1, ext2),
			A2(
				$author$project$Compiler$Type$Error$andMap,
				fieldsDiff,
				$author$project$Compiler$Type$Error$pure($author$project$Compiler$Reporting$Render$Type$record)));
		var doc1 = _v56.a;
		var doc2 = _v56.b;
		var status = _v56.c;
		return A3(
			$author$project$Compiler$Type$Error$Diff,
			doc1,
			doc2,
			A2(
				$author$project$Compiler$Type$Error$merge,
				status,
				function () {
					var _v57 = _Utils_Tuple2(
						$author$project$Compiler$Type$Error$hasFixedFields(ext1),
						$author$project$Compiler$Type$Error$hasFixedFields(ext2));
					if (_v57.a) {
						if (_v57.b) {
							var _v58 = $author$project$Extra$Type$Map$lookupMin(left);
							if (_v58.$ === 'Just') {
								var _v59 = _v58.a;
								var f = _v59.a;
								return $author$project$Compiler$Type$Error$Different(
									$author$project$Compiler$Data$Bag$one(
										A2(
											$author$project$Compiler$Type$Error$FieldTypo,
											f,
											$author$project$Extra$Type$Map$keys(fields2))));
							} else {
								return $author$project$Extra$Type$Map$null(right) ? $author$project$Compiler$Type$Error$Similar : $author$project$Compiler$Type$Error$Different(
									$author$project$Compiler$Data$Bag$one(
										$author$project$Compiler$Type$Error$FieldsMissing(
											$author$project$Extra$Type$Map$keys(right))));
							}
						} else {
							var _v62 = $author$project$Extra$Type$Map$lookupMin(right);
							if (_v62.$ === 'Just') {
								var _v63 = _v62.a;
								var f = _v63.a;
								return $author$project$Compiler$Type$Error$Different(
									$author$project$Compiler$Data$Bag$one(
										A2(
											$author$project$Compiler$Type$Error$FieldTypo,
											f,
											$author$project$Extra$Type$Map$keys(fields1))));
							} else {
								return $author$project$Compiler$Type$Error$Similar;
							}
						}
					} else {
						if (_v57.b) {
							var _v60 = $author$project$Extra$Type$Map$lookupMin(left);
							if (_v60.$ === 'Just') {
								var _v61 = _v60.a;
								var f = _v61.a;
								return $author$project$Compiler$Type$Error$Different(
									$author$project$Compiler$Data$Bag$one(
										A2(
											$author$project$Compiler$Type$Error$FieldTypo,
											f,
											$author$project$Extra$Type$Map$keys(fields2))));
							} else {
								return $author$project$Compiler$Type$Error$Similar;
							}
						} else {
							return $author$project$Compiler$Type$Error$Similar;
						}
					}
				}()));
	});
var $author$project$Compiler$Type$Error$toDiff = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v45 = _Utils_Tuple2(tipe1, tipe2);
		_v45$7:
		while (true) {
			switch (_v45.a.$) {
				case 'Unit':
					if (_v45.b.$ === 'Unit') {
						var _v46 = _v45.a;
						var _v47 = _v45.b;
						return A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1);
					} else {
						break _v45$7;
					}
				case 'Error':
					if (_v45.b.$ === 'Error') {
						var _v48 = _v45.a;
						var _v49 = _v45.b;
						return A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1);
					} else {
						break _v45$7;
					}
				case 'Infinite':
					if (_v45.b.$ === 'Infinite') {
						var _v50 = _v45.a;
						var _v51 = _v45.b;
						return A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1);
					} else {
						break _v45$7;
					}
				case 'FlexVar':
					if (_v45.b.$ === 'FlexVar') {
						var x = _v45.a.a;
						var y = _v45.b.a;
						return _Utils_eq(x, y) ? A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1) : A4($author$project$Compiler$Type$Error$toDiff2, localizer, ctx, tipe1, tipe2);
					} else {
						break _v45$7;
					}
				case 'FlexSuper':
					if (_v45.b.$ === 'FlexSuper') {
						var _v52 = _v45.a;
						var x = _v52.b;
						var _v53 = _v45.b;
						var y = _v53.b;
						return _Utils_eq(x, y) ? A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1) : A4($author$project$Compiler$Type$Error$toDiff2, localizer, ctx, tipe1, tipe2);
					} else {
						break _v45$7;
					}
				case 'RigidVar':
					if (_v45.b.$ === 'RigidVar') {
						var x = _v45.a.a;
						var y = _v45.b.a;
						return _Utils_eq(x, y) ? A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1) : A4($author$project$Compiler$Type$Error$toDiff2, localizer, ctx, tipe1, tipe2);
					} else {
						break _v45$7;
					}
				case 'RigidSuper':
					if (_v45.b.$ === 'RigidSuper') {
						var _v54 = _v45.a;
						var x = _v54.b;
						var _v55 = _v45.b;
						var y = _v55.b;
						return _Utils_eq(x, y) ? A3($author$project$Compiler$Type$Error$same, localizer, ctx, tipe1) : A4($author$project$Compiler$Type$Error$toDiff2, localizer, ctx, tipe1, tipe2);
					} else {
						break _v45$7;
					}
				default:
					break _v45$7;
			}
		}
		return A4($author$project$Compiler$Type$Error$toDiff2, localizer, ctx, tipe1, tipe2);
	});
var $author$project$Compiler$Type$Error$toDiff2 = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v43 = _Utils_Tuple2(tipe1, tipe2);
		_v43$1:
		while (true) {
			switch (_v43.a.$) {
				case 'FlexVar':
					return A4($author$project$Compiler$Type$Error$similar, localizer, ctx, tipe1, tipe2);
				case 'FlexSuper':
					if (_v43.b.$ === 'FlexVar') {
						break _v43$1;
					} else {
						var _v44 = _v43.a;
						var s = _v44.a;
						var t = _v43.b;
						return A2($author$project$Compiler$Type$Error$isSuper, s, t) ? A4($author$project$Compiler$Type$Error$similar, localizer, ctx, tipe1, tipe2) : A4($author$project$Compiler$Type$Error$toDiff3, localizer, ctx, tipe1, tipe2);
					}
				default:
					if (_v43.b.$ === 'FlexVar') {
						break _v43$1;
					} else {
						return A4($author$project$Compiler$Type$Error$toDiff3, localizer, ctx, tipe1, tipe2);
					}
			}
		}
		return A4($author$project$Compiler$Type$Error$similar, localizer, ctx, tipe1, tipe2);
	});
var $author$project$Compiler$Type$Error$toDiff3 = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v27 = _Utils_Tuple2(tipe1, tipe2);
		_v27$7:
		while (true) {
			switch (_v27.b.$) {
				case 'FlexSuper':
					var t = _v27.a;
					var _v28 = _v27.b;
					var s = _v28.a;
					return A2($author$project$Compiler$Type$Error$isSuper, s, t) ? A4($author$project$Compiler$Type$Error$similar, localizer, ctx, tipe1, tipe2) : A4($author$project$Compiler$Type$Error$toDiff4, localizer, ctx, tipe1, tipe2);
				case 'Lambda':
					if (_v27.a.$ === 'Lambda') {
						var _v29 = _v27.a;
						var a = _v29.a;
						var b = _v29.b;
						var cs = _v29.c;
						var _v30 = _v27.b;
						var x = _v30.a;
						var y = _v30.b;
						var zs = _v30.c;
						if (_Utils_eq(
							$author$project$Extra$Type$List$length(cs),
							$author$project$Extra$Type$List$length(zs))) {
							return A2(
								$author$project$Compiler$Type$Error$andMap,
								A3(
									$author$project$Extra$Type$List$sequenceA,
									$author$project$Compiler$Type$Error$pure,
									$author$project$Compiler$Type$Error$liftA2,
									A3(
										$author$project$Extra$Type$List$zipWith,
										A2($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$Func),
										cs,
										zs)),
								A2(
									$author$project$Compiler$Type$Error$andMap,
									A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$Func, b, y),
									A2(
										$author$project$Compiler$Type$Error$andMap,
										A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$Func, a, x),
										$author$project$Compiler$Type$Error$pure(
											$author$project$Compiler$Reporting$Render$Type$lambda(ctx)))));
						} else {
							var f = A2($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$Func);
							return A3(
								$author$project$Compiler$Type$Error$different,
								$author$project$Compiler$Reporting$Doc$dullyellow(
									A4(
										$author$project$Compiler$Reporting$Render$Type$lambda,
										ctx,
										f(a),
										f(b),
										A2($author$project$Extra$Type$List$map, f, cs))),
								$author$project$Compiler$Reporting$Doc$dullyellow(
									A4(
										$author$project$Compiler$Reporting$Render$Type$lambda,
										ctx,
										f(x),
										f(y),
										A2($author$project$Extra$Type$List$map, f, zs))),
								$author$project$Compiler$Data$Bag$one(
									A2(
										$author$project$Compiler$Type$Error$ArityMismatch,
										2 + $author$project$Extra$Type$List$length(cs),
										2 + $author$project$Extra$Type$List$length(zs))));
						}
					} else {
						break _v27$7;
					}
				case 'Tuple':
					if (_v27.a.$ === 'Tuple') {
						if (_v27.a.c.$ === 'Nothing') {
							if (_v27.b.c.$ === 'Nothing') {
								var _v31 = _v27.a;
								var a = _v31.a;
								var b = _v31.b;
								var _v32 = _v31.c;
								var _v33 = _v27.b;
								var x = _v33.a;
								var y = _v33.b;
								var _v34 = _v33.c;
								return A2(
									$author$project$Compiler$Type$Error$andMap,
									$author$project$Compiler$Type$Error$pure(_List_Nil),
									A2(
										$author$project$Compiler$Type$Error$andMap,
										A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, b, y),
										A2(
											$author$project$Compiler$Type$Error$andMap,
											A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, a, x),
											$author$project$Compiler$Type$Error$pure($author$project$Compiler$Reporting$Render$Type$tuple))));
							} else {
								break _v27$7;
							}
						} else {
							if (_v27.b.c.$ === 'Just') {
								var _v35 = _v27.a;
								var a = _v35.a;
								var b = _v35.b;
								var c = _v35.c.a;
								var _v36 = _v27.b;
								var x = _v36.a;
								var y = _v36.b;
								var z = _v36.c.a;
								return A2(
									$author$project$Compiler$Type$Error$andMap,
									A2(
										$author$project$Compiler$Type$Error$fmap,
										function (d) {
											return _List_fromArray(
												[d]);
										},
										A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, c, z)),
									A2(
										$author$project$Compiler$Type$Error$andMap,
										A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, b, y),
										A2(
											$author$project$Compiler$Type$Error$andMap,
											A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, a, x),
											$author$project$Compiler$Type$Error$pure($author$project$Compiler$Reporting$Render$Type$tuple))));
							} else {
								break _v27$7;
							}
						}
					} else {
						break _v27$7;
					}
				case 'Record':
					if (_v27.a.$ === 'Record') {
						var _v37 = _v27.a;
						var fields1 = _v37.a;
						var ext1 = _v37.b;
						var _v38 = _v27.b;
						var fields2 = _v38.a;
						var ext2 = _v38.b;
						return A5($author$project$Compiler$Type$Error$diffRecord, localizer, fields1, ext1, fields2, ext2);
					} else {
						break _v27$7;
					}
				case 'Type':
					if (_v27.a.$ === 'Type') {
						var _v39 = _v27.a;
						var home1 = _v39.a;
						var name1 = _v39.b;
						var args1 = _v39.c;
						var _v40 = _v27.b;
						var home2 = _v40.a;
						var name2 = _v40.b;
						var args2 = _v40.c;
						return (_Utils_eq(home1, home2) && _Utils_eq(name1, name2)) ? A2(
							$author$project$Compiler$Type$Error$fmap,
							A2(
								$author$project$Compiler$Reporting$Render$Type$apply,
								ctx,
								A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home1, name1)),
							A3(
								$author$project$Extra$Type$List$sequenceA,
								$author$project$Compiler$Type$Error$pure,
								$author$project$Compiler$Type$Error$liftA2,
								A3(
									$author$project$Extra$Type$List$zipWith,
									A2($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$App),
									args1,
									args2))) : A4($author$project$Compiler$Type$Error$toDiff4, localizer, ctx, tipe1, tipe2);
					} else {
						break _v27$7;
					}
				case 'Alias':
					if (_v27.a.$ === 'Alias') {
						var _v41 = _v27.a;
						var home1 = _v41.a;
						var name1 = _v41.b;
						var args1 = _v41.c;
						var _v42 = _v27.b;
						var home2 = _v42.a;
						var name2 = _v42.b;
						var args2 = _v42.c;
						return (_Utils_eq(home1, home2) && _Utils_eq(name1, name2)) ? A2(
							$author$project$Compiler$Type$Error$fmap,
							A2(
								$author$project$Compiler$Reporting$Render$Type$apply,
								ctx,
								A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home1, name1)),
							A3(
								$author$project$Extra$Type$List$sequenceA,
								$author$project$Compiler$Type$Error$pure,
								$author$project$Compiler$Type$Error$liftA2,
								A3(
									$author$project$Extra$Type$List$zipWith,
									A2($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$App),
									A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, args1),
									A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, args2)))) : A4($author$project$Compiler$Type$Error$toDiff4, localizer, ctx, tipe1, tipe2);
					} else {
						break _v27$7;
					}
				default:
					break _v27$7;
			}
		}
		return A4($author$project$Compiler$Type$Error$toDiff4, localizer, ctx, tipe1, tipe2);
	});
var $author$project$Compiler$Type$Error$toDiff4 = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v24 = _Utils_Tuple2(tipe1, tipe2);
		if ((_v24.a.$ === 'Type') && (_v24.b.$ === 'Type')) {
			var _v25 = _v24.a;
			var home1 = _v25.a;
			var name1 = _v25.b;
			var args1 = _v25.c;
			var _v26 = _v24.b;
			var home2 = _v26.a;
			var name2 = _v26.b;
			var args2 = _v26.c;
			return _Utils_eq(
				A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home1, name1),
				A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home2, name2)) ? A3(
				$author$project$Compiler$Type$Error$different,
				A5($author$project$Compiler$Type$Error$nameClashToDoc, ctx, localizer, home1, name1, args1),
				A5($author$project$Compiler$Type$Error$nameClashToDoc, ctx, localizer, home2, name2, args2),
				$author$project$Compiler$Data$Bag$empty) : A4($author$project$Compiler$Type$Error$toDiff5, localizer, ctx, tipe1, tipe2);
		} else {
			return A4($author$project$Compiler$Type$Error$toDiff5, localizer, ctx, tipe1, tipe2);
		}
	});
var $author$project$Compiler$Type$Error$toDiff5 = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v21 = _Utils_Tuple2(tipe1, tipe2);
		if (((_v21.a.$ === 'Type') && _v21.a.c.b) && (!_v21.a.c.b.b)) {
			var _v22 = _v21.a;
			var home = _v22.a;
			var name = _v22.b;
			var _v23 = _v22.c;
			var t1 = _v23.a;
			var t2 = _v21.b;
			return (A2($author$project$Compiler$Type$Error$isMaybe, home, name) && $author$project$Compiler$Type$Error$isSimilar(
				A4($author$project$Compiler$Type$Error$toDiff, localizer, ctx, t1, t2))) ? A3(
				$author$project$Compiler$Type$Error$different,
				A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					ctx,
					$author$project$Compiler$Reporting$Doc$dullyellow(
						A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home, name)),
					_List_fromArray(
						[
							A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App, t1)
						])),
				A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, t2),
				$author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$AnythingFromMaybe)) : A4($author$project$Compiler$Type$Error$toDiff6, localizer, ctx, tipe1, tipe2);
		} else {
			return A4($author$project$Compiler$Type$Error$toDiff6, localizer, ctx, tipe1, tipe2);
		}
	});
var $author$project$Compiler$Type$Error$toDiff6 = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v18 = _Utils_Tuple2(tipe1, tipe2);
		if (((_v18.b.$ === 'Type') && _v18.b.c.b) && (!_v18.b.c.b.b)) {
			var t1 = _v18.a;
			var _v19 = _v18.b;
			var home = _v19.a;
			var name = _v19.b;
			var _v20 = _v19.c;
			var t2 = _v20.a;
			return (A2($author$project$Compiler$Type$Error$isList, home, name) && $author$project$Compiler$Type$Error$isSimilar(
				A4($author$project$Compiler$Type$Error$toDiff, localizer, ctx, t1, t2))) ? A3(
				$author$project$Compiler$Type$Error$different,
				A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, t1),
				A3(
					$author$project$Compiler$Reporting$Render$Type$apply,
					ctx,
					$author$project$Compiler$Reporting$Doc$dullyellow(
						A3($author$project$Compiler$Reporting$Render$Type$Localizer$toDoc, localizer, home, name)),
					_List_fromArray(
						[
							A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$App, t2)
						])),
				$author$project$Compiler$Data$Bag$empty) : A4($author$project$Compiler$Type$Error$toDiff7, localizer, ctx, tipe1, tipe2);
		} else {
			return A4($author$project$Compiler$Type$Error$toDiff7, localizer, ctx, tipe1, tipe2);
		}
	});
var $author$project$Compiler$Type$Error$toDiff7 = F4(
	function (localizer, ctx, tipe1, tipe2) {
		var _v0 = _Utils_Tuple2(tipe1, tipe2);
		if (_v0.a.$ === 'Alias') {
			var _v1 = _v0.a;
			var home1 = _v1.a;
			var name1 = _v1.b;
			var args1 = _v1.c;
			var t1 = _v1.d;
			var t2 = _v0.b;
			var _v2 = A3($author$project$Compiler$Type$Error$diffAliasedRecord, localizer, t1, t2);
			if (_v2.$ === 'Just') {
				var _v3 = _v2.a;
				var doc2 = _v3.b;
				var status = _v3.c;
				return A3(
					$author$project$Compiler$Type$Error$Diff,
					$author$project$Compiler$Reporting$Doc$dullyellow(
						A5($author$project$Compiler$Type$Error$aliasToDoc, localizer, ctx, home1, name1, args1)),
					doc2,
					status);
			} else {
				var otherwise = function (_v5) {
					return A3(
						$author$project$Compiler$Type$Error$different,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe1)),
						$author$project$Compiler$Reporting$Doc$dullyellow(
							A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe2)),
						$author$project$Compiler$Data$Bag$empty);
				};
				if (t2.$ === 'Type') {
					var home2 = t2.a;
					var name2 = t2.b;
					var args2 = t2.c;
					return _Utils_eq(
						A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home1, name1),
						A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home2, name2)) ? A3(
						$author$project$Compiler$Type$Error$different,
						A5(
							$author$project$Compiler$Type$Error$nameClashToDoc,
							ctx,
							localizer,
							home1,
							name1,
							A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, args1)),
						A5($author$project$Compiler$Type$Error$nameClashToDoc, ctx, localizer, home2, name2, args2),
						$author$project$Compiler$Data$Bag$empty) : otherwise(_Utils_Tuple0);
				} else {
					return otherwise(_Utils_Tuple0);
				}
			}
		} else {
			if (_v0.b.$ === 'Alias') {
				var t1 = _v0.a;
				var _v6 = _v0.b;
				var home2 = _v6.a;
				var name2 = _v6.b;
				var args2 = _v6.c;
				var t2 = _v6.d;
				var _v7 = A3($author$project$Compiler$Type$Error$diffAliasedRecord, localizer, t1, t2);
				if (_v7.$ === 'Just') {
					var _v8 = _v7.a;
					var doc1 = _v8.a;
					var status = _v8.c;
					return A3(
						$author$project$Compiler$Type$Error$Diff,
						doc1,
						$author$project$Compiler$Reporting$Doc$dullyellow(
							A5($author$project$Compiler$Type$Error$aliasToDoc, localizer, ctx, home2, name2, args2)),
						status);
				} else {
					var otherwise = function (_v10) {
						return A3(
							$author$project$Compiler$Type$Error$different,
							$author$project$Compiler$Reporting$Doc$dullyellow(
								A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe1)),
							$author$project$Compiler$Reporting$Doc$dullyellow(
								A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe2)),
							$author$project$Compiler$Data$Bag$empty);
					};
					if (t1.$ === 'Type') {
						var home1 = t1.a;
						var name1 = t1.b;
						var args1 = t1.c;
						return _Utils_eq(
							A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home1, name1),
							A3($author$project$Compiler$Reporting$Render$Type$Localizer$toChars, localizer, home2, name2)) ? A3(
							$author$project$Compiler$Type$Error$different,
							A5($author$project$Compiler$Type$Error$nameClashToDoc, ctx, localizer, home1, name1, args1),
							A5(
								$author$project$Compiler$Type$Error$nameClashToDoc,
								ctx,
								localizer,
								home2,
								name2,
								A2($author$project$Extra$Type$List$map, $elm$core$Tuple$second, args2)),
							$author$project$Compiler$Data$Bag$empty) : otherwise(_Utils_Tuple0);
					} else {
						return otherwise(_Utils_Tuple0);
					}
				}
			} else {
				var pair = _v0;
				var doc2 = $author$project$Compiler$Reporting$Doc$dullyellow(
					A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe2));
				var doc1 = $author$project$Compiler$Reporting$Doc$dullyellow(
					A3($author$project$Compiler$Type$Error$toDoc, localizer, ctx, tipe1));
				return A3(
					$author$project$Compiler$Type$Error$different,
					doc1,
					doc2,
					function () {
						_v11$3:
						while (true) {
							_v11$4:
							while (true) {
								_v11$5:
								while (true) {
									_v11$7:
									while (true) {
										switch (pair.a.$) {
											case 'RigidVar':
												var x = pair.a.a;
												var other = pair.b;
												return $author$project$Compiler$Data$Bag$one(
													A2($author$project$Compiler$Type$Error$BadRigidVar, x, other));
											case 'FlexSuper':
												var _v12 = pair.a;
												var s = _v12.a;
												var other = pair.b;
												return $author$project$Compiler$Data$Bag$one(
													A3($author$project$Compiler$Type$Error$BadFlexSuper, $author$project$Compiler$Type$Error$Have, s, other));
											case 'RigidSuper':
												var _v13 = pair.a;
												var s = _v13.a;
												var x = _v13.b;
												var other = pair.b;
												return $author$project$Compiler$Data$Bag$one(
													A3($author$project$Compiler$Type$Error$BadRigidSuper, s, x, other));
											case 'Type':
												switch (pair.b.$) {
													case 'RigidVar':
														break _v11$3;
													case 'FlexSuper':
														break _v11$4;
													case 'RigidSuper':
														break _v11$5;
													case 'Type':
														if ((!pair.a.c.b) && (!pair.b.c.b)) {
															var _v16 = pair.a;
															var home1 = _v16.a;
															var name1 = _v16.b;
															var _v17 = pair.b;
															var home2 = _v17.a;
															var name2 = _v17.b;
															return (A2($author$project$Compiler$Type$Error$isInt, home1, name1) && A2($author$project$Compiler$Type$Error$isFloat, home2, name2)) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$IntFloat) : ((A2($author$project$Compiler$Type$Error$isFloat, home1, name1) && A2($author$project$Compiler$Type$Error$isInt, home2, name2)) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$IntFloat) : ((A2($author$project$Compiler$Type$Error$isInt, home1, name1) && A2($author$project$Compiler$Type$Error$isString, home2, name2)) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$StringFromInt) : ((A2($author$project$Compiler$Type$Error$isFloat, home1, name1) && A2($author$project$Compiler$Type$Error$isString, home2, name2)) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$StringFromFloat) : ((A2($author$project$Compiler$Type$Error$isString, home1, name1) && A2($author$project$Compiler$Type$Error$isInt, home2, name2)) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$StringToInt) : ((A2($author$project$Compiler$Type$Error$isString, home1, name1) && A2($author$project$Compiler$Type$Error$isFloat, home2, name2)) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$StringToFloat) : (A2($author$project$Compiler$Type$Error$isBool, home2, name2) ? $author$project$Compiler$Data$Bag$one($author$project$Compiler$Type$Error$AnythingToBool) : $author$project$Compiler$Data$Bag$empty))))));
														} else {
															break _v11$7;
														}
													default:
														break _v11$7;
												}
											default:
												switch (pair.b.$) {
													case 'RigidVar':
														break _v11$3;
													case 'FlexSuper':
														break _v11$4;
													case 'RigidSuper':
														break _v11$5;
													default:
														break _v11$7;
												}
										}
									}
									return $author$project$Compiler$Data$Bag$empty;
								}
								var other = pair.a;
								var _v15 = pair.b;
								var s = _v15.a;
								var x = _v15.b;
								return $author$project$Compiler$Data$Bag$one(
									A3($author$project$Compiler$Type$Error$BadRigidSuper, s, x, other));
							}
							var other = pair.a;
							var _v14 = pair.b;
							var s = _v14.a;
							return $author$project$Compiler$Data$Bag$one(
								A3($author$project$Compiler$Type$Error$BadFlexSuper, $author$project$Compiler$Type$Error$Need, s, other));
						}
						var other = pair.a;
						var x = pair.b.a;
						return $author$project$Compiler$Data$Bag$one(
							A2($author$project$Compiler$Type$Error$BadRigidVar, x, other));
					}());
			}
		}
	});
var $author$project$Compiler$Data$Bag$toListHelp = F2(
	function (bag, list) {
		toListHelp:
		while (true) {
			switch (bag.$) {
				case 'Empty':
					return list;
				case 'One':
					var x = bag.a;
					return A2($elm$core$List$cons, x, list);
				default:
					var a = bag.a;
					var b = bag.b;
					var $temp$bag = a,
						$temp$list = A2($author$project$Compiler$Data$Bag$toListHelp, b, list);
					bag = $temp$bag;
					list = $temp$list;
					continue toListHelp;
			}
		}
	});
var $author$project$Compiler$Data$Bag$toList = function (bag) {
	return A2($author$project$Compiler$Data$Bag$toListHelp, bag, _List_Nil);
};
var $author$project$Compiler$Type$Error$toComparison = F3(
	function (localizer, tipe1, tipe2) {
		var _v0 = A4($author$project$Compiler$Type$Error$toDiff, localizer, $author$project$Compiler$Reporting$Render$Type$None, tipe1, tipe2);
		if (_v0.c.$ === 'Similar') {
			var doc1 = _v0.a;
			var doc2 = _v0.b;
			var _v1 = _v0.c;
			return _Utils_Tuple3(doc1, doc2, _List_Nil);
		} else {
			var doc1 = _v0.a;
			var doc2 = _v0.b;
			var problems = _v0.c.a;
			return _Utils_Tuple3(
				doc1,
				doc2,
				$author$project$Compiler$Data$Bag$toList(problems));
		}
	});
var $author$project$Compiler$Reporting$Error$Type$loneType = F5(
	function (localizer, actual, expected, iAmSeeing, furtherDetails) {
		var _v0 = A3($author$project$Compiler$Type$Error$toComparison, localizer, actual, expected);
		var actualDoc = _v0.a;
		var problems = _v0.c;
		return $author$project$Compiler$Reporting$Doc$stack(
			_Utils_ap(
				_List_fromArray(
					[
						iAmSeeing,
						A2($author$project$Compiler$Reporting$Doc$indent, 4, actualDoc)
					]),
				_Utils_ap(
					furtherDetails,
					$author$project$Compiler$Reporting$Error$Type$problemsToHint(problems))));
	});
var $author$project$Compiler$Reporting$Error$Type$AList = {$: 'AList'};
var $author$project$Compiler$Reporting$Error$Type$ANumber = F2(
	function (a, b) {
		return {$: 'ANumber', a: a, b: b};
	});
var $author$project$Compiler$Reporting$Error$Type$AOther = {$: 'AOther'};
var $author$project$Compiler$Reporting$Error$Type$AString = {$: 'AString'};
var $author$project$Compiler$Reporting$Error$Type$toAppendType = function (tipe) {
	_v0$2:
	while (true) {
		switch (tipe.$) {
			case 'Type':
				var home = tipe.a;
				var name = tipe.b;
				return A2($author$project$Compiler$Type$Error$isInt, home, name) ? A2(
					$author$project$Compiler$Reporting$Error$Type$ANumber,
					$author$project$Compiler$Reporting$Doc$d('Int'),
					$author$project$Compiler$Reporting$Doc$d('String.fromInt')) : (A2($author$project$Compiler$Type$Error$isFloat, home, name) ? A2(
					$author$project$Compiler$Reporting$Error$Type$ANumber,
					$author$project$Compiler$Reporting$Doc$d('Float'),
					$author$project$Compiler$Reporting$Doc$d('String.fromFloat')) : (A2($author$project$Compiler$Type$Error$isString, home, name) ? $author$project$Compiler$Reporting$Error$Type$AString : (A2($author$project$Compiler$Type$Error$isList, home, name) ? $author$project$Compiler$Reporting$Error$Type$AList : $author$project$Compiler$Reporting$Error$Type$AOther)));
			case 'FlexSuper':
				if (tipe.a.$ === 'Number') {
					var _v1 = tipe.a;
					return A2(
						$author$project$Compiler$Reporting$Error$Type$ANumber,
						$author$project$Compiler$Reporting$Doc$d('number'),
						$author$project$Compiler$Reporting$Doc$d('String.fromInt'));
				} else {
					break _v0$2;
				}
			default:
				break _v0$2;
		}
	}
	return $author$project$Compiler$Reporting$Error$Type$AOther;
};
var $author$project$Compiler$Reporting$Error$Type$badAppendLeft = F4(
	function (localizer, category, tipe, expected) {
		var _v0 = $author$project$Compiler$Reporting$Error$Type$toAppendType(tipe);
		if (_v0.$ === 'ANumber') {
			var thing = _v0.a;
			var stringFromThing = _v0.b;
			return _Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$fillSep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('The'),
							$author$project$Compiler$Reporting$Doc$d('(++)'),
							$author$project$Compiler$Reporting$Doc$d('operator'),
							$author$project$Compiler$Reporting$Doc$d('can'),
							$author$project$Compiler$Reporting$Doc$d('append'),
							$author$project$Compiler$Reporting$Doc$d('List'),
							$author$project$Compiler$Reporting$Doc$d('and'),
							$author$project$Compiler$Reporting$Doc$d('String'),
							$author$project$Compiler$Reporting$Doc$d('values,d'),
							$author$project$Compiler$Reporting$Doc$d('but'),
							$author$project$Compiler$Reporting$Doc$d('not'),
							$author$project$Compiler$Reporting$Doc$dullyellow(thing),
							$author$project$Compiler$Reporting$Doc$d('values'),
							$author$project$Compiler$Reporting$Doc$d('like'),
							$author$project$Compiler$Reporting$Doc$d('this:')
						])),
				$author$project$Compiler$Reporting$Doc$fillSep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Try'),
							$author$project$Compiler$Reporting$Doc$d('using'),
							$author$project$Compiler$Reporting$Doc$green(stringFromThing),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('turn'),
							$author$project$Compiler$Reporting$Doc$d('it'),
							$author$project$Compiler$Reporting$Doc$d('into'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('string?'),
							$author$project$Compiler$Reporting$Doc$d('Or'),
							$author$project$Compiler$Reporting$Doc$d('put'),
							$author$project$Compiler$Reporting$Doc$d('it'),
							$author$project$Compiler$Reporting$Doc$d('in'),
							$author$project$Compiler$Reporting$Doc$d('[]'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('make'),
							$author$project$Compiler$Reporting$Doc$d('it'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('list?'),
							$author$project$Compiler$Reporting$Doc$d('Or'),
							$author$project$Compiler$Reporting$Doc$d('switch'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$d('(::)'),
							$author$project$Compiler$Reporting$Doc$d('operator?')
						])));
		} else {
			return _Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$reflow('The (++) operator cannot append this type of value:'),
				A5(
					$author$project$Compiler$Reporting$Error$Type$loneType,
					localizer,
					tipe,
					expected,
					$author$project$Compiler$Reporting$Doc$reflow(
						A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'I am seeing', category)),
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$fillSep(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('But'),
									$author$project$Compiler$Reporting$Doc$d('the'),
									$author$project$Compiler$Reporting$Doc$d('(++)'),
									$author$project$Compiler$Reporting$Doc$d('operator'),
									$author$project$Compiler$Reporting$Doc$d('is'),
									$author$project$Compiler$Reporting$Doc$d('only'),
									$author$project$Compiler$Reporting$Doc$d('for'),
									$author$project$Compiler$Reporting$Doc$d('appending'),
									$author$project$Compiler$Reporting$Doc$dullyellowS('List'),
									$author$project$Compiler$Reporting$Doc$d('and'),
									$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
									$author$project$Compiler$Reporting$Doc$d('values.'),
									$author$project$Compiler$Reporting$Doc$d('Maybe'),
									$author$project$Compiler$Reporting$Doc$d('put'),
									$author$project$Compiler$Reporting$Doc$d('this'),
									$author$project$Compiler$Reporting$Doc$d('value'),
									$author$project$Compiler$Reporting$Doc$d('in'),
									$author$project$Compiler$Reporting$Doc$d('[]'),
									$author$project$Compiler$Reporting$Doc$d('to'),
									$author$project$Compiler$Reporting$Doc$d('make'),
									$author$project$Compiler$Reporting$Doc$d('it'),
									$author$project$Compiler$Reporting$Doc$d('a'),
									$author$project$Compiler$Reporting$Doc$d('list?')
								]))
						])));
		}
	});
var $author$project$Compiler$Reporting$Error$Type$badBool = F5(
	function (localizer, op, direction, tipe, expected) {
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$reflow('I am struggling with this boolean operation:'),
			A5(
				$author$project$Compiler$Reporting$Error$Type$loneType,
				localizer,
				tipe,
				expected,
				$author$project$Compiler$Reporting$Doc$fillSep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Both'),
							$author$project$Compiler$Reporting$Doc$d('sides'),
							$author$project$Compiler$Reporting$Doc$d('of'),
							$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$d('('),
									op,
									$author$project$Compiler$Reporting$Doc$d(')')
								])),
							$author$project$Compiler$Reporting$Doc$d('must'),
							$author$project$Compiler$Reporting$Doc$d('be'),
							$author$project$Compiler$Reporting$Doc$dullyellowS('Bool'),
							$author$project$Compiler$Reporting$Doc$d('values,'),
							$author$project$Compiler$Reporting$Doc$d('but'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							direction,
							$author$project$Compiler$Reporting$Doc$d('side'),
							$author$project$Compiler$Reporting$Doc$d('is:')
						])),
				_List_Nil));
	});
var $author$project$Compiler$Reporting$Error$Type$badCompLeft = F6(
	function (localizer, category, op, direction, tipe, expected) {
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$reflow('I cannot do a comparison with this value:'),
			A5(
				$author$project$Compiler$Reporting$Error$Type$loneType,
				localizer,
				tipe,
				expected,
				$author$project$Compiler$Reporting$Doc$reflow(
					A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'The ' + (direction + (' side of (' + (op + ') is'))), category)),
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('But'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('('),
										$author$project$Compiler$Reporting$Doc$fromChars(op),
										$author$project$Compiler$Reporting$Doc$d(')')
									])),
								$author$project$Compiler$Reporting$Doc$d('only'),
								$author$project$Compiler$Reporting$Doc$d('works'),
								$author$project$Compiler$Reporting$Doc$d('on'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
										$author$project$Compiler$Reporting$Doc$d(',')
									])),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
										$author$project$Compiler$Reporting$Doc$d(',')
									])),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Char'),
										$author$project$Compiler$Reporting$Doc$d(',')
									])),
								$author$project$Compiler$Reporting$Doc$d('and'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
								$author$project$Compiler$Reporting$Doc$d('values.'),
								$author$project$Compiler$Reporting$Doc$d('It'),
								$author$project$Compiler$Reporting$Doc$d('can'),
								$author$project$Compiler$Reporting$Doc$d('work'),
								$author$project$Compiler$Reporting$Doc$d('on'),
								$author$project$Compiler$Reporting$Doc$d('lists'),
								$author$project$Compiler$Reporting$Doc$d('and'),
								$author$project$Compiler$Reporting$Doc$d('tuples'),
								$author$project$Compiler$Reporting$Doc$d('of'),
								$author$project$Compiler$Reporting$Doc$d('comparable'),
								$author$project$Compiler$Reporting$Doc$d('values'),
								$author$project$Compiler$Reporting$Doc$d('as'),
								$author$project$Compiler$Reporting$Doc$d('well,d'),
								$author$project$Compiler$Reporting$Doc$d('but'),
								$author$project$Compiler$Reporting$Doc$d('it'),
								$author$project$Compiler$Reporting$Doc$d('is'),
								$author$project$Compiler$Reporting$Doc$d('usually'),
								$author$project$Compiler$Reporting$Doc$d('better'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('find'),
								$author$project$Compiler$Reporting$Doc$d('a'),
								$author$project$Compiler$Reporting$Doc$d('different'),
								$author$project$Compiler$Reporting$Doc$d('path.')
							]))
					])));
	});
var $author$project$Extra$Data$Pretty$blackS = function (str) {
	return A2(
		$the_sett$elm_pretty_printer$Pretty$taggedString,
		str,
		function ($) {
			return $.black;
		});
};
var $author$project$Compiler$Reporting$Doc$blackS = $author$project$Extra$Data$Pretty$blackS;
var $author$project$Compiler$Reporting$Error$Type$isInt = function (tipe) {
	if ((tipe.$ === 'Type') && (!tipe.c.b)) {
		var home = tipe.a;
		var name = tipe.b;
		return A2($author$project$Compiler$Type$Error$isInt, home, name);
	} else {
		return false;
	}
};
var $author$project$Compiler$Reporting$Error$Type$badFDiv = F4(
	function (localizer, direction, tipe, expected) {
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$reflow('The (/) operator is specifically for floating-point division:'),
			$author$project$Compiler$Reporting$Error$Type$isInt(tipe) ? $author$project$Compiler$Reporting$Doc$stack(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('The'),
								direction,
								$author$project$Compiler$Reporting$Doc$d('side'),
								$author$project$Compiler$Reporting$Doc$d('of'),
								$author$project$Compiler$Reporting$Doc$d('(/)'),
								$author$project$Compiler$Reporting$Doc$d('must'),
								$author$project$Compiler$Reporting$Doc$d('be'),
								$author$project$Compiler$Reporting$Doc$d('a'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
										$author$project$Compiler$Reporting$Doc$d(',')
									])),
								$author$project$Compiler$Reporting$Doc$d('but'),
								$author$project$Compiler$Reporting$Doc$d('I'),
								$author$project$Compiler$Reporting$Doc$d('am'),
								$author$project$Compiler$Reporting$Doc$d('seeing'),
								$author$project$Compiler$Reporting$Doc$d('an'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
										$author$project$Compiler$Reporting$Doc$d('.')
									])),
								$author$project$Compiler$Reporting$Doc$d('I'),
								$author$project$Compiler$Reporting$Doc$d('recommend:')
							])),
						$author$project$Compiler$Reporting$Doc$vcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('toFloat'),
										$author$project$Compiler$Reporting$Doc$d(' for explicit conversions     '),
										$author$project$Compiler$Reporting$Doc$blackS('(toFloat 5 / 2) == 2.5')
									])),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('(//)   '),
										$author$project$Compiler$Reporting$Doc$d(' for integer division         '),
										$author$project$Compiler$Reporting$Doc$blackS('(5 // 2)        == 2')
									]))
							])),
						A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Read', 'implicit-casts', 'to learn why Elm does not implicitly convert Ints to Floats.')
					])) : A5(
				$author$project$Compiler$Reporting$Error$Type$loneType,
				localizer,
				tipe,
				expected,
				$author$project$Compiler$Reporting$Doc$fillSep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('The'),
							direction,
							$author$project$Compiler$Reporting$Doc$d('side'),
							$author$project$Compiler$Reporting$Doc$d('of'),
							$author$project$Compiler$Reporting$Doc$d('(/)'),
							$author$project$Compiler$Reporting$Doc$d('must'),
							$author$project$Compiler$Reporting$Doc$d('be'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
									$author$project$Compiler$Reporting$Doc$d(',')
								])),
							$author$project$Compiler$Reporting$Doc$d('but'),
							$author$project$Compiler$Reporting$Doc$d('instead'),
							$author$project$Compiler$Reporting$Doc$d('I'),
							$author$project$Compiler$Reporting$Doc$d('am'),
							$author$project$Compiler$Reporting$Doc$d('seeing:')
						])),
				_List_Nil));
	});
var $author$project$Compiler$Reporting$Error$Type$isFloat = function (tipe) {
	if ((tipe.$ === 'Type') && (!tipe.c.b)) {
		var home = tipe.a;
		var name = tipe.b;
		return A2($author$project$Compiler$Type$Error$isFloat, home, name);
	} else {
		return false;
	}
};
var $author$project$Compiler$Reporting$Error$Type$badIDiv = F4(
	function (localizer, direction, tipe, expected) {
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$reflow('The (//) operator is specifically for integer division:'),
			$author$project$Compiler$Reporting$Error$Type$isFloat(tipe) ? $author$project$Compiler$Reporting$Doc$stack(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('The'),
								direction,
								$author$project$Compiler$Reporting$Doc$d('side'),
								$author$project$Compiler$Reporting$Doc$d('of'),
								$author$project$Compiler$Reporting$Doc$d('(//)'),
								$author$project$Compiler$Reporting$Doc$d('must'),
								$author$project$Compiler$Reporting$Doc$d('be'),
								$author$project$Compiler$Reporting$Doc$d('an'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
										$author$project$Compiler$Reporting$Doc$d(',')
									])),
								$author$project$Compiler$Reporting$Doc$d('but'),
								$author$project$Compiler$Reporting$Doc$d('I'),
								$author$project$Compiler$Reporting$Doc$d('am'),
								$author$project$Compiler$Reporting$Doc$d('seeing'),
								$author$project$Compiler$Reporting$Doc$d('a'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
										$author$project$Compiler$Reporting$Doc$d('.')
									])),
								$author$project$Compiler$Reporting$Doc$d('I'),
								$author$project$Compiler$Reporting$Doc$d('recommend'),
								$author$project$Compiler$Reporting$Doc$d('doing'),
								$author$project$Compiler$Reporting$Doc$d('the'),
								$author$project$Compiler$Reporting$Doc$d('conversion'),
								$author$project$Compiler$Reporting$Doc$d('explicitly'),
								$author$project$Compiler$Reporting$Doc$d('with'),
								$author$project$Compiler$Reporting$Doc$d('one'),
								$author$project$Compiler$Reporting$Doc$d('of'),
								$author$project$Compiler$Reporting$Doc$d('these'),
								$author$project$Compiler$Reporting$Doc$d('functions:')
							])),
						$author$project$Compiler$Reporting$Doc$vcat(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('round'),
										$author$project$Compiler$Reporting$Doc$d(' 3.5     == 4')
									])),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('floor'),
										$author$project$Compiler$Reporting$Doc$d(' 3.5     == 3')
									])),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('ceiling'),
										$author$project$Compiler$Reporting$Doc$d(' 3.5   == 4')
									])),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$greenS('truncate'),
										$author$project$Compiler$Reporting$Doc$d(' 3.5  == 3')
									]))
							])),
						A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Read', 'implicit-casts', 'to learn why Elm does not implicitly convert Ints to Floats.')
					])) : A5(
				$author$project$Compiler$Reporting$Error$Type$loneType,
				localizer,
				tipe,
				expected,
				$author$project$Compiler$Reporting$Doc$fillSep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('The'),
							direction,
							$author$project$Compiler$Reporting$Doc$d('side'),
							$author$project$Compiler$Reporting$Doc$d('of'),
							$author$project$Compiler$Reporting$Doc$d('(//)'),
							$author$project$Compiler$Reporting$Doc$d('must'),
							$author$project$Compiler$Reporting$Doc$d('be'),
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$da(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
									$author$project$Compiler$Reporting$Doc$d(',')
								])),
							$author$project$Compiler$Reporting$Doc$d('but'),
							$author$project$Compiler$Reporting$Doc$d('instead'),
							$author$project$Compiler$Reporting$Doc$d('I'),
							$author$project$Compiler$Reporting$Doc$d('am'),
							$author$project$Compiler$Reporting$Doc$d('seeing:')
						])),
				_List_Nil));
	});
var $author$project$Compiler$Reporting$Error$Type$badListAdd = F5(
	function (localizer, category, direction, tipe, expected) {
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$d('I cannot do addition with lists:'),
			A5(
				$author$project$Compiler$Reporting$Error$Type$loneType,
				localizer,
				tipe,
				expected,
				$author$project$Compiler$Reporting$Doc$reflow(
					A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'The ' + (direction + ' side of (+) is'), category)),
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('But'),
								$author$project$Compiler$Reporting$Doc$d('(+)'),
								$author$project$Compiler$Reporting$Doc$d('only'),
								$author$project$Compiler$Reporting$Doc$d('works'),
								$author$project$Compiler$Reporting$Doc$d('with'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
								$author$project$Compiler$Reporting$Doc$d('and'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
								$author$project$Compiler$Reporting$Doc$d('values.')
							])),
						$author$project$Compiler$Reporting$Doc$toFancyHint(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('Switch'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('the'),
								$author$project$Compiler$Reporting$Doc$greenS('(++)'),
								$author$project$Compiler$Reporting$Doc$d('operator'),
								$author$project$Compiler$Reporting$Doc$d('to'),
								$author$project$Compiler$Reporting$Doc$d('append'),
								$author$project$Compiler$Reporting$Doc$d('lists!')
							]))
					])));
	});
var $author$project$Compiler$Reporting$Error$Type$badMath = F8(
	function (localizer, category, operation, direction, op, tipe, expected, otherHints) {
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$reflow(operation + ' does not work with this value:'),
			A5(
				$author$project$Compiler$Reporting$Error$Type$loneType,
				localizer,
				tipe,
				expected,
				$author$project$Compiler$Reporting$Doc$reflow(
					A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'The ' + (direction + (' side of (' + (op + ') is'))), category)),
				A2(
					$elm$core$List$cons,
					$author$project$Compiler$Reporting$Doc$fillSep(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('But'),
								$author$project$Compiler$Reporting$Doc$da(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('('),
										$author$project$Compiler$Reporting$Doc$fromChars(op),
										$author$project$Compiler$Reporting$Doc$d(')')
									])),
								$author$project$Compiler$Reporting$Doc$d('only'),
								$author$project$Compiler$Reporting$Doc$d('works'),
								$author$project$Compiler$Reporting$Doc$d('with'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
								$author$project$Compiler$Reporting$Doc$d('and'),
								$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
								$author$project$Compiler$Reporting$Doc$d('values.')
							])),
					otherHints)));
	});
var $author$project$Compiler$Reporting$Error$Type$badListMul = F5(
	function (localizer, category, direction, tipe, expected) {
		return A8(
			$author$project$Compiler$Reporting$Error$Type$badMath,
			localizer,
			category,
			'Multiplication',
			direction,
			'*',
			tipe,
			expected,
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$toFancyHint(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Maybe'),
							$author$project$Compiler$Reporting$Doc$d('you'),
							$author$project$Compiler$Reporting$Doc$d('want'),
							$author$project$Compiler$Reporting$Doc$greenS('List.repeat'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('build'),
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$d('list'),
							$author$project$Compiler$Reporting$Doc$d('of'),
							$author$project$Compiler$Reporting$Doc$d('repeated'),
							$author$project$Compiler$Reporting$Doc$d('values?')
						]))
				]));
	});
var $author$project$Compiler$Reporting$Error$Type$badStringAdd = _Utils_Tuple2(
	$author$project$Compiler$Reporting$Doc$fillSep(
		_List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$d('I'),
				$author$project$Compiler$Reporting$Doc$d('cannot'),
				$author$project$Compiler$Reporting$Doc$d('do'),
				$author$project$Compiler$Reporting$Doc$d('addition'),
				$author$project$Compiler$Reporting$Doc$d('with'),
				$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
				$author$project$Compiler$Reporting$Doc$d('values'),
				$author$project$Compiler$Reporting$Doc$d('like'),
				$author$project$Compiler$Reporting$Doc$d('this'),
				$author$project$Compiler$Reporting$Doc$d('one:')
			])),
	$author$project$Compiler$Reporting$Doc$stack(
		_List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$fillSep(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$d('The'),
						$author$project$Compiler$Reporting$Doc$d('(+)'),
						$author$project$Compiler$Reporting$Doc$d('operator'),
						$author$project$Compiler$Reporting$Doc$d('only'),
						$author$project$Compiler$Reporting$Doc$d('works'),
						$author$project$Compiler$Reporting$Doc$d('with'),
						$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
						$author$project$Compiler$Reporting$Doc$d('and'),
						$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
						$author$project$Compiler$Reporting$Doc$d('values.')
					])),
				$author$project$Compiler$Reporting$Doc$toFancyHint(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$d('Switch'),
						$author$project$Compiler$Reporting$Doc$d('to'),
						$author$project$Compiler$Reporting$Doc$d('the'),
						$author$project$Compiler$Reporting$Doc$greenS('(++)'),
						$author$project$Compiler$Reporting$Doc$d('operator'),
						$author$project$Compiler$Reporting$Doc$d('to'),
						$author$project$Compiler$Reporting$Doc$d('append'),
						$author$project$Compiler$Reporting$Doc$d('strings!')
					]))
			])));
var $author$project$Compiler$Reporting$Error$Type$isList = function (tipe) {
	if (((tipe.$ === 'Type') && tipe.c.b) && (!tipe.c.b.b)) {
		var home = tipe.a;
		var name = tipe.b;
		var _v1 = tipe.c;
		return A2($author$project$Compiler$Type$Error$isList, home, name);
	} else {
		return false;
	}
};
var $author$project$Compiler$Reporting$Error$Type$isString = function (tipe) {
	if ((tipe.$ === 'Type') && (!tipe.c.b)) {
		var home = tipe.a;
		var name = tipe.b;
		return A2($author$project$Compiler$Type$Error$isString, home, name);
	} else {
		return false;
	}
};
var $author$project$Compiler$Reporting$Error$Type$typeComparison = F6(
	function (localizer, actual, expected, iAmSeeing, insteadOf, contextHints) {
		var _v0 = A3($author$project$Compiler$Type$Error$toComparison, localizer, actual, expected);
		var actualDoc = _v0.a;
		var expectedDoc = _v0.b;
		var problems = _v0.c;
		return $author$project$Compiler$Reporting$Doc$stack(
			_Utils_ap(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow(iAmSeeing),
						A2($author$project$Compiler$Reporting$Doc$indent, 4, actualDoc),
						$author$project$Compiler$Reporting$Doc$reflow(insteadOf),
						A2($author$project$Compiler$Reporting$Doc$indent, 4, expectedDoc)
					]),
				_Utils_ap(
					contextHints,
					$author$project$Compiler$Reporting$Error$Type$problemsToHint(problems))));
	});
var $author$project$Compiler$Reporting$Error$Type$opLeftToDocs = F5(
	function (localizer, category, op, tipe, expected) {
		switch (op) {
			case '+':
				return $author$project$Compiler$Reporting$Error$Type$isString(tipe) ? $author$project$Compiler$Reporting$Error$Type$badStringAdd : ($author$project$Compiler$Reporting$Error$Type$isList(tipe) ? A5($author$project$Compiler$Reporting$Error$Type$badListAdd, localizer, category, 'left', tipe, expected) : A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Addition', 'left', '+', tipe, expected, _List_Nil));
			case '*':
				return $author$project$Compiler$Reporting$Error$Type$isList(tipe) ? A5($author$project$Compiler$Reporting$Error$Type$badListMul, localizer, category, 'left', tipe, expected) : A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Multiplication', 'left', '*', tipe, expected, _List_Nil);
			case '-':
				return A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Subtraction', 'left', '-', tipe, expected, _List_Nil);
			case '^':
				return A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Exponentiation', 'left', '^', tipe, expected, _List_Nil);
			case '/':
				return A4(
					$author$project$Compiler$Reporting$Error$Type$badFDiv,
					localizer,
					$author$project$Compiler$Reporting$Doc$d('left'),
					tipe,
					expected);
			case '//':
				return A4(
					$author$project$Compiler$Reporting$Error$Type$badIDiv,
					localizer,
					$author$project$Compiler$Reporting$Doc$d('left'),
					tipe,
					expected);
			case '&&':
				return A5(
					$author$project$Compiler$Reporting$Error$Type$badBool,
					localizer,
					$author$project$Compiler$Reporting$Doc$d('&&'),
					$author$project$Compiler$Reporting$Doc$d('left'),
					tipe,
					expected);
			case '||':
				return A5(
					$author$project$Compiler$Reporting$Error$Type$badBool,
					localizer,
					$author$project$Compiler$Reporting$Doc$d('||'),
					$author$project$Compiler$Reporting$Doc$d('left'),
					tipe,
					expected);
			case '<':
				return A6($author$project$Compiler$Reporting$Error$Type$badCompLeft, localizer, category, '<', 'left', tipe, expected);
			case '>':
				return A6($author$project$Compiler$Reporting$Error$Type$badCompLeft, localizer, category, '>', 'left', tipe, expected);
			case '<=':
				return A6($author$project$Compiler$Reporting$Error$Type$badCompLeft, localizer, category, '<=', 'left', tipe, expected);
			case '>=':
				return A6($author$project$Compiler$Reporting$Error$Type$badCompLeft, localizer, category, '>=', 'left', tipe, expected);
			case '++':
				return A4($author$project$Compiler$Reporting$Error$Type$badAppendLeft, localizer, category, tipe, expected);
			case '<|':
				return _Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$d('The left side of (<|) needs to be a function so I can pipe arguments to it!'),
					A5(
						$author$project$Compiler$Reporting$Error$Type$loneType,
						localizer,
						tipe,
						expected,
						$author$project$Compiler$Reporting$Doc$reflow(
							A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'I am seeing', category)),
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('This needs to be some kind of function though!')
							])));
			default:
				return _Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('The left argument of (' + (op + ') is causing problems:')),
					A6(
						$author$project$Compiler$Reporting$Error$Type$typeComparison,
						localizer,
						tipe,
						expected,
						A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'The left argument is', category),
						'But (' + (op + ') needs the left argument to be:'),
						_List_Nil));
		}
	});
var $author$project$Compiler$Reporting$Error$Type$EmphRight = function (a) {
	return {$: 'EmphRight', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$FloatInt = {$: 'FloatInt'};
var $author$project$Compiler$Reporting$Error$Type$IntFloat = {$: 'IntFloat'};
var $author$project$Compiler$Reporting$Error$Type$EmphBoth = function (a) {
	return {$: 'EmphBoth', a: a};
};
var $author$project$Compiler$Reporting$Error$Type$badAppendRight = F4(
	function (localizer, category, tipe, expected) {
		var _v0 = _Utils_Tuple2(
			$author$project$Compiler$Reporting$Error$Type$toAppendType(expected),
			$author$project$Compiler$Reporting$Error$Type$toAppendType(tipe));
		_v0$4:
		while (true) {
			switch (_v0.a.$) {
				case 'AString':
					switch (_v0.b.$) {
						case 'ANumber':
							var _v1 = _v0.a;
							var _v2 = _v0.b;
							var thing = _v2.a;
							var stringFromThing = _v2.b;
							return $author$project$Compiler$Reporting$Error$Type$EmphRight(
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('thought'),
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('was'),
												$author$project$Compiler$Reporting$Doc$d('appending'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
												$author$project$Compiler$Reporting$Doc$d('values'),
												$author$project$Compiler$Reporting$Doc$d('here,d'),
												$author$project$Compiler$Reporting$Doc$d('not'),
												$author$project$Compiler$Reporting$Doc$dullyellow(thing),
												$author$project$Compiler$Reporting$Doc$d('values'),
												$author$project$Compiler$Reporting$Doc$d('like'),
												$author$project$Compiler$Reporting$Doc$d('this:')
											])),
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('Try'),
												$author$project$Compiler$Reporting$Doc$d('using'),
												$author$project$Compiler$Reporting$Doc$green(stringFromThing),
												$author$project$Compiler$Reporting$Doc$d('to'),
												$author$project$Compiler$Reporting$Doc$d('turn'),
												$author$project$Compiler$Reporting$Doc$d('it'),
												$author$project$Compiler$Reporting$Doc$d('into'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$d('string?')
											]))));
						case 'AList':
							var _v5 = _v0.a;
							var _v6 = _v0.b;
							return $author$project$Compiler$Reporting$Error$Type$EmphBoth(
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('The (++) operator needs the same type of value on both sides:'),
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('see'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
												$author$project$Compiler$Reporting$Doc$d('on'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('left'),
												$author$project$Compiler$Reporting$Doc$d('and'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('List'),
												$author$project$Compiler$Reporting$Doc$d('on'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('right.'),
												$author$project$Compiler$Reporting$Doc$d('Which'),
												$author$project$Compiler$Reporting$Doc$d('should'),
												$author$project$Compiler$Reporting$Doc$d('it'),
												$author$project$Compiler$Reporting$Doc$d('be?'),
												$author$project$Compiler$Reporting$Doc$d('Does'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('string'),
												$author$project$Compiler$Reporting$Doc$d('need'),
												$author$project$Compiler$Reporting$Doc$d('[]'),
												$author$project$Compiler$Reporting$Doc$d('around'),
												$author$project$Compiler$Reporting$Doc$d('it'),
												$author$project$Compiler$Reporting$Doc$d('to'),
												$author$project$Compiler$Reporting$Doc$d('become'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$d('list?')
											]))));
						default:
							break _v0$4;
					}
				case 'AList':
					switch (_v0.b.$) {
						case 'ANumber':
							var _v3 = _v0.a;
							var _v4 = _v0.b;
							var thing = _v4.a;
							return $author$project$Compiler$Reporting$Error$Type$EmphRight(
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('thought'),
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('was'),
												$author$project$Compiler$Reporting$Doc$d('appending'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('List'),
												$author$project$Compiler$Reporting$Doc$d('values'),
												$author$project$Compiler$Reporting$Doc$d('here,'),
												$author$project$Compiler$Reporting$Doc$d('not'),
												$author$project$Compiler$Reporting$Doc$dullyellow(thing),
												$author$project$Compiler$Reporting$Doc$d('values'),
												$author$project$Compiler$Reporting$Doc$d('like'),
												$author$project$Compiler$Reporting$Doc$d('this:')
											])),
									$author$project$Compiler$Reporting$Doc$reflow('Try putting it in [] to make it a list?')));
						case 'AString':
							var _v7 = _v0.a;
							var _v8 = _v0.b;
							return $author$project$Compiler$Reporting$Error$Type$EmphBoth(
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow('The (++) operator needs the same type of value on both sides:'),
									$author$project$Compiler$Reporting$Doc$fillSep(
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$d('I'),
												$author$project$Compiler$Reporting$Doc$d('see'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('List'),
												$author$project$Compiler$Reporting$Doc$d('on'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('left'),
												$author$project$Compiler$Reporting$Doc$d('and'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$dullyellowS('String'),
												$author$project$Compiler$Reporting$Doc$d('on'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('right.'),
												$author$project$Compiler$Reporting$Doc$d('Which'),
												$author$project$Compiler$Reporting$Doc$d('should'),
												$author$project$Compiler$Reporting$Doc$d('it'),
												$author$project$Compiler$Reporting$Doc$d('be?'),
												$author$project$Compiler$Reporting$Doc$d('Does'),
												$author$project$Compiler$Reporting$Doc$d('the'),
												$author$project$Compiler$Reporting$Doc$d('string'),
												$author$project$Compiler$Reporting$Doc$d('need'),
												$author$project$Compiler$Reporting$Doc$d('[]'),
												$author$project$Compiler$Reporting$Doc$d('around'),
												$author$project$Compiler$Reporting$Doc$d('it'),
												$author$project$Compiler$Reporting$Doc$d('to'),
												$author$project$Compiler$Reporting$Doc$d('become'),
												$author$project$Compiler$Reporting$Doc$d('a'),
												$author$project$Compiler$Reporting$Doc$d('list?')
											]))));
						default:
							break _v0$4;
					}
				default:
					break _v0$4;
			}
		}
		return $author$project$Compiler$Reporting$Error$Type$EmphBoth(
			_Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$reflow('The (++) operator cannot append these two values:'),
				A6(
					$author$project$Compiler$Reporting$Error$Type$typeComparison,
					localizer,
					expected,
					tipe,
					'I already figured out that the left side of (++) is:',
					A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'But this clashes with the right side, which is', category),
					_List_Nil)));
	});
var $author$project$Compiler$Reporting$Error$Type$badCastHelp = F4(
	function (anInt, aFloat, toFloat, round) {
		return $author$project$Compiler$Reporting$Doc$stack(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$fillSep(
					_Utils_ap(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('But'),
								$author$project$Compiler$Reporting$Doc$d('I'),
								$author$project$Compiler$Reporting$Doc$d('see')
							]),
						_Utils_ap(
							anInt,
							_Utils_ap(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('on'),
										$author$project$Compiler$Reporting$Doc$d('the'),
										$author$project$Compiler$Reporting$Doc$d('left'),
										$author$project$Compiler$Reporting$Doc$d('and')
									]),
								_Utils_ap(
									aFloat,
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('on'),
											$author$project$Compiler$Reporting$Doc$d('the'),
											$author$project$Compiler$Reporting$Doc$d('right.')
										])))))),
					$author$project$Compiler$Reporting$Doc$fillSep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('Use'),
							toFloat,
							$author$project$Compiler$Reporting$Doc$d('on'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$d('left'),
							$author$project$Compiler$Reporting$Doc$d('(or'),
							round,
							$author$project$Compiler$Reporting$Doc$d('on'),
							$author$project$Compiler$Reporting$Doc$d('the'),
							$author$project$Compiler$Reporting$Doc$d('right)'),
							$author$project$Compiler$Reporting$Doc$d('to'),
							$author$project$Compiler$Reporting$Doc$d('make'),
							$author$project$Compiler$Reporting$Doc$d('both'),
							$author$project$Compiler$Reporting$Doc$d('sides'),
							$author$project$Compiler$Reporting$Doc$d('match!')
						])),
					A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'Read', 'implicit-casts', 'to learn why Elm does not implicitly convert Ints to Floats.')
				]));
	});
var $author$project$Compiler$Reporting$Error$Type$badCast = F2(
	function (op, thisThenThat) {
		return $author$project$Compiler$Reporting$Error$Type$EmphBoth(
			_Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$reflow('I need both sides of (' + (op + ') to be the exact same type. Both Int or both Float.')),
				function () {
					var toFloat = $author$project$Compiler$Reporting$Doc$greenS('toFloat');
					var round = $author$project$Compiler$Reporting$Doc$greenS('round');
					var anInt = _List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('an'),
							$author$project$Compiler$Reporting$Doc$dullyellowS('Int')
						]);
					var aFloat = _List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('a'),
							$author$project$Compiler$Reporting$Doc$dullyellowS('Float')
						]);
					if (thisThenThat.$ === 'FloatInt') {
						return A4($author$project$Compiler$Reporting$Error$Type$badCastHelp, aFloat, anInt, round, toFloat);
					} else {
						return A4($author$project$Compiler$Reporting$Error$Type$badCastHelp, anInt, aFloat, toFloat, round);
					}
				}()));
	});
var $author$project$Compiler$Reporting$Error$Type$badCompRight = F4(
	function (localizer, op, tipe, expected) {
		return $author$project$Compiler$Reporting$Error$Type$EmphBoth(
			_Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$reflow('I need both sides of (' + (op + ') to be the same type:')),
				A6(
					$author$project$Compiler$Reporting$Error$Type$typeComparison,
					localizer,
					expected,
					tipe,
					'The left side of (' + (op + ') is:'),
					'But the right side is:',
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$reflow('I cannot compare different types though! Which side of (' + (op + ') is the problem?'))
						]))));
	});
var $author$project$Compiler$Reporting$Error$Type$badOpRightFallback = F5(
	function (localizer, category, op, tipe, expected) {
		return $author$project$Compiler$Reporting$Error$Type$EmphRight(
			_Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$reflow('The right argument of (' + (op + ') is causing problems.')),
				A6(
					$author$project$Compiler$Reporting$Error$Type$typeComparison,
					localizer,
					tipe,
					expected,
					A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'The right argument is', category),
					'But (' + (op + ') needs the right argument to be:'),
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$toSimpleHint('With operators like (' + (op + (') I always check the left' + (' side first. If it seems fine, I assume it is correct and check the right' + ' side. So the problem may be in how the left and right arguments interact!'))))
						]))));
	});
var $author$project$Compiler$Reporting$Error$Type$badConsRight = F4(
	function (localizer, category, tipe, expected) {
		var otherwise1 = function (_v8) {
			return $author$project$Compiler$Reporting$Error$Type$EmphRight(
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('The (::) operator can only add elements onto lists.'),
					A5(
						$author$project$Compiler$Reporting$Error$Type$loneType,
						localizer,
						tipe,
						expected,
						$author$project$Compiler$Reporting$Doc$reflow(
							A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'The right side is', category)),
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$fillSep(
								_List_fromArray(
									[
										$author$project$Compiler$Reporting$Doc$d('But'),
										$author$project$Compiler$Reporting$Doc$d('(::)'),
										$author$project$Compiler$Reporting$Doc$d('needs'),
										$author$project$Compiler$Reporting$Doc$d('a'),
										$author$project$Compiler$Reporting$Doc$dullyellowS('List'),
										$author$project$Compiler$Reporting$Doc$d('on'),
										$author$project$Compiler$Reporting$Doc$d('the'),
										$author$project$Compiler$Reporting$Doc$d('right.')
									]))
							]))));
		};
		if (((tipe.$ === 'Type') && tipe.c.b) && (!tipe.c.b.b)) {
			var home1 = tipe.a;
			var name1 = tipe.b;
			var _v1 = tipe.c;
			var actualElement = _v1.a;
			if (A2($author$project$Compiler$Type$Error$isList, home1, name1)) {
				var otherwise2 = function (_v7) {
					return A5($author$project$Compiler$Reporting$Error$Type$badOpRightFallback, localizer, category, '::', tipe, expected);
				};
				if (((expected.$ === 'Type') && expected.c.b) && (!expected.c.b.b)) {
					var home2 = expected.a;
					var name2 = expected.b;
					var _v3 = expected.c;
					var expectedElement = _v3.a;
					return A2($author$project$Compiler$Type$Error$isList, home2, name2) ? $author$project$Compiler$Reporting$Error$Type$EmphBoth(
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('I am having trouble with this (::) operator:'),
							A6(
								$author$project$Compiler$Reporting$Error$Type$typeComparison,
								localizer,
								expectedElement,
								actualElement,
								'The left side of (::) is:',
								'But you are trying to put that into a list filled with:',
								function () {
									var otherwise3 = function (_v6) {
										return _List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('Lists need ALL elements to be the same type though.')
											]);
									};
									if (((expectedElement.$ === 'Type') && expectedElement.c.b) && (!expectedElement.c.b.b)) {
										var home = expectedElement.a;
										var name = expectedElement.b;
										var _v5 = expectedElement.c;
										return A2($author$project$Compiler$Type$Error$isList, home, name) ? _List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$toSimpleHint('Are you trying to append two lists? The (++) operator' + (' appends lists, whereas the (::) operator is only for' + ' adding ONE element to a list.'))
											]) : otherwise3(_Utils_Tuple0);
									} else {
										return otherwise3(_Utils_Tuple0);
									}
								}()))) : otherwise2(_Utils_Tuple0);
				} else {
					return otherwise2(_Utils_Tuple0);
				}
			} else {
				return otherwise1(_Utils_Tuple0);
			}
		} else {
			return otherwise1(_Utils_Tuple0);
		}
	});
var $author$project$Compiler$Reporting$Error$Type$badEquality = F4(
	function (localizer, op, tipe, expected) {
		return $author$project$Compiler$Reporting$Error$Type$EmphBoth(
			_Utils_Tuple2(
				$author$project$Compiler$Reporting$Doc$reflow('I need both sides of (' + (op + ') to be the same type:')),
				A6(
					$author$project$Compiler$Reporting$Error$Type$typeComparison,
					localizer,
					expected,
					tipe,
					'The left side of (' + (op + ') is:'),
					'But the right side is:',
					_List_fromArray(
						[
							($author$project$Compiler$Reporting$Error$Type$isFloat(tipe) || $author$project$Compiler$Reporting$Error$Type$isFloat(expected)) ? $author$project$Compiler$Reporting$Doc$toSimpleNote('Equality on floats is not 100% reliable due to the design of IEEE 754. I' + ' recommend a check like (abs (x - y) < 0.0001) instead.') : $author$project$Compiler$Reporting$Doc$reflow('Different types can never be equal though! Which side is messed up?')
						]))));
	});
var $author$project$Compiler$Reporting$Error$Type$opRightToDocs = F5(
	function (localizer, category, op, tipe, expected) {
		switch (op) {
			case '+':
				return ($author$project$Compiler$Reporting$Error$Type$isFloat(expected) && $author$project$Compiler$Reporting$Error$Type$isInt(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$FloatInt) : (($author$project$Compiler$Reporting$Error$Type$isInt(expected) && $author$project$Compiler$Reporting$Error$Type$isFloat(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$IntFloat) : ($author$project$Compiler$Reporting$Error$Type$isString(tipe) ? $author$project$Compiler$Reporting$Error$Type$EmphRight($author$project$Compiler$Reporting$Error$Type$badStringAdd) : ($author$project$Compiler$Reporting$Error$Type$isList(tipe) ? $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A5($author$project$Compiler$Reporting$Error$Type$badListAdd, localizer, category, 'right', tipe, expected)) : $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Addition', 'right', '+', tipe, expected, _List_Nil)))));
			case '*':
				return ($author$project$Compiler$Reporting$Error$Type$isFloat(expected) && $author$project$Compiler$Reporting$Error$Type$isInt(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$FloatInt) : (($author$project$Compiler$Reporting$Error$Type$isInt(expected) && $author$project$Compiler$Reporting$Error$Type$isFloat(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$IntFloat) : ($author$project$Compiler$Reporting$Error$Type$isList(tipe) ? $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A5($author$project$Compiler$Reporting$Error$Type$badListMul, localizer, category, 'right', tipe, expected)) : $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Multiplication', 'right', '*', tipe, expected, _List_Nil))));
			case '-':
				return ($author$project$Compiler$Reporting$Error$Type$isFloat(expected) && $author$project$Compiler$Reporting$Error$Type$isInt(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$FloatInt) : (($author$project$Compiler$Reporting$Error$Type$isInt(expected) && $author$project$Compiler$Reporting$Error$Type$isFloat(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$IntFloat) : $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Subtraction', 'right', '-', tipe, expected, _List_Nil)));
			case '^':
				return ($author$project$Compiler$Reporting$Error$Type$isFloat(expected) && $author$project$Compiler$Reporting$Error$Type$isInt(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$FloatInt) : (($author$project$Compiler$Reporting$Error$Type$isInt(expected) && $author$project$Compiler$Reporting$Error$Type$isFloat(tipe)) ? A2($author$project$Compiler$Reporting$Error$Type$badCast, op, $author$project$Compiler$Reporting$Error$Type$IntFloat) : $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A8($author$project$Compiler$Reporting$Error$Type$badMath, localizer, category, 'Exponentiation', 'right', '^', tipe, expected, _List_Nil)));
			case '/':
				return $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A4(
						$author$project$Compiler$Reporting$Error$Type$badFDiv,
						localizer,
						$author$project$Compiler$Reporting$Doc$d('right'),
						tipe,
						expected));
			case '//':
				return $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A4(
						$author$project$Compiler$Reporting$Error$Type$badIDiv,
						localizer,
						$author$project$Compiler$Reporting$Doc$d('right'),
						tipe,
						expected));
			case '&&':
				return $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A5(
						$author$project$Compiler$Reporting$Error$Type$badBool,
						localizer,
						$author$project$Compiler$Reporting$Doc$d('&&'),
						$author$project$Compiler$Reporting$Doc$d('right'),
						tipe,
						expected));
			case '||':
				return $author$project$Compiler$Reporting$Error$Type$EmphRight(
					A5(
						$author$project$Compiler$Reporting$Error$Type$badBool,
						localizer,
						$author$project$Compiler$Reporting$Doc$d('||'),
						$author$project$Compiler$Reporting$Doc$d('right'),
						tipe,
						expected));
			case '<':
				return A4($author$project$Compiler$Reporting$Error$Type$badCompRight, localizer, '<', tipe, expected);
			case '>':
				return A4($author$project$Compiler$Reporting$Error$Type$badCompRight, localizer, '>', tipe, expected);
			case '<=':
				return A4($author$project$Compiler$Reporting$Error$Type$badCompRight, localizer, '<=', tipe, expected);
			case '>=':
				return A4($author$project$Compiler$Reporting$Error$Type$badCompRight, localizer, '>=', tipe, expected);
			case '==':
				return A4($author$project$Compiler$Reporting$Error$Type$badEquality, localizer, '==', tipe, expected);
			case '/=':
				return A4($author$project$Compiler$Reporting$Error$Type$badEquality, localizer, '/=', tipe, expected);
			case '::':
				return A4($author$project$Compiler$Reporting$Error$Type$badConsRight, localizer, category, tipe, expected);
			case '++':
				return A4($author$project$Compiler$Reporting$Error$Type$badAppendRight, localizer, category, tipe, expected);
			case '<|':
				return $author$project$Compiler$Reporting$Error$Type$EmphRight(
					_Utils_Tuple2(
						$author$project$Compiler$Reporting$Doc$reflow('I cannot send this through the (<|) pipe:'),
						A6($author$project$Compiler$Reporting$Error$Type$typeComparison, localizer, tipe, expected, 'The argument is:', 'But (<|) is piping it to a function that expects:', _List_Nil)));
			case '|>':
				var _v1 = _Utils_Tuple2(tipe, expected);
				if ((_v1.a.$ === 'Lambda') && (_v1.b.$ === 'Lambda')) {
					var _v2 = _v1.a;
					var expectedArgType = _v2.a;
					var _v3 = _v1.b;
					var argType = _v3.a;
					return $author$project$Compiler$Reporting$Error$Type$EmphRight(
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('This function cannot handle the argument sent through the (|>) pipe:'),
							A6($author$project$Compiler$Reporting$Error$Type$typeComparison, localizer, argType, expectedArgType, 'The argument is:', 'But (|>) is piping it to a function that expects:', _List_Nil)));
				} else {
					return $author$project$Compiler$Reporting$Error$Type$EmphRight(
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('The right side of (|>) needs to be a function so I can pipe arguments to it!'),
							A5(
								$author$project$Compiler$Reporting$Error$Type$loneType,
								localizer,
								tipe,
								expected,
								$author$project$Compiler$Reporting$Doc$reflow(
									A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'But instead of a function, I am seeing', category)),
								_List_Nil)));
				}
			default:
				return A5($author$project$Compiler$Reporting$Error$Type$badOpRightFallback, localizer, category, op, tipe, expected);
		}
	});
var $author$project$Compiler$Reporting$Doc$ordinal = function (index) {
	return $author$project$Compiler$Reporting$Doc$intToOrdinal(
		$author$project$Compiler$Data$Index$toHuman(index));
};
var $author$project$Compiler$Reporting$Error$Type$extToDoc = function (ext) {
	switch (ext.$) {
		case 'Closed':
			return $elm$core$Maybe$Nothing;
		case 'FlexOpen':
			var x = ext.a;
			return $elm$core$Maybe$Just(
				$author$project$Compiler$Reporting$Doc$fromName(x));
		default:
			var x = ext.a;
			return $elm$core$Maybe$Just(
				$author$project$Compiler$Reporting$Doc$fromName(x));
	}
};
var $author$project$Compiler$Reporting$Error$Type$fieldToDocs = F2(
	function (localizer, _v0) {
		var name = _v0.a;
		var tipe = _v0.b;
		return _Utils_Tuple2(
			$author$project$Compiler$Reporting$Doc$fromName(name),
			A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, tipe));
	});
var $author$project$Compiler$Reporting$Render$Type$vrecord = F2(
	function (entries, maybeExt) {
		var _v0 = _Utils_Tuple2(
			A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Render$Type$entryToDoc, entries),
			maybeExt);
		if (_v0.b.$ === 'Nothing') {
			if (!_v0.a.b) {
				var _v1 = _v0.b;
				return $author$project$Compiler$Reporting$Doc$d('{}');
			} else {
				var fields = _v0.a;
				var _v2 = _v0.b;
				return $author$project$Compiler$Reporting$Doc$vcat(
					_Utils_ap(
						A3($author$project$Compiler$Reporting$Render$Type$zipWithHelp, '{', ',', fields),
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$d('}')
							])));
			}
		} else {
			var fields = _v0.a;
			var ext = _v0.b.a;
			return $author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$hang,
						4,
						$author$project$Compiler$Reporting$Doc$vcat(
							_List_fromArray(
								[
									$author$project$Compiler$Reporting$Doc$hsep(
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$d('{'),
											ext
										])),
									$author$project$Compiler$Reporting$Doc$cat(
									A3($author$project$Compiler$Reporting$Render$Type$zipWithHelp, '|', ',', fields))
								]))),
						$author$project$Compiler$Reporting$Doc$d('}')
					]));
		}
	});
var $author$project$Compiler$Reporting$Render$Type$vrecordSnippet = F2(
	function (entry, entries) {
		var fields = A3(
			$author$project$Compiler$Reporting$Render$Type$zipWithHelp,
			',',
			',',
			_Utils_ap(
				A2($author$project$Extra$Type$List$map, $author$project$Compiler$Reporting$Render$Type$entryToDoc, entries),
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$d('...')
					])));
		var field = $author$project$Compiler$Reporting$Doc$hsep(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$d('{'),
					$author$project$Compiler$Reporting$Render$Type$entryToDoc(entry)
				]));
		return $author$project$Compiler$Reporting$Doc$vcat(
			A2(
				$elm$core$List$cons,
				field,
				_Utils_ap(
					fields,
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$d('}')
						]))));
	});
var $author$project$Compiler$Reporting$Error$Type$toNearbyRecord = F4(
	function (localizer, f, fs, ext) {
		return A2(
			$author$project$Compiler$Reporting$Doc$indent,
			4,
			($author$project$Extra$Type$List$length(fs) <= 3) ? A2(
				$author$project$Compiler$Reporting$Render$Type$vrecord,
				A2(
					$author$project$Extra$Type$List$map,
					$author$project$Compiler$Reporting$Error$Type$fieldToDocs(localizer),
					A2($elm$core$List$cons, f, fs)),
				$author$project$Compiler$Reporting$Error$Type$extToDoc(ext)) : A2(
				$author$project$Compiler$Reporting$Render$Type$vrecordSnippet,
				A2($author$project$Compiler$Reporting$Error$Type$fieldToDocs, localizer, f),
				A2(
					$author$project$Extra$Type$List$map,
					$author$project$Compiler$Reporting$Error$Type$fieldToDocs(localizer),
					A2($author$project$Extra$Type$List$take, 3, fs))));
	});
var $author$project$Compiler$Reporting$Error$Type$toExprReport = F6(
	function (source, localizer, exprRegion, category, tipe, expected) {
		switch (expected.$) {
			case 'NoExpectation':
				var expectedType = expected.a;
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'TYPE MISMATCH',
					exprRegion,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						exprRegion,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$d('This expression is being used in an unexpected way:'),
							A6(
								$author$project$Compiler$Reporting$Error$Type$typeComparison,
								localizer,
								tipe,
								expectedType,
								A2($author$project$Compiler$Reporting$Error$Type$addCategory, 'It is', category),
								'But you are trying to use it as:',
								_List_Nil))));
			case 'FromAnnotation':
				var name = expected.a;
				var subContext = expected.c;
				var expectedType = expected.d;
				var thing = function () {
					switch (subContext.$) {
						case 'TypedIfBranch':
							var index = subContext.a;
							return $author$project$Compiler$Reporting$Doc$ordinal(index) + ' branch of this `if` expression:';
						case 'TypedCaseBranch':
							var index = subContext.a;
							return $author$project$Compiler$Reporting$Doc$ordinal(index) + ' branch of this `case` expression:';
						default:
							return 'body of the `' + (name + '` definition:');
					}
				}();
				var itIs = function () {
					switch (subContext.$) {
						case 'TypedIfBranch':
							var index = subContext.a;
							return 'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' branch is');
						case 'TypedCaseBranch':
							var index = subContext.a;
							return 'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' branch is');
						default:
							return 'The body is';
					}
				}();
				return A3(
					$author$project$Compiler$Reporting$Report$Report,
					'TYPE MISMATCH',
					exprRegion,
					A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						exprRegion,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$reflow('Something is off with the ' + thing),
							A6(
								$author$project$Compiler$Reporting$Error$Type$typeComparison,
								localizer,
								tipe,
								expectedType,
								A2($author$project$Compiler$Reporting$Error$Type$addCategory, itIs, category),
								'But the type annotation on `' + (name + '` says it should be:'),
								_List_Nil))));
			default:
				var region = expected.a;
				var context = expected.b;
				var expectedType = expected.c;
				var mismatch = function (_v18) {
					var maybeHighlight = _v18.a;
					var problem = _v18.b;
					var _v19 = _v18.c;
					var thisIs = _v19.a;
					var insteadOf = _v19.b;
					var furtherDetails = _v19.c;
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'TYPE MISMATCH',
						exprRegion,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							maybeHighlight,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow(problem),
								A6(
									$author$project$Compiler$Reporting$Error$Type$typeComparison,
									localizer,
									tipe,
									expectedType,
									A2($author$project$Compiler$Reporting$Error$Type$addCategory, thisIs, category),
									insteadOf,
									furtherDetails))));
				};
				var custom = F2(
					function (maybeHighlight, docPair) {
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'TYPE MISMATCH',
							exprRegion,
							A4($author$project$Compiler$Reporting$Render$Code$toSnippet, source, region, maybeHighlight, docPair));
					});
				var badType = function (_v16) {
					var maybeHighlight = _v16.a;
					var problem = _v16.b;
					var _v17 = _v16.c;
					var thisIs = _v17.a;
					var furtherDetails = _v17.b;
					return A3(
						$author$project$Compiler$Reporting$Report$Report,
						'TYPE MISMATCH',
						exprRegion,
						A4(
							$author$project$Compiler$Reporting$Render$Code$toSnippet,
							source,
							region,
							maybeHighlight,
							_Utils_Tuple2(
								$author$project$Compiler$Reporting$Doc$reflow(problem),
								A5(
									$author$project$Compiler$Reporting$Error$Type$loneType,
									localizer,
									tipe,
									expectedType,
									$author$project$Compiler$Reporting$Doc$reflow(
										A2($author$project$Compiler$Reporting$Error$Type$addCategory, thisIs, category)),
									furtherDetails))));
				};
				switch (context.$) {
					case 'ListEntry':
						var index = context.a;
						var ith = $author$project$Compiler$Reporting$Doc$ordinal(index);
						return mismatch(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'The ' + (ith + ' element of this list does not match all the previous elements:'),
								_Utils_Tuple3(
									'The ' + (ith + ' element is'),
									'But all the previous elements in the list are:',
									_List_fromArray(
										[
											A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'Everything in a list must be the same type of value. This way, we never' + ' run into unexpected values partway through a List.map, List.foldl, etc. Read', 'custom-types', 'to learn how to mix types.')
										]))));
					case 'Negate':
						return badType(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'I do not know how to negate this type of value:',
								_Utils_Tuple2(
									'It is',
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$d('But'),
													$author$project$Compiler$Reporting$Doc$d('I'),
													$author$project$Compiler$Reporting$Doc$d('only'),
													$author$project$Compiler$Reporting$Doc$d('now'),
													$author$project$Compiler$Reporting$Doc$d('how'),
													$author$project$Compiler$Reporting$Doc$d('to'),
													$author$project$Compiler$Reporting$Doc$d('negate'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('Int'),
													$author$project$Compiler$Reporting$Doc$d('and'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('Float'),
													$author$project$Compiler$Reporting$Doc$d('values.')
												]))
										]))));
					case 'OpLeft':
						var op = context.a;
						return A2(
							custom,
							$elm$core$Maybe$Just(exprRegion),
							A5($author$project$Compiler$Reporting$Error$Type$opLeftToDocs, localizer, category, op, tipe, expectedType));
					case 'OpRight':
						var op = context.a;
						var _v4 = A5($author$project$Compiler$Reporting$Error$Type$opRightToDocs, localizer, category, op, tipe, expectedType);
						if (_v4.$ === 'EmphBoth') {
							var details = _v4.a;
							return A2(custom, $elm$core$Maybe$Nothing, details);
						} else {
							var details = _v4.a;
							return A2(
								custom,
								$elm$core$Maybe$Just(exprRegion),
								details);
						}
					case 'IfCondition':
						return badType(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'This `if` condition does not evaluate to a boolean value, True or False.',
								_Utils_Tuple2(
									'It is',
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$fillSep(
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$d('But'),
													$author$project$Compiler$Reporting$Doc$d('I'),
													$author$project$Compiler$Reporting$Doc$d('need'),
													$author$project$Compiler$Reporting$Doc$d('this'),
													$author$project$Compiler$Reporting$Doc$d('`if`'),
													$author$project$Compiler$Reporting$Doc$d('condition'),
													$author$project$Compiler$Reporting$Doc$d('to'),
													$author$project$Compiler$Reporting$Doc$d('be'),
													$author$project$Compiler$Reporting$Doc$d('a'),
													$author$project$Compiler$Reporting$Doc$dullyellowS('Bool'),
													$author$project$Compiler$Reporting$Doc$d('value.')
												]))
										]))));
					case 'IfBranch':
						var index = context.a;
						var ith = $author$project$Compiler$Reporting$Doc$ordinal(index);
						return mismatch(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'The ' + (ith + ' branch of this `if` does not match all the previous branches:'),
								_Utils_Tuple3(
									'The ' + (ith + ' branch is'),
									'But all the previous branches result in:',
									_List_fromArray(
										[
											A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'All branches in an `if` must produce the same type of values. This way, no' + ' matter which branch we take, the result is always a consistent shape. Read', 'custom-types', 'to learn how to mix types.')
										]))));
					case 'CaseBranch':
						var index = context.a;
						var ith = $author$project$Compiler$Reporting$Doc$ordinal(index);
						return mismatch(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'The ' + (ith + ' branch of this `case` does not match all the previous branches:'),
								_Utils_Tuple3(
									'The ' + (ith + ' branch is'),
									'But all the previous branches result in:',
									_List_fromArray(
										[
											A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'All branches in a `case` must produce the same type of values. This way, no' + ' matter which branch we take, the result is always a consistent shape. Read', 'custom-types', 'to learn how to mix types.')
										]))));
					case 'CallArity':
						var maybeFuncName = context.a;
						var numGivenArgs = context.b;
						return A3(
							$author$project$Compiler$Reporting$Report$Report,
							'TOO MANY ARGS',
							exprRegion,
							A4(
								$author$project$Compiler$Reporting$Render$Code$toSnippet,
								source,
								region,
								$elm$core$Maybe$Just(exprRegion),
								function () {
									var _v5 = $author$project$Compiler$Reporting$Error$Type$countArgs(tipe);
									if (!_v5) {
										var thisValue = function () {
											switch (maybeFuncName.$) {
												case 'NoName':
													return 'This value';
												case 'FuncName':
													var name = maybeFuncName.a;
													return 'The `' + (name + '` value');
												case 'CtorName':
													var name = maybeFuncName.a;
													return 'The `' + (name + '` value');
												default:
													var op = maybeFuncName.a;
													return 'The (' + (op + ') operator');
											}
										}();
										return _Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow(
												thisValue + (' is not a function, but it was given ' + ($author$project$Compiler$Reporting$Doc$args(numGivenArgs) + '.'))),
											$author$project$Compiler$Reporting$Doc$reflow('Are there any missing commas? Or missing parentheses?'));
									} else {
										var n = _v5;
										var thisFunction = function () {
											switch (maybeFuncName.$) {
												case 'NoName':
													return 'This function';
												case 'FuncName':
													var name = maybeFuncName.a;
													return 'The `' + (name + '` function');
												case 'CtorName':
													var name = maybeFuncName.a;
													return 'The `' + (name + '` constructor');
												default:
													var op = maybeFuncName.a;
													return 'The (' + (op + ') operator');
											}
										}();
										return _Utils_Tuple2(
											$author$project$Compiler$Reporting$Doc$reflow(
												thisFunction + (' expects ' + ($author$project$Compiler$Reporting$Doc$args(n) + (', but it got ' + ($elm$core$String$fromInt(numGivenArgs) + ' instead.'))))),
											$author$project$Compiler$Reporting$Doc$reflow('Are there any missing commas? Or missing parentheses?'));
									}
								}()));
					case 'CallArg':
						var maybeFuncName = context.a;
						var index = context.b;
						var thisFunction = function () {
							switch (maybeFuncName.$) {
								case 'NoName':
									return 'this function';
								case 'FuncName':
									var name = maybeFuncName.a;
									return '`' + (name + '`');
								case 'CtorName':
									var name = maybeFuncName.a;
									return '`' + (name + '`');
								default:
									var op = maybeFuncName.a;
									return '(' + (op + ')');
							}
						}();
						var ith = $author$project$Compiler$Reporting$Doc$ordinal(index);
						return mismatch(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'The ' + (ith + (' argument to ' + (thisFunction + ' is not what I expect:'))),
								_Utils_Tuple3(
									'This argument is',
									'But ' + (thisFunction + (' needs the ' + (ith + ' argument to be:'))),
									($author$project$Compiler$Data$Index$toHuman(index) === 1) ? _List_Nil : _List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$toSimpleHint('I always figure out the argument types from left to right. If an argument' + (' is acceptable, I assume it is correct and move on. So the problem may' + ' actually be in one of the previous arguments!'))
										]))));
					case 'RecordAccess':
						var recordRegion = context.a;
						var maybeName = context.b;
						var fieldRegion = context.c;
						var field = context.d;
						var _v9 = $author$project$Compiler$Type$Error$iteratedDealias(tipe);
						if (_v9.$ === 'Record') {
							var fields = _v9.a;
							var ext = _v9.b;
							return A2(
								custom,
								$elm$core$Maybe$Just(fieldRegion),
								_Utils_Tuple2(
									$author$project$Compiler$Reporting$Doc$reflow(
										'This ' + (A3(
											$author$project$Extra$Type$Maybe$maybe,
											'',
											function (n) {
												return '`' + (n + '`');
											},
											maybeName) + (' record does not have a `' + (field + '` field:')))),
									function () {
										var _v10 = A3(
											$author$project$Compiler$Reporting$Suggest$sort,
											field,
											$elm$core$Tuple$first,
											$author$project$Extra$Type$Map$toList(fields));
										if (!_v10.b) {
											return $author$project$Compiler$Reporting$Doc$reflow('In fact, it is a record with NO fields!');
										} else {
											var f = _v10.a;
											var fs = _v10.b;
											return $author$project$Compiler$Reporting$Doc$stack(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$reflow(
														'This is usually a typo. Here are the ' + (A3(
															$author$project$Extra$Type$Maybe$maybe,
															'',
															function (n) {
																return '`' + (n + '`');
															},
															maybeName) + ' fields that are most similar:')),
														A4($author$project$Compiler$Reporting$Error$Type$toNearbyRecord, localizer, f, fs, ext),
														$author$project$Compiler$Reporting$Doc$fillSep(
														_List_fromArray(
															[
																$author$project$Compiler$Reporting$Doc$d('So'),
																$author$project$Compiler$Reporting$Doc$d('maybe'),
																$author$project$Compiler$Reporting$Doc$dullyellow(
																$author$project$Compiler$Reporting$Doc$fromName(field)),
																$author$project$Compiler$Reporting$Doc$d('should'),
																$author$project$Compiler$Reporting$Doc$d('be'),
																$author$project$Compiler$Reporting$Doc$da(
																_List_fromArray(
																	[
																		$author$project$Compiler$Reporting$Doc$green(
																		$author$project$Compiler$Reporting$Doc$fromName(f.a)),
																		$author$project$Compiler$Reporting$Doc$d('?')
																	]))
															]))
													]));
										}
									}()));
						} else {
							return badType(
								_Utils_Tuple3(
									$elm$core$Maybe$Just(recordRegion),
									'This is not a record, so it has no fields to access!',
									_Utils_Tuple2(
										'It is',
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$fillSep(
												_List_fromArray(
													[
														$author$project$Compiler$Reporting$Doc$d('But'),
														$author$project$Compiler$Reporting$Doc$d('I'),
														$author$project$Compiler$Reporting$Doc$d('need'),
														$author$project$Compiler$Reporting$Doc$d('a'),
														$author$project$Compiler$Reporting$Doc$d('record'),
														$author$project$Compiler$Reporting$Doc$d('with'),
														$author$project$Compiler$Reporting$Doc$d('a'),
														$author$project$Compiler$Reporting$Doc$dullyellow(
														$author$project$Compiler$Reporting$Doc$fromName(field)),
														$author$project$Compiler$Reporting$Doc$d('field!')
													]))
											]))));
						}
					case 'RecordUpdateKeys':
						var record = context.a;
						var expectedFields = context.b;
						var _v11 = $author$project$Compiler$Type$Error$iteratedDealias(tipe);
						if (_v11.$ === 'Record') {
							var actualFields = _v11.a;
							var ext = _v11.b;
							var _v12 = $author$project$Extra$Type$Map$lookupMin(
								A2($author$project$Extra$Type$Map$difference, expectedFields, actualFields));
							if (_v12.$ === 'Nothing') {
								return mismatch(
									_Utils_Tuple3(
										$elm$core$Maybe$Nothing,
										'Something is off with this record update:',
										_Utils_Tuple3(
											'The `' + (record + '` record is'),
											'But this update needs it to be compatable with:',
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('Do you mind creating an <http://sscce.org/> that produces this error message and' + (' sharing it at <https://github.com/elm/error-message-catalog/issues> so we' + ' can try to give better advice here?'))
												]))));
							} else {
								var _v13 = _v12.a;
								var field = _v13.a;
								var _v14 = _v13.b;
								var fieldRegion = _v14.a;
								var rStr = '`' + (record + '`');
								var fStr = '`' + (field + '`');
								return A2(
									custom,
									$elm$core$Maybe$Just(fieldRegion),
									_Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('The ' + (rStr + (' record does not have a ' + (fStr + ' field:')))),
										function () {
											var _v15 = A3(
												$author$project$Compiler$Reporting$Suggest$sort,
												field,
												$elm$core$Tuple$first,
												$author$project$Extra$Type$Map$toList(actualFields));
											if (!_v15.b) {
												return $author$project$Compiler$Reporting$Doc$reflow('In fact, ' + (rStr + ' is a record with NO fields!'));
											} else {
												var f = _v15.a;
												var fs = _v15.b;
												return $author$project$Compiler$Reporting$Doc$stack(
													_List_fromArray(
														[
															$author$project$Compiler$Reporting$Doc$reflow('This is usually a typo. Here are the ' + (rStr + ' fields that are most similar:')),
															A4($author$project$Compiler$Reporting$Error$Type$toNearbyRecord, localizer, f, fs, ext),
															$author$project$Compiler$Reporting$Doc$fillSep(
															_List_fromArray(
																[
																	$author$project$Compiler$Reporting$Doc$d('So'),
																	$author$project$Compiler$Reporting$Doc$d('maybe'),
																	$author$project$Compiler$Reporting$Doc$dullyellow(
																	$author$project$Compiler$Reporting$Doc$fromName(field)),
																	$author$project$Compiler$Reporting$Doc$d('should'),
																	$author$project$Compiler$Reporting$Doc$d('be'),
																	$author$project$Compiler$Reporting$Doc$da(
																	_List_fromArray(
																		[
																			$author$project$Compiler$Reporting$Doc$green(
																			$author$project$Compiler$Reporting$Doc$fromName(f.a)),
																			$author$project$Compiler$Reporting$Doc$d('?')
																		]))
																]))
														]));
											}
										}()));
							}
						} else {
							return badType(
								_Utils_Tuple3(
									$elm$core$Maybe$Just(exprRegion),
									'This is not a record, so it has no fields to update!',
									_Utils_Tuple2(
										'It is',
										_List_fromArray(
											[
												$author$project$Compiler$Reporting$Doc$reflow('But I need a record!')
											]))));
						}
					case 'RecordUpdateValue':
						var field = context.a;
						return mismatch(
							_Utils_Tuple3(
								$elm$core$Maybe$Just(exprRegion),
								'I cannot update the `' + (field + '` field like this:'),
								_Utils_Tuple3(
									'You are trying to update `' + (field + '` to be'),
									'But it should be:',
									_List_fromArray(
										[
											$author$project$Compiler$Reporting$Doc$toSimpleNote('The record update syntax does not allow you to change the type of fields.' + ' You can achieve that with record constructors or the record literal syntax.')
										]))));
					default:
						return mismatch(
							_Utils_Tuple3(
								$elm$core$Maybe$Nothing,
								'This definition is causing issues:',
								_Utils_Tuple3('You are defining', 'But then trying to destructure it as:', _List_Nil)));
				}
		}
	});
var $author$project$Compiler$Reporting$Error$Type$toInfiniteReport = F5(
	function (source, localizer, region, name, overallType) {
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'INFINITE TYPE',
			region,
			A4(
				$author$project$Compiler$Reporting$Render$Code$toSnippet,
				source,
				region,
				$elm$core$Maybe$Nothing,
				_Utils_Tuple2(
					$author$project$Compiler$Reporting$Doc$reflow('I am inferring a weird self-referential type for ' + (name + ':')),
					$author$project$Compiler$Reporting$Doc$stack(
						_List_fromArray(
							[
								$author$project$Compiler$Reporting$Doc$reflow('Here is my best effort at writing down the type. You will see  for' + ' parts of the type that repeat something already printed out infinitely.'),
								A2(
								$author$project$Compiler$Reporting$Doc$indent,
								4,
								$author$project$Compiler$Reporting$Doc$dullyellow(
									A3($author$project$Compiler$Type$Error$toDoc, localizer, $author$project$Compiler$Reporting$Render$Type$None, overallType))),
								A3($author$project$Compiler$Reporting$Doc$reflowLink, 'Staring at this type is usually not so helpful, so I recommend reading the hints at', 'infinite-type', 'to get unstuck!')
							])))));
	});
var $author$project$Compiler$Reporting$Error$Type$addPatternCategory = F2(
	function (iAmTryingToMatch, category) {
		return _Utils_ap(
			iAmTryingToMatch,
			function () {
				switch (category.$) {
					case 'PRecord':
						return ' record values of type:';
					case 'PUnit':
						return ' unit values:';
					case 'PTuple':
						return ' tuples of type:';
					case 'PList':
						return ' lists of type:';
					case 'PCtor':
						var name = category.a;
						return ' `' + (name + '` values of type:');
					case 'PInt':
						return ' integers:';
					case 'PStr':
						return ' strings:';
					case 'PChr':
						return ' characters:';
					default:
						return ' booleans:';
				}
			}());
	});
var $author$project$Compiler$Reporting$Error$Type$patternTypeComparison = F6(
	function (localizer, actual, expected, iAmSeeing, insteadOf, contextHints) {
		var _v0 = A3($author$project$Compiler$Type$Error$toComparison, localizer, actual, expected);
		var actualDoc = _v0.a;
		var expectedDoc = _v0.b;
		var problems = _v0.c;
		return $author$project$Compiler$Reporting$Doc$stack(
			_Utils_ap(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$reflow(iAmSeeing),
						A2($author$project$Compiler$Reporting$Doc$indent, 4, actualDoc),
						$author$project$Compiler$Reporting$Doc$reflow(insteadOf),
						A2($author$project$Compiler$Reporting$Doc$indent, 4, expectedDoc)
					]),
				_Utils_ap(
					$author$project$Compiler$Reporting$Error$Type$problemsToHint(problems),
					contextHints)));
	});
var $author$project$Compiler$Reporting$Error$Type$toPatternReport = F6(
	function (source, localizer, patternRegion, category, tipe, expected) {
		return A3(
			$author$project$Compiler$Reporting$Report$Report,
			'TYPE MISMATCH',
			patternRegion,
			function () {
				if (expected.$ === 'PNoExpectation') {
					var expectedType = expected.a;
					return A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						patternRegion,
						$elm$core$Maybe$Nothing,
						_Utils_Tuple2(
							$author$project$Compiler$Reporting$Doc$d('This pattern is being used in an unexpected way:'),
							A6(
								$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
								localizer,
								tipe,
								expectedType,
								A2($author$project$Compiler$Reporting$Error$Type$addPatternCategory, 'It is', category),
								'But it needs to match:',
								_List_Nil)));
				} else {
					var region = expected.a;
					var context = expected.b;
					var expectedType = expected.c;
					return A4(
						$author$project$Compiler$Reporting$Render$Code$toSnippet,
						source,
						region,
						$elm$core$Maybe$Just(patternRegion),
						function () {
							switch (context.$) {
								case 'PTypedArg':
									var name = context.a;
									var index = context.b;
									return _Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow(
											'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + (' argument to `' + (name + '` is weird.')))),
										A6(
											$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
											localizer,
											tipe,
											expectedType,
											A2($author$project$Compiler$Reporting$Error$Type$addPatternCategory, 'The argument is a pattern that matches', category),
											'But the type annotation on `' + (name + ('` says the ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' argument should be:'))),
											_List_Nil));
								case 'PCaseMatch':
									var index = context.a;
									return _Utils_eq(index, $author$project$Compiler$Data$Index$first) ? _Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('The 1st pattern in this `case` causing a mismatch:'),
										A6(
											$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
											localizer,
											tipe,
											expectedType,
											A2($author$project$Compiler$Reporting$Error$Type$addPatternCategory, 'The first pattern is trying to match', category),
											'But the expression between `case` and `of` is:',
											_List_fromArray(
												[
													$author$project$Compiler$Reporting$Doc$reflow('These can never match! Is the pattern the problem? Or is it the expression?')
												]))) : _Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow(
											'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' pattern in this `case` does not match the previous ones.')),
										A6(
											$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
											localizer,
											tipe,
											expectedType,
											A2(
												$author$project$Compiler$Reporting$Error$Type$addPatternCategory,
												'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' pattern is trying to match'),
												category),
											'But all the previous patterns match:',
											_List_fromArray(
												[
													A4($author$project$Compiler$Reporting$Doc$link, 'Note', 'A `case` expression can only handle one type of value, so you may want to use', 'custom-types', 'to handle mixing types.')
												])));
								case 'PCtorArg':
									var name = context.a;
									var index = context.b;
									return _Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow(
											'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + (' argument to `' + (name + '` is weird.')))),
										A6(
											$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
											localizer,
											tipe,
											expectedType,
											A2($author$project$Compiler$Reporting$Error$Type$addPatternCategory, 'It is trying to match', category),
											'But `' + (name + ('` needs its ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' argument to be:'))),
											_List_Nil));
								case 'PListEntry':
									var index = context.a;
									return _Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow(
											'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' pattern in this list does not match all the previous ones:')),
										A6(
											$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
											localizer,
											tipe,
											expectedType,
											A2(
												$author$project$Compiler$Reporting$Error$Type$addPatternCategory,
												'The ' + ($author$project$Compiler$Reporting$Doc$ordinal(index) + ' pattern is trying to match'),
												category),
											'But all the previous patterns in the list are:',
											_List_fromArray(
												[
													A4($author$project$Compiler$Reporting$Doc$link, 'Hint', 'Everything in a list must be the same type of value. This way, we never' + ' run into unexpected values partway through a List.map, List.foldl, etc. Read', 'custom-types', 'to learn how to mix types.')
												])));
								default:
									return _Utils_Tuple2(
										$author$project$Compiler$Reporting$Doc$reflow('The pattern after (::) is causing issues.'),
										A6(
											$author$project$Compiler$Reporting$Error$Type$patternTypeComparison,
											localizer,
											tipe,
											expectedType,
											A2($author$project$Compiler$Reporting$Error$Type$addPatternCategory, 'The pattern after (::) is trying to match', category),
											'But it needs to match lists like this:',
											_List_Nil));
							}
						}());
				}
			}());
	});
var $author$project$Compiler$Reporting$Error$Type$toReport = F3(
	function (source, localizer, err) {
		switch (err.$) {
			case 'BadExpr':
				var region = err.a;
				var category = err.b;
				var actualType = err.c;
				var expected = err.d;
				return A6($author$project$Compiler$Reporting$Error$Type$toExprReport, source, localizer, region, category, actualType, expected);
			case 'BadPattern':
				var region = err.a;
				var category = err.b;
				var tipe = err.c;
				var expected = err.d;
				return A6($author$project$Compiler$Reporting$Error$Type$toPatternReport, source, localizer, region, category, tipe, expected);
			default:
				var region = err.a;
				var name = err.b;
				var overallType = err.c;
				return A5($author$project$Compiler$Reporting$Error$Type$toInfiniteReport, source, localizer, region, name, overallType);
		}
	});
var $author$project$Compiler$Reporting$Error$toReports = F2(
	function (source, err) {
		switch (err.$) {
			case 'BadSyntax':
				var syntaxError = err.a;
				return A2(
					$author$project$Compiler$Data$NonEmptyList$CList,
					A2($author$project$Compiler$Reporting$Error$Syntax$toReport, source, syntaxError),
					_List_Nil);
			case 'BadImports':
				var errs = err.a;
				return A2(
					$author$project$Compiler$Data$NonEmptyList$fmap,
					$author$project$Compiler$Reporting$Error$Import$toReport(source),
					errs);
			case 'BadNames':
				var errs = err.a;
				return A2(
					$author$project$Compiler$Data$NonEmptyList$fmap,
					$author$project$Compiler$Reporting$Error$Canonicalize$toReport(source),
					A2($author$project$Compiler$Data$OneOrMore$destruct, $author$project$Compiler$Data$NonEmptyList$CList, errs));
			case 'BadTypes':
				var localizer = err.a;
				var errs = err.b;
				return A2(
					$author$project$Compiler$Data$NonEmptyList$fmap,
					A2($author$project$Compiler$Reporting$Error$Type$toReport, source, localizer),
					errs);
			case 'BadMains':
				var localizer = err.a;
				var errs = err.b;
				return A2(
					$author$project$Compiler$Data$NonEmptyList$fmap,
					A2($author$project$Compiler$Reporting$Error$Main$toReport, localizer, source),
					A2($author$project$Compiler$Data$OneOrMore$destruct, $author$project$Compiler$Data$NonEmptyList$CList, errs));
			default:
				var errs = err.a;
				return A2(
					$author$project$Compiler$Data$NonEmptyList$fmap,
					$author$project$Compiler$Reporting$Error$Pattern$toReport(source),
					errs);
		}
	});
var $author$project$Compiler$Reporting$Error$moduleToDoc = F2(
	function (root, _v0) {
		var absolutePath = _v0.b;
		var source = _v0.d;
		var err = _v0.e;
		var reports = A2(
			$author$project$Compiler$Reporting$Error$toReports,
			$author$project$Compiler$Reporting$Render$Code$toSource(source),
			err);
		var relativePath = A2($author$project$Extra$System$File$makeRelative, root, absolutePath);
		return $author$project$Compiler$Reporting$Doc$vcat(
			A2(
				$author$project$Extra$Type$List$map,
				$author$project$Compiler$Reporting$Error$reportToDoc(relativePath),
				$author$project$Compiler$Data$NonEmptyList$toList(reports)));
	});
var $author$project$Extra$Data$Pretty$dullred = $the_sett$elm_pretty_printer$Pretty$setTag(
	function ($) {
		return $.dullred;
	});
var $author$project$Compiler$Reporting$Doc$dullred = $author$project$Extra$Data$Pretty$dullred;
var $author$project$Compiler$Reporting$Error$getName = function (_v0) {
	var name = _v0.a;
	return name;
};
var $author$project$Compiler$Reporting$Error$toSeparator = F2(
	function (beforeModule, afterModule) {
		var before = $author$project$Compiler$Elm$ModuleName$toChars(
			$author$project$Compiler$Reporting$Error$getName(beforeModule)) + '      ';
		var after = '      ' + $author$project$Compiler$Elm$ModuleName$toChars(
			$author$project$Compiler$Reporting$Error$getName(afterModule));
		return $author$project$Compiler$Reporting$Doc$dullred(
			$author$project$Compiler$Reporting$Doc$vcat(
				_List_fromArray(
					[
						A2(
						$author$project$Compiler$Reporting$Doc$indent,
						80 - $elm$core$String$length(before),
						$author$project$Compiler$Reporting$Doc$fromChars(before)),
						$author$project$Compiler$Reporting$Doc$d('====o======================================================================o===='),
						$author$project$Compiler$Reporting$Doc$fromChars(after),
						$author$project$Compiler$Reporting$Doc$d(''),
						$author$project$Compiler$Reporting$Doc$d('')
					])));
	});
var $author$project$Compiler$Reporting$Error$toDocHelp = F3(
	function (root, module1, modules) {
		if (!modules.b) {
			return _List_fromArray(
				[
					A2($author$project$Compiler$Reporting$Error$moduleToDoc, root, module1),
					$author$project$Compiler$Reporting$Doc$d('')
				]);
		} else {
			var module2 = modules.a;
			var otherModules = modules.b;
			return A2(
				$elm$core$List$cons,
				A2($author$project$Compiler$Reporting$Error$moduleToDoc, root, module1),
				A2(
					$elm$core$List$cons,
					A2($author$project$Compiler$Reporting$Error$toSeparator, module1, module2),
					A3($author$project$Compiler$Reporting$Error$toDocHelp, root, module2, otherModules)));
		}
	});
var $author$project$Compiler$Reporting$Error$toDoc = F3(
	function (root, err, errs) {
		var _v0 = A2(
			$author$project$Compiler$Data$NonEmptyList$sortBy,
			$author$project$Compiler$Reporting$Error$getModificationTime,
			A2($author$project$Compiler$Data$NonEmptyList$CList, err, errs));
		var m = _v0.a;
		var ms = _v0.b;
		return $author$project$Compiler$Reporting$Doc$vcat(
			A3($author$project$Compiler$Reporting$Error$toDocHelp, root, m, ms));
	});
var $author$project$Builder$Reporting$Exit$Help$reportToDoc = function (report_) {
	if (report_.$ === 'CompilerReport') {
		var root = report_.a;
		var e = report_.b;
		var es = report_.c;
		return A3($author$project$Compiler$Reporting$Error$toDoc, root, e, es);
	} else {
		var title = report_.a;
		var maybePath = report_.b;
		var message = report_.c;
		var makeDashes = function (n) {
			return A2(
				$elm$core$String$repeat,
				A2($elm$core$Basics$max, 1, 80 - n),
				'-');
		};
		var errorBarEnd = function () {
			if (maybePath.$ === 'Nothing') {
				return makeDashes(
					4 + $elm$core$String$length(title));
			} else {
				var path = maybePath.a;
				return makeDashes(
					(5 + $elm$core$String$length(title)) + $elm$core$String$length(
						$author$project$Extra$System$File$toString(path))) + (' ' + $author$project$Extra$System$File$toString(path));
			}
		}();
		var errorBar = $author$project$Compiler$Reporting$Doc$dullcyan(
			$author$project$Compiler$Reporting$Doc$hsep(
				_List_fromArray(
					[
						$author$project$Compiler$Reporting$Doc$d('--'),
						$author$project$Compiler$Reporting$Doc$fromChars(title),
						$author$project$Compiler$Reporting$Doc$fromChars(errorBarEnd)
					])));
		return $author$project$Compiler$Reporting$Doc$stack(
			_List_fromArray(
				[
					errorBar,
					message,
					$author$project$Compiler$Reporting$Doc$d('')
				]));
	}
};
var $author$project$Repl$Worker$errorToString = function (error) {
	return $author$project$Compiler$Reporting$Doc$toString(
		$author$project$Builder$Reporting$Exit$Help$reportToDoc(
			$author$project$Builder$Reporting$Exit$replToReport(error)));
};
var $author$project$Terminal$Repl$Configured = F3(
	function (a, b, c) {
		return {$: 'Configured', a: a, b: b, c: c};
	});
var $author$project$Terminal$Repl$Flags = F3(
	function (a, b, c) {
		return {$: 'Flags', a: a, b: b, c: c};
	});
var $author$project$Terminal$Repl$Env = F6(
	function (a, b, c, d, e, f) {
		return {$: 'Env', a: a, b: b, c: c, d: d, e: e, f: f};
	});
var $author$project$Terminal$Repl$defaultHeader = 'module ' + ($author$project$Compiler$Data$Name$toBuilder($author$project$Compiler$Data$Name$replModule) + ' exposing (..)');
var $author$project$Compiler$Elm$Licenses$bsd3 = $author$project$Compiler$Elm$Licenses$License(
	$author$project$Compiler$Json$String$fromChars('BSD-3-Clause'));
var $author$project$Compiler$Elm$Version$max = A3(
	$author$project$Compiler$Elm$Version$Version,
	A2($elm$core$Basics$pow, 2, 16) - 1,
	0,
	0);
var $author$project$Compiler$Elm$Constraint$anything = A4($author$project$Compiler$Elm$Constraint$Range, $author$project$Compiler$Elm$Version$one, $author$project$Compiler$Elm$Constraint$LessOrEqual, $author$project$Compiler$Elm$Constraint$LessOrEqual, $author$project$Compiler$Elm$Version$max);
var $author$project$Terminal$Repl$defaultDeps = $author$project$Extra$Type$Map$fromList(
	_List_fromArray(
		[
			_Utils_Tuple2(
			$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$core),
			$author$project$Compiler$Elm$Constraint$anything),
			_Utils_Tuple2(
			$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$json),
			$author$project$Compiler$Elm$Constraint$anything),
			_Utils_Tuple2(
			$author$project$Compiler$Elm$Package$toComparable($author$project$Compiler$Elm$Package$html),
			$author$project$Compiler$Elm$Constraint$anything)
		]));
var $author$project$Compiler$Elm$Version$getMajor = function (_v0) {
	var major = _v0.a;
	return major;
};
var $author$project$Compiler$Elm$Constraint$untilNextMajor = function (version) {
	return A4(
		$author$project$Compiler$Elm$Constraint$Range,
		version,
		$author$project$Compiler$Elm$Constraint$LessOrEqual,
		$author$project$Compiler$Elm$Constraint$Less,
		$author$project$Compiler$Elm$Version$bumpMajor(version));
};
var $author$project$Compiler$Elm$Version$bumpMinor = function (_v0) {
	var major = _v0.a;
	var minor = _v0.b;
	return A3($author$project$Compiler$Elm$Version$Version, major, minor + 1, 0);
};
var $author$project$Compiler$Elm$Constraint$untilNextMinor = function (version) {
	return A4(
		$author$project$Compiler$Elm$Constraint$Range,
		version,
		$author$project$Compiler$Elm$Constraint$LessOrEqual,
		$author$project$Compiler$Elm$Constraint$Less,
		$author$project$Compiler$Elm$Version$bumpMinor(version));
};
var $author$project$Compiler$Elm$Constraint$defaultElm = ($author$project$Compiler$Elm$Version$getMajor($author$project$Compiler$Elm$Version$compiler) > 0) ? $author$project$Compiler$Elm$Constraint$untilNextMajor($author$project$Compiler$Elm$Version$compiler) : $author$project$Compiler$Elm$Constraint$untilNextMinor($author$project$Compiler$Elm$Version$compiler);
var $author$project$Builder$Elm$Outline$defaultSummary = $author$project$Compiler$Json$String$fromChars('helpful summary of your project, less than 80 characters');
var $author$project$Builder$Stuff$findRootHelp = function (dirs) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Extra$System$File$doesFileExist(
			A2($author$project$Extra$System$File$addName, dirs, 'elm.json')),
		function (exists) {
			if (exists) {
				return $author$project$Extra$System$IO$return(
					$elm$core$Maybe$Just(dirs));
			} else {
				var _v0 = $author$project$Extra$System$File$splitLastName(dirs);
				if (_v0.b === '') {
					return $author$project$Extra$System$IO$return($elm$core$Maybe$Nothing);
				} else {
					var parent = _v0.a;
					return $author$project$Builder$Stuff$findRootHelp(parent);
				}
			}
		});
};
var $author$project$Builder$Stuff$findRoot = A2(
	$author$project$Extra$System$IO$bind,
	$author$project$Extra$System$File$getCurrentDirectory,
	function (dir) {
		return $author$project$Builder$Stuff$findRootHelp(dir);
	});
var $author$project$Builder$Stuff$getReplCache = $author$project$Builder$Stuff$getCacheDir('repl');
var $author$project$Compiler$Elm$Constraint$encode = function (constraint) {
	return $author$project$Compiler$Json$Encode$chars(
		$author$project$Compiler$Elm$Constraint$toChars(constraint));
};
var $author$project$Compiler$Json$String$toBuilder = $elm$core$Basics$identity;
var $author$project$Compiler$Json$Encode$string = function (str) {
	return $author$project$Compiler$Json$Encode$CString(
		'\"' + ($author$project$Compiler$Json$String$toBuilder(str) + '\"'));
};
var $author$project$Compiler$Elm$Licenses$encode = function (_v0) {
	var code = _v0.a;
	return $author$project$Compiler$Json$Encode$string(code);
};
var $author$project$Compiler$Elm$Package$encode = function (name) {
	return $author$project$Compiler$Json$Encode$chars(
		$author$project$Compiler$Elm$Package$toChars(name));
};
var $author$project$Compiler$Json$Encode$dict = F3(
	function (encodeKey, encodeValue, pairs) {
		return $author$project$Compiler$Json$Encode$Object(
			A2(
				$author$project$Extra$Type$List$map,
				function (_v0) {
					var k = _v0.a;
					var v = _v0.b;
					return _Utils_Tuple2(
						encodeKey(k),
						encodeValue(v));
				},
				$author$project$Extra$Type$Map$toList(pairs)));
	});
var $author$project$Compiler$Elm$Package$toJsonString = function (_v0) {
	var author = _v0.a;
	var project = _v0.b;
	return A2(
		$elm$core$String$join,
		'/',
		_List_fromArray(
			[author, project]));
};
var $author$project$Builder$Elm$Outline$encodeDeps = F2(
	function (encodeValue, deps) {
		return A3(
			$author$project$Compiler$Json$Encode$dict,
			A2($elm$core$Basics$composeL, $author$project$Compiler$Elm$Package$toJsonString, $author$project$Compiler$Elm$Package$fromComparable),
			encodeValue,
			deps);
	});
var $author$project$Builder$Elm$Outline$encodeModule = function (name) {
	return $author$project$Compiler$Json$Encode$name(name);
};
var $author$project$Builder$Elm$Outline$encodeExposed = function (exposed) {
	if (exposed.$ === 'ExposedList') {
		var modules = exposed.a;
		return A2($author$project$Compiler$Json$Encode$list, $author$project$Builder$Elm$Outline$encodeModule, modules);
	} else {
		var chunks = exposed.a;
		return $author$project$Compiler$Json$Encode$object(
			A2(
				$author$project$Extra$Type$List$map,
				$elm$core$Tuple$mapSecond(
					$author$project$Compiler$Json$Encode$list($author$project$Builder$Elm$Outline$encodeModule)),
				chunks));
	}
};
var $author$project$Builder$Elm$Outline$encodeSrcDir = function (srcDir) {
	if (srcDir.$ === 'AbsoluteSrcDir') {
		var dir = srcDir.a;
		return $author$project$Compiler$Json$Encode$chars(
			$author$project$Extra$System$File$toString(dir));
	} else {
		var dir = srcDir.a;
		return $author$project$Compiler$Json$Encode$chars(
			$author$project$Extra$System$File$toString(dir));
	}
};
var $author$project$Builder$Elm$Outline$encode = function (outline) {
	if (outline.$ === 'App') {
		var _v1 = outline.a;
		var elm = _v1.a;
		var srcDirs = _v1.b;
		var depsDirect = _v1.c;
		var depsTrans = _v1.d;
		var testDirect = _v1.e;
		var testTrans = _v1.f;
		return $author$project$Compiler$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'type',
					$author$project$Compiler$Json$Encode$chars('application')),
					_Utils_Tuple2(
					'source-directories',
					A2(
						$author$project$Compiler$Json$Encode$list,
						$author$project$Builder$Elm$Outline$encodeSrcDir,
						$author$project$Compiler$Data$NonEmptyList$toList(srcDirs))),
					_Utils_Tuple2(
					'elm-version',
					$author$project$Compiler$Elm$Version$encode(elm)),
					_Utils_Tuple2(
					'dependencies',
					$author$project$Compiler$Json$Encode$object(
						_List_fromArray(
							[
								_Utils_Tuple2(
								'direct',
								A2($author$project$Builder$Elm$Outline$encodeDeps, $author$project$Compiler$Elm$Version$encode, depsDirect)),
								_Utils_Tuple2(
								'indirect',
								A2($author$project$Builder$Elm$Outline$encodeDeps, $author$project$Compiler$Elm$Version$encode, depsTrans))
							]))),
					_Utils_Tuple2(
					'test-dependencies',
					$author$project$Compiler$Json$Encode$object(
						_List_fromArray(
							[
								_Utils_Tuple2(
								'direct',
								A2($author$project$Builder$Elm$Outline$encodeDeps, $author$project$Compiler$Elm$Version$encode, testDirect)),
								_Utils_Tuple2(
								'indirect',
								A2($author$project$Builder$Elm$Outline$encodeDeps, $author$project$Compiler$Elm$Version$encode, testTrans))
							])))
				]));
	} else {
		var _v2 = outline.a;
		var name = _v2.a;
		var summary = _v2.b;
		var license = _v2.c;
		var version = _v2.d;
		var exposed = _v2.e;
		var deps = _v2.f;
		var tests = _v2.g;
		var elm = _v2.h;
		return $author$project$Compiler$Json$Encode$object(
			_List_fromArray(
				[
					_Utils_Tuple2(
					'type',
					$author$project$Compiler$Json$Encode$string(
						$author$project$Compiler$Json$String$fromChars('package'))),
					_Utils_Tuple2(
					'name',
					$author$project$Compiler$Elm$Package$encode(name)),
					_Utils_Tuple2(
					'summary',
					$author$project$Compiler$Json$Encode$string(summary)),
					_Utils_Tuple2(
					'license',
					$author$project$Compiler$Elm$Licenses$encode(license)),
					_Utils_Tuple2(
					'version',
					$author$project$Compiler$Elm$Version$encode(version)),
					_Utils_Tuple2(
					'exposed-modules',
					$author$project$Builder$Elm$Outline$encodeExposed(exposed)),
					_Utils_Tuple2(
					'elm-version',
					$author$project$Compiler$Elm$Constraint$encode(elm)),
					_Utils_Tuple2(
					'dependencies',
					A2($author$project$Builder$Elm$Outline$encodeDeps, $author$project$Compiler$Elm$Constraint$encode, deps)),
					_Utils_Tuple2(
					'test-dependencies',
					A2($author$project$Builder$Elm$Outline$encodeDeps, $author$project$Compiler$Elm$Constraint$encode, tests))
				]));
	}
};
var $author$project$Compiler$Json$Encode$arrayClose = ']';
var $author$project$Compiler$Json$Encode$arrayOpen = '[\n';
var $author$project$Compiler$Json$Encode$commaNewline = ',\n';
var $author$project$Compiler$Json$Encode$newline = '\n';
var $author$project$Compiler$Json$Encode$encodeSequence = F6(
	function (open, close, encodeEntry, indent, first, rest) {
		var newIndent = indent + '    ';
		var newIndentBuilder = newIndent;
		var closer = _Utils_ap(
			$author$project$Compiler$Json$Encode$newline,
			_Utils_ap(indent, close));
		var addValue = F2(
			function (field, builder) {
				return _Utils_ap(
					$author$project$Compiler$Json$Encode$commaNewline,
					_Utils_ap(
						newIndentBuilder,
						_Utils_ap(
							A2(encodeEntry, newIndent, field),
							builder)));
			});
		return _Utils_ap(
			open,
			_Utils_ap(
				newIndentBuilder,
				_Utils_ap(
					A2(encodeEntry, newIndent, first),
					A3($author$project$Extra$Type$List$foldr, addValue, closer, rest))));
	});
var $author$project$Compiler$Json$Encode$objectClose = '}';
var $author$project$Compiler$Json$Encode$objectOpen = '{\n';
var $author$project$Compiler$Json$Encode$encodeField = F2(
	function (indent, _v3) {
		var key = _v3.a;
		var value = _v3.b;
		return '\"' + (key + ('\": ' + A2($author$project$Compiler$Json$Encode$encodeHelp, indent, value)));
	});
var $author$project$Compiler$Json$Encode$encodeHelp = F2(
	function (indent, value) {
		switch (value.$) {
			case 'Array':
				if (!value.a.b) {
					return '[]';
				} else {
					var _v1 = value.a;
					var first = _v1.a;
					var rest = _v1.b;
					return A3(
						$author$project$Compiler$Json$Encode$cyclic$encodeArray(),
						indent,
						first,
						rest);
				}
			case 'Object':
				if (!value.a.b) {
					return '{}';
				} else {
					var _v2 = value.a;
					var first = _v2.a;
					var rest = _v2.b;
					return A3(
						$author$project$Compiler$Json$Encode$cyclic$encodeObject(),
						indent,
						first,
						rest);
				}
			default:
				var builder = value.a;
				return builder;
		}
	});
function $author$project$Compiler$Json$Encode$cyclic$encodeArray() {
	return A3($author$project$Compiler$Json$Encode$encodeSequence, $author$project$Compiler$Json$Encode$arrayOpen, $author$project$Compiler$Json$Encode$arrayClose, $author$project$Compiler$Json$Encode$encodeHelp);
}
function $author$project$Compiler$Json$Encode$cyclic$encodeObject() {
	return A3($author$project$Compiler$Json$Encode$encodeSequence, $author$project$Compiler$Json$Encode$objectOpen, $author$project$Compiler$Json$Encode$objectClose, $author$project$Compiler$Json$Encode$encodeField);
}
try {
	var $author$project$Compiler$Json$Encode$encodeArray = $author$project$Compiler$Json$Encode$cyclic$encodeArray();
	$author$project$Compiler$Json$Encode$cyclic$encodeArray = function () {
		return $author$project$Compiler$Json$Encode$encodeArray;
	};
	var $author$project$Compiler$Json$Encode$encodeObject = $author$project$Compiler$Json$Encode$cyclic$encodeObject();
	$author$project$Compiler$Json$Encode$cyclic$encodeObject = function () {
		return $author$project$Compiler$Json$Encode$encodeObject;
	};
} catch ($) {
	throw 'Some top-level definitions from `Compiler.Json.Encode` are causing infinite recursion:\n\n  \n      encodeArray\n       \n      encodeObject\n       \n      encodeField\n       \n      encodeHelp\n  \n\nThese errors are very tricky, so read https://elm-lang.org/0.19.1/bad-recursion to learn how to fix it!';}
var $author$project$Compiler$Json$Encode$encode = function (value) {
	return A2($author$project$Compiler$Json$Encode$encodeHelp, '', value);
};
var $author$project$Builder$File$writeBuilder = $author$project$Builder$File$writeUtf8;
var $author$project$Compiler$Json$Encode$write = F2(
	function (path, value) {
		return A2(
			$author$project$Builder$File$writeBuilder,
			path,
			$author$project$Compiler$Json$Encode$encode(value) + '\n');
	});
var $author$project$Builder$Elm$Outline$write = F2(
	function (root, outline) {
		return A2(
			$author$project$Compiler$Json$Encode$write,
			A2($author$project$Extra$System$File$addName, root, 'elm.json'),
			$author$project$Builder$Elm$Outline$encode(outline));
	});
var $author$project$Terminal$Repl$getRoot = A2(
	$author$project$Extra$System$IO$bind,
	$author$project$Builder$Stuff$findRoot,
	function (maybeRoot) {
		if (maybeRoot.$ === 'Just') {
			var root = maybeRoot.a;
			return $author$project$Extra$System$IO$return(root);
		} else {
			return A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Builder$Stuff$getReplCache,
				function (cache) {
					var root = A2($author$project$Extra$System$File$addName, cache, 'tmp');
					return A2(
						$author$project$Extra$System$IO$bind,
						A2(
							$author$project$Extra$System$File$createDirectoryIfMissing,
							true,
							A2($author$project$Extra$System$File$addName, root, 'src')),
						function (_v1) {
							return A2(
								$author$project$Extra$System$IO$bind,
								A2(
									$author$project$Builder$Elm$Outline$write,
									root,
									$author$project$Builder$Elm$Outline$Pkg(
										A8(
											$author$project$Builder$Elm$Outline$PkgOutline,
											$author$project$Compiler$Elm$Package$dummyName,
											$author$project$Builder$Elm$Outline$defaultSummary,
											$author$project$Compiler$Elm$Licenses$bsd3,
											$author$project$Compiler$Elm$Version$one,
											$author$project$Builder$Elm$Outline$ExposedList(_List_Nil),
											$author$project$Terminal$Repl$defaultDeps,
											$author$project$Extra$Type$Map$empty,
											$author$project$Compiler$Elm$Constraint$defaultElm))),
								function (_v2) {
									return $author$project$Extra$System$IO$return(root);
								});
						});
				});
		}
	});
var $author$project$Builder$Build$findModulePath = F3(
	function (root, details, name) {
		return A2(
			$author$project$Extra$System$IO$bind,
			A2($author$project$Builder$Build$makeEnv, root, details),
			function (_v0) {
				var srcDirs = _v0.c;
				var fileNames = $author$project$Compiler$Elm$ModuleName$toFileNames(name);
				return A2(
					$author$project$Extra$System$IO$rmap,
					A4(
						$author$project$Extra$Type$List$filterM,
						$author$project$Extra$System$IO$pure,
						$author$project$Extra$System$IO$liftA2,
						$author$project$Builder$File$exists,
						A2(
							$author$project$Extra$Type$List$map,
							function (d) {
								return A2($author$project$Builder$Build$addRelative, d, fileNames);
							},
							srcDirs)),
					function (paths) {
						if (paths.b && (!paths.b.b)) {
							var path = paths.a;
							return $elm$core$Maybe$Just(path);
						} else {
							return $elm$core$Maybe$Nothing;
						}
					});
			});
	});
var $author$project$Compiler$Data$NonEmptyList$singleton = function (a) {
	return A2($author$project$Compiler$Data$NonEmptyList$CList, a, _List_Nil);
};
var $author$project$Terminal$Repl$findOpenModulePath = F4(
	function (root, details, src, name) {
		return A2(
			$author$project$Extra$System$IO$rmap,
			A3($author$project$Builder$Build$findModulePath, root, details, name),
			function (maybePath) {
				if (maybePath.$ === 'Just') {
					var path = maybePath.a;
					return $author$project$Extra$Type$Either$Right(path);
				} else {
					return $author$project$Extra$Type$Either$Left(
						$author$project$Compiler$Reporting$Error$BadImports(
							$author$project$Compiler$Data$NonEmptyList$singleton(
								function () {
									var region = A2(
										$author$project$Compiler$Reporting$Annotation$Region,
										A2($author$project$Compiler$Reporting$Annotation$Position, 1, 8),
										A2(
											$author$project$Compiler$Reporting$Annotation$Position,
											1,
											$elm$core$String$length(src)));
									return A4($author$project$Compiler$Reporting$Error$Import$Error, region, name, $author$project$Extra$Type$Set$empty, $author$project$Compiler$Reporting$Error$Import$NotFound);
								}())));
				}
			});
	});
var $author$project$Terminal$Repl$parseOpenModuleName = function (src) {
	return $author$project$Extra$System$IO$return(
		function () {
			var _v0 = A3($author$project$Compiler$Parse$Primitives$fromByteString, $author$project$Compiler$Parse$Module$chompImport, $author$project$Compiler$Reporting$Error$Syntax$ModuleBadEnd, src);
			if (_v0.$ === 'Right') {
				var _v1 = _v0.a;
				var _v2 = _v1.a;
				var name = _v2.b;
				return $author$project$Extra$Type$Either$Right(name);
			} else {
				var err = _v0.a;
				return $author$project$Extra$Type$Either$Left(
					$author$project$Compiler$Reporting$Error$BadSyntax(
						$author$project$Compiler$Reporting$Error$Syntax$ParseError(err)));
			}
		}());
};
var $author$project$Terminal$Repl$openModule = F2(
	function (root, input) {
		var src = 'import ' + (input + '\n');
		return A2(
			$author$project$Builder$Reporting$Task$bind,
			A2(
				$author$project$Builder$Reporting$Task$eio,
				$author$project$Builder$Reporting$Exit$ReplBadInput(src),
				$author$project$Terminal$Repl$parseOpenModuleName(src)),
			function (name) {
				return A2(
					$author$project$Builder$Reporting$Task$bind,
					A2(
						$author$project$Builder$Reporting$Task$eio,
						$author$project$Builder$Reporting$Exit$ReplBadDetails,
						$author$project$Builder$Elm$Details$load(root)),
					function (details) {
						return A2(
							$author$project$Builder$Reporting$Task$bind,
							A2(
								$author$project$Builder$Reporting$Task$eio,
								$author$project$Builder$Reporting$Exit$ReplBadInput(src),
								A4($author$project$Terminal$Repl$findOpenModulePath, root, details, src, name)),
							function (path) {
								return $author$project$Builder$Reporting$Task$io(
									$author$project$Builder$File$readUtf8(path));
							});
					});
			});
	});
var $author$project$Extra$Type$Maybe$sequenceA = F3(
	function (pPure, pFmap, mfa) {
		return A2(
			$author$project$Extra$Class$Traversable$sequenceA,
			A2($author$project$Extra$Type$Maybe$traverse, pPure, pFmap),
			mfa);
	});
var $author$project$Terminal$Repl$initEnv = function (_v0) {
	var interpreter = _v0.a;
	var mode = _v0.b;
	var htmlEnabled = _v0.c;
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Terminal$Repl$getRoot,
		function (root) {
			return A2(
				$author$project$Extra$System$IO$bind,
				A4(
					$author$project$Extra$Type$Maybe$traverse,
					$author$project$Extra$System$IO$pure,
					$author$project$Extra$System$IO$fmap,
					A2(
						$elm$core$Basics$composeL,
						$author$project$Builder$Reporting$Task$run,
						$author$project$Terminal$Repl$openModule(root)),
					$author$project$Terminal$Repl$openedModule(mode)),
				function (openResult) {
					var _v1 = A3($author$project$Extra$Type$Maybe$sequenceA, $author$project$Extra$Type$Either$pure, $author$project$Extra$Type$Either$fmap, openResult);
					if (_v1.$ === 'Left') {
						var err = _v1.a;
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Left(err));
					} else {
						var source = _v1.a;
						return $author$project$Extra$System$IO$return(
							$author$project$Extra$Type$Either$Right(
								A6(
									$author$project$Terminal$Repl$Env,
									root,
									interpreter,
									false,
									mode,
									A2($elm$core$Maybe$withDefault, $author$project$Terminal$Repl$defaultHeader, source),
									htmlEnabled)));
					}
				});
		});
};
var $author$project$Terminal$Repl$InterpreterFailure = {$: 'InterpreterFailure'};
var $author$project$Terminal$Repl$InterpreterSuccess = {$: 'InterpreterSuccess'};
var $author$project$Repl$Worker$lensJavaScriptCont = {
	getter: function (_v0) {
		var _v1 = _v0.h;
		var x = _v1.a;
		return x;
	},
	setter: F2(
		function (x, _v2) {
			var a = _v2.a;
			var b = _v2.b;
			var c = _v2.c;
			var d = _v2.d;
			var e = _v2.e;
			var f = _v2.f;
			var g = _v2.g;
			var _v3 = _v2.h;
			var bi = _v3.b;
			var ci = _v3.c;
			return A8(
				$author$project$Global$State,
				a,
				b,
				c,
				d,
				e,
				f,
				g,
				A3($author$project$Repl$Worker$LocalState, x, bi, ci));
		})
};
var $elm$json$Json$Decode$bool = _Json_decodeBool;
var $author$project$Repl$Worker$receiveFromJavaScriptPort = _Platform_incomingPort(
	'receiveFromJavaScriptPort',
	A2(
		$elm$json$Json$Decode$andThen,
		function (_v0) {
			return A2(
				$elm$json$Json$Decode$andThen,
				function (_v1) {
					return $elm$json$Json$Decode$succeed(
						_Utils_Tuple2(_v0, _v1));
				},
				A2($elm$json$Json$Decode$index, 1, $elm$json$Json$Decode$string));
		},
		A2($elm$json$Json$Decode$index, 0, $elm$json$Json$Decode$bool)));
var $author$project$Repl$Worker$sendToJavaScriptPort = _Platform_outgoingPort('sendToJavaScriptPort', $elm$json$Json$Encode$string);
var $author$project$Repl$Api$javaScriptRequestCodec = {decode: $elm$core$Basics$identity, encode: $elm$core$Basics$identity};
var $author$project$Repl$Api$JavaScriptError = function (a) {
	return {$: 'JavaScriptError', a: a};
};
var $author$project$Repl$Api$JavaScriptOutput = function (a) {
	return {$: 'JavaScriptOutput', a: a};
};
var $author$project$Repl$Api$javaScriptResponseCodec = {
	decode: function (wire) {
		if (wire.a) {
			var output = wire.b;
			return $author$project$Repl$Api$JavaScriptOutput(output);
		} else {
			var error = wire.b;
			return $author$project$Repl$Api$JavaScriptError(error);
		}
	},
	encode: function (response) {
		if (response.$ === 'JavaScriptOutput') {
			var output = response.a;
			return _Utils_Tuple2(true, output);
		} else {
			var error = response.a;
			return _Utils_Tuple2(false, error);
		}
	}
};
var $author$project$Repl$Api$workerToJavaScriptRequester = A2($author$project$Extra$System$IO$Port$syncApi, $author$project$Repl$Api$javaScriptRequestCodec, $author$project$Repl$Api$javaScriptResponseCodec).requesterFun;
var $author$project$Repl$Worker$workerToJavaScriptRequester = A3($author$project$Repl$Api$workerToJavaScriptRequester, $author$project$Repl$Worker$lensJavaScriptCont, $author$project$Repl$Worker$sendToJavaScriptPort, $author$project$Repl$Worker$receiveFromJavaScriptPort);
var $author$project$Repl$Worker$callJavaScript = function (javaScript) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Repl$Worker$workerToJavaScriptRequester.request(javaScript),
		function (javaScriptResponse) {
			if (javaScriptResponse.$ === 'JavaScriptOutput') {
				var output = javaScriptResponse.a;
				return A2(
					$author$project$Extra$System$IO$bindSequence,
					_List_fromArray(
						[
							$author$project$Terminal$Command$putLine(output)
						]),
					$author$project$Extra$System$IO$return($author$project$Terminal$Repl$InterpreterSuccess));
			} else {
				var error = javaScriptResponse.a;
				return A2(
					$author$project$Extra$System$IO$bindSequence,
					_List_fromArray(
						[
							$author$project$Terminal$Command$putLine(error)
						]),
					$author$project$Extra$System$IO$return($author$project$Terminal$Repl$InterpreterFailure));
			}
		});
};
var $author$project$Terminal$Repl$continueInterpreter = F2(
	function (noCont, result) {
		return A2(
			$author$project$Extra$System$IO$bind,
			$author$project$Extra$System$IO$getLens($author$project$Terminal$Repl$lensCont),
			function (maybeCont) {
				if (maybeCont.$ === 'Just') {
					var cont = maybeCont.a;
					return $author$project$Extra$System$IO$sequence(
						_List_fromArray(
							[
								A2($author$project$Extra$System$IO$putLens, $author$project$Terminal$Repl$lensCont, $elm$core$Maybe$Nothing),
								cont(result)
							]));
				} else {
					return noCont;
				}
			});
	});
var $author$project$Repl$Worker$workerInterpreter = function (input) {
	switch (input.$) {
		case 'InterpretValue':
			var javaScript = input.a;
			return A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Repl$Worker$callJavaScript(javaScript),
				$author$project$Terminal$Repl$continueInterpreter($author$project$Extra$System$IO$noOp));
		case 'InterpretHtml':
			return $author$project$Extra$System$IO$noOp;
		default:
			var error = input.a;
			return A2(
				$author$project$Extra$System$IO$bindSequence,
				_List_fromArray(
					[
						$author$project$Terminal$Command$putLine(
						$author$project$Repl$Worker$errorToString(error))
					]),
				A2($author$project$Terminal$Repl$continueInterpreter, $author$project$Extra$System$IO$noOp, $author$project$Terminal$Repl$InterpreterFailure));
	}
};
var $author$project$Repl$Worker$getEnv = A2(
	$author$project$Extra$System$IO$bind,
	$author$project$Extra$System$IO$getLens($author$project$Repl$Worker$lensReplMode),
	function (_v0) {
		var imports = _v0.a;
		var types = _v0.b;
		var decls = _v0.c;
		return $author$project$Terminal$Repl$initEnv(
			A3(
				$author$project$Terminal$Repl$Flags,
				$author$project$Repl$Worker$workerInterpreter,
				A3($author$project$Terminal$Repl$Configured, imports, types, decls),
				false));
	});
var $author$project$Compiler$Reporting$Doc$empty = $author$project$Extra$Data$Pretty$empty;
var $author$project$Terminal$Command$putDoc = function (doc) {
	return $author$project$Terminal$Command$putOutput(
		$author$project$Terminal$Command$Permanent(
			$author$project$Compiler$Reporting$Doc$toString(doc)));
};
var $author$project$Terminal$Repl$printWelcomeMessage = function () {
	var vsn = $author$project$Compiler$Elm$Version$toChars($author$project$Compiler$Elm$Version$compiler);
	var title = $author$project$Compiler$Reporting$Doc$hsep(
		_List_fromArray(
			[
				$author$project$Compiler$Reporting$Doc$d('Elm'),
				$author$project$Compiler$Reporting$Doc$fromChars(vsn)
			]));
	var dashes = A2(
		$elm$core$String$repeat,
		70 - $elm$core$String$length(vsn),
		'-');
	return $author$project$Terminal$Command$putDoc(
		$author$project$Compiler$Reporting$Doc$vcat(
			_List_fromArray(
				[
					$author$project$Compiler$Reporting$Doc$hsep(
					_List_fromArray(
						[
							$author$project$Compiler$Reporting$Doc$blackS('----'),
							$author$project$Compiler$Reporting$Doc$dullcyan(title),
							$author$project$Compiler$Reporting$Doc$blackS(dashes)
						])),
					$author$project$Compiler$Reporting$Doc$blackS(
					'Say :help for help and :exit to exit! More at ' + $author$project$Compiler$Reporting$Doc$makeLink('repl')),
					$author$project$Compiler$Reporting$Doc$blackS('--------------------------------------------------------------------------------'),
					$author$project$Compiler$Reporting$Doc$empty
				])));
}();
var $author$project$Repl$Worker$startRepl = function (replCallback) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Repl$Worker$getEnv,
		function (envResult) {
			if (envResult.$ === 'Left') {
				var error = envResult.a;
				return $author$project$Extra$System$IO$return(
					$author$project$Repl$Api$WorkerStateStopped(
						$elm$core$Maybe$Just(
							$author$project$Repl$Worker$errorToString(error))));
			} else {
				var env = envResult.a;
				return A2(
					$author$project$Extra$System$IO$bindSequence,
					_List_fromArray(
						[$author$project$Terminal$Repl$printWelcomeMessage]),
					A2(
						replCallback,
						env,
						$author$project$Terminal$Repl$initialState(env)));
			}
		});
};
var $author$project$Repl$Worker$withRunningRepl = function (callback) {
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Extra$System$IO$getLens($author$project$Repl$Worker$lensReplState),
		function (replState) {
			if (replState.$ === 'ReplRunning') {
				var env = replState.a;
				var state = replState.b;
				var maybeLines = replState.c;
				return A3(callback, env, state, maybeLines);
			} else {
				return $author$project$Repl$Worker$startRepl(
					F2(
						function (env, state) {
							return A3(callback, env, state, $elm$core$Maybe$Nothing);
						}));
			}
		});
};
var $author$project$Repl$Worker$handleClientCall = function (_v0) {
	var userInput = _v0.userInput;
	return A2(
		$author$project$Extra$System$IO$bind,
		$author$project$Repl$Worker$withRunningRepl(
			F3(
				function (env, state, maybeLines) {
					return A3(
						$author$project$Repl$Worker$handleClientRequestHelp,
						env,
						state,
						A2($author$project$Repl$Worker$addLine, userInput, maybeLines));
				})),
		function (workerState) {
			return A2(
				$author$project$Extra$System$IO$bind,
				$author$project$Repl$Worker$collectMessages,
				function (messages) {
					return $author$project$Extra$System$IO$return(
						{messages: messages, workerState: workerState});
				});
		});
};
var $author$project$Repl$Worker$subscriptions = function (model) {
	return $elm$core$Platform$Sub$batch(
		_List_fromArray(
			[
				$author$project$Repl$Worker$clientToWorkerResponder($author$project$Repl$Worker$handleClientCall),
				$author$project$Repl$Worker$workerToJavaScriptRequester.respond(model)
			]));
};
var $elm$core$Platform$worker = _Platform_worker;
var $author$project$Repl$Worker$main = $elm$core$Platform$worker(
	{init: $author$project$Repl$Worker$init, subscriptions: $author$project$Repl$Worker$subscriptions, update: $author$project$Repl$Worker$update});
_Platform_export({'Repl':{'Worker':{'init':$author$project$Repl$Worker$main(
	$elm$json$Json$Decode$list(
		A2(
			$elm$json$Json$Decode$andThen,
			function (_v0) {
				return A2(
					$elm$json$Json$Decode$andThen,
					function (_v1) {
						return A2(
							$elm$json$Json$Decode$andThen,
							function (_v2) {
								return $elm$json$Json$Decode$succeed(
									_Utils_Tuple3(_v0, _v1, _v2));
							},
							A2($elm$json$Json$Decode$index, 2, $elm$json$Json$Decode$string));
					},
					A2($elm$json$Json$Decode$index, 1, $elm$json$Json$Decode$string));
			},
			A2($elm$json$Json$Decode$index, 0, $elm$json$Json$Decode$string))))(0)}}});}(this));